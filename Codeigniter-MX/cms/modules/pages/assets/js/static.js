;
(function() {
    'use strict';

    function FastClick(layer, options) {
        var oldOnClick;
        options = options || {};
        this.trackingClick = false;
        this.trackingClickStart = 0;
        this.targetElement = null;
        this.touchStartX = 0;
        this.touchStartY = 0;
        this.lastTouchIdentifier = 0;
        this.touchBoundary = options.touchBoundary || 10;
        this.layer = layer;
        this.tapDelay = options.tapDelay || 200;
        this.tapTimeout = options.tapTimeout || 700;
        if (FastClick.notNeeded(layer)) {
            return;
        }

        function bind(method, context) {
            return function() {
                return method.apply(context, arguments);
            };
        }
        var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
        var context = this;
        for (var i = 0, l = methods.length; i < l; i++) {
            context[methods[i]] = bind(context[methods[i]], context);
        }
        if (deviceIsAndroid) {
            layer.addEventListener('mouseover', this.onMouse, true);
            layer.addEventListener('mousedown', this.onMouse, true);
            layer.addEventListener('mouseup', this.onMouse, true);
        }
        layer.addEventListener('click', this.onClick, true);
        layer.addEventListener('touchstart', this.onTouchStart, false);
        layer.addEventListener('touchmove', this.onTouchMove, false);
        layer.addEventListener('touchend', this.onTouchEnd, false);
        layer.addEventListener('touchcancel', this.onTouchCancel, false);
        if (!Event.prototype.stopImmediatePropagation) {
            layer.removeEventListener = function(type, callback, capture) {
                var rmv = Node.prototype.removeEventListener;
                if (type === 'click') {
                    rmv.call(layer, type, callback.hijacked || callback, capture);
                } else {
                    rmv.call(layer, type, callback, capture);
                }
            };
            layer.addEventListener = function(type, callback, capture) {
                var adv = Node.prototype.addEventListener;
                if (type === 'click') {
                    adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
                        if (!event.propagationStopped) {
                            callback(event);
                        }
                    }), capture);
                } else {
                    adv.call(layer, type, callback, capture);
                }
            };
        }
        if (typeof layer.onclick === 'function') {
            oldOnClick = layer.onclick;
            layer.addEventListener('click', function(event) {
                oldOnClick(event);
            }, false);
            layer.onclick = null;
        }
    }
    var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;
    var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;
    var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;
    var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);
    var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\d/).test(navigator.userAgent);
    var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;
    FastClick.prototype.needsClick = function(target) {
        switch (target.nodeName.toLowerCase()) {
            case 'button':
            case 'select':
            case 'textarea':
                if (target.disabled) {
                    return true;
                }
                break;
            case 'input':
                if ((deviceIsIOS && target.type === 'file') || target.disabled) {
                    return true;
                }
                break;
            case 'label':
            case 'iframe':
            case 'video':
                return true;
        }
        return (/\bneedsclick\b/).test(target.className);
    };
    FastClick.prototype.needsFocus = function(target) {
        switch (target.nodeName.toLowerCase()) {
            case 'textarea':
                return true;
            case 'select':
                return !deviceIsAndroid;
            case 'input':
                switch (target.type) {
                    case 'button':
                    case 'checkbox':
                    case 'file':
                    case 'image':
                    case 'radio':
                    case 'submit':
                        return false;
                }
                return !target.disabled && !target.readOnly;
            default:
                return (/\bneedsfocus\b/).test(target.className);
        }
    };
    FastClick.prototype.sendClick = function(targetElement, event) {
        var clickEvent, touch;
        if (document.activeElement && document.activeElement !== targetElement) {
            document.activeElement.blur();
        }
        touch = event.changedTouches[0];
        clickEvent = document.createEvent('MouseEvents');
        clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
        clickEvent.forwardedTouchEvent = true;
        targetElement.dispatchEvent(clickEvent);
    };
    FastClick.prototype.determineEventType = function(targetElement) {
        if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
            return 'mousedown';
        }
        return 'click';
    };
    FastClick.prototype.focus = function(targetElement) {
        var length;
        if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {
            length = targetElement.value.length;
            targetElement.setSelectionRange(length, length);
        } else {
            targetElement.focus();
        }
    };
    FastClick.prototype.updateScrollParent = function(targetElement) {
        var scrollParent, parentElement;
        scrollParent = targetElement.fastClickScrollParent;
        if (!scrollParent || !scrollParent.contains(targetElement)) {
            parentElement = targetElement;
            do {
                if (parentElement.scrollHeight > parentElement.offsetHeight) {
                    scrollParent = parentElement;
                    targetElement.fastClickScrollParent = parentElement;
                    break;
                }
                parentElement = parentElement.parentElement;
            } while (parentElement);
        }
        if (scrollParent) {
            scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
        }
    };
    FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {
        if (eventTarget.nodeType === Node.TEXT_NODE) {
            return eventTarget.parentNode;
        }
        return eventTarget;
    };
    FastClick.prototype.onTouchStart = function(event) {
        var targetElement, touch, selection;
        if (event.targetTouches.length > 1) {
            return true;
        }
        targetElement = this.getTargetElementFromEventTarget(event.target);
        touch = event.targetTouches[0];
        if (deviceIsIOS) {
            selection = window.getSelection();
            if (selection.rangeCount && !selection.isCollapsed) {
                return true;
            }
            if (!deviceIsIOS4) {
                if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
                    event.preventDefault();
                    return false;
                }
                this.lastTouchIdentifier = touch.identifier;
                this.updateScrollParent(targetElement);
            }
        }
        this.trackingClick = true;
        this.trackingClickStart = event.timeStamp;
        this.targetElement = targetElement;
        this.touchStartX = touch.pageX;
        this.touchStartY = touch.pageY;
        if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
            event.preventDefault();
        }
        return true;
    };
    FastClick.prototype.touchHasMoved = function(event) {
        var touch = event.changedTouches[0],
            boundary = this.touchBoundary;
        if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
            return true;
        }
        return false;
    };
    FastClick.prototype.onTouchMove = function(event) {
        if (!this.trackingClick) {
            return true;
        }
        if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
            this.trackingClick = false;
            this.targetElement = null;
        }
        return true;
    };
    FastClick.prototype.findControl = function(labelElement) {
        if (labelElement.control !== undefined) {
            return labelElement.control;
        }
        if (labelElement.htmlFor) {
            return document.getElementById(labelElement.htmlFor);
        }
        return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
    };
    FastClick.prototype.onTouchEnd = function(event) {
        var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;
        if (!this.trackingClick) {
            return true;
        }
        if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
            this.cancelNextClick = true;
            return true;
        }
        if ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {
            return true;
        }
        this.cancelNextClick = false;
        this.lastClickTime = event.timeStamp;
        trackingClickStart = this.trackingClickStart;
        this.trackingClick = false;
        this.trackingClickStart = 0;
        if (deviceIsIOSWithBadTarget) {
            touch = event.changedTouches[0];
            targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
            targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
        }
        targetTagName = targetElement.tagName.toLowerCase();
        if (targetTagName === 'label') {
            forElement = this.findControl(targetElement);
            if (forElement) {
                this.focus(targetElement);
                if (deviceIsAndroid) {
                    return false;
                }
                targetElement = forElement;
            }
        } else if (this.needsFocus(targetElement)) {
            if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
                this.targetElement = null;
                return false;
            }
            this.focus(targetElement);
            this.sendClick(targetElement, event);
            if (!deviceIsIOS || targetTagName !== 'select') {
                this.targetElement = null;
                event.preventDefault();
            }
            return false;
        }
        if (deviceIsIOS && !deviceIsIOS4) {
            scrollParent = targetElement.fastClickScrollParent;
            if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
                return true;
            }
        }
        if (!this.needsClick(targetElement)) {
            event.preventDefault();
            this.sendClick(targetElement, event);
        }
        return false;
    };
    FastClick.prototype.onTouchCancel = function() {
        this.trackingClick = false;
        this.targetElement = null;
    };
    FastClick.prototype.onMouse = function(event) {
        if (!this.targetElement) {
            return true;
        }
        if (event.forwardedTouchEvent) {
            return true;
        }
        if (!event.cancelable) {
            return true;
        }
        if (!this.needsClick(this.targetElement) || this.cancelNextClick) {
            if (event.stopImmediatePropagation) {
                event.stopImmediatePropagation();
            } else {
                event.propagationStopped = true;
            }
            event.stopPropagation();
            event.preventDefault();
            return false;
        }
        return true;
    };
    FastClick.prototype.onClick = function(event) {
        var permitted;
        if (this.trackingClick) {
            this.targetElement = null;
            this.trackingClick = false;
            return true;
        }
        if (event.target.type === 'submit' && event.detail === 0) {
            return true;
        }
        permitted = this.onMouse(event);
        if (!permitted) {
            this.targetElement = null;
        }
        return permitted;
    };
    FastClick.prototype.destroy = function() {
        var layer = this.layer;
        if (deviceIsAndroid) {
            layer.removeEventListener('mouseover', this.onMouse, true);
            layer.removeEventListener('mousedown', this.onMouse, true);
            layer.removeEventListener('mouseup', this.onMouse, true);
        }
        layer.removeEventListener('click', this.onClick, true);
        layer.removeEventListener('touchstart', this.onTouchStart, false);
        layer.removeEventListener('touchmove', this.onTouchMove, false);
        layer.removeEventListener('touchend', this.onTouchEnd, false);
        layer.removeEventListener('touchcancel', this.onTouchCancel, false);
    };
    FastClick.notNeeded = function(layer) {
        var metaViewport;
        var chromeVersion;
        var blackberryVersion;
        var firefoxVersion;
        if (typeof window.ontouchstart === 'undefined') {
            return true;
        }
        chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];
        if (chromeVersion) {
            if (deviceIsAndroid) {
                metaViewport = document.querySelector('meta[name=viewport]');
                if (metaViewport) {
                    if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
                        return true;
                    }
                    if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
                        return true;
                    }
                }
            } else {
                return true;
            }
        }
        if (deviceIsBlackBerry10) {
            blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);
            if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
                metaViewport = document.querySelector('meta[name=viewport]');
                if (metaViewport) {
                    if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
                        return true;
                    }
                    if (document.documentElement.scrollWidth <= window.outerWidth) {
                        return true;
                    }
                }
            }
        }
        if (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {
            return true;
        }
        firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];
        if (firefoxVersion >= 27) {
            metaViewport = document.querySelector('meta[name=viewport]');
            if (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
                return true;
            }
        }
        if (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {
            return true;
        }
        return false;
    };
    FastClick.attach = function(layer, options) {
        return new FastClick(layer, options);
    };
    if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
        define(function() {
            return FastClick;
        });
    } else if (typeof module !== 'undefined' && module.exports) {
        module.exports = FastClick.attach;
        module.exports.FastClick = FastClick;
    } else {
        window.FastClick = FastClick;
    }
}());

$(function() {
    var needsClick = FastClick.prototype.needsClick;
    FastClick.prototype.needsClick = function(target) {
        if ((target.className || '').indexOf('pac-item') > -1) {
            return true;
        } else if ((target.parentNode.className || '').indexOf('pac-item') > -1) {
            return true;
        } else {
            return needsClick.apply(this, arguments);
        }
    };
    FastClick.attach(document.body);
});
(function() {
    var method;
    var noop = function() {};
    var methods = ['assert', 'clear', 'count', 'debug', 'dir', 'dirxml', 'error', 'exception', 'group', 'groupCollapsed', 'groupEnd', 'info', 'log', 'markTimeline', 'profile', 'profileEnd', 'table', 'time', 'timeEnd', 'timeStamp', 'trace', 'warn'];
    var length = methods.length;
    var console = (window.console = window.console || {});
    while (length--) {
        method = methods[length];
        if (!console[method]) {
            console[method] = noop;
        }
    }
}());
$.support.transition = (function() {
    var thisBody = document.body || document.documentElement,
        thisStyle = thisBody.style,
        support = thisStyle.transition !== undefined || thisStyle.WebkitTransition !== undefined || thisStyle.MozTransition !== undefined || thisStyle.MsTransition !== undefined || thisStyle.OTransition !== undefined;
    return support;
})();
(function($) {
    var event = $.event,
        resizeTimeout;
    event.special['smartresize'] = {
        setup: function() {
            $(this).bind('resize', event.special.smartresize.handler);
        },
        teardown: function() {
            $(this).unbind('resize', event.special.smartresize.handler);
        },
        handler: function(event, execAsap) {
            var context = this,
                args = arguments;
            event.type = 'smartresize';
            if (resizeTimeout) clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(function() {
                jQuery.event.handle.apply(context, args);
            }, execAsap === 'execAsap' ? 0 : 100);
        }
    }
    $.fn.smartresize = function(fn) {
        return fn ? this.bind('smartresize', fn) : this.trigger('smartresize', ['execAsap']);
    };
})(jQuery);
(function(a, b, c) {
    "use strict";
    var d = b.event,
        e;
    d.special.smartresize = {
        setup: function() {
            b(this).bind("resize", d.special.smartresize.handler)
        },
        teardown: function() {
            b(this).unbind("resize", d.special.smartresize.handler)
        },
        handler: function(a, c) {
            var d = this,
                f = arguments;
            a.type = "smartresize", e && clearTimeout(e), e = setTimeout(function() {
                b.event.handle.apply(d, f)
            }, c === "execAsap" ? 0 : 100)
        }
    }, b.fn.smartresize = function(a) {
        return a ? this.bind("smartresize", a) : this.trigger("smartresize", ["execAsap"])
    }, b.Mason = function(a, c) {
        this.element = b(c), this._create(a), this._init()
    }, b.Mason.settings = {
        isResizable: !0,
        isAnimated: !1,
        animationOptions: {
            queue: !1,
            duration: 500
        },
        gutterWidth: 0,
        isRTL: !1,
        isFitWidth: !1,
        containerStyle: {
            position: "relative"
        }
    }, b.Mason.prototype = {
        _filterFindBricks: function(a) {
            var b = this.options.itemSelector;
            return b ? a.filter(b).add(a.find(b)) : a
        },
        _getBricks: function(a) {
            var b = this._filterFindBricks(a).css({
                position: "absolute"
            }).addClass("masonry-brick");
            return b
        },
        _create: function(c) {
            this.options = b.extend(!0, {}, b.Mason.settings, c), this.styleQueue = [];
            var d = this.element[0].style;
            this.originalStyle = {
                height: d.height || ""
            };
            var e = this.options.containerStyle;
            for (var f in e) this.originalStyle[f] = d[f] || "";
            this.element.css(e), this.horizontalDirection = this.options.isRTL ? "right" : "left", this.offset = {
                x: parseInt(this.element.css("padding-" + this.horizontalDirection), 10),
                y: parseInt(this.element.css("padding-top"), 10)
            }, this.isFluid = this.options.columnWidth && typeof this.options.columnWidth == "function";
            var g = this;
            setTimeout(function() {
                g.element.addClass("masonry")
            }, 0), this.options.isResizable && b(a).bind("smartresize.masonry", function() {
                g.resize()
            }), this.reloadItems()
        },
        _init: function(a) {
            this._getColumns(), this._reLayout(a)
        },
        option: function(a, c) {
            b.isPlainObject(a) && (this.options = b.extend(!0, this.options, a))
        },
        layout: function(a, b) {
            for (var c = 0, d = a.length; c < d; c++) this._placeBrick(a[c]);
            var e = {};
            e.height = Math.max.apply(Math, this.colYs);
            if (this.options.isFitWidth) {
                var f = 0;
                c = this.cols;
                while (--c) {
                    if (this.colYs[c] !== 0) break;
                    f++
                }
                e.width = (this.cols - f) * this.columnWidth - this.options.gutterWidth
            }
            this.styleQueue.push({
                $el: this.element,
                style: e
            });
            var g = this.isLaidOut ? this.options.isAnimated ? "animate" : "css" : "css",
                h = this.options.animationOptions,
                i;
            for (c = 0, d = this.styleQueue.length; c < d; c++) i = this.styleQueue[c], i.$el[g](i.style, h);
            this.styleQueue = [], b && b.call(a), this.isLaidOut = !0
        },
        _getColumns: function() {
            var a = this.options.isFitWidth ? this.element.parent() : this.element,
                b = a.width();
            this.columnWidth = this.isFluid ? this.options.columnWidth(b) : this.options.columnWidth || this.$bricks.outerWidth(!0) || b, this.columnWidth += this.options.gutterWidth, this.cols = Math.floor((b + this.options.gutterWidth) / this.columnWidth), this.cols = Math.max(this.cols, 1)
        },
        _placeBrick: function(a) {
            var c = b(a),
                d, e, f, g, h;
            d = Math.ceil(c.outerWidth(!0) / this.columnWidth), d = Math.min(d, this.cols);
            if (d === 1) f = this.colYs;
            else {
                e = this.cols + 1 - d, f = [];
                for (h = 0; h < e; h++) g = this.colYs.slice(h, h + d), f[h] = Math.max.apply(Math, g)
            }
            var i = Math.min.apply(Math, f),
                j = 0;
            for (var k = 0, l = f.length; k < l; k++)
                if (f[k] === i) {
                    j = k;
                    break
                }
            var m = {
                top: i + this.offset.y
            };
            m[this.horizontalDirection] = this.columnWidth * j + this.offset.x, this.styleQueue.push({
                $el: c,
                style: m
            });
            var n = i + c.outerHeight(!0),
                o = this.cols + 1 - l;
            for (k = 0; k < o; k++) this.colYs[j + k] = n
        },
        resize: function() {
            var a = this.cols;
            this._getColumns(), (this.isFluid || this.cols !== a) && this._reLayout()
        },
        _reLayout: function(a) {
            var b = this.cols;
            this.colYs = [];
            while (b--) this.colYs.push(0);
            this.layout(this.$bricks, a)
        },
        reloadItems: function() {
            this.$bricks = this._getBricks(this.element.children())
        },
        reload: function(a) {
            this.reloadItems(), this._init(a)
        },
        appended: function(a, b, c) {
            if (b) {
                this._filterFindBricks(a).css({
                    top: this.element.height()
                });
                var d = this;
                setTimeout(function() {
                    d._appended(a, c)
                }, 1)
            } else this._appended(a, c)
        },
        _appended: function(a, b) {
            var c = this._getBricks(a);
            this.$bricks = this.$bricks.add(c), this.layout(c, b)
        },
        remove: function(a) {
            this.$bricks = this.$bricks.not(a), a.remove()
        },
        destroy: function() {
            this.$bricks.removeClass("masonry-brick").each(function() {
                this.style.position = "", this.style.top = "", this.style.left = ""
            });
            var c = this.element[0].style;
            for (var d in this.originalStyle) c[d] = this.originalStyle[d];
            this.element.unbind(".masonry").removeClass("masonry").removeData("masonry"), b(a).unbind(".masonry")
        }
    }, b.fn.imagesLoaded = function(a) {
        function h() {
            a.call(c, d)
        }

        function i(a) {
            var c = a.target;
            c.src !== f && b.inArray(c, g) === -1 && (g.push(c), --e <= 0 && (setTimeout(h), d.unbind(".imagesLoaded", i)))
        }
        var c = this,
            d = c.find("img").add(c.filter("img")),
            e = d.length,
            f = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==",
            g = [];
        return e || h(), d.bind("load.imagesLoaded error.imagesLoaded", i).each(function() {
            var a = this.src;
            this.src = f, this.src = a
        }), c
    };
    var f = function(b) {
        a.console && a.console.error(b)
    };
    b.fn.masonry = function(a) {
        if (typeof a == "string") {
            var c = Array.prototype.slice.call(arguments, 1);
            this.each(function() {
                var d = b.data(this, "masonry");
                if (!d) {
                    f("cannot call methods on masonry prior to initialization; attempted to call method '" + a + "'");
                    return
                }
                if (!b.isFunction(d[a]) || a.charAt(0) === "_") {
                    f("no such method '" + a + "' for masonry instance");
                    return
                }
                d[a].apply(d, c)
            })
        } else this.each(function() {
            var c = b.data(this, "masonry");
            c ? (c.option(a || {}), c._init()) : b.data(this, "masonry", new b.Mason(a, this))
        });
        return this
    }
})(window, jQuery);
(function(w) {
    if (!(/iPhone|iPad|iPod/.test(navigator.platform) && navigator.userAgent.indexOf('AppleWebKit') > -1)) {
        return;
    }
    var doc = w.document;
    if (!doc.querySelector) return;
    var meta = doc.querySelector('meta[name=viewport]'),
        initialContent = meta && meta.getAttribute('content'),
        disabledZoom = initialContent + ',maximum-scale=1',
        enabledZoom = initialContent + ',maximum-scale=10',
        enabled = true,
        x, y, z, aig;
    if (!meta) return;

    function restoreZoom() {
        meta.setAttribute('content', enabledZoom);
        enabled = true;
    }

    function disableZoom() {
        meta.setAttribute('content', disabledZoom);
        enabled = false;
    }

    function checkTilt(e) {
        aig = e.accelerationIncludingGravity;
        x = Math.abs(aig.x);
        y = Math.abs(aig.y);
        z = Math.abs(aig.z);
        if ((!w.orientation || w.orientation === 180) && (x > 7 || ((z > 6 && y < 8 || z < 8 && y > 6) && x > 5))) {
            if (enabled) {
                disableZoom();
            }
        } else if (!enabled) {
            restoreZoom();
        }
    }
    w.addEventListener('orientationchange', restoreZoom, false);
    w.addEventListener('devicemotion', checkTilt, false);
})(this);
(function() {
    jQuery.fn.eqHeight = function() {
        return this.each(function(i, v) {
            var tallest = 0;
            var $cols = $(this).children().css('min-height', 0);
            $cols.each(function() {
                var height = $(this).outerHeight();
                if (height > tallest) tallest = height;
            });
            $cols.css('min-height', tallest + 2);
        });
    };
})();
(function($) {
    $.fn.touchwipe = function(settings) {
        var config = {
            min_move_x: 20,
            min_move_y: 20,
            wipeLeft: function(e) {},
            wipeRight: function(e) {},
            wipeUp: function(e) {},
            wipeDown: function(e) {},
            preventDefaultEvents: true
        };
        if (settings) $.extend(config, settings);
        this.each(function() {
            var startX;
            var startY;
            var isMoving = false;

            function cancelTouch() {
                this.removeEventListener('touchmove', onTouchMove);
                startX = null;
                isMoving = false;
            }

            function onTouchMove(e) {
                if (config.preventDefaultEvents) {
                    e.preventDefault();
                }
                if (isMoving) {
                    var x = e.touches[0].pageX;
                    var y = e.touches[0].pageY;
                    var dx = startX - x;
                    var dy = startY - y;
                    if (Math.abs(dx) >= config.min_move_x) {
                        cancelTouch();
                        if (dx > 0) {
                            config.wipeLeft(e);
                        } else {
                            config.wipeRight(e);
                        }
                    } else if (Math.abs(dy) >= config.min_move_y) {
                        cancelTouch();
                        if (dy > 0) {
                            config.wipeDown(e);
                        } else {
                            config.wipeUp(e);
                        }
                    }
                }
            }

            function onTouchStart(e) {
                if (e.touches.length == 1) {
                    startX = e.touches[0].pageX;
                    startY = e.touches[0].pageY;
                    isMoving = true;
                    this.addEventListener('touchmove', onTouchMove, false);
                }
            }
            if ('ontouchstart' in document.documentElement) {
                this.addEventListener('touchstart', onTouchStart, false);
            }
        });
        return this;
    };
})(jQuery);;
(function(window, document, $) {
    var isInputSupported = 'placeholder' in document.createElement('input'),
        isTextareaSupported = 'placeholder' in document.createElement('textarea'),
        prototype = $.fn,
        valHooks = $.valHooks,
        hooks, placeholder;
    if (isInputSupported && isTextareaSupported) {
        placeholder = prototype.placeholder = function() {
            return this;
        };
        placeholder.input = placeholder.textarea = true;
    } else {
        placeholder = prototype.placeholder = function() {
            var $this = this;
            $this.filter((isInputSupported ? 'textarea' : ':input') + '[placeholder]').not('.placeholder').bind({
                'focus.placeholder': clearPlaceholder,
                'blur.placeholder': setPlaceholder
            }).data('placeholder-enabled', true).trigger('blur.placeholder');
            return $this;
        };
        placeholder.input = isInputSupported;
        placeholder.textarea = isTextareaSupported;
        hooks = {
            'get': function(element) {
                var $element = $(element);
                return $element.data('placeholder-enabled') && $element.hasClass('placeholder') ? '' : element.value;
            },
            'set': function(element, value) {
                var $element = $(element);
                if (!$element.data('placeholder-enabled')) {
                    return element.value = value;
                }
                if (value == '') {
                    element.value = value;
                    if (element != document.activeElement) {
                        setPlaceholder.call(element);
                    }
                } else if ($element.hasClass('placeholder')) {
                    clearPlaceholder.call(element, true, value) || (element.value = value);
                } else {
                    element.value = value;
                }
                return $element;
            }
        };
        isInputSupported || (valHooks.input = hooks);
        isTextareaSupported || (valHooks.textarea = hooks);
        $(function() {
            $(document).delegate('form', 'submit.placeholder', function() {
                var $inputs = $('.placeholder', this).each(clearPlaceholder);
                setTimeout(function() {
                    $inputs.each(setPlaceholder);
                }, 10);
            });
        });
        $(window).bind('beforeunload.placeholder', function() {
            $('.placeholder').each(function() {
                this.value = '';
            });
        });
    }

    function args(elem) {
        var newAttrs = {},
            rinlinejQuery = /^jQuery\d+$/;
        $.each(elem.attributes, function(i, attr) {
            if (attr.specified && !rinlinejQuery.test(attr.name)) {
                newAttrs[attr.name] = attr.value;
            }
        });
        return newAttrs;
    }

    function clearPlaceholder(event, value) {
        var input = this,
            $input = $(input);
        if (input.value == $input.attr('placeholder') && $input.hasClass('placeholder')) {
            if ($input.data('placeholder-password')) {
                $input = $input.hide().next().show().attr('id', $input.removeAttr('id').data('placeholder-id'));
                if (event === true) {
                    return $input[0].value = value;
                }
                $input.focus();
            } else {
                input.value = '';
                $input.removeClass('placeholder');
                input == document.activeElement && input.select();
            }
        }
    }

    function setPlaceholder() {
        var $replacement, input = this,
            $input = $(input),
            $origInput = $input,
            id = this.id;
        if (input.value == '') {
            if (input.type == 'password') {
                if (!$input.data('placeholder-textinput')) {
                    try {
                        $replacement = $input.clone().attr({
                            'type': 'text'
                        });
                    } catch (e) {
                        $replacement = $('<input>').attr($.extend(args(this), {
                            'type': 'text'
                        }));
                    }
                    $replacement.removeAttr('name').data({
                        'placeholder-password': true,
                        'placeholder-id': id
                    }).bind('focus.placeholder', clearPlaceholder);
                    $input.data({
                        'placeholder-textinput': $replacement,
                        'placeholder-id': id
                    }).before($replacement);
                }
                $input = $input.removeAttr('id').hide().prev().attr('id', id).show();
            }
            $input.addClass('placeholder');
            $input[0].value = $input.attr('placeholder');
        } else {
            $input.removeClass('placeholder');
        }
    }
}(this, document, jQuery));

var BREW = {
    mobile: navigator.userAgent.match(/(iPhone|iPod|iPad|Android|BlackBerry)/) ? true : false,
    events: {
        click: 'click'
    }
};
BREW.Cookie = function(key, value, options) {
    if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value === null || value === undefined)) {
        options = $.extend({}, options);
        if (value === null || value === undefined) {
            options.expires = -1;
        }
        if (typeof options.expires === 'number') {
            var days = options.expires,
                t = options.expires = new Date();
            t.setDate(t.getDate() + days);
        }
        value = String(value);
        return (document.cookie = [encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value), options.expires ? '; expires=' + options.expires.toUTCString() : '', options.path ? '; path=' + options.path : '', options.domain ? '; domain=' + options.domain : '', options.secure ? '; secure' : ''].join(''));
    }
    options = value || {};
    var decode = options.raw ? function(s) {
        return s;
    } : decodeURIComponent;
    var pairs = document.cookie.split('; ');
    for (var i = 0, pair; pair = pairs[i] && pairs[i].split('='); i++) {
        if (decode(pair[0]) === key) return decode(pair[1] || '');
    }
    return null;
};
BREW.Splitlist = function(el, options) {
    var options = $.extend({
        columns: 3
    }, options);
    var $el = $(el),
        items = $el.children(),
        tag = $el.get(0).tagName.toLowerCase(),
        rows = Math.ceil(items.length / options.columns);
    var $list = $el;
    for (var i = 1; i < items.length / rows; i++) {
        var $new = $(document.createElement(tag));
        for (var j = rows * i; j < (rows * i) + rows; j++) {
            $new.append(items[j]);
        }
        $new.attr('class', $list.attr('class'));
        $list.after($new);
        $list = $new;
    }
};
$.fn.Splitlist = function(options) {
    return this.each(function() {
        (new BREW.Splitlist(this, options));
    });
};
BREW.Resize = function(el, options) {
    var self = this,
        $el = $(el);
    var self = this,
        $el = $(el),
        $canvas = $el.parent();
    var options = $.extend({
        method: 'scale',
        ratio: '3:4',
        className: 'brewImage',
        bgColor: 'transparent'
    }, options);
    var opts = $el.data('resize') || $canvas.data('resize');
    if (opts) $.extend(options, opts);
    var ratio = options.ratio.split(':'),
        shimHPercent = (ratio[0] / ratio[1]) * 100;
    var $shim = $('<div class="shim"/>');
    $shim.css({
        'padding-bottom': shimHPercent + '%'
    }).insertAfter($el);
    $canvas.addClass(options.className).css({
        'background': options.bgColor
    });
    self.pixelsToPercent = function(chi, par) {
        return ((parseInt(chi, 10) / parseInt(par, 10)) * 100) + '%';
    };
    self.resize = function() {
        var resizeMe = function() {
            $el.css({
                'position': 'absolute',
                'max-width': '9999em',
                'height': 'auto',
                'width': 'auto'
            });
            var imgHeight = $el.height(),
                imgWidth = $el.width(),
                imgHPercent = (imgHeight / imgWidth) * 100;
            if (imgHeight <= 0) {
                throw {
                    message: 'Height Error'
                };
            }
            $el.attr('style', '');
            var landscape = (shimHPercent >= imgHPercent);
            $el.removeClass(landscape ? 'portrait' : 'landscape').addClass(landscape ? 'landscape' : 'portrait').addClass(options.method);
            var canvasHeight = $canvas.height(),
                canvasWidth = $canvas.width();
            if (options.method === 'crop') {
                if (landscape) {
                    var left = (canvasWidth - $el.width()) / 2;
                    $el.css({
                        'left': self.pixelsToPercent(left, canvasWidth),
                        'top': 0
                    });
                } else {
                    var top = ($el.height() - canvasHeight) / 2;
                    $el.css({
                        'top': self.pixelsToPercent(top * -1, canvasHeight),
                        'left': 0
                    });
                }
            } else if (options.method === 'scale') {
                if (landscape) {
                    var top = ($el.height() - canvasHeight) / 2;
                    $el.css({
                        'top': self.pixelsToPercent(top * -1, canvasHeight),
                        'left': 0
                    });
                } else {
                    var left = (canvasWidth - $el.width()) / 2;
                    $el.css({
                        'left': self.pixelsToPercent(left, canvasWidth),
                        'top': 0
                    });
                }
            }
        };
        try {
            $el.on('load', function() {
                resizeMe();
            }).trigger('load');
        } catch (e) {
            setTimeout(function() {
                try {
                    resizeMe();
                } catch (e) {}
            }, 1000);
        }
    };
    if (el.nodeType === 1 && el.tagName.toLowerCase() === 'img' && el.src !== '') {
        $el.addClass('hidden');
        self.resize($el);
        $el.removeClass('hidden');
    }
};
$.fn.Resize = function(options) {
    var ns = 'BREW.Resize';
    var methods = {
        resize: function(row) {
            $(this).data(ns).resize;
        }
    };
    if (methods[options]) {
        return methods[options].apply(this, Array.prototype.slice.call(arguments, 1));
    } else if (typeof options === 'object' || !options) {
        return this.each(function() {
            var $this = $(this);
            if (undefined == $this.data(ns)) {
                var plugin = new BREW.Resize(this, options);
                $this.data(ns, plugin);
            }
        });
    }
};
BREW.Images = function(el, options) {
    var $el = $(el);
    var options = $.extend({
        resize: {
            method: 'scale'
        },
        onComplete: null,
        onLoad: function(el) {
            var opts = this,
                $img = $(el);
            $img.Resize(opts.resize);
        }
    }, options);
    if ($el.is('img')) $el = $el.parent();
    var $imgs = $el.find('img[data-src]'),
        imgs = [];
    $imgs.each(function() {
        imgs.push(this);
    });
    var total = imgs.length,
        loaded = 0;
    if (total === 0 && options.onComplete) options.onComplete($imgs);
    $.each(imgs, function(i, img) {
        var $img = $(img);
        var src = $img.attr('data-src');
        if ($img.attr('src') === src) {
            if (options.onLoad) options.onLoad(img);
            if (total === ++loaded && options.onComplete) options.onComplete($imgs);
            return true;
        }
        var $canvas = $img.parent().addClass('stateLoading'),
            image = new Image();
        $(image).bind('load.images error.images', function(e) {
            $canvas.removeClass('stateLoading');
            img.src = image.src;
            if (!$img.hasClass('loaded')) {
                $img.addClass('loaded');
                if (e.type === 'load' && options.onLoad) options.onLoad(img);
            }
            if (total === ++loaded && options.onComplete) options.onComplete($imgs);
        });
        $img.attr('data-org', img.src);
        image.src = $img.attr('data-src');
    });
};
$.fn.Images = function(options) {
    return this.each(function() {
        (new BREW.Images(this, options));
    });
};
BREW.Gallery = function(el, options) {
    var self = this,
        $el = $(el);
    var options = $.extend({
        current: 0,
        prevBtn: 'a.prev',
        nextBtn: 'a.next',
        playBtn: 'a.play',
        stopBtn: 'a.stop',
        toggleBtn: 'a.toggle',
        fullscreen: false,
        repeat: true,
        autoplay: true,
        interval: 5000,
        paginate: 'dots',
        onInit: null,
        onPlay: null,
        onStop: null,
        onChange: null,
        onClick: function(el) {
            if (options.fullscreen) {
                var el = $(el).find('img').get(0);
                if (el.requestFullScreen) {
                    el.requestFullScreen();
                } else if (el.mozRequestFullScreen) {
                    el.mozRequestFullScreen();
                } else if (el.webkitRequestFullScreen) {
                    el.webkitRequestFullScreen();
                }
            }
        }
    }, options);
    var $slides = $el.find('.slideset').children('.slide');
    self.current = options.current;
    self.firstrun = true;
    self.init = function() {
        var i = $slides.length;
        while (i--) $($slides[i]).addClass('hidden');
        setTimeout(function() {
            $el.addClass('init');
            self.setSlide(self.current);
        }, 0);
        self.bindEvents();
        if (options.paginate) self.buildPagination();
        if (typeof options.onInit == 'function') options.onInit.call(this);
    };
    self.setSlide = function(index, stop) {
        var slide = self.getSlide(index),
            $slide = $(slide),
            $last = $slides.not('.hidden');
        if (stop) self.stop();
        if (!$slide.hasClass('hidden')) return;
        $slide.Images({
            onComplete: $.proxy(function(el) {
                self.current = index;
                $slide.removeClass('hidden').addClass('current');
                if ($last) $last.addClass('hidden').removeClass('current');
                if (options.paginate) $el.find('a[data-page="' + index + '"]').parent().addClass('current').siblings().removeClass('current');
                if (self.firstrun && options.autoplay) {
                    self.firstrun = false;
                    self.play();
                }
                if (typeof options.onChange == 'function') options.onChange.call(this);
            }, this)
        });
    };
    self.getSlide = function(index) {
        var index = index != null ? index : self.current;
        return $slides.get(index);
    };
    self.prev = function() {
        if (self.current > 0) {
            self.setSlide(self.current - 1);
        } else if (options.repeat) {
            self.setSlide($slides.length - 1);
        }
    };
    self.next = function() {
        if (self.current + 1 < $slides.length) {
            self.setSlide(self.current + 1);
        } else if (options.repeat) {
            self.setSlide(0);
        }
    };
    self.play = function() {
        if (self.timeout) clearInterval(self.timeout);
        self.timeout = setInterval(self.next, options.interval);
        if (typeof options.onPlay == 'function') options.onPlay.call(this);
    };
    self.stop = function() {
        if (self.timeout) clearInterval(self.timeout);
        if (typeof options.onStop == 'function') options.onStop.call(this);
    };
    self.buildPagination = function() {
        var len = $slides.length,
            links = [];
        for (i = 0; i < len; i++) {
            links.push('<li' + (self.current == i ? ' class="current"' : '') + '><a href="javascript:void(0);" data-page="' + i + '">' + (i + 1) + '</a></li>');
        }
        var $nav = $el.find('.pagination');
        switch (options.paginate) {
            case 'dots':
                $nav.addClass('dots');
                break;
            case 'nums':
                $nav.addClass('nums');
                break;
        }
        $nav.append(links.join(''));
        $el.find('.nav').append($nav);
        $nav.on(BREW.events.click + '.gallery', 'a', function(e) {
            e.preventDefault();
            var $this = $(this),
                page = $this.attr('data-page');
            self.setSlide(page);
            self.stop();
        });
    };
    self.bindEvents = function() {
        $el.on(BREW.events.click + '.gallery', options.prevBtn, function(e) {
            e.preventDefault();
            self.prev();
            self.stop();
        });
        $el.on(BREW.events.click + '.gallery', options.nextBtn, function(e) {
            e.preventDefault();
            self.next();
            self.stop();
        });
        $el.on(BREW.events.click + '.gallery', options.playBtn, function(e) {
            e.preventDefault();
            self.play();
        });
        $el.on(BREW.events.click + '.gallery', options.stopBtn, function(e) {
            e.preventDefault();
            self.stop();
        });
        $el.on(BREW.events.click + '.gallery', options.toggleBtn, function(e) {
            e.preventDefault();
            var ico = $(this).find('.ico');
            if (ico.hasClass('icon-pause')) {
                ico.addClass('icon-play').removeClass('icon-pause');
                self.stop();
            } else {
                ico.addClass('icon-pause').removeClass('icon-play');
                self.play();
            }
        });
        $slides.on(BREW.events.click + '.gallery', function(e) {
            if (options.onClick) options.onClick(this);
            if (this.tagName.toLowerCase() !== 'a') {
                e.preventDefault();
            }
        });
        if (BREW.mobile) {
            $el.touchwipe({
                preventDefaultEvents: false,
                wipeLeft: function() {
                    self.next();
                    self.stop();
                },
                wipeRight: function() {
                    self.prev();
                    self.stop();
                }
            });
        }
    };
    self.init();
};
$.fn.Gallery = function(options) {
    var ns = 'BREW.Gallery';
    var methods = {
        setSlide: function(index, stop) {
            $(this).data(ns).setSlide(index, stop);
        },
        getSlide: function(index) {
            return $(this).data(ns).getSlide(index);
        },
        prev: function() {
            $(this).data(ns).prev();
        },
        next: function() {
            $(this).data(ns).next();
        },
        stop: function() {
            $(this).data(ns).stop();
        },
        play: function() {
            $(this).data(ns).play();
        }
    };
    if (methods[options]) {
        return methods[options].apply(this, Array.prototype.slice.call(arguments, 1));
    } else if (typeof options === 'object' || !options) {
        return this.each(function() {
            var $this = $(this);
            if (undefined == $this.data(ns)) {
                var plugin = new BREW.Gallery(this, options);
                $this.data(ns, plugin);
            }
        });
    }
};
BREW.Carousel = function(el, options) {
    var self = this,
        $el = $(el);
    var options = $.extend({
        prevBtn: 'a.prev',
        nextBtn: 'a.next',
        paginate: 'dots',
        columns: 0,
        slideHeight: 'auto',
        slideWidth: '108px',
        repeat: false,
        fullscreen: false,
        onHover: null,
        onClick: function(el) {
            if (options.fullscreen) {
                var el = $(el).find('img').get(0);
                if (el.requestFullScreen) {
                    el.requestFullScreen();
                } else if (el.mozRequestFullScreen) {
                    el.mozRequestFullScreen();
                } else if (el.webkitRequestFullScreen) {
                    el.webkitRequestFullScreen();
                }
            }
        }
    }, options);
    var $row = $el.find('.slideset').wrap('<div class="wrap"></div>'),
        $imgs = $row.find('div');
    self.row = 0;
    self.rows = 0;
    self.init = function() {
        var rowWidth = 0,
            maxWidth = $el.width();
        if (options.columns > 0) {
            var $col = $('<div class="slidesetcol" />').css('float', 'left'),
                c = options.columns,
                i = 0,
                l = $imgs.length;
            for (i; i < l; i += c) $imgs.slice(i, i + c).wrapAll($col);
            var baseSize = 800,
                baseGutter = 20,
                numberofCols = Math.ceil($imgs.length / options.columns);
            mainContainerPixelW = ((baseSize + baseGutter) * numberofCols) - baseGutter, mainContainerPercentW = (mainContainerPixelW / baseSize) * 100, colContainerPixelW = baseSize, colContainerPercentW = (colContainerPixelW / mainContainerPixelW) * 100, colContainerPercentG = (baseGutter / mainContainerPixelW) * 100, slidePixelW = ((baseSize + baseGutter) / options.columns) - baseGutter, slidePercentW = (slidePixelW / baseSize) * 100, slidePercentG = (baseGutter / baseSize) * 100;
            $el.find('.slideset').css('width', mainContainerPercentW + '%');
            $el.find('.slidesetcol').css('width', colContainerPercentW + '%').not(':last-child').css('margin-right', colContainerPercentG + '%');
            $el.find('.slide').css('width', slidePercentW + '%').not(':last-child').css('margin-right', slidePercentG + '%');
            var tallest = 0;
            $el.find('.slidesetcol').each(function() {
                var x = $(this).outerHeight(true);
                if (x > tallest) tallest = x;
            });
            $el.find('.wrap').css('height', tallest).find('.prev,.next').each(function() {
                var $this = $(this);
                $this.css('margin-top', '-' + $this.height() / 2);
            });
        } else {
            if (options.slideHeight && options.slideWidth) {
                $el.find('.slide').css({
                    height: options.slideHeight,
                    width: options.slideWidth
                });
            }
        }
        $row.Images({
            onComplete: function(el) {
                $imgs.each(function() {
                    var $this = $(this),
                        width = $this.width() + parseInt($this.css('margin-right'));
                    rowWidth += width;
                    if (rowWidth > maxWidth && width < rowWidth) {
                        rowWidth = width;
                        self.rows++;
                    }
                    $this.attr('data-row', self.rows);
                });
                $el.removeClass('hidden');
                if (options.paginate) self.buildPagination();
                self.bindEvents();
            }
        });
    };
    self.buildPagination = function() {
        var $nav = $el.find('.pagination');
        switch (options.paginate) {
            case 'dots':
                $nav.addClass('dots');
                break;
            case 'nums':
                $nav.addClass('nums');
                break;
        }
        $nav.on(BREW.events.click + '.carousel', 'a', function(e) {
            e.preventDefault();
            var $this = $(this),
                row = $this.attr('data-row');
            self.setRow(row);
        });
        self.updatePagination();
    };
    self.updatePagination = function() {
        if (options.columns > 0) self.rows = (Math.ceil($imgs.length / options.columns).toFixed(1)) - 1;
        var links = [],
            i = 0;
        for (i; i <= self.rows; i++) {
            links.push('<li' + (self.row == i ? ' class="current"' : '') + '><a href="javascript:void(0);" data-row="' + i + '">' + (i + 1) + '</a></li>');
        }
        var $pagination = $el.find('.pagination');
        $pagination.toggleClass('hidden', i < 2);
        $pagination.html(links.join(''));
    };
    self.setRow = function(row) {
        if (options.columns > 0) {
            $el.find('.slideset').css('left', '-' + $el.find('.slidesetcol').eq(row).position().left / $el.find('.wrap').width() * 100 + '%');
            self.row = parseInt(row);
            if (options.paginate) {
                $el.find('.prev, .next').show();
                if (self.row === 0) $el.find('.prev').hide().siblings('a').show();
                if (self.row === $el.find('.slidesetcol').length - 1) $el.find('.next').hide();
                $el.find('a[data-row="' + row + '"]').parent().addClass('current').siblings().removeClass('current');
            }
        } else {
            var $img = $imgs.filter('[data-row=' + row + ']:first');
            if ($img.length > 0) {
                var left = $img.position().left;
                if ($.support.transition) {
                    $row.css('left', -left);
                } else {
                    $row.animate({
                        'left': -left
                    });
                }
            }
            if (options.paginate) $el.find('a[data-row="' + row + '"]').parent().addClass('current').siblings().removeClass('current');
            self.row = parseInt(row);
        }
    };
    self.prev = function() {
        if (self.row > 0) {
            self.setRow(self.row - 1);
        } else if (options.repeat) {
            self.setRow(self.rows);
        }
    };
    self.next = function() {
        if (self.row < self.rows) {
            self.setRow(self.row + 1);
        } else if (options.repeat) {
            self.setRow(0);
        }
    };
    self.bindEvents = function() {
        if (options.columns > 0) {
            $(window).bind('smartresize.carousel', function() {
                var rowWidth = 0,
                    maxWidth = $el.width();
                self.rows = 0;
                $imgs.each(function() {
                    var $this = $(this),
                        width = $this.width() + parseInt($this.css('margin-right'));
                    rowWidth += width;
                    if (rowWidth > maxWidth && width < rowWidth) {
                        rowWidth = width;
                        self.rows++;
                    }
                    $this.attr('data-row', self.rows);
                });
                if (options.paginate) self.updatePagination();
            });
        }
        $el.on(BREW.events.click + '.carousel', options.prevBtn, function(e) {
            e.preventDefault();
            self.prev();
        });
        $el.on(BREW.events.click + '.carousel', options.nextBtn, function(e) {
            e.preventDefault();
            self.next();
        });
        $imgs.on('mouseenter.carousel', function(e) {
            if (options.onHover) options.onHover(this);
            e.preventDefault();
        });
        $imgs.on(BREW.events.click + '.carousel', function(e) {
            if (options.onClick) options.onClick(this);
        });
        if (BREW.mobile) {
            $el.touchwipe({
                wipeLeft: function() {
                    self.next();
                    self.stop();
                },
                wipeRight: function() {
                    self.prev();
                    self.stop();
                }
            });
        }
    };
    self.init();
};
$.fn.Carousel = function(options) {
    var ns = 'BREW.Carousel';
    var methods = {
        setRow: function(row) {
            $(this).data(ns).setRow(row);
        },
        prev: function() {
            $(this).data(ns).prev();
        },
        next: function() {
            $(this).data(ns).next();
        }
    };
    if (methods[options]) {
        return methods[options].apply(this, Array.prototype.slice.call(arguments, 1));
    } else if (typeof options === 'object' || !options) {
        return this.each(function() {
            var $this = $(this);
            if (undefined == $this.data(ns)) {
                var plugin = new BREW.Carousel(this, options);
                $this.data(ns, plugin);
            }
        });
    }
};
BREW.Menu = function(el, options) {
    var self = this,
        $el = $(el);
    var options = $.extend({
        onOpen: null,
        onClose: null,
        onClick: null
    }, options);
    var $btn = $el.find('>.btn'),
        $menu = $el.find('.menu');
    self.init = function() {
        self.bindEvents();
    };
    self.open = function() {
        $menu.removeClass('hidden');
        if (options.onOpen) options.onOpen(this);
    };
    self.close = function() {
        $menu.addClass('hidden');
        if (options.onClose) options.onClose(this);
    };
    self.toggle = function(e) {
        e.preventDefault();
        if ($menu.hasClass('hidden')) {
            self.open();
        } else {
            self.close();
        }
    };
    self.bindEvents = function() {
        $(document).bind(BREW.events.click + '.menu', function(e) {
            var $t = $(e.target).closest('.trigger');
            if ($t.get(0) != el) {
                self.close();
            }
        });
        $btn.on(BREW.events.click + '.menu', self.toggle);
        $menu.on('li', BREW.events.click + '.menu', function(e) {
            if (options.onClick) options.onClick(this);
            e.preventDefault();
        });
    };
    self.init();
};
$.fn.Menu = function(options) {
    var ns = 'BREW.Menu';
    var methods = {
        open: function() {
            $(this).data(ns).open();
        },
        close: function() {
            $(this).data(ns).close();
        }
    };
    if (methods[options]) {
        return methods[options].apply(this, Array.prototype.slice.call(arguments, 1));
    } else if (typeof options === 'object' || !options) {
        return this.each(function() {
            var $this = $(this);
            if (undefined == $this.data(ns)) {
                var plugin = new BREW.Menu(this, options);
                $this.data(ns, plugin);
            }
        });
    }
};
BREW.Window = function(el, options) {
    var self = this,
        $el = $(el);
    var options = $.extend({
        ajax: null,
        iframe: null,
        header: true,
        title: null,
        content: null,
        open: true,
        overlay: true,
        closeOnEscape: true,
        closeOnClick: false,
        stack: false,
        onOpen: null,
        onClose: null,
        closeBtn: true,
        width: 'auto',
        height: 'auto',
        noClose: false
    }, options);
    var $overlay = $('<div class="overlay" />');
    self.init = function() {
        $el.addClass('init');
        if (options.width) $el.css('width', options.width);
        if (options.height) $el.css('height', options.height).find('div.pane').css('max-height', options.height);
        if (options.stack) $el.addClass('stacked');
        $el.appendTo('body');
        if (options.open) self.open();
        self.bindEvents();
    };
    self.getWindow = function() {
        return $el;
    };
    self.addOverlay = function() {
        $overlay.appendTo(document.body).show();
    };
    self.removeOverlay = function() {
        $overlay.remove();
        $('body').off('touchmove.window');
    };
    self.hideOverlay = function() {
        $overlay.hide();
    };
    self.getTitle = function() {
        return $el.find('header .title').html();
    };
    self.getContents = function() {
        return $el.find('div.pane').html();
    };
    self.setTitle = function(title) {
        $el.find('header .title').html(title);
    };
    self.setContents = function(contents) {
        $el.find('div.pane').html(contents);
    };
    self.position = function() {
        if (options.iframe) {
            var $iframe = $el.find('iframe');
            if ($iframe.length > 0) {
                $iframe.trigger('adjustHeight');
            }
        }
        var maxHeight = $(window).height();
        var origHeight = $el.outerHeight();
        var height = maxHeight > 0 && origHeight > maxHeight ? maxHeight : origHeight;
        if ($el.hasClass('positioned')) {
            $el.animate({
                'margin-top': -(height !== false ? height / 2 : $el.outerHeight() / 2) + 'px',
                'margin-left': -($el.outerWidth() / 2) + 'px'
            }, 'fast');
        } else {
            $el.css({
                'margin-top': -(height !== false ? height / 2 : $el.outerHeight() / 2) + 'px',
                'margin-left': -($el.outerWidth() / 2) + 'px'
            }).addClass('positioned');
        }
    };
    self.open = function() {
        if ($el.hasClass('closed')) {
            $('.window.init:not(.stacked)').not($el).Window('close');
            self.position();
            $el.removeClass('closed');
            $('body').addClass('mute');
            if (options.overlay) self.addOverlay();
            if (options.onOpen) options.onOpen(this);
            $('html, body').scrollTop(0);
        }
    };
    self.close = function() {
        $('body').removeClass('mute');
        if (options.iframe || options.ajax || options.content) $el.remove();
        if (options.overlay) self.removeOverlay();
        if (options.onClose) options.onClose(this);
    };
    self.hide = function() {
        $el.addClass('closed').hide();
        $('body').removeClass('mute');
        if (options.overlay) self.hideOverlay();
        if (options.onClose) options.onClose(this);
    };
    self.bindEvents = function() {
        setTimeout(function() {
            $(document).on(BREW.events.click + '.window', function(e) {
                var $t = $(e.target).closest('.uiWindow');
                $t.get(0) != el && options.closeOnClick && self.close();
                $(document).off(BREW.events.click + '.window');
            });
        }, 100);
        $(document).on('keyup.window', function(e) {
            options.closeOnEscape && e.which == 27 && self.close();
        });
        if (options.closeBtn) {
            $el.on(BREW.events.click + '.window', 'header .btnset', function(e) {
                e.preventDefault();
                self.close();
            });
        }
        $(window).bind('smartresize.window', self.position);
    };
    self.init();
};
$.Window = $.fn.Window = function(options) {
    var ns = 'BREW.Window',
        options = options ? options : {};
    if (options.noClose) {
        var options = $.extend({
            closeBtn: false,
            closeOnClick: false,
            closeOnEscape: false
        }, options);
    }
    var methods = {
        setTitle: function(title) {
            this.setTitle(title);
        },
        addOverlay: function() {
            this.addOverlay();
        },
        removeOverlay: function() {
            this.removeOverlay();
        },
        position: function() {
            this.position();
        },
        open: function() {
            this.open();
        },
        close: function() {
            this.close();
        },
        hide: function() {
            this.hide();
        }
    };
    var createWindow = function(options) {
        return $('<div class="window' + (options.iframe ? ' iframe' : '') + ' closed">' +
            (options.header === false ? '' : '<header>' + '<h4 class="title">' + (options.title ? options.title : (options.ajax || options.iframe ? 'Loading&hellip;' : '&nbsp;')) + '</h4>' +
                (options.closeBtn !== false ? '<div class="btnset"><a class="close btn"><i class="icon-remove"></i></a></div>' : '') + '</header>') + '<div class="pane">' + (options.content ? options.content : '') + '</div>' + '</div>');
    };
    if (!(this instanceof $) && typeof(options) != 'string') {
        if (options.ajax) {
            $.ajax({
                url: options.ajax,
                type: 'get',
                dataType: 'html',
                success: function(html) {
                    var $html = $(html),
                        title = $html.filter('title').text(),
                        html = $html.find('#content').html();
                    options.title = title;
                    options.content = html
                    var $el = createWindow(options);
                    return $el.Window(options);
                }
            });
        } else if (options.iframe) {
            options.iframe = (options.iframe.indexOf('?') != -1 ? options.iframe + '&' : options.iframe + '?') + 'popup';
            var options = $.extend(options, {
                    width: 800,
                    open: false,
                    content: '<iframe src="' + options.iframe + '" width="100%" frameborder="0"></iframe>'
                }),
                $el = createWindow(options);
            $el.find('iframe').on('load', function() {
                var doc = this.contentWindow.document,
                    docTitle = doc.title,
                    $body = $('body', doc);
                $el.Window('open');
                setTimeout(function() {
                    $el.Window('setTitle', docTitle);
                    $el.Window('position');
                    $body.find('a').each(function() {
                        var $this = $(this),
                            href = $this.attr('href'),
                            target = $this.attr('target');
                        if (target != '_blank' && target != '_parent' && href && href.length > 0 && href.indexOf('javascript:') !== 0 && href.indexOf('#') !== 0) {
                            $this.attr('href', (href.indexOf('?') != -1 ? href + '&' : href + '?') + 'popup');
                        }
                    });
                    $body.find('form').each(function() {
                        var $this = $(this),
                            action = $this.attr('action');
                        if (action && action.length > 0) {
                            $this.attr('action', (action.indexOf('?') != -1 ? action + '&' : action + '?') + 'popup');
                        }
                        $this.on('submit', function() {
                            return true;
                        });
                    });
                }, 100);
            }).on('adjustHeight', function() {
                var doc = this.contentWindow.document,
                    $body = $('body', doc),
                    height = $body.height();
                var h = $(window).height() - 50;
                height = (h < height) ? h - 10 : height + 10;
                $(this).height(height);
                $el.height(height);
            });
            $window = $el.Window(options);
            $window.Window('addOverlay');
            $('html, body').scrollTop(0);
            return $window;
        } else {
            var $el = createWindow(options);
            return $el.Window(options);
        }
    }
    if (typeof(options) == 'string' && methods[options]) {
        if (!(this instanceof $)) {
            $('.window.init').each(function() {
                var win = $(this).data(ns);
                if (win) methods[options].apply(win, Array.prototype.slice.call(arguments, 1))
            });
            return;
        }
        var win = $(this).data(ns);
        if (win) return methods[options].apply(win, Array.prototype.slice.call(arguments, 1));
    } else if (typeof options === 'object' || !options) {
        return this.each(function() {
            var $this = $(this);
            if (undefined == $this.data(ns)) {
                var plugin = new BREW.Window(this, options);
                $this.data(ns, plugin);
            }
        });
    }
};
BREW.Truncate = function(el, options) {
    var options = $.extend({
        count: 600,
        ending: '...',
        moreText: 'more &raquo;',
        lessText: '&laquo; less '
    }, options);
    var $el = $(el),
        fullText = $el.html(),
        truncText = $el.html().substring(0, options.count).split(" ").slice(0, -1).join(" ") + options.ending;
    if (fullText.length < options.count) {
        return;
    }
    $el.html(truncText + ' <a href="#" class="more">' + options.moreText + '</a>');
    $el.find('a.more').live('click', function() {
        $el.html(fullText + ' <a href="#" class="less">' + options.lessText + '</a>').show();
        return false;
    });
    $el.find('a.less').live('click', function() {
        $el.html(truncText + ' <a href="#" class="more"">' + options.moreText + '</a>').show();
        return false;
    });
};
$.fn.Truncate = function(options) {
    return this.each(function() {
        (new BREW.Truncate(this, options));
    });
};

Number.prototype.format = function(c, d, t) {
    var n = this,
        c = isNaN(c = Math.abs(c)) ? 0 : c,
        d = d == undefined ? '.' : d,
        t = t == undefined ? ',' : t,
        s = n < 0 ? '-' : '',
        i = parseInt(n = Math.abs(+n || 0).toFixed(c)) + '',
        j = (j = i.length) > 3 ? j % 3 : 0;
    return s + (j ? i.substr(0, j) + t : '') + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c ? d + Math.abs(n - i).toFixed(c).slice(2) : '');
};
/**
 * React (with addons) v15.0.1
 *
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */
! function(e) {
    if ("object" == typeof exports && "undefined" != typeof module) module.exports = e();
    else if ("function" == typeof define && define.amd) define([], e);
    else {
        var t;
        t = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, t.React = e()
    }
}(function() {
    return function e(t, n, r) {
        function o(a, s) {
            if (!n[a]) {
                if (!t[a]) {
                    var u = "function" == typeof require && require;
                    if (!s && u) return u(a, !0);
                    if (i) return i(a, !0);
                    var l = new Error("Cannot find module '" + a + "'");
                    throw l.code = "MODULE_NOT_FOUND", l
                }
                var c = n[a] = {
                    exports: {}
                };
                t[a][0].call(c.exports, function(e) {
                    var n = t[a][1][e];
                    return o(n ? n : e)
                }, c, c.exports, e, t, n, r)
            }
            return n[a].exports
        }
        for (var i = "function" == typeof require && require, a = 0; a < r.length; a++) o(r[a]);
        return o
    }({
        1: [function(e, t, n) {
            "use strict";
            var r = e(42),
                o = e(162),
                i = {
                    focusDOMComponent: function() {
                        o(r.getNodeFromInstance(this))
                    }
                };
            t.exports = i
        }, {
            162: 162,
            42: 42
        }],
        2: [function(e, t, n) {
            "use strict";

            function r() {
                var e = window.opera;
                return "object" == typeof e && "function" == typeof e.version && parseInt(e.version(), 10) <= 12
            }

            function o(e) {
                return (e.ctrlKey || e.altKey || e.metaKey) && !(e.ctrlKey && e.altKey)
            }

            function i(e) {
                switch (e) {
                    case S.topCompositionStart:
                        return M.compositionStart;
                    case S.topCompositionEnd:
                        return M.compositionEnd;
                    case S.topCompositionUpdate:
                        return M.compositionUpdate
                }
            }

            function a(e, t) {
                return e === S.topKeyDown && t.keyCode === _
            }

            function s(e, t) {
                switch (e) {
                    case S.topKeyUp:
                        return -1 !== b.indexOf(t.keyCode);
                    case S.topKeyDown:
                        return t.keyCode !== _;
                    case S.topKeyPress:
                    case S.topMouseDown:
                    case S.topBlur:
                        return !0;
                    default:
                        return !1
                }
            }

            function u(e) {
                var t = e.detail;
                return "object" == typeof t && "data" in t ? t.data : null
            }

            function l(e, t, n, r) {
                var o, l;
                if (E ? o = i(e) : R ? s(e, n) && (o = M.compositionEnd) : a(e, n) && (o = M.compositionStart), !o) return null;
                P && (R || o !== M.compositionStart ? o === M.compositionEnd && R && (l = R.getData()) : R = m.getPooled(r));
                var c = g.getPooled(o, t, n, r);
                if (l) c.data = l;
                else {
                    var p = u(n);
                    null !== p && (c.data = p)
                }
                return h.accumulateTwoPhaseDispatches(c), c
            }

            function c(e, t) {
                switch (e) {
                    case S.topCompositionEnd:
                        return u(t);
                    case S.topKeyPress:
                        var n = t.which;
                        return n !== N ? null : (k = !0, w);
                    case S.topTextInput:
                        var r = t.data;
                        return r === w && k ? null : r;
                    default:
                        return null
                }
            }

            function p(e, t) {
                if (R) {
                    if (e === S.topCompositionEnd || s(e, t)) {
                        var n = R.getData();
                        return m.release(R), R = null, n
                    }
                    return null
                }
                switch (e) {
                    case S.topPaste:
                        return null;
                    case S.topKeyPress:
                        return t.which && !o(t) ? String.fromCharCode(t.which) : null;
                    case S.topCompositionEnd:
                        return P ? null : t.data;
                    default:
                        return null
                }
            }

            function d(e, t, n, r) {
                var o;
                if (o = x ? c(e, n) : p(e, n), !o) return null;
                var i = y.getPooled(M.beforeInput, t, n, r);
                return i.data = o, h.accumulateTwoPhaseDispatches(i), i
            }
            var f = e(15),
                h = e(19),
                v = e(154),
                m = e(20),
                g = e(108),
                y = e(112),
                C = e(172),
                b = [9, 13, 27, 32],
                _ = 229,
                E = v.canUseDOM && "CompositionEvent" in window,
                T = null;
            v.canUseDOM && "documentMode" in document && (T = document.documentMode);
            var x = v.canUseDOM && "TextEvent" in window && !T && !r(),
                P = v.canUseDOM && (!E || T && T > 8 && 11 >= T),
                N = 32,
                w = String.fromCharCode(N),
                S = f.topLevelTypes,
                M = {
                    beforeInput: {
                        phasedRegistrationNames: {
                            bubbled: C({
                                onBeforeInput: null
                            }),
                            captured: C({
                                onBeforeInputCapture: null
                            })
                        },
                        dependencies: [S.topCompositionEnd, S.topKeyPress, S.topTextInput, S.topPaste]
                    },
                    compositionEnd: {
                        phasedRegistrationNames: {
                            bubbled: C({
                                onCompositionEnd: null
                            }),
                            captured: C({
                                onCompositionEndCapture: null
                            })
                        },
                        dependencies: [S.topBlur, S.topCompositionEnd, S.topKeyDown, S.topKeyPress, S.topKeyUp, S.topMouseDown]
                    },
                    compositionStart: {
                        phasedRegistrationNames: {
                            bubbled: C({
                                onCompositionStart: null
                            }),
                            captured: C({
                                onCompositionStartCapture: null
                            })
                        },
                        dependencies: [S.topBlur, S.topCompositionStart, S.topKeyDown, S.topKeyPress, S.topKeyUp, S.topMouseDown]
                    },
                    compositionUpdate: {
                        phasedRegistrationNames: {
                            bubbled: C({
                                onCompositionUpdate: null
                            }),
                            captured: C({
                                onCompositionUpdateCapture: null
                            })
                        },
                        dependencies: [S.topBlur, S.topCompositionUpdate, S.topKeyDown, S.topKeyPress, S.topKeyUp, S.topMouseDown]
                    }
                },
                k = !1,
                R = null,
                D = {
                    eventTypes: M,
                    extractEvents: function(e, t, n, r) {
                        return [l(e, t, n, r), d(e, t, n, r)]
                    }
                };
            t.exports = D
        }, {
            108: 108,
            112: 112,
            15: 15,
            154: 154,
            172: 172,
            19: 19,
            20: 20
        }],
        3: [function(e, t, n) {
            "use strict";

            function r(e, t) {
                return e + t.charAt(0).toUpperCase() + t.substring(1)
            }
            var o = {
                    animationIterationCount: !0,
                    borderImageOutset: !0,
                    borderImageSlice: !0,
                    borderImageWidth: !0,
                    boxFlex: !0,
                    boxFlexGroup: !0,
                    boxOrdinalGroup: !0,
                    columnCount: !0,
                    flex: !0,
                    flexGrow: !0,
                    flexPositive: !0,
                    flexShrink: !0,
                    flexNegative: !0,
                    flexOrder: !0,
                    gridRow: !0,
                    gridColumn: !0,
                    fontWeight: !0,
                    lineClamp: !0,
                    lineHeight: !0,
                    opacity: !0,
                    order: !0,
                    orphans: !0,
                    tabSize: !0,
                    widows: !0,
                    zIndex: !0,
                    zoom: !0,
                    fillOpacity: !0,
                    floodOpacity: !0,
                    stopOpacity: !0,
                    strokeDasharray: !0,
                    strokeDashoffset: !0,
                    strokeMiterlimit: !0,
                    strokeOpacity: !0,
                    strokeWidth: !0
                },
                i = ["Webkit", "ms", "Moz", "O"];
            Object.keys(o).forEach(function(e) {
                i.forEach(function(t) {
                    o[r(t, e)] = o[e]
                })
            });
            var a = {
                    background: {
                        backgroundAttachment: !0,
                        backgroundColor: !0,
                        backgroundImage: !0,
                        backgroundPositionX: !0,
                        backgroundPositionY: !0,
                        backgroundRepeat: !0
                    },
                    backgroundPosition: {
                        backgroundPositionX: !0,
                        backgroundPositionY: !0
                    },
                    border: {
                        borderWidth: !0,
                        borderStyle: !0,
                        borderColor: !0
                    },
                    borderBottom: {
                        borderBottomWidth: !0,
                        borderBottomStyle: !0,
                        borderBottomColor: !0
                    },
                    borderLeft: {
                        borderLeftWidth: !0,
                        borderLeftStyle: !0,
                        borderLeftColor: !0
                    },
                    borderRight: {
                        borderRightWidth: !0,
                        borderRightStyle: !0,
                        borderRightColor: !0
                    },
                    borderTop: {
                        borderTopWidth: !0,
                        borderTopStyle: !0,
                        borderTopColor: !0
                    },
                    font: {
                        fontStyle: !0,
                        fontVariant: !0,
                        fontWeight: !0,
                        fontSize: !0,
                        lineHeight: !0,
                        fontFamily: !0
                    },
                    outline: {
                        outlineWidth: !0,
                        outlineStyle: !0,
                        outlineColor: !0
                    }
                },
                s = {
                    isUnitlessNumber: o,
                    shorthandPropertyExpansions: a
                };
            t.exports = s
        }, {}],
        4: [function(e, t, n) {
            "use strict";
            var r = e(3),
                o = e(154),
                i = e(84),
                a = (e(156), e(125)),
                s = e(167),
                u = e(174),
                l = (e(176), u(function(e) {
                    return s(e)
                })),
                c = !1,
                p = "cssFloat";
            if (o.canUseDOM) {
                var d = document.createElement("div").style;
                try {
                    d.font = ""
                } catch (f) {
                    c = !0
                }
                void 0 === document.documentElement.style.cssFloat && (p = "styleFloat")
            }
            var h = {
                createMarkupForStyles: function(e, t) {
                    var n = "";
                    for (var r in e)
                        if (e.hasOwnProperty(r)) {
                            var o = e[r];
                            null != o && (n += l(r) + ":", n += a(r, o, t) + ";")
                        }
                    return n || null
                },
                setValueForStyles: function(e, t, n) {
                    var o = e.style;
                    for (var i in t)
                        if (t.hasOwnProperty(i)) {
                            var s = a(i, t[i], n);
                            if ("float" !== i && "cssFloat" !== i || (i = p), s) o[i] = s;
                            else {
                                var u = c && r.shorthandPropertyExpansions[i];
                                if (u)
                                    for (var l in u) o[l] = "";
                                else o[i] = ""
                            }
                        }
                }
            };
            i.measureMethods(h, "CSSPropertyOperations", {
                setValueForStyles: "setValueForStyles"
            }), t.exports = h
        }, {
            125: 125,
            154: 154,
            156: 156,
            167: 167,
            174: 174,
            176: 176,
            3: 3,
            84: 84
        }],
        5: [function(e, t, n) {
            "use strict";

            function r() {
                this._callbacks = null, this._contexts = null
            }
            var o = e(177),
                i = e(24),
                a = e(168);
            o(r.prototype, {
                enqueue: function(e, t) {
                    this._callbacks = this._callbacks || [], this._contexts = this._contexts || [], this._callbacks.push(e), this._contexts.push(t)
                },
                notifyAll: function() {
                    var e = this._callbacks,
                        t = this._contexts;
                    if (e) {
                        e.length !== t.length ? a(!1) : void 0, this._callbacks = null, this._contexts = null;
                        for (var n = 0; n < e.length; n++) e[n].call(t[n]);
                        e.length = 0, t.length = 0
                    }
                },
                checkpoint: function() {
                    return this._callbacks ? this._callbacks.length : 0
                },
                rollback: function(e) {
                    this._callbacks && (this._callbacks.length = e, this._contexts.length = e)
                },
                reset: function() {
                    this._callbacks = null, this._contexts = null
                },
                destructor: function() {
                    this.reset()
                }
            }), i.addPoolingTo(r), t.exports = r
        }, {
            168: 168,
            177: 177,
            24: 24
        }],
        6: [function(e, t, n) {
            "use strict";

            function r(e) {
                var t = e.nodeName && e.nodeName.toLowerCase();
                return "select" === t || "input" === t && "file" === e.type
            }

            function o(e) {
                var t = x.getPooled(k.change, D, e, P(e));
                b.accumulateTwoPhaseDispatches(t), T.batchedUpdates(i, t)
            }

            function i(e) {
                C.enqueueEvents(e), C.processEventQueue(!1)
            }

            function a(e, t) {
                R = e, D = t, R.attachEvent("onchange", o)
            }

            function s() {
                R && (R.detachEvent("onchange", o), R = null, D = null)
            }

            function u(e, t) {
                return e === M.topChange ? t : void 0
            }

            function l(e, t, n) {
                e === M.topFocus ? (s(), a(t, n)) : e === M.topBlur && s()
            }

            function c(e, t) {
                R = e, D = t, A = e.value, I = Object.getOwnPropertyDescriptor(e.constructor.prototype, "value"), Object.defineProperty(R, "value", U), R.attachEvent ? R.attachEvent("onpropertychange", d) : R.addEventListener("propertychange", d, !1)
            }

            function p() {
                R && (delete R.value, R.detachEvent ? R.detachEvent("onpropertychange", d) : R.removeEventListener("propertychange", d, !1), R = null, D = null, A = null, I = null)
            }

            function d(e) {
                if ("value" === e.propertyName) {
                    var t = e.srcElement.value;
                    t !== A && (A = t, o(e))
                }
            }

            function f(e, t) {
                return e === M.topInput ? t : void 0
            }

            function h(e, t, n) {
                e === M.topFocus ? (p(), c(t, n)) : e === M.topBlur && p()
            }

            function v(e, t) {
                return e !== M.topSelectionChange && e !== M.topKeyUp && e !== M.topKeyDown || !R || R.value === A ? void 0 : (A = R.value, D)
            }

            function m(e) {
                return e.nodeName && "input" === e.nodeName.toLowerCase() && ("checkbox" === e.type || "radio" === e.type)
            }

            function g(e, t) {
                return e === M.topClick ? t : void 0
            }
            var y = e(15),
                C = e(16),
                b = e(19),
                _ = e(154),
                E = e(42),
                T = e(99),
                x = e(110),
                P = e(133),
                N = e(140),
                w = e(141),
                S = e(172),
                M = y.topLevelTypes,
                k = {
                    change: {
                        phasedRegistrationNames: {
                            bubbled: S({
                                onChange: null
                            }),
                            captured: S({
                                onChangeCapture: null
                            })
                        },
                        dependencies: [M.topBlur, M.topChange, M.topClick, M.topFocus, M.topInput, M.topKeyDown, M.topKeyUp, M.topSelectionChange]
                    }
                },
                R = null,
                D = null,
                A = null,
                I = null,
                O = !1;
            _.canUseDOM && (O = N("change") && (!("documentMode" in document) || document.documentMode > 8));
            var L = !1;
            _.canUseDOM && (L = N("input") && (!("documentMode" in document) || document.documentMode > 11));
            var U = {
                    get: function() {
                        return I.get.call(this)
                    },
                    set: function(e) {
                        A = "" + e, I.set.call(this, e)
                    }
                },
                F = {
                    eventTypes: k,
                    extractEvents: function(e, t, n, o) {
                        var i, a, s = t ? E.getNodeFromInstance(t) : window;
                        if (r(s) ? O ? i = u : a = l : w(s) ? L ? i = f : (i = v, a = h) : m(s) && (i = g), i) {
                            var c = i(e, t);
                            if (c) {
                                var p = x.getPooled(k.change, c, n, o);
                                return p.type = "change", b.accumulateTwoPhaseDispatches(p), p
                            }
                        }
                        a && a(e, s, t)
                    }
                };
            t.exports = F
        }, {
            110: 110,
            133: 133,
            140: 140,
            141: 141,
            15: 15,
            154: 154,
            16: 16,
            172: 172,
            19: 19,
            42: 42,
            99: 99
        }],
        7: [function(e, t, n) {
            "use strict";

            function r(e, t) {
                return Array.isArray(t) && (t = t[1]), t ? t.nextSibling : e.firstChild
            }

            function o(e, t, n) {
                c.insertTreeBefore(e, t, n)
            }

            function i(e, t, n) {
                Array.isArray(t) ? s(e, t[0], t[1], n) : g(e, t, n)
            }

            function a(e, t) {
                if (Array.isArray(t)) {
                    var n = t[1];
                    t = t[0], u(e, t, n), e.removeChild(n)
                }
                e.removeChild(t)
            }

            function s(e, t, n, r) {
                for (var o = t;;) {
                    var i = o.nextSibling;
                    if (g(e, o, r), o === n) break;
                    o = i
                }
            }

            function u(e, t, n) {
                for (;;) {
                    var r = t.nextSibling;
                    if (r === n) break;
                    e.removeChild(r)
                }
            }

            function l(e, t, n) {
                var r = e.parentNode,
                    o = e.nextSibling;
                o === t ? n && g(r, document.createTextNode(n), o) : n ? (m(o, n), u(r, o, t)) : u(r, e, t)
            }
            var c = e(8),
                p = e(12),
                d = e(79),
                f = e(84),
                h = e(124),
                v = e(145),
                m = e(146),
                g = h(function(e, t, n) {
                    e.insertBefore(t, n)
                }),
                y = {
                    dangerouslyReplaceNodeWithMarkup: p.dangerouslyReplaceNodeWithMarkup,
                    replaceDelimitedText: l,
                    processUpdates: function(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var s = t[n];
                            switch (s.type) {
                                case d.INSERT_MARKUP:
                                    o(e, s.content, r(e, s.afterNode));
                                    break;
                                case d.MOVE_EXISTING:
                                    i(e, s.fromNode, r(e, s.afterNode));
                                    break;
                                case d.SET_MARKUP:
                                    v(e, s.content);
                                    break;
                                case d.TEXT_CONTENT:
                                    m(e, s.content);
                                    break;
                                case d.REMOVE_NODE:
                                    a(e, s.fromNode)
                            }
                        }
                    }
                };
            f.measureMethods(y, "DOMChildrenOperations", {
                replaceDelimitedText: "replaceDelimitedText"
            }), t.exports = y
        }, {
            12: 12,
            124: 124,
            145: 145,
            146: 146,
            79: 79,
            8: 8,
            84: 84
        }],
        8: [function(e, t, n) {
            "use strict";

            function r(e) {
                if (p) {
                    var t = e.node,
                        n = e.children;
                    if (n.length)
                        for (var r = 0; r < n.length; r++) d(t, n[r], null);
                    else null != e.html ? t.innerHTML = e.html : null != e.text && c(t, e.text)
                }
            }

            function o(e, t) {
                e.parentNode.replaceChild(t.node, e), r(t)
            }

            function i(e, t) {
                p ? e.children.push(t) : e.node.appendChild(t.node)
            }

            function a(e, t) {
                p ? e.html = t : e.node.innerHTML = t
            }

            function s(e, t) {
                p ? e.text = t : c(e.node, t)
            }

            function u(e) {
                return {
                    node: e,
                    children: [],
                    html: null,
                    text: null
                }
            }
            var l = e(124),
                c = e(146),
                p = "undefined" != typeof document && "number" == typeof document.documentMode || "undefined" != typeof navigator && "string" == typeof navigator.userAgent && /\bEdge\/\d/.test(navigator.userAgent),
                d = l(function(e, t, n) {
                    11 === t.node.nodeType ? (r(t), e.insertBefore(t.node, n)) : (e.insertBefore(t.node, n), r(t))
                });
            u.insertTreeBefore = d, u.replaceChildWithTree = o, u.queueChild = i, u.queueHTML = a, u.queueText = s, t.exports = u
        }, {
            124: 124,
            146: 146
        }],
        9: [function(e, t, n) {
            "use strict";
            var r = {
                html: "http://www.w3.org/1999/xhtml",
                mathml: "http://www.w3.org/1998/Math/MathML",
                svg: "http://www.w3.org/2000/svg"
            };
            t.exports = r
        }, {}],
        10: [function(e, t, n) {
            "use strict";

            function r(e, t) {
                return (e & t) === t
            }
            var o = e(168),
                i = {
                    MUST_USE_PROPERTY: 1,
                    HAS_SIDE_EFFECTS: 2,
                    HAS_BOOLEAN_VALUE: 4,
                    HAS_NUMERIC_VALUE: 8,
                    HAS_POSITIVE_NUMERIC_VALUE: 24,
                    HAS_OVERLOADED_BOOLEAN_VALUE: 32,
                    injectDOMPropertyConfig: function(e) {
                        var t = i,
                            n = e.Properties || {},
                            a = e.DOMAttributeNamespaces || {},
                            u = e.DOMAttributeNames || {},
                            l = e.DOMPropertyNames || {},
                            c = e.DOMMutationMethods || {};
                        e.isCustomAttribute && s._isCustomAttributeFunctions.push(e.isCustomAttribute);
                        for (var p in n) {
                            s.properties.hasOwnProperty(p) ? o(!1) : void 0;
                            var d = p.toLowerCase(),
                                f = n[p],
                                h = {
                                    attributeName: d,
                                    attributeNamespace: null,
                                    propertyName: p,
                                    mutationMethod: null,
                                    mustUseProperty: r(f, t.MUST_USE_PROPERTY),
                                    hasSideEffects: r(f, t.HAS_SIDE_EFFECTS),
                                    hasBooleanValue: r(f, t.HAS_BOOLEAN_VALUE),
                                    hasNumericValue: r(f, t.HAS_NUMERIC_VALUE),
                                    hasPositiveNumericValue: r(f, t.HAS_POSITIVE_NUMERIC_VALUE),
                                    hasOverloadedBooleanValue: r(f, t.HAS_OVERLOADED_BOOLEAN_VALUE)
                                };
                            if (!h.mustUseProperty && h.hasSideEffects ? o(!1) : void 0, h.hasBooleanValue + h.hasNumericValue + h.hasOverloadedBooleanValue <= 1 ? void 0 : o(!1), u.hasOwnProperty(p)) {
                                var v = u[p];
                                h.attributeName = v
                            }
                            a.hasOwnProperty(p) && (h.attributeNamespace = a[p]), l.hasOwnProperty(p) && (h.propertyName = l[p]), c.hasOwnProperty(p) && (h.mutationMethod = c[p]), s.properties[p] = h
                        }
                    }
                },
                a = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD",
                s = {
                    ID_ATTRIBUTE_NAME: "data-reactid",
                    ROOT_ATTRIBUTE_NAME: "data-reactroot",
                    ATTRIBUTE_NAME_START_CHAR: a,
                    ATTRIBUTE_NAME_CHAR: a + "\\-.0-9\\uB7\\u0300-\\u036F\\u203F-\\u2040",
                    properties: {},
                    getPossibleStandardName: null,
                    _isCustomAttributeFunctions: [],
                    isCustomAttribute: function(e) {
                        for (var t = 0; t < s._isCustomAttributeFunctions.length; t++) {
                            var n = s._isCustomAttributeFunctions[t];
                            if (n(e)) return !0
                        }
                        return !1
                    },
                    injection: i
                };
            t.exports = s
        }, {
            168: 168
        }],
        11: [function(e, t, n) {
            "use strict";

            function r(e) {
                return c.hasOwnProperty(e) ? !0 : l.hasOwnProperty(e) ? !1 : u.test(e) ? (c[e] = !0, !0) : (l[e] = !0, !1)
            }

            function o(e, t) {
                return null == t || e.hasBooleanValue && !t || e.hasNumericValue && isNaN(t) || e.hasPositiveNumericValue && 1 > t || e.hasOverloadedBooleanValue && t === !1
            }
            var i = e(10),
                a = (e(50), e(84)),
                s = e(143),
                u = (e(176), new RegExp("^[" + i.ATTRIBUTE_NAME_START_CHAR + "][" + i.ATTRIBUTE_NAME_CHAR + "]*$")),
                l = {},
                c = {},
                p = {
                    createMarkupForID: function(e) {
                        return i.ID_ATTRIBUTE_NAME + "=" + s(e)
                    },
                    setAttributeForID: function(e, t) {
                        e.setAttribute(i.ID_ATTRIBUTE_NAME, t)
                    },
                    createMarkupForRoot: function() {
                        return i.ROOT_ATTRIBUTE_NAME + '=""'
                    },
                    setAttributeForRoot: function(e) {
                        e.setAttribute(i.ROOT_ATTRIBUTE_NAME, "")
                    },
                    createMarkupForProperty: function(e, t) {
                        var n = i.properties.hasOwnProperty(e) ? i.properties[e] : null;
                        if (n) {
                            if (o(n, t)) return "";
                            var r = n.attributeName;
                            return n.hasBooleanValue || n.hasOverloadedBooleanValue && t === !0 ? r + '=""' : r + "=" + s(t)
                        }
                        return i.isCustomAttribute(e) ? null == t ? "" : e + "=" + s(t) : null
                    },
                    createMarkupForCustomAttribute: function(e, t) {
                        return r(e) && null != t ? e + "=" + s(t) : ""
                    },
                    setValueForProperty: function(e, t, n) {
                        var r = i.properties.hasOwnProperty(t) ? i.properties[t] : null;
                        if (r) {
                            var a = r.mutationMethod;
                            if (a) a(e, n);
                            else if (o(r, n)) this.deleteValueForProperty(e, t);
                            else if (r.mustUseProperty) {
                                var s = r.propertyName;
                                r.hasSideEffects && "" + e[s] == "" + n || (e[s] = n)
                            } else {
                                var u = r.attributeName,
                                    l = r.attributeNamespace;
                                l ? e.setAttributeNS(l, u, "" + n) : r.hasBooleanValue || r.hasOverloadedBooleanValue && n === !0 ? e.setAttribute(u, "") : e.setAttribute(u, "" + n)
                            }
                        } else i.isCustomAttribute(t) && p.setValueForAttribute(e, t, n)
                    },
                    setValueForAttribute: function(e, t, n) {
                        r(t) && (null == n ? e.removeAttribute(t) : e.setAttribute(t, "" + n))
                    },
                    deleteValueForProperty: function(e, t) {
                        var n = i.properties.hasOwnProperty(t) ? i.properties[t] : null;
                        if (n) {
                            var r = n.mutationMethod;
                            if (r) r(e, void 0);
                            else if (n.mustUseProperty) {
                                var o = n.propertyName;
                                n.hasBooleanValue ? e[o] = !1 : n.hasSideEffects && "" + e[o] == "" || (e[o] = "")
                            } else e.removeAttribute(n.attributeName)
                        } else i.isCustomAttribute(t) && e.removeAttribute(t)
                    }
                };
            a.measureMethods(p, "DOMPropertyOperations", {
                setValueForProperty: "setValueForProperty",
                setValueForAttribute: "setValueForAttribute",
                deleteValueForProperty: "deleteValueForProperty"
            }), t.exports = p
        }, {
            10: 10,
            143: 143,
            176: 176,
            50: 50,
            84: 84
        }],
        12: [function(e, t, n) {
            "use strict";

            function r(e) {
                return e.substring(1, e.indexOf(" "))
            }
            var o = e(8),
                i = e(154),
                a = e(159),
                s = e(160),
                u = e(164),
                l = e(168),
                c = /^(<[^ \/>]+)/,
                p = "data-danger-index",
                d = {
                    dangerouslyRenderMarkup: function(e) {
                        i.canUseDOM ? void 0 : l(!1);
                        for (var t, n = {}, o = 0; o < e.length; o++) e[o] ? void 0 : l(!1), t = r(e[o]), t = u(t) ? t : "*", n[t] = n[t] || [], n[t][o] = e[o];
                        var d = [],
                            f = 0;
                        for (t in n)
                            if (n.hasOwnProperty(t)) {
                                var h, v = n[t];
                                for (h in v)
                                    if (v.hasOwnProperty(h)) {
                                        var m = v[h];
                                        v[h] = m.replace(c, "$1 " + p + '="' + h + '" ')
                                    }
                                for (var g = a(v.join(""), s), y = 0; y < g.length; ++y) {
                                    var C = g[y];
                                    C.hasAttribute && C.hasAttribute(p) && (h = +C.getAttribute(p), C.removeAttribute(p), d.hasOwnProperty(h) ? l(!1) : void 0, d[h] = C, f += 1)
                                }
                            }
                        return f !== d.length ? l(!1) : void 0, d.length !== e.length ? l(!1) : void 0, d
                    },
                    dangerouslyReplaceNodeWithMarkup: function(e, t) {
                        if (i.canUseDOM ? void 0 : l(!1), t ? void 0 : l(!1), "HTML" === e.nodeName ? l(!1) : void 0, "string" == typeof t) {
                            var n = a(t, s)[0];
                            e.parentNode.replaceChild(n, e)
                        } else o.replaceChildWithTree(e, t)
                    }
                };
            t.exports = d
        }, {
            154: 154,
            159: 159,
            160: 160,
            164: 164,
            168: 168,
            8: 8
        }],
        13: [function(e, t, n) {
            "use strict";
            var r = e(172),
                o = [r({
                    ResponderEventPlugin: null
                }), r({
                    SimpleEventPlugin: null
                }), r({
                    TapEventPlugin: null
                }), r({
                    EnterLeaveEventPlugin: null
                }), r({
                    ChangeEventPlugin: null
                }), r({
                    SelectEventPlugin: null
                }), r({
                    BeforeInputEventPlugin: null
                })];
            t.exports = o
        }, {
            172: 172
        }],
        14: [function(e, t, n) {
            "use strict";
            var r = e(15),
                o = e(19),
                i = e(42),
                a = e(114),
                s = e(172),
                u = r.topLevelTypes,
                l = {
                    mouseEnter: {
                        registrationName: s({
                            onMouseEnter: null
                        }),
                        dependencies: [u.topMouseOut, u.topMouseOver]
                    },
                    mouseLeave: {
                        registrationName: s({
                            onMouseLeave: null
                        }),
                        dependencies: [u.topMouseOut, u.topMouseOver]
                    }
                },
                c = {
                    eventTypes: l,
                    extractEvents: function(e, t, n, r) {
                        if (e === u.topMouseOver && (n.relatedTarget || n.fromElement)) return null;
                        if (e !== u.topMouseOut && e !== u.topMouseOver) return null;
                        var s;
                        if (r.window === r) s = r;
                        else {
                            var c = r.ownerDocument;
                            s = c ? c.defaultView || c.parentWindow : window
                        }
                        var p, d;
                        if (e === u.topMouseOut) {
                            p = t;
                            var f = n.relatedTarget || n.toElement;
                            d = f ? i.getClosestInstanceFromNode(f) : null
                        } else p = null, d = t;
                        if (p === d) return null;
                        var h = null == p ? s : i.getNodeFromInstance(p),
                            v = null == d ? s : i.getNodeFromInstance(d),
                            m = a.getPooled(l.mouseLeave, p, n, r);
                        m.type = "mouseleave", m.target = h, m.relatedTarget = v;
                        var g = a.getPooled(l.mouseEnter, d, n, r);
                        return g.type = "mouseenter", g.target = v, g.relatedTarget = h, o.accumulateEnterLeaveDispatches(m, g, p, d), [m, g]
                    }
                };
            t.exports = c
        }, {
            114: 114,
            15: 15,
            172: 172,
            19: 19,
            42: 42
        }],
        15: [function(e, t, n) {
            "use strict";
            var r = e(171),
                o = r({
                    bubbled: null,
                    captured: null
                }),
                i = r({
                    topAbort: null,
                    topAnimationEnd: null,
                    topAnimationIteration: null,
                    topAnimationStart: null,
                    topBlur: null,
                    topCanPlay: null,
                    topCanPlayThrough: null,
                    topChange: null,
                    topClick: null,
                    topCompositionEnd: null,
                    topCompositionStart: null,
                    topCompositionUpdate: null,
                    topContextMenu: null,
                    topCopy: null,
                    topCut: null,
                    topDoubleClick: null,
                    topDrag: null,
                    topDragEnd: null,
                    topDragEnter: null,
                    topDragExit: null,
                    topDragLeave: null,
                    topDragOver: null,
                    topDragStart: null,
                    topDrop: null,
                    topDurationChange: null,
                    topEmptied: null,
                    topEncrypted: null,
                    topEnded: null,
                    topError: null,
                    topFocus: null,
                    topInput: null,
                    topInvalid: null,
                    topKeyDown: null,
                    topKeyPress: null,
                    topKeyUp: null,
                    topLoad: null,
                    topLoadedData: null,
                    topLoadedMetadata: null,
                    topLoadStart: null,
                    topMouseDown: null,
                    topMouseMove: null,
                    topMouseOut: null,
                    topMouseOver: null,
                    topMouseUp: null,
                    topPaste: null,
                    topPause: null,
                    topPlay: null,
                    topPlaying: null,
                    topProgress: null,
                    topRateChange: null,
                    topReset: null,
                    topScroll: null,
                    topSeeked: null,
                    topSeeking: null,
                    topSelectionChange: null,
                    topStalled: null,
                    topSubmit: null,
                    topSuspend: null,
                    topTextInput: null,
                    topTimeUpdate: null,
                    topTouchCancel: null,
                    topTouchEnd: null,
                    topTouchMove: null,
                    topTouchStart: null,
                    topTransitionEnd: null,
                    topVolumeChange: null,
                    topWaiting: null,
                    topWheel: null
                }),
                a = {
                    topLevelTypes: i,
                    PropagationPhases: o
                };
            t.exports = a
        }, {
            171: 171
        }],
        16: [function(e, t, n) {
            "use strict";
            var r = e(17),
                o = e(18),
                i = e(65),
                a = e(121),
                s = e(129),
                u = e(168),
                l = {},
                c = null,
                p = function(e, t) {
                    e && (o.executeDispatchesInOrder(e, t), e.isPersistent() || e.constructor.release(e))
                },
                d = function(e) {
                    return p(e, !0)
                },
                f = function(e) {
                    return p(e, !1)
                },
                h = {
                    injection: {
                        injectEventPluginOrder: r.injectEventPluginOrder,
                        injectEventPluginsByName: r.injectEventPluginsByName
                    },
                    putListener: function(e, t, n) {
                        "function" != typeof n ? u(!1) : void 0;
                        var o = l[t] || (l[t] = {});
                        o[e._rootNodeID] = n;
                        var i = r.registrationNameModules[t];
                        i && i.didPutListener && i.didPutListener(e, t, n)
                    },
                    getListener: function(e, t) {
                        var n = l[t];
                        return n && n[e._rootNodeID]
                    },
                    deleteListener: function(e, t) {
                        var n = r.registrationNameModules[t];
                        n && n.willDeleteListener && n.willDeleteListener(e, t);
                        var o = l[t];
                        o && delete o[e._rootNodeID]
                    },
                    deleteAllListeners: function(e) {
                        for (var t in l)
                            if (l[t][e._rootNodeID]) {
                                var n = r.registrationNameModules[t];
                                n && n.willDeleteListener && n.willDeleteListener(e, t), delete l[t][e._rootNodeID]
                            }
                    },
                    extractEvents: function(e, t, n, o) {
                        for (var i, s = r.plugins, u = 0; u < s.length; u++) {
                            var l = s[u];
                            if (l) {
                                var c = l.extractEvents(e, t, n, o);
                                c && (i = a(i, c))
                            }
                        }
                        return i
                    },
                    enqueueEvents: function(e) {
                        e && (c = a(c, e))
                    },
                    processEventQueue: function(e) {
                        var t = c;
                        c = null, e ? s(t, d) : s(t, f), c ? u(!1) : void 0, i.rethrowCaughtError()
                    },
                    __purge: function() {
                        l = {}
                    },
                    __getListenerBank: function() {
                        return l
                    }
                };
            t.exports = h
        }, {
            121: 121,
            129: 129,
            168: 168,
            17: 17,
            18: 18,
            65: 65
        }],
        17: [function(e, t, n) {
            "use strict";

            function r() {
                if (s)
                    for (var e in u) {
                        var t = u[e],
                            n = s.indexOf(e);
                        if (n > -1 ? void 0 : a(!1), !l.plugins[n]) {
                            t.extractEvents ? void 0 : a(!1), l.plugins[n] = t;
                            var r = t.eventTypes;
                            for (var i in r) o(r[i], t, i) ? void 0 : a(!1)
                        }
                    }
            }

            function o(e, t, n) {
                l.eventNameDispatchConfigs.hasOwnProperty(n) ? a(!1) : void 0, l.eventNameDispatchConfigs[n] = e;
                var r = e.phasedRegistrationNames;
                if (r) {
                    for (var o in r)
                        if (r.hasOwnProperty(o)) {
                            var s = r[o];
                            i(s, t, n)
                        }
                    return !0
                }
                return e.registrationName ? (i(e.registrationName, t, n), !0) : !1
            }

            function i(e, t, n) {
                l.registrationNameModules[e] ? a(!1) : void 0, l.registrationNameModules[e] = t, l.registrationNameDependencies[e] = t.eventTypes[n].dependencies
            }
            var a = e(168),
                s = null,
                u = {},
                l = {
                    plugins: [],
                    eventNameDispatchConfigs: {},
                    registrationNameModules: {},
                    registrationNameDependencies: {},
                    possibleRegistrationNames: null,
                    injectEventPluginOrder: function(e) {
                        s ? a(!1) : void 0, s = Array.prototype.slice.call(e), r()
                    },
                    injectEventPluginsByName: function(e) {
                        var t = !1;
                        for (var n in e)
                            if (e.hasOwnProperty(n)) {
                                var o = e[n];
                                u.hasOwnProperty(n) && u[n] === o || (u[n] ? a(!1) : void 0, u[n] = o, t = !0)
                            }
                        t && r()
                    },
                    getPluginModuleForEvent: function(e) {
                        var t = e.dispatchConfig;
                        if (t.registrationName) return l.registrationNameModules[t.registrationName] || null;
                        for (var n in t.phasedRegistrationNames)
                            if (t.phasedRegistrationNames.hasOwnProperty(n)) {
                                var r = l.registrationNameModules[t.phasedRegistrationNames[n]];
                                if (r) return r
                            }
                        return null
                    },
                    _resetEventPlugins: function() {
                        s = null;
                        for (var e in u) u.hasOwnProperty(e) && delete u[e];
                        l.plugins.length = 0;
                        var t = l.eventNameDispatchConfigs;
                        for (var n in t) t.hasOwnProperty(n) && delete t[n];
                        var r = l.registrationNameModules;
                        for (var o in r) r.hasOwnProperty(o) && delete r[o]
                    }
                };
            t.exports = l
        }, {
            168: 168
        }],
        18: [function(e, t, n) {
            "use strict";

            function r(e) {
                return e === y.topMouseUp || e === y.topTouchEnd || e === y.topTouchCancel
            }

            function o(e) {
                return e === y.topMouseMove || e === y.topTouchMove
            }

            function i(e) {
                return e === y.topMouseDown || e === y.topTouchStart
            }

            function a(e, t, n, r) {
                var o = e.type || "unknown-event";
                e.currentTarget = C.getNodeFromInstance(r), t ? v.invokeGuardedCallbackWithCatch(o, n, e) : v.invokeGuardedCallback(o, n, e), e.currentTarget = null
            }

            function s(e, t) {
                var n = e._dispatchListeners,
                    r = e._dispatchInstances;
                if (Array.isArray(n))
                    for (var o = 0; o < n.length && !e.isPropagationStopped(); o++) a(e, t, n[o], r[o]);
                else n && a(e, t, n, r);
                e._dispatchListeners = null, e._dispatchInstances = null
            }

            function u(e) {
                var t = e._dispatchListeners,
                    n = e._dispatchInstances;
                if (Array.isArray(t)) {
                    for (var r = 0; r < t.length && !e.isPropagationStopped(); r++)
                        if (t[r](e, n[r])) return n[r]
                } else if (t && t(e, n)) return n;
                return null
            }

            function l(e) {
                var t = u(e);
                return e._dispatchInstances = null, e._dispatchListeners = null, t
            }

            function c(e) {
                var t = e._dispatchListeners,
                    n = e._dispatchInstances;
                Array.isArray(t) ? m(!1) : void 0, e.currentTarget = C.getNodeFromInstance(n);
                var r = t ? t(e) : null;
                return e.currentTarget = null, e._dispatchListeners = null, e._dispatchInstances = null, r
            }

            function p(e) {
                return !!e._dispatchListeners
            }
            var d, f, h = e(15),
                v = e(65),
                m = e(168),
                g = (e(176), {
                    injectComponentTree: function(e) {
                        d = e
                    },
                    injectTreeTraversal: function(e) {
                        f = e
                    }
                }),
                y = h.topLevelTypes,
                C = {
                    isEndish: r,
                    isMoveish: o,
                    isStartish: i,
                    executeDirectDispatch: c,
                    executeDispatchesInOrder: s,
                    executeDispatchesInOrderStopAtTrue: l,
                    hasDispatches: p,
                    getInstanceFromNode: function(e) {
                        return d.getInstanceFromNode(e)
                    },
                    getNodeFromInstance: function(e) {
                        return d.getNodeFromInstance(e)
                    },
                    isAncestor: function(e, t) {
                        return f.isAncestor(e, t)
                    },
                    getLowestCommonAncestor: function(e, t) {
                        return f.getLowestCommonAncestor(e, t)
                    },
                    getParentInstance: function(e) {
                        return f.getParentInstance(e)
                    },
                    traverseTwoPhase: function(e, t, n) {
                        return f.traverseTwoPhase(e, t, n)
                    },
                    traverseEnterLeave: function(e, t, n, r, o) {
                        return f.traverseEnterLeave(e, t, n, r, o)
                    },
                    injection: g
                };
            t.exports = C
        }, {
            15: 15,
            168: 168,
            176: 176,
            65: 65
        }],
        19: [function(e, t, n) {
            "use strict";

            function r(e, t, n) {
                var r = t.dispatchConfig.phasedRegistrationNames[n];
                return C(e, r)
            }

            function o(e, t, n) {
                var o = t ? y.bubbled : y.captured,
                    i = r(e, n, o);
                i && (n._dispatchListeners = m(n._dispatchListeners, i), n._dispatchInstances = m(n._dispatchInstances, e))
            }

            function i(e) {
                e && e.dispatchConfig.phasedRegistrationNames && v.traverseTwoPhase(e._targetInst, o, e)
            }

            function a(e) {
                if (e && e.dispatchConfig.phasedRegistrationNames) {
                    var t = e._targetInst,
                        n = t ? v.getParentInstance(t) : null;
                    v.traverseTwoPhase(n, o, e)
                }
            }

            function s(e, t, n) {
                if (n && n.dispatchConfig.registrationName) {
                    var r = n.dispatchConfig.registrationName,
                        o = C(e, r);
                    o && (n._dispatchListeners = m(n._dispatchListeners, o), n._dispatchInstances = m(n._dispatchInstances, e))
                }
            }

            function u(e) {
                e && e.dispatchConfig.registrationName && s(e._targetInst, null, e)
            }

            function l(e) {
                g(e, i)
            }

            function c(e) {
                g(e, a)
            }

            function p(e, t, n, r) {
                v.traverseEnterLeave(n, r, s, e, t)
            }

            function d(e) {
                g(e, u)
            }
            var f = e(15),
                h = e(16),
                v = e(18),
                m = e(121),
                g = e(129),
                y = (e(176), f.PropagationPhases),
                C = h.getListener,
                b = {
                    accumulateTwoPhaseDispatches: l,
                    accumulateTwoPhaseDispatchesSkipTarget: c,
                    accumulateDirectDispatches: d,
                    accumulateEnterLeaveDispatches: p
                };
            t.exports = b
        }, {
            121: 121,
            129: 129,
            15: 15,
            16: 16,
            176: 176,
            18: 18
        }],
        20: [function(e, t, n) {
            "use strict";

            function r(e) {
                this._root = e, this._startText = this.getText(), this._fallbackText = null
            }
            var o = e(177),
                i = e(24),
                a = e(137);
            o(r.prototype, {
                destructor: function() {
                    this._root = null, this._startText = null, this._fallbackText = null
                },
                getText: function() {
                    return "value" in this._root ? this._root.value : this._root[a()]
                },
                getData: function() {
                    if (this._fallbackText) return this._fallbackText;
                    var e, t, n = this._startText,
                        r = n.length,
                        o = this.getText(),
                        i = o.length;
                    for (e = 0; r > e && n[e] === o[e]; e++);
                    var a = r - e;
                    for (t = 1; a >= t && n[r - t] === o[i - t]; t++);
                    var s = t > 1 ? 1 - t : void 0;
                    return this._fallbackText = o.slice(e, s), this._fallbackText
                }
            }), i.addPoolingTo(r), t.exports = r
        }, {
            137: 137,
            177: 177,
            24: 24
        }],
        21: [function(e, t, n) {
            "use strict";
            var r = e(10),
                o = r.injection.MUST_USE_PROPERTY,
                i = r.injection.HAS_BOOLEAN_VALUE,
                a = r.injection.HAS_SIDE_EFFECTS,
                s = r.injection.HAS_NUMERIC_VALUE,
                u = r.injection.HAS_POSITIVE_NUMERIC_VALUE,
                l = r.injection.HAS_OVERLOADED_BOOLEAN_VALUE,
                c = {
                    isCustomAttribute: RegExp.prototype.test.bind(new RegExp("^(data|aria)-[" + r.ATTRIBUTE_NAME_CHAR + "]*$")),
                    Properties: {
                        accept: 0,
                        acceptCharset: 0,
                        accessKey: 0,
                        action: 0,
                        allowFullScreen: i,
                        allowTransparency: 0,
                        alt: 0,
                        async: i,
                        autoComplete: 0,
                        autoPlay: i,
                        capture: i,
                        cellPadding: 0,
                        cellSpacing: 0,
                        charSet: 0,
                        challenge: 0,
                        checked: o | i,
                        cite: 0,
                        classID: 0,
                        className: 0,
                        cols: u,
                        colSpan: 0,
                        content: 0,
                        contentEditable: 0,
                        contextMenu: 0,
                        controls: i,
                        coords: 0,
                        crossOrigin: 0,
                        data: 0,
                        dateTime: 0,
                        "default": i,
                        defer: i,
                        dir: 0,
                        disabled: i,
                        download: l,
                        draggable: 0,
                        encType: 0,
                        form: 0,
                        formAction: 0,
                        formEncType: 0,
                        formMethod: 0,
                        formNoValidate: i,
                        formTarget: 0,
                        frameBorder: 0,
                        headers: 0,
                        height: 0,
                        hidden: i,
                        high: 0,
                        href: 0,
                        hrefLang: 0,
                        htmlFor: 0,
                        httpEquiv: 0,
                        icon: 0,
                        id: 0,
                        inputMode: 0,
                        integrity: 0,
                        is: 0,
                        keyParams: 0,
                        keyType: 0,
                        kind: 0,
                        label: 0,
                        lang: 0,
                        list: 0,
                        loop: i,
                        low: 0,
                        manifest: 0,
                        marginHeight: 0,
                        marginWidth: 0,
                        max: 0,
                        maxLength: 0,
                        media: 0,
                        mediaGroup: 0,
                        method: 0,
                        min: 0,
                        minLength: 0,
                        multiple: o | i,
                        muted: o | i,
                        name: 0,
                        nonce: 0,
                        noValidate: i,
                        open: i,
                        optimum: 0,
                        pattern: 0,
                        placeholder: 0,
                        poster: 0,
                        preload: 0,
                        profile: 0,
                        radioGroup: 0,
                        readOnly: i,
                        rel: 0,
                        required: i,
                        reversed: i,
                        role: 0,
                        rows: u,
                        rowSpan: s,
                        sandbox: 0,
                        scope: 0,
                        scoped: i,
                        scrolling: 0,
                        seamless: i,
                        selected: o | i,
                        shape: 0,
                        size: u,
                        sizes: 0,
                        span: u,
                        spellCheck: 0,
                        src: 0,
                        srcDoc: 0,
                        srcLang: 0,
                        srcSet: 0,
                        start: s,
                        step: 0,
                        style: 0,
                        summary: 0,
                        tabIndex: 0,
                        target: 0,
                        title: 0,
                        type: 0,
                        useMap: 0,
                        value: o | a,
                        width: 0,
                        wmode: 0,
                        wrap: 0,
                        about: 0,
                        datatype: 0,
                        inlist: 0,
                        prefix: 0,
                        property: 0,
                        resource: 0,
                        "typeof": 0,
                        vocab: 0,
                        autoCapitalize: 0,
                        autoCorrect: 0,
                        autoSave: 0,
                        color: 0,
                        itemProp: 0,
                        itemScope: i,
                        itemType: 0,
                        itemID: 0,
                        itemRef: 0,
                        results: 0,
                        security: 0,
                        unselectable: 0
                    },
                    DOMAttributeNames: {
                        acceptCharset: "accept-charset",
                        className: "class",
                        htmlFor: "for",
                        httpEquiv: "http-equiv"
                    },
                    DOMPropertyNames: {}
                };
            t.exports = c
        }, {
            10: 10
        }],
        22: [function(e, t, n) {
            "use strict";
            var r = e(75),
                o = e(94),
                i = {
                    linkState: function(e) {
                        return new r(this.state[e], o.createStateKeySetter(this, e))
                    }
                };
            t.exports = i
        }, {
            75: 75,
            94: 94
        }],
        23: [function(e, t, n) {
            "use strict";

            function r(e) {
                null != e.checkedLink && null != e.valueLink ? l(!1) : void 0
            }

            function o(e) {
                r(e), null != e.value || null != e.onChange ? l(!1) : void 0
            }

            function i(e) {
                r(e), null != e.checked || null != e.onChange ? l(!1) : void 0
            }

            function a(e) {
                if (e) {
                    var t = e.getName();
                    if (t) return " Check the render method of `" + t + "`."
                }
                return ""
            }
            var s = e(87),
                u = e(86),
                l = e(168),
                c = (e(176), {
                    button: !0,
                    checkbox: !0,
                    image: !0,
                    hidden: !0,
                    radio: !0,
                    reset: !0,
                    submit: !0
                }),
                p = {
                    value: function(e, t, n) {
                        return !e[t] || c[e.type] || e.onChange || e.readOnly || e.disabled ? null : new Error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.")
                    },
                    checked: function(e, t, n) {
                        return !e[t] || e.onChange || e.readOnly || e.disabled ? null : new Error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.")
                    },
                    onChange: s.func
                },
                d = {},
                f = {
                    checkPropTypes: function(e, t, n) {
                        for (var r in p) {
                            if (p.hasOwnProperty(r)) var o = p[r](t, r, e, u.prop);
                            o instanceof Error && !(o.message in d) && (d[o.message] = !0, a(n))
                        }
                    },
                    getValue: function(e) {
                        return e.valueLink ? (o(e), e.valueLink.value) : e.value
                    },
                    getChecked: function(e) {
                        return e.checkedLink ? (i(e), e.checkedLink.value) : e.checked
                    },
                    executeOnChange: function(e, t) {
                        return e.valueLink ? (o(e), e.valueLink.requestChange(t.target.value)) : e.checkedLink ? (i(e), e.checkedLink.requestChange(t.target.checked)) : e.onChange ? e.onChange.call(void 0, t) : void 0
                    }
                };
            t.exports = f
        }, {
            168: 168,
            176: 176,
            86: 86,
            87: 87
        }],
        24: [function(e, t, n) {
            "use strict";
            var r = e(168),
                o = function(e) {
                    var t = this;
                    if (t.instancePool.length) {
                        var n = t.instancePool.pop();
                        return t.call(n, e), n
                    }
                    return new t(e)
                },
                i = function(e, t) {
                    var n = this;
                    if (n.instancePool.length) {
                        var r = n.instancePool.pop();
                        return n.call(r, e, t), r
                    }
                    return new n(e, t)
                },
                a = function(e, t, n) {
                    var r = this;
                    if (r.instancePool.length) {
                        var o = r.instancePool.pop();
                        return r.call(o, e, t, n), o
                    }
                    return new r(e, t, n)
                },
                s = function(e, t, n, r) {
                    var o = this;
                    if (o.instancePool.length) {
                        var i = o.instancePool.pop();
                        return o.call(i, e, t, n, r), i
                    }
                    return new o(e, t, n, r)
                },
                u = function(e, t, n, r, o) {
                    var i = this;
                    if (i.instancePool.length) {
                        var a = i.instancePool.pop();
                        return i.call(a, e, t, n, r, o), a
                    }
                    return new i(e, t, n, r, o)
                },
                l = function(e) {
                    var t = this;
                    e instanceof t ? void 0 : r(!1), e.destructor(), t.instancePool.length < t.poolSize && t.instancePool.push(e)
                },
                c = 10,
                p = o,
                d = function(e, t) {
                    var n = e;
                    return n.instancePool = [], n.getPooled = t || p, n.poolSize || (n.poolSize = c), n.release = l, n
                },
                f = {
                    addPoolingTo: d,
                    oneArgumentPooler: o,
                    twoArgumentPooler: i,
                    threeArgumentPooler: a,
                    fourArgumentPooler: s,
                    fiveArgumentPooler: u
                };
            t.exports = f
        }, {
            168: 168
        }],
        25: [function(e, t, n) {
            "use strict";
            var r = e(177),
                o = e(30),
                i = e(32),
                a = e(31),
                s = e(46),
                u = e(62),
                l = (e(63), e(87)),
                c = e(100),
                p = e(142),
                d = (e(176), u.createElement),
                f = u.createFactory,
                h = u.cloneElement,
                v = r,
                m = {
                    Children: {
                        map: o.map,
                        forEach: o.forEach,
                        count: o.count,
                        toArray: o.toArray,
                        only: p
                    },
                    Component: i,
                    createElement: d,
                    cloneElement: h,
                    isValidElement: u.isValidElement,
                    PropTypes: l,
                    createClass: a.createClass,
                    createFactory: f,
                    createMixin: function(e) {
                        return e
                    },
                    DOM: s,
                    version: c,
                    __spread: v
                };
            t.exports = m
        }, {
            100: 100,
            142: 142,
            176: 176,
            177: 177,
            30: 30,
            31: 31,
            32: 32,
            46: 46,
            62: 62,
            63: 63,
            87: 87
        }],
        26: [function(e, t, n) {
            "use strict";

            function r(e) {
                return Object.prototype.hasOwnProperty.call(e, m) || (e[m] = h++, d[e[m]] = {}), d[e[m]]
            }
            var o, i = e(177),
                a = e(15),
                s = e(17),
                u = e(66),
                l = e(120),
                c = e(138),
                p = e(140),
                d = {},
                f = !1,
                h = 0,
                v = {
                    topAbort: "abort",
                    topAnimationEnd: c("animationend") || "animationend",
                    topAnimationIteration: c("animationiteration") || "animationiteration",
                    topAnimationStart: c("animationstart") || "animationstart",
                    topBlur: "blur",
                    topCanPlay: "canplay",
                    topCanPlayThrough: "canplaythrough",
                    topChange: "change",
                    topClick: "click",
                    topCompositionEnd: "compositionend",
                    topCompositionStart: "compositionstart",
                    topCompositionUpdate: "compositionupdate",
                    topContextMenu: "contextmenu",
                    topCopy: "copy",
                    topCut: "cut",
                    topDoubleClick: "dblclick",
                    topDrag: "drag",
                    topDragEnd: "dragend",
                    topDragEnter: "dragenter",
                    topDragExit: "dragexit",
                    topDragLeave: "dragleave",
                    topDragOver: "dragover",
                    topDragStart: "dragstart",
                    topDrop: "drop",
                    topDurationChange: "durationchange",
                    topEmptied: "emptied",
                    topEncrypted: "encrypted",
                    topEnded: "ended",
                    topError: "error",
                    topFocus: "focus",
                    topInput: "input",
                    topKeyDown: "keydown",
                    topKeyPress: "keypress",
                    topKeyUp: "keyup",
                    topLoadedData: "loadeddata",
                    topLoadedMetadata: "loadedmetadata",
                    topLoadStart: "loadstart",
                    topMouseDown: "mousedown",
                    topMouseMove: "mousemove",
                    topMouseOut: "mouseout",
                    topMouseOver: "mouseover",
                    topMouseUp: "mouseup",
                    topPaste: "paste",
                    topPause: "pause",
                    topPlay: "play",
                    topPlaying: "playing",
                    topProgress: "progress",
                    topRateChange: "ratechange",
                    topScroll: "scroll",
                    topSeeked: "seeked",
                    topSeeking: "seeking",
                    topSelectionChange: "selectionchange",
                    topStalled: "stalled",
                    topSuspend: "suspend",
                    topTextInput: "textInput",
                    topTimeUpdate: "timeupdate",
                    topTouchCancel: "touchcancel",
                    topTouchEnd: "touchend",
                    topTouchMove: "touchmove",
                    topTouchStart: "touchstart",
                    topTransitionEnd: c("transitionend") || "transitionend",
                    topVolumeChange: "volumechange",
                    topWaiting: "waiting",
                    topWheel: "wheel"
                },
                m = "_reactListenersID" + String(Math.random()).slice(2),
                g = i({}, u, {
                    ReactEventListener: null,
                    injection: {
                        injectReactEventListener: function(e) {
                            e.setHandleTopLevel(g.handleTopLevel), g.ReactEventListener = e
                        }
                    },
                    setEnabled: function(e) {
                        g.ReactEventListener && g.ReactEventListener.setEnabled(e)
                    },
                    isEnabled: function() {
                        return !(!g.ReactEventListener || !g.ReactEventListener.isEnabled())
                    },
                    listenTo: function(e, t) {
                        for (var n = t, o = r(n), i = s.registrationNameDependencies[e], u = a.topLevelTypes, l = 0; l < i.length; l++) {
                            var c = i[l];
                            o.hasOwnProperty(c) && o[c] || (c === u.topWheel ? p("wheel") ? g.ReactEventListener.trapBubbledEvent(u.topWheel, "wheel", n) : p("mousewheel") ? g.ReactEventListener.trapBubbledEvent(u.topWheel, "mousewheel", n) : g.ReactEventListener.trapBubbledEvent(u.topWheel, "DOMMouseScroll", n) : c === u.topScroll ? p("scroll", !0) ? g.ReactEventListener.trapCapturedEvent(u.topScroll, "scroll", n) : g.ReactEventListener.trapBubbledEvent(u.topScroll, "scroll", g.ReactEventListener.WINDOW_HANDLE) : c === u.topFocus || c === u.topBlur ? (p("focus", !0) ? (g.ReactEventListener.trapCapturedEvent(u.topFocus, "focus", n), g.ReactEventListener.trapCapturedEvent(u.topBlur, "blur", n)) : p("focusin") && (g.ReactEventListener.trapBubbledEvent(u.topFocus, "focusin", n), g.ReactEventListener.trapBubbledEvent(u.topBlur, "focusout", n)), o[u.topBlur] = !0, o[u.topFocus] = !0) : v.hasOwnProperty(c) && g.ReactEventListener.trapBubbledEvent(c, v[c], n), o[c] = !0)
                        }
                    },
                    trapBubbledEvent: function(e, t, n) {
                        return g.ReactEventListener.trapBubbledEvent(e, t, n)
                    },
                    trapCapturedEvent: function(e, t, n) {
                        return g.ReactEventListener.trapCapturedEvent(e, t, n)
                    },
                    ensureScrollValueMonitoring: function() {
                        if (void 0 === o && (o = document.createEvent && "pageX" in document.createEvent("MouseEvent")), !o && !f) {
                            var e = l.refreshScrollValues;
                            g.ReactEventListener.monitorScrollValue(e), f = !0
                        }
                    }
                });
            t.exports = g
        }, {
            120: 120,
            138: 138,
            140: 140,
            15: 15,
            17: 17,
            177: 177,
            66: 66
        }],
        27: [function(e, t, n) {
            "use strict";

            function r(e) {
                var t = "transition" + e + "Timeout",
                    n = "transition" + e;
                return function(e) {
                    if (e[n]) {
                        if (null == e[t]) return new Error(t + " wasn't supplied to ReactCSSTransitionGroup: this can cause unreliable animations and won't be supported in a future version of React. See https://fb.me/react-animation-transition-group-timeout for more information.");
                        if ("number" != typeof e[t]) return new Error(t + " must be a number (in milliseconds)")
                    }
                }
            }
            var o = e(177),
                i = e(25),
                a = e(97),
                s = e(28),
                u = i.createClass({
                    displayName: "ReactCSSTransitionGroup",
                    propTypes: {
                        transitionName: s.propTypes.name,
                        transitionAppear: i.PropTypes.bool,
                        transitionEnter: i.PropTypes.bool,
                        transitionLeave: i.PropTypes.bool,
                        transitionAppearTimeout: r("Appear"),
                        transitionEnterTimeout: r("Enter"),
                        transitionLeaveTimeout: r("Leave")
                    },
                    getDefaultProps: function() {
                        return {
                            transitionAppear: !1,
                            transitionEnter: !0,
                            transitionLeave: !0
                        }
                    },
                    _wrapChild: function(e) {
                        return i.createElement(s, {
                            name: this.props.transitionName,
                            appear: this.props.transitionAppear,
                            enter: this.props.transitionEnter,
                            leave: this.props.transitionLeave,
                            appearTimeout: this.props.transitionAppearTimeout,
                            enterTimeout: this.props.transitionEnterTimeout,
                            leaveTimeout: this.props.transitionLeaveTimeout
                        }, e)
                    },
                    render: function() {
                        return i.createElement(a, o({}, this.props, {
                            childFactory: this._wrapChild
                        }))
                    }
                });
            t.exports = u
        }, {
            177: 177,
            25: 25,
            28: 28,
            97: 97
        }],
        28: [function(e, t, n) {
            "use strict";
            var r = e(25),
                o = e(38),
                i = e(152),
                a = e(96),
                s = e(142),
                u = 17,
                l = r.createClass({
                    displayName: "ReactCSSTransitionGroupChild",
                    propTypes: {
                        name: r.PropTypes.oneOfType([r.PropTypes.string, r.PropTypes.shape({
                            enter: r.PropTypes.string,
                            leave: r.PropTypes.string,
                            active: r.PropTypes.string
                        }), r.PropTypes.shape({
                            enter: r.PropTypes.string,
                            enterActive: r.PropTypes.string,
                            leave: r.PropTypes.string,
                            leaveActive: r.PropTypes.string,
                            appear: r.PropTypes.string,
                            appearActive: r.PropTypes.string
                        })]).isRequired,
                        appear: r.PropTypes.bool,
                        enter: r.PropTypes.bool,
                        leave: r.PropTypes.bool,
                        appearTimeout: r.PropTypes.number,
                        enterTimeout: r.PropTypes.number,
                        leaveTimeout: r.PropTypes.number
                    },
                    transition: function(e, t, n) {
                        var r = o.findDOMNode(this);
                        if (!r) return void(t && t());
                        var s = this.props.name[e] || this.props.name + "-" + e,
                            u = this.props.name[e + "Active"] || s + "-active",
                            l = null,
                            c = function(e) {
                                e && e.target !== r || (clearTimeout(l), i.removeClass(r, s), i.removeClass(r, u), a.removeEndEventListener(r, c), t && t())
                            };
                        i.addClass(r, s), this.queueClass(u), n ? (l = setTimeout(c, n), this.transitionTimeouts.push(l)) : a.addEndEventListener(r, c)
                    },
                    queueClass: function(e) {
                        this.classNameQueue.push(e), this.timeout || (this.timeout = setTimeout(this.flushClassNameQueue, u))
                    },
                    flushClassNameQueue: function() {
                        this.isMounted() && this.classNameQueue.forEach(i.addClass.bind(i, o.findDOMNode(this))), this.classNameQueue.length = 0, this.timeout = null
                    },
                    componentWillMount: function() {
                        this.classNameQueue = [], this.transitionTimeouts = []
                    },
                    componentWillUnmount: function() {
                        this.timeout && clearTimeout(this.timeout), this.transitionTimeouts.forEach(function(e) {
                            clearTimeout(e)
                        })
                    },
                    componentWillAppear: function(e) {
                        this.props.appear ? this.transition("appear", e, this.props.appearTimeout) : e()
                    },
                    componentWillEnter: function(e) {
                        this.props.enter ? this.transition("enter", e, this.props.enterTimeout) : e()
                    },
                    componentWillLeave: function(e) {
                        this.props.leave ? this.transition("leave", e, this.props.leaveTimeout) : e()
                    },
                    render: function() {
                        return s(this.props.children)
                    }
                });
            t.exports = l
        }, {
            142: 142,
            152: 152,
            25: 25,
            38: 38,
            96: 96
        }],
        29: [function(e, t, n) {
            "use strict";

            function r(e, t, n) {
                var r = void 0 === e[n];
                null != t && r && (e[n] = i(t))
            }
            var o = e(89),
                i = e(139),
                a = e(148),
                s = e(149),
                u = (e(176), {
                    instantiateChildren: function(e, t, n) {
                        if (null == e) return null;
                        var o = {};
                        return s(e, r, o), o
                    },
                    updateChildren: function(e, t, n, r, s) {
                        if (t || e) {
                            var u, l;
                            for (u in t)
                                if (t.hasOwnProperty(u)) {
                                    l = e && e[u];
                                    var c = l && l._currentElement,
                                        p = t[u];
                                    if (null != l && a(c, p)) o.receiveComponent(l, p, r, s), t[u] = l;
                                    else {
                                        l && (n[u] = o.getNativeNode(l), o.unmountComponent(l, !1));
                                        var d = i(p);
                                        t[u] = d
                                    }
                                }
                            for (u in e) !e.hasOwnProperty(u) || t && t.hasOwnProperty(u) || (l = e[u], n[u] = o.getNativeNode(l), o.unmountComponent(l, !1))
                        }
                    },
                    unmountChildren: function(e, t) {
                        for (var n in e)
                            if (e.hasOwnProperty(n)) {
                                var r = e[n];
                                o.unmountComponent(r, t)
                            }
                    }
                });
            t.exports = u
        }, {
            139: 139,
            148: 148,
            149: 149,
            176: 176,
            89: 89
        }],
        30: [function(e, t, n) {
            "use strict";

            function r(e) {
                return ("" + e).replace(b, "$&/")
            }

            function o(e, t) {
                this.func = e, this.context = t, this.count = 0
            }

            function i(e, t, n) {
                var r = e.func,
                    o = e.context;
                r.call(o, t, e.count++)
            }

            function a(e, t, n) {
                if (null == e) return e;
                var r = o.getPooled(t, n);
                g(e, i, r), o.release(r)
            }

            function s(e, t, n, r) {
                this.result = e, this.keyPrefix = t, this.func = n, this.context = r, this.count = 0
            }

            function u(e, t, n) {
                var o = e.result,
                    i = e.keyPrefix,
                    a = e.func,
                    s = e.context,
                    u = a.call(s, t, e.count++);
                Array.isArray(u) ? l(u, o, n, m.thatReturnsArgument) : null != u && (v.isValidElement(u) && (u = v.cloneAndReplaceKey(u, i + (!u.key || t && t.key === u.key ? "" : r(u.key) + "/") + n)), o.push(u))
            }

            function l(e, t, n, o, i) {
                var a = "";
                null != n && (a = r(n) + "/");
                var l = s.getPooled(t, a, o, i);
                g(e, u, l), s.release(l)
            }

            function c(e, t, n) {
                if (null == e) return e;
                var r = [];
                return l(e, r, null, t, n), r
            }

            function p(e, t, n) {
                return null
            }

            function d(e, t) {
                return g(e, p, null)
            }

            function f(e) {
                var t = [];
                return l(e, t, null, m.thatReturnsArgument), t
            }
            var h = e(24),
                v = e(62),
                m = e(160),
                g = e(149),
                y = h.twoArgumentPooler,
                C = h.fourArgumentPooler,
                b = /\/+/g;
            o.prototype.destructor = function() {
                this.func = null, this.context = null, this.count = 0
            }, h.addPoolingTo(o, y), s.prototype.destructor = function() {
                this.result = null, this.keyPrefix = null, this.func = null, this.context = null, this.count = 0
            }, h.addPoolingTo(s, C);
            var _ = {
                forEach: a,
                map: c,
                mapIntoWithKeyPrefixInternal: l,
                count: d,
                toArray: f
            };
            t.exports = _
        }, {
            149: 149,
            160: 160,
            24: 24,
            62: 62
        }],
        31: [function(e, t, n) {
            "use strict";

            function r(e, t) {
                var n = E.hasOwnProperty(t) ? E[t] : null;
                x.hasOwnProperty(t) && (n !== b.OVERRIDE_BASE ? m(!1) : void 0), e && (n !== b.DEFINE_MANY && n !== b.DEFINE_MANY_MERGED ? m(!1) : void 0)
            }

            function o(e, t) {
                if (t) {
                    "function" == typeof t ? m(!1) : void 0, f.isValidElement(t) ? m(!1) : void 0;
                    var n = e.prototype,
                        o = n.__reactAutoBindPairs;
                    t.hasOwnProperty(C) && T.mixins(e, t.mixins);
                    for (var i in t)
                        if (t.hasOwnProperty(i) && i !== C) {
                            var a = t[i],
                                l = n.hasOwnProperty(i);
                            if (r(l, i), T.hasOwnProperty(i)) T[i](e, a);
                            else {
                                var c = E.hasOwnProperty(i),
                                    p = "function" == typeof a,
                                    d = p && !c && !l && t.autobind !== !1;
                                if (d) o.push(i, a), n[i] = a;
                                else if (l) {
                                    var h = E[i];
                                    !c || h !== b.DEFINE_MANY_MERGED && h !== b.DEFINE_MANY ? m(!1) : void 0, h === b.DEFINE_MANY_MERGED ? n[i] = s(n[i], a) : h === b.DEFINE_MANY && (n[i] = u(n[i], a))
                                } else n[i] = a
                            }
                        }
                }
            }

            function i(e, t) {
                if (t)
                    for (var n in t) {
                        var r = t[n];
                        if (t.hasOwnProperty(n)) {
                            var o = n in T;
                            o ? m(!1) : void 0;
                            var i = n in e;
                            i ? m(!1) : void 0, e[n] = r
                        }
                    }
            }

            function a(e, t) {
                e && t && "object" == typeof e && "object" == typeof t ? void 0 : m(!1);
                for (var n in t) t.hasOwnProperty(n) && (void 0 !== e[n] ? m(!1) : void 0, e[n] = t[n]);
                return e
            }

            function s(e, t) {
                return function() {
                    var n = e.apply(this, arguments),
                        r = t.apply(this, arguments);
                    if (null == n) return r;
                    if (null == r) return n;
                    var o = {};
                    return a(o, n), a(o, r), o
                }
            }

            function u(e, t) {
                return function() {
                    e.apply(this, arguments), t.apply(this, arguments)
                }
            }

            function l(e, t) {
                var n = t.bind(e);
                return n
            }

            function c(e) {
                for (var t = e.__reactAutoBindPairs, n = 0; n < t.length; n += 2) {
                    var r = t[n],
                        o = t[n + 1];
                    e[r] = l(e, o)
                }
            }
            var p = e(177),
                d = e(32),
                f = e(62),
                h = (e(86), e(85), e(82)),
                v = e(161),
                m = e(168),
                g = e(171),
                y = e(172),
                C = (e(176), y({
                    mixins: null
                })),
                b = g({
                    DEFINE_ONCE: null,
                    DEFINE_MANY: null,
                    OVERRIDE_BASE: null,
                    DEFINE_MANY_MERGED: null
                }),
                _ = [],
                E = {
                    mixins: b.DEFINE_MANY,
                    statics: b.DEFINE_MANY,
                    propTypes: b.DEFINE_MANY,
                    contextTypes: b.DEFINE_MANY,
                    childContextTypes: b.DEFINE_MANY,
                    getDefaultProps: b.DEFINE_MANY_MERGED,
                    getInitialState: b.DEFINE_MANY_MERGED,
                    getChildContext: b.DEFINE_MANY_MERGED,
                    render: b.DEFINE_ONCE,
                    componentWillMount: b.DEFINE_MANY,
                    componentDidMount: b.DEFINE_MANY,
                    componentWillReceiveProps: b.DEFINE_MANY,
                    shouldComponentUpdate: b.DEFINE_ONCE,
                    componentWillUpdate: b.DEFINE_MANY,
                    componentDidUpdate: b.DEFINE_MANY,
                    componentWillUnmount: b.DEFINE_MANY,
                    updateComponent: b.OVERRIDE_BASE
                },
                T = {
                    displayName: function(e, t) {
                        e.displayName = t
                    },
                    mixins: function(e, t) {
                        if (t)
                            for (var n = 0; n < t.length; n++) o(e, t[n])
                    },
                    childContextTypes: function(e, t) {
                        e.childContextTypes = p({}, e.childContextTypes, t)
                    },
                    contextTypes: function(e, t) {
                        e.contextTypes = p({}, e.contextTypes, t)
                    },
                    getDefaultProps: function(e, t) {
                        e.getDefaultProps ? e.getDefaultProps = s(e.getDefaultProps, t) : e.getDefaultProps = t
                    },
                    propTypes: function(e, t) {
                        e.propTypes = p({}, e.propTypes, t)
                    },
                    statics: function(e, t) {
                        i(e, t)
                    },
                    autobind: function() {}
                },
                x = {
                    replaceState: function(e, t) {
                        this.updater.enqueueReplaceState(this, e), t && this.updater.enqueueCallback(this, t, "replaceState")
                    },
                    isMounted: function() {
                        return this.updater.isMounted(this)
                    }
                },
                P = function() {};
            p(P.prototype, d.prototype, x);
            var N = {
                createClass: function(e) {
                    var t = function(e, t, n) {
                        this.__reactAutoBindPairs.length && c(this), this.props = e, this.context = t, this.refs = v, this.updater = n || h, this.state = null;
                        var r = this.getInitialState ? this.getInitialState() : null;
                        "object" != typeof r || Array.isArray(r) ? m(!1) : void 0, this.state = r
                    };
                    t.prototype = new P, t.prototype.constructor = t, t.prototype.__reactAutoBindPairs = [], _.forEach(o.bind(null, t)), o(t, e), t.getDefaultProps && (t.defaultProps = t.getDefaultProps()), t.prototype.render ? void 0 : m(!1);
                    for (var n in E) t.prototype[n] || (t.prototype[n] = null);
                    return t
                },
                injection: {
                    injectMixin: function(e) {
                        _.push(e)
                    }
                }
            };
            t.exports = N
        }, {
            161: 161,
            168: 168,
            171: 171,
            172: 172,
            176: 176,
            177: 177,
            32: 32,
            62: 62,
            82: 82,
            85: 85,
            86: 86
        }],
        32: [function(e, t, n) {
            "use strict";

            function r(e, t, n) {
                this.props = e, this.context = t, this.refs = i, this.updater = n || o
            }
            var o = e(82),
                i = (e(73), e(123), e(161)),
                a = e(168);
            e(176);
            r.prototype.isReactComponent = {}, r.prototype.setState = function(e, t) {
                "object" != typeof e && "function" != typeof e && null != e ? a(!1) : void 0, this.updater.enqueueSetState(this, e), t && this.updater.enqueueCallback(this, t, "setState")
            }, r.prototype.forceUpdate = function(e) {
                this.updater.enqueueForceUpdate(this), e && this.updater.enqueueCallback(this, e, "forceUpdate")
            };
            t.exports = r
        }, {
            123: 123,
            161: 161,
            168: 168,
            176: 176,
            73: 73,
            82: 82
        }],
        33: [function(e, t, n) {
            "use strict";
            var r = e(7),
                o = e(48),
                i = e(84),
                a = {
                    processChildrenUpdates: o.dangerouslyProcessChildrenUpdates,
                    replaceNodeWithMarkup: r.dangerouslyReplaceNodeWithMarkup,
                    unmountIDFromEnvironment: function(e) {}
                };
            i.measureMethods(a, "ReactComponentBrowserEnvironment", {
                replaceNodeWithMarkup: "replaceNodeWithMarkup"
            }), t.exports = a
        }, {
            48: 48,
            7: 7,
            84: 84
        }],
        34: [function(e, t, n) {
            "use strict";
            var r = e(168),
                o = !1,
                i = {
                    unmountIDFromEnvironment: null,
                    replaceNodeWithMarkup: null,
                    processChildrenUpdates: null,
                    injection: {
                        injectEnvironment: function(e) {
                            o ? r(!1) : void 0, i.unmountIDFromEnvironment = e.unmountIDFromEnvironment, i.replaceNodeWithMarkup = e.replaceNodeWithMarkup, i.processChildrenUpdates = e.processChildrenUpdates, o = !0
                        }
                    }
                };
            t.exports = i
        }, {
            168: 168
        }],
        35: [function(e, t, n) {
            "use strict";
            var r = e(147),
                o = {
                    shouldComponentUpdate: function(e, t) {
                        return r(this, e, t)
                    }
                };
            t.exports = o
        }, {
            147: 147
        }],
        36: [function(e, t, n) {
            "use strict";

            function r(e) {
                var t = e._currentElement._owner || null;
                if (t) {
                    var n = t.getName();
                    if (n) return " Check the render method of `" + n + "`."
                }
                return ""
            }

            function o(e) {}

            function i(e, t) {}
            var a = e(177),
                s = e(34),
                u = e(37),
                l = e(62),
                c = e(65),
                p = e(72),
                d = (e(73), e(81)),
                f = e(84),
                h = e(86),
                v = (e(85), e(89)),
                m = e(98),
                g = e(161),
                y = e(168),
                C = e(148);
            e(176);
            o.prototype.render = function() {
                var e = p.get(this)._currentElement.type,
                    t = e(this.props, this.context, this.updater);
                return i(e, t), t
            };
            var b = 1,
                _ = {
                    construct: function(e) {
                        this._currentElement = e, this._rootNodeID = null, this._instance = null, this._nativeParent = null, this._nativeContainerInfo = null, this._pendingElement = null, this._pendingStateQueue = null, this._pendingReplaceState = !1, this._pendingForceUpdate = !1, this._renderedNodeType = null, this._renderedComponent = null, this._context = null, this._mountOrder = 0, this._topLevelWrapper = null, this._pendingCallbacks = null
                    },
                    mountComponent: function(e, t, n, r) {
                        this._context = r, this._mountOrder = b++, this._nativeParent = t, this._nativeContainerInfo = n;
                        var a, s, u = this._processProps(this._currentElement.props),
                            c = this._processContext(r),
                            d = this._currentElement.type;
                        d.prototype && d.prototype.isReactComponent ? a = new d(u, c, m) : (a = d(u, c, m), null != a && null != a.render || (s = a, i(d, s), null === a || a === !1 || l.isValidElement(a) ? void 0 : y(!1), a = new o(d))), a.props = u, a.context = c, a.refs = g, a.updater = m, this._instance = a, p.set(a, this);
                        var f = a.state;
                        void 0 === f && (a.state = f = null), "object" != typeof f || Array.isArray(f) ? y(!1) : void 0, this._pendingStateQueue = null, this._pendingReplaceState = !1, this._pendingForceUpdate = !1;
                        var h;
                        return h = a.unstable_handleError ? this.performInitialMountWithErrorHandling(s, t, n, e, r) : this.performInitialMount(s, t, n, e, r), a.componentDidMount && e.getReactMountReady().enqueue(a.componentDidMount, a), h
                    },
                    performInitialMountWithErrorHandling: function(e, t, n, r, o) {
                        var i, a = r.checkpoint();
                        try {
                            i = this.performInitialMount(e, t, n, r, o)
                        } catch (s) {
                            r.rollback(a), this._instance.unstable_handleError(s), this._pendingStateQueue && (this._instance.state = this._processPendingState(this._instance.props, this._instance.context)), a = r.checkpoint(), this._renderedComponent.unmountComponent(!0), r.rollback(a), i = this.performInitialMount(e, t, n, r, o)
                        }
                        return i
                    },
                    performInitialMount: function(e, t, n, r, o) {
                        var i = this._instance;
                        i.componentWillMount && (i.componentWillMount(), this._pendingStateQueue && (i.state = this._processPendingState(i.props, i.context))), void 0 === e && (e = this._renderValidatedComponent()), this._renderedNodeType = d.getType(e), this._renderedComponent = this._instantiateReactComponent(e);
                        var a = v.mountComponent(this._renderedComponent, r, t, n, this._processChildContext(o));
                        return a
                    },
                    getNativeNode: function() {
                        return v.getNativeNode(this._renderedComponent)
                    },
                    unmountComponent: function(e) {
                        if (this._renderedComponent) {
                            var t = this._instance;
                            if (t.componentWillUnmount)
                                if (e) {
                                    var n = this.getName() + ".componentWillUnmount()";
                                    c.invokeGuardedCallback(n, t.componentWillUnmount.bind(t))
                                } else t.componentWillUnmount();
                            this._renderedComponent && (v.unmountComponent(this._renderedComponent, e), this._renderedNodeType = null, this._renderedComponent = null, this._instance = null), this._pendingStateQueue = null, this._pendingReplaceState = !1, this._pendingForceUpdate = !1, this._pendingCallbacks = null, this._pendingElement = null, this._context = null, this._rootNodeID = null, this._topLevelWrapper = null, p.remove(t)
                        }
                    },
                    _maskContext: function(e) {
                        var t = this._currentElement.type,
                            n = t.contextTypes;
                        if (!n) return g;
                        var r = {};
                        for (var o in n) r[o] = e[o];
                        return r
                    },
                    _processContext: function(e) {
                        var t = this._maskContext(e);
                        return t
                    },
                    _processChildContext: function(e) {
                        var t = this._currentElement.type,
                            n = this._instance,
                            r = n.getChildContext && n.getChildContext();
                        if (r) {
                            "object" != typeof t.childContextTypes ? y(!1) : void 0;
                            for (var o in r) o in t.childContextTypes ? void 0 : y(!1);
                            return a({}, e, r)
                        }
                        return e
                    },
                    _processProps: function(e) {
                        return e
                    },
                    _checkPropTypes: function(e, t, n) {
                        var o = this.getName();
                        for (var i in e)
                            if (e.hasOwnProperty(i)) {
                                var a;
                                try {
                                    "function" != typeof e[i] ? y(!1) : void 0, a = e[i](t, i, o, n)
                                } catch (s) {
                                    a = s
                                }
                                a instanceof Error && (r(this), n === h.prop)
                            }
                    },
                    receiveComponent: function(e, t, n) {
                        var r = this._currentElement,
                            o = this._context;
                        this._pendingElement = null, this.updateComponent(t, r, e, o, n)
                    },
                    performUpdateIfNecessary: function(e) {
                        null != this._pendingElement && v.receiveComponent(this, this._pendingElement, e, this._context), (null !== this._pendingStateQueue || this._pendingForceUpdate) && this.updateComponent(e, this._currentElement, this._currentElement, this._context, this._context)
                    },
                    updateComponent: function(e, t, n, r, o) {
                        var i, a, s = this._instance,
                            u = !1;
                        this._context === o ? i = s.context : (i = this._processContext(o), u = !0), t === n ? a = n.props : (a = this._processProps(n.props), u = !0), u && s.componentWillReceiveProps && s.componentWillReceiveProps(a, i);
                        var l = this._processPendingState(a, i),
                            c = this._pendingForceUpdate || !s.shouldComponentUpdate || s.shouldComponentUpdate(a, l, i);
                        c ? (this._pendingForceUpdate = !1, this._performComponentUpdate(n, a, l, i, e, o)) : (this._currentElement = n, this._context = o, s.props = a, s.state = l, s.context = i)
                    },
                    _processPendingState: function(e, t) {
                        var n = this._instance,
                            r = this._pendingStateQueue,
                            o = this._pendingReplaceState;
                        if (this._pendingReplaceState = !1, this._pendingStateQueue = null, !r) return n.state;
                        if (o && 1 === r.length) return r[0];
                        for (var i = a({}, o ? r[0] : n.state), s = o ? 1 : 0; s < r.length; s++) {
                            var u = r[s];
                            a(i, "function" == typeof u ? u.call(n, i, e, t) : u)
                        }
                        return i
                    },
                    _performComponentUpdate: function(e, t, n, r, o, i) {
                        var a, s, u, l = this._instance,
                            c = Boolean(l.componentDidUpdate);
                        c && (a = l.props, s = l.state, u = l.context), l.componentWillUpdate && l.componentWillUpdate(t, n, r), this._currentElement = e, this._context = i, l.props = t, l.state = n, l.context = r, this._updateRenderedComponent(o, i), c && o.getReactMountReady().enqueue(l.componentDidUpdate.bind(l, a, s, u), l)
                    },
                    _updateRenderedComponent: function(e, t) {
                        var n = this._renderedComponent,
                            r = n._currentElement,
                            o = this._renderValidatedComponent();
                        if (C(r, o)) v.receiveComponent(n, o, e, this._processChildContext(t));
                        else {
                            var i = v.getNativeNode(n);
                            v.unmountComponent(n, !1), this._renderedNodeType = d.getType(o), this._renderedComponent = this._instantiateReactComponent(o);
                            var a = v.mountComponent(this._renderedComponent, e, this._nativeParent, this._nativeContainerInfo, this._processChildContext(t));
                            this._replaceNodeWithMarkup(i, a)
                        }
                    },
                    _replaceNodeWithMarkup: function(e, t) {
                        s.replaceNodeWithMarkup(e, t)
                    },
                    _renderValidatedComponentWithoutOwnerOrContext: function() {
                        var e = this._instance,
                            t = e.render();
                        return t
                    },
                    _renderValidatedComponent: function() {
                        var e;
                        u.current = this;
                        try {
                            e = this._renderValidatedComponentWithoutOwnerOrContext()
                        } finally {
                            u.current = null
                        }
                        return null === e || e === !1 || l.isValidElement(e) ? void 0 : y(!1), e
                    },
                    attachRef: function(e, t) {
                        var n = this.getPublicInstance();
                        null == n ? y(!1) : void 0;
                        var r = t.getPublicInstance(),
                            o = n.refs === g ? n.refs = {} : n.refs;
                        o[e] = r
                    },
                    detachRef: function(e) {
                        var t = this.getPublicInstance().refs;
                        delete t[e]
                    },
                    getName: function() {
                        var e = this._currentElement.type,
                            t = this._instance && this._instance.constructor;
                        return e.displayName || t && t.displayName || e.name || t && t.name || null
                    },
                    getPublicInstance: function() {
                        var e = this._instance;
                        return e instanceof o ? null : e
                    },
                    _instantiateReactComponent: null
                };
            f.measureMethods(_, "ReactCompositeComponent", {
                mountComponent: "mountComponent",
                updateComponent: "updateComponent",
                _renderValidatedComponent: "_renderValidatedComponent"
            });
            var E = {
                Mixin: _
            };
            t.exports = E
        }, {
            148: 148,
            161: 161,
            168: 168,
            176: 176,
            177: 177,
            34: 34,
            37: 37,
            62: 62,
            65: 65,
            72: 72,
            73: 73,
            81: 81,
            84: 84,
            85: 85,
            86: 86,
            89: 89,
            98: 98
        }],
        37: [function(e, t, n) {
            "use strict";
            var r = {
                current: null
            };
            t.exports = r
        }, {}],
        38: [function(e, t, n) {
            "use strict";
            var r = e(42),
                o = e(61),
                i = e(77),
                a = e(84),
                s = e(89),
                u = e(99),
                l = e(100),
                c = e(127),
                p = e(135),
                d = e(144);
            e(176);
            o.inject();
            var f = a.measure("React", "render", i.render),
                h = {
                    findDOMNode: c,
                    render: f,
                    unmountComponentAtNode: i.unmountComponentAtNode,
                    version: l,
                    unstable_batchedUpdates: u.batchedUpdates,
                    unstable_renderSubtreeIntoContainer: d
                };
            "undefined" != typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" == typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject && __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
                ComponentTree: {
                    getClosestInstanceFromNode: r.getClosestInstanceFromNode,
                    getNodeFromInstance: function(e) {
                        return e._renderedComponent && (e = p(e)), e ? r.getNodeFromInstance(e) : null
                    }
                },
                Mount: i,
                Reconciler: s
            });
            t.exports = h
        }, {
            100: 100,
            127: 127,
            135: 135,
            144: 144,
            176: 176,
            42: 42,
            61: 61,
            77: 77,
            84: 84,
            89: 89,
            99: 99
        }],
        39: [function(e, t, n) {
            "use strict";
            var r = {
                    onClick: !0,
                    onDoubleClick: !0,
                    onMouseDown: !0,
                    onMouseMove: !0,
                    onMouseUp: !0,
                    onClickCapture: !0,
                    onDoubleClickCapture: !0,
                    onMouseDownCapture: !0,
                    onMouseMoveCapture: !0,
                    onMouseUpCapture: !0
                },
                o = {
                    getNativeProps: function(e, t) {
                        if (!t.disabled) return t;
                        var n = {};
                        for (var o in t) t.hasOwnProperty(o) && !r[o] && (n[o] = t[o]);
                        return n
                    }
                };
            t.exports = o
        }, {}],
        40: [function(e, t, n) {
            "use strict";

            function r(e, t) {
                t && (G[e._tag] && (null != t.children || null != t.dangerouslySetInnerHTML ? I(!1) : void 0), null != t.dangerouslySetInnerHTML && (null != t.children ? I(!1) : void 0, "object" == typeof t.dangerouslySetInnerHTML && K in t.dangerouslySetInnerHTML ? void 0 : I(!1)), null != t.style && "object" != typeof t.style ? I(!1) : void 0)
            }

            function o(e, t, n, r) {
                var o = e._nativeContainerInfo,
                    a = o._ownerDocument;
                a && (V(t, a), r.getReactMountReady().enqueue(i, {
                    inst: e,
                    registrationName: t,
                    listener: n
                }))
            }

            function i() {
                var e = this;
                b.putListener(e.inst, e.registrationName, e.listener)
            }

            function a() {
                var e = this;
                S.postMountWrapper(e)
            }

            function s() {
                var e = this;
                e._rootNodeID ? void 0 : I(!1);
                var t = F(e);
                switch (t ? void 0 : I(!1), e._tag) {
                    case "iframe":
                    case "object":
                        e._wrapperState.listeners = [E.trapBubbledEvent(C.topLevelTypes.topLoad, "load", t)];
                        break;
                    case "video":
                    case "audio":
                        e._wrapperState.listeners = [];
                        for (var n in H) H.hasOwnProperty(n) && e._wrapperState.listeners.push(E.trapBubbledEvent(C.topLevelTypes[n], H[n], t));
                        break;
                    case "img":
                        e._wrapperState.listeners = [E.trapBubbledEvent(C.topLevelTypes.topError, "error", t), E.trapBubbledEvent(C.topLevelTypes.topLoad, "load", t)];
                        break;
                    case "form":
                        e._wrapperState.listeners = [E.trapBubbledEvent(C.topLevelTypes.topReset, "reset", t), E.trapBubbledEvent(C.topLevelTypes.topSubmit, "submit", t)];
                        break;
                    case "input":
                    case "select":
                    case "textarea":
                        e._wrapperState.listeners = [E.trapBubbledEvent(C.topLevelTypes.topInvalid, "invalid", t)]
                }
            }

            function u() {
                M.postUpdateWrapper(this)
            }

            function l(e) {
                $.call(Q, e) || (X.test(e) ? void 0 : I(!1), Q[e] = !0)
            }

            function c(e, t) {
                return e.indexOf("-") >= 0 || null != t.is
            }

            function p(e) {
                var t = e.type;
                l(t), this._currentElement = e, this._tag = t.toLowerCase(), this._namespaceURI = null, this._renderedChildren = null, this._previousStyle = null, this._previousStyleCopy = null, this._nativeNode = null, this._nativeParent = null, this._rootNodeID = null, this._domID = null, this._nativeContainerInfo = null, this._wrapperState = null, this._topLevelWrapper = null, this._flags = 0
            }
            var d = e(177),
                f = e(1),
                h = e(4),
                v = e(8),
                m = e(9),
                g = e(10),
                y = e(11),
                C = e(15),
                b = e(16),
                _ = e(17),
                E = e(26),
                T = e(33),
                x = e(39),
                P = e(41),
                N = e(42),
                w = e(49),
                S = e(51),
                M = e(52),
                k = e(56),
                R = e(78),
                D = e(84),
                A = e(126),
                I = e(168),
                O = (e(140), e(172)),
                L = (e(175), e(151), e(176), P),
                U = b.deleteListener,
                F = N.getNodeFromInstance,
                V = E.listenTo,
                B = _.registrationNameModules,
                j = {
                    string: !0,
                    number: !0
                },
                W = O({
                    style: null
                }),
                K = O({
                    __html: null
                }),
                q = {
                    children: null,
                    dangerouslySetInnerHTML: null,
                    suppressContentEditableWarning: null
                },
                H = {
                    topAbort: "abort",
                    topCanPlay: "canplay",
                    topCanPlayThrough: "canplaythrough",
                    topDurationChange: "durationchange",
                    topEmptied: "emptied",
                    topEncrypted: "encrypted",
                    topEnded: "ended",
                    topError: "error",
                    topLoadedData: "loadeddata",
                    topLoadedMetadata: "loadedmetadata",
                    topLoadStart: "loadstart",
                    topPause: "pause",
                    topPlay: "play",
                    topPlaying: "playing",
                    topProgress: "progress",
                    topRateChange: "ratechange",
                    topSeeked: "seeked",
                    topSeeking: "seeking",
                    topStalled: "stalled",
                    topSuspend: "suspend",
                    topTimeUpdate: "timeupdate",
                    topVolumeChange: "volumechange",
                    topWaiting: "waiting"
                },
                Y = {
                    area: !0,
                    base: !0,
                    br: !0,
                    col: !0,
                    embed: !0,
                    hr: !0,
                    img: !0,
                    input: !0,
                    keygen: !0,
                    link: !0,
                    meta: !0,
                    param: !0,
                    source: !0,
                    track: !0,
                    wbr: !0
                },
                z = {
                    listing: !0,
                    pre: !0,
                    textarea: !0
                },
                G = d({
                    menuitem: !0
                }, Y),
                X = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/,
                Q = {},
                $ = {}.hasOwnProperty,
                Z = 1;
            p.displayName = "ReactDOMComponent", p.Mixin = {
                    mountComponent: function(e, t, n, o) {
                        this._rootNodeID = Z++, this._domID = n._idCounter++, this._nativeParent = t, this._nativeContainerInfo = n;
                        var i = this._currentElement.props;
                        switch (this._tag) {
                            case "iframe":
                            case "object":
                            case "img":
                            case "form":
                            case "video":
                            case "audio":
                                this._wrapperState = {
                                    listeners: null
                                }, e.getReactMountReady().enqueue(s, this);
                                break;
                            case "button":
                                i = x.getNativeProps(this, i, t);
                                break;
                            case "input":
                                w.mountWrapper(this, i, t), i = w.getNativeProps(this, i), e.getReactMountReady().enqueue(s, this);
                                break;
                            case "option":
                                S.mountWrapper(this, i, t), i = S.getNativeProps(this, i);
                                break;
                            case "select":
                                M.mountWrapper(this, i, t), i = M.getNativeProps(this, i), e.getReactMountReady().enqueue(s, this);
                                break;
                            case "textarea":
                                k.mountWrapper(this, i, t), i = k.getNativeProps(this, i), e.getReactMountReady().enqueue(s, this)
                        }
                        r(this, i);
                        var u, l;
                        null != t ? (u = t._namespaceURI, l = t._tag) : n._tag && (u = n._namespaceURI, l = n._tag), (null == u || u === m.svg && "foreignobject" === l) && (u = m.html), u === m.html && ("svg" === this._tag ? u = m.svg : "math" === this._tag && (u = m.mathml)), this._namespaceURI = u;
                        var c;
                        if (e.useCreateElement) {
                            var p, d = n._ownerDocument;
                            if (u === m.html)
                                if ("script" === this._tag) {
                                    var h = d.createElement("div"),
                                        g = this._currentElement.type;
                                    h.innerHTML = "<" + g + "></" + g + ">", p = h.removeChild(h.firstChild)
                                } else p = d.createElement(this._currentElement.type);
                            else p = d.createElementNS(u, this._currentElement.type);
                            N.precacheNode(this, p), this._flags |= L.hasCachedChildNodes, this._nativeParent || y.setAttributeForRoot(p), this._updateDOMProperties(null, i, e);
                            var C = v(p);
                            this._createInitialChildren(e, i, o, C), c = C
                        } else {
                            var b = this._createOpenTagMarkupAndPutListeners(e, i),
                                _ = this._createContentMarkup(e, i, o);
                            c = !_ && Y[this._tag] ? b + "/>" : b + ">" + _ + "</" + this._currentElement.type + ">"
                        }
                        switch (this._tag) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                i.autoFocus && e.getReactMountReady().enqueue(f.focusDOMComponent, this);
                                break;
                            case "option":
                                e.getReactMountReady().enqueue(a, this)
                        }
                        return c
                    },
                    _createOpenTagMarkupAndPutListeners: function(e, t) {
                        var n = "<" + this._currentElement.type;
                        for (var r in t)
                            if (t.hasOwnProperty(r)) {
                                var i = t[r];
                                if (null != i)
                                    if (B.hasOwnProperty(r)) i && o(this, r, i, e);
                                    else {
                                        r === W && (i && (i = this._previousStyleCopy = d({}, t.style)), i = h.createMarkupForStyles(i, this));
                                        var a = null;
                                        null != this._tag && c(this._tag, t) ? q.hasOwnProperty(r) || (a = y.createMarkupForCustomAttribute(r, i)) : a = y.createMarkupForProperty(r, i), a && (n += " " + a)
                                    }
                            }
                        return e.renderToStaticMarkup ? n : (this._nativeParent || (n += " " + y.createMarkupForRoot()), n += " " + y.createMarkupForID(this._domID))
                    },
                    _createContentMarkup: function(e, t, n) {
                        var r = "",
                            o = t.dangerouslySetInnerHTML;
                        if (null != o) null != o.__html && (r = o.__html);
                        else {
                            var i = j[typeof t.children] ? t.children : null,
                                a = null != i ? null : t.children;
                            if (null != i) r = A(i);
                            else if (null != a) {
                                var s = this.mountChildren(a, e, n);
                                r = s.join("")
                            }
                        }
                        return z[this._tag] && "\n" === r.charAt(0) ? "\n" + r : r
                    },
                    _createInitialChildren: function(e, t, n, r) {
                        var o = t.dangerouslySetInnerHTML;
                        if (null != o) null != o.__html && v.queueHTML(r, o.__html);
                        else {
                            var i = j[typeof t.children] ? t.children : null,
                                a = null != i ? null : t.children;
                            if (null != i) v.queueText(r, i);
                            else if (null != a)
                                for (var s = this.mountChildren(a, e, n), u = 0; u < s.length; u++) v.queueChild(r, s[u])
                        }
                    },
                    receiveComponent: function(e, t, n) {
                        var r = this._currentElement;
                        this._currentElement = e, this.updateComponent(t, r, e, n)
                    },
                    updateComponent: function(e, t, n, o) {
                        var i = t.props,
                            a = this._currentElement.props;
                        switch (this._tag) {
                            case "button":
                                i = x.getNativeProps(this, i), a = x.getNativeProps(this, a);
                                break;
                            case "input":
                                w.updateWrapper(this), i = w.getNativeProps(this, i), a = w.getNativeProps(this, a);
                                break;
                            case "option":
                                i = S.getNativeProps(this, i), a = S.getNativeProps(this, a);
                                break;
                            case "select":
                                i = M.getNativeProps(this, i), a = M.getNativeProps(this, a);
                                break;
                            case "textarea":
                                k.updateWrapper(this), i = k.getNativeProps(this, i), a = k.getNativeProps(this, a)
                        }
                        r(this, a), this._updateDOMProperties(i, a, e), this._updateDOMChildren(i, a, e, o), "select" === this._tag && e.getReactMountReady().enqueue(u, this)
                    },
                    _updateDOMProperties: function(e, t, n) {
                        var r, i, a;
                        for (r in e)
                            if (!t.hasOwnProperty(r) && e.hasOwnProperty(r) && null != e[r])
                                if (r === W) {
                                    var s = this._previousStyleCopy;
                                    for (i in s) s.hasOwnProperty(i) && (a = a || {}, a[i] = "");
                                    this._previousStyleCopy = null
                                } else B.hasOwnProperty(r) ? e[r] && U(this, r) : (g.properties[r] || g.isCustomAttribute(r)) && y.deleteValueForProperty(F(this), r);
                        for (r in t) {
                            var u = t[r],
                                l = r === W ? this._previousStyleCopy : null != e ? e[r] : void 0;
                            if (t.hasOwnProperty(r) && u !== l && (null != u || null != l))
                                if (r === W)
                                    if (u ? u = this._previousStyleCopy = d({}, u) : this._previousStyleCopy = null, l) {
                                        for (i in l) !l.hasOwnProperty(i) || u && u.hasOwnProperty(i) || (a = a || {}, a[i] = "");
                                        for (i in u) u.hasOwnProperty(i) && l[i] !== u[i] && (a = a || {}, a[i] = u[i])
                                    } else a = u;
                            else if (B.hasOwnProperty(r)) u ? o(this, r, u, n) : l && U(this, r);
                            else if (c(this._tag, t)) q.hasOwnProperty(r) || y.setValueForAttribute(F(this), r, u);
                            else if (g.properties[r] || g.isCustomAttribute(r)) {
                                var p = F(this);
                                null != u ? y.setValueForProperty(p, r, u) : y.deleteValueForProperty(p, r)
                            }
                        }
                        a && h.setValueForStyles(F(this), a, this)
                    },
                    _updateDOMChildren: function(e, t, n, r) {
                        var o = j[typeof e.children] ? e.children : null,
                            i = j[typeof t.children] ? t.children : null,
                            a = e.dangerouslySetInnerHTML && e.dangerouslySetInnerHTML.__html,
                            s = t.dangerouslySetInnerHTML && t.dangerouslySetInnerHTML.__html,
                            u = null != o ? null : e.children,
                            l = null != i ? null : t.children,
                            c = null != o || null != a,
                            p = null != i || null != s;
                        null != u && null == l ? this.updateChildren(null, n, r) : c && !p && this.updateTextContent(""), null != i ? o !== i && this.updateTextContent("" + i) : null != s ? a !== s && this.updateMarkup("" + s) : null != l && this.updateChildren(l, n, r)
                    },
                    getNativeNode: function() {
                        return F(this)
                    },
                    unmountComponent: function(e) {
                        switch (this._tag) {
                            case "iframe":
                            case "object":
                            case "img":
                            case "form":
                            case "video":
                            case "audio":
                                var t = this._wrapperState.listeners;
                                if (t)
                                    for (var n = 0; n < t.length; n++) t[n].remove();
                                break;
                            case "html":
                            case "head":
                            case "body":
                                I(!1)
                        }
                        this.unmountChildren(e), N.uncacheNode(this), b.deleteAllListeners(this), T.unmountIDFromEnvironment(this._rootNodeID), this._rootNodeID = null, this._domID = null, this._wrapperState = null
                    },
                    getPublicInstance: function() {
                        return F(this)
                    }
                }, D.measureMethods(p.Mixin, "ReactDOMComponent", {
                    mountComponent: "mountComponent",
                    receiveComponent: "receiveComponent"
                }), d(p.prototype, p.Mixin, R.Mixin),
                t.exports = p
        }, {
            1: 1,
            10: 10,
            11: 11,
            126: 126,
            140: 140,
            15: 15,
            151: 151,
            16: 16,
            168: 168,
            17: 17,
            172: 172,
            175: 175,
            176: 176,
            177: 177,
            26: 26,
            33: 33,
            39: 39,
            4: 4,
            41: 41,
            42: 42,
            49: 49,
            51: 51,
            52: 52,
            56: 56,
            78: 78,
            8: 8,
            84: 84,
            9: 9
        }],
        41: [function(e, t, n) {
            "use strict";
            var r = {
                hasCachedChildNodes: 1
            };
            t.exports = r
        }, {}],
        42: [function(e, t, n) {
            "use strict";

            function r(e) {
                for (var t; t = e._renderedComponent;) e = t;
                return e
            }

            function o(e, t) {
                var n = r(e);
                n._nativeNode = t, t[v] = n
            }

            function i(e) {
                var t = e._nativeNode;
                t && (delete t[v], e._nativeNode = null)
            }

            function a(e, t) {
                if (!(e._flags & h.hasCachedChildNodes)) {
                    var n = e._renderedChildren,
                        i = t.firstChild;
                    e: for (var a in n)
                        if (n.hasOwnProperty(a)) {
                            var s = n[a],
                                u = r(s)._domID;
                            if (null != u) {
                                for (; null !== i; i = i.nextSibling)
                                    if (1 === i.nodeType && i.getAttribute(f) === String(u) || 8 === i.nodeType && i.nodeValue === " react-text: " + u + " " || 8 === i.nodeType && i.nodeValue === " react-empty: " + u + " ") {
                                        o(s, i);
                                        continue e
                                    }
                                d(!1)
                            }
                        }
                    e._flags |= h.hasCachedChildNodes
                }
            }

            function s(e) {
                if (e[v]) return e[v];
                for (var t = []; !e[v];) {
                    if (t.push(e), !e.parentNode) return null;
                    e = e.parentNode
                }
                for (var n, r; e && (r = e[v]); e = t.pop()) n = r, t.length && a(r, e);
                return n
            }

            function u(e) {
                var t = s(e);
                return null != t && t._nativeNode === e ? t : null
            }

            function l(e) {
                if (void 0 === e._nativeNode ? d(!1) : void 0, e._nativeNode) return e._nativeNode;
                for (var t = []; !e._nativeNode;) t.push(e), e._nativeParent ? void 0 : d(!1), e = e._nativeParent;
                for (; t.length; e = t.pop()) a(e, e._nativeNode);
                return e._nativeNode
            }
            var c = e(10),
                p = e(41),
                d = e(168),
                f = c.ID_ATTRIBUTE_NAME,
                h = p,
                v = "__reactInternalInstance$" + Math.random().toString(36).slice(2),
                m = {
                    getClosestInstanceFromNode: s,
                    getInstanceFromNode: u,
                    getNodeFromInstance: l,
                    precacheChildNodes: a,
                    precacheNode: o,
                    uncacheNode: i
                };
            t.exports = m
        }, {
            10: 10,
            168: 168,
            41: 41
        }],
        43: [function(e, t, n) {
            "use strict";

            function r(e, t) {
                var n = {
                    _topLevelWrapper: e,
                    _idCounter: 1,
                    _ownerDocument: t ? t.nodeType === o ? t : t.ownerDocument : null,
                    _tag: t ? t.nodeName.toLowerCase() : null,
                    _namespaceURI: t ? t.namespaceURI : null
                };
                return n
            }
            var o = (e(151), 9);
            t.exports = r
        }, {
            151: 151
        }],
        44: [function(e, t, n) {
            "use strict";

            function r(e, t, n, r, o, i) {}
            var o = e(58),
                i = (e(176), []),
                a = {
                    addDevtool: function(e) {
                        i.push(e)
                    },
                    removeDevtool: function(e) {
                        for (var t = 0; t < i.length; t++) i[t] === e && (i.splice(t, 1), t--)
                    },
                    onCreateMarkupForProperty: function(e, t) {
                        r("onCreateMarkupForProperty", e, t)
                    },
                    onSetValueForProperty: function(e, t, n) {
                        r("onSetValueForProperty", e, t, n)
                    },
                    onDeleteValueForProperty: function(e, t) {
                        r("onDeleteValueForProperty", e, t)
                    }
                };
            a.addDevtool(o), t.exports = a
        }, {
            176: 176,
            58: 58
        }],
        45: [function(e, t, n) {
            "use strict";
            var r = e(177),
                o = e(8),
                i = e(42),
                a = function(e) {
                    this._currentElement = null, this._nativeNode = null, this._nativeParent = null, this._nativeContainerInfo = null, this._domID = null
                };
            r(a.prototype, {
                mountComponent: function(e, t, n, r) {
                    var a = n._idCounter++;
                    this._domID = a, this._nativeParent = t, this._nativeContainerInfo = n;
                    var s = " react-empty: " + this._domID + " ";
                    if (e.useCreateElement) {
                        var u = n._ownerDocument,
                            l = u.createComment(s);
                        return i.precacheNode(this, l), o(l)
                    }
                    return e.renderToStaticMarkup ? "" : "<!--" + s + "-->"
                },
                receiveComponent: function() {},
                getNativeNode: function() {
                    return i.getNodeFromInstance(this)
                },
                unmountComponent: function() {
                    i.uncacheNode(this)
                }
            }), t.exports = a
        }, {
            177: 177,
            42: 42,
            8: 8
        }],
        46: [function(e, t, n) {
            "use strict";

            function r(e) {
                return o.createFactory(e)
            }
            var o = e(62),
                i = (e(63), e(173)),
                a = i({
                    a: "a",
                    abbr: "abbr",
                    address: "address",
                    area: "area",
                    article: "article",
                    aside: "aside",
                    audio: "audio",
                    b: "b",
                    base: "base",
                    bdi: "bdi",
                    bdo: "bdo",
                    big: "big",
                    blockquote: "blockquote",
                    body: "body",
                    br: "br",
                    button: "button",
                    canvas: "canvas",
                    caption: "caption",
                    cite: "cite",
                    code: "code",
                    col: "col",
                    colgroup: "colgroup",
                    data: "data",
                    datalist: "datalist",
                    dd: "dd",
                    del: "del",
                    details: "details",
                    dfn: "dfn",
                    dialog: "dialog",
                    div: "div",
                    dl: "dl",
                    dt: "dt",
                    em: "em",
                    embed: "embed",
                    fieldset: "fieldset",
                    figcaption: "figcaption",
                    figure: "figure",
                    footer: "footer",
                    form: "form",
                    h1: "h1",
                    h2: "h2",
                    h3: "h3",
                    h4: "h4",
                    h5: "h5",
                    h6: "h6",
                    head: "head",
                    header: "header",
                    hgroup: "hgroup",
                    hr: "hr",
                    html: "html",
                    i: "i",
                    iframe: "iframe",
                    img: "img",
                    input: "input",
                    ins: "ins",
                    kbd: "kbd",
                    keygen: "keygen",
                    label: "label",
                    legend: "legend",
                    li: "li",
                    link: "link",
                    main: "main",
                    map: "map",
                    mark: "mark",
                    menu: "menu",
                    menuitem: "menuitem",
                    meta: "meta",
                    meter: "meter",
                    nav: "nav",
                    noscript: "noscript",
                    object: "object",
                    ol: "ol",
                    optgroup: "optgroup",
                    option: "option",
                    output: "output",
                    p: "p",
                    param: "param",
                    picture: "picture",
                    pre: "pre",
                    progress: "progress",
                    q: "q",
                    rp: "rp",
                    rt: "rt",
                    ruby: "ruby",
                    s: "s",
                    samp: "samp",
                    script: "script",
                    section: "section",
                    select: "select",
                    small: "small",
                    source: "source",
                    span: "span",
                    strong: "strong",
                    style: "style",
                    sub: "sub",
                    summary: "summary",
                    sup: "sup",
                    table: "table",
                    tbody: "tbody",
                    td: "td",
                    textarea: "textarea",
                    tfoot: "tfoot",
                    th: "th",
                    thead: "thead",
                    time: "time",
                    title: "title",
                    tr: "tr",
                    track: "track",
                    u: "u",
                    ul: "ul",
                    "var": "var",
                    video: "video",
                    wbr: "wbr",
                    circle: "circle",
                    clipPath: "clipPath",
                    defs: "defs",
                    ellipse: "ellipse",
                    g: "g",
                    image: "image",
                    line: "line",
                    linearGradient: "linearGradient",
                    mask: "mask",
                    path: "path",
                    pattern: "pattern",
                    polygon: "polygon",
                    polyline: "polyline",
                    radialGradient: "radialGradient",
                    rect: "rect",
                    stop: "stop",
                    svg: "svg",
                    text: "text",
                    tspan: "tspan"
                }, r);
            t.exports = a
        }, {
            173: 173,
            62: 62,
            63: 63
        }],
        47: [function(e, t, n) {
            "use strict";
            var r = {
                useCreateElement: !0
            };
            t.exports = r
        }, {}],
        48: [function(e, t, n) {
            "use strict";
            var r = e(7),
                o = e(42),
                i = e(84),
                a = {
                    dangerouslyProcessChildrenUpdates: function(e, t) {
                        var n = o.getNodeFromInstance(e);
                        r.processUpdates(n, t)
                    }
                };
            i.measureMethods(a, "ReactDOMIDOperations", {
                dangerouslyProcessChildrenUpdates: "dangerouslyProcessChildrenUpdates"
            }), t.exports = a
        }, {
            42: 42,
            7: 7,
            84: 84
        }],
        49: [function(e, t, n) {
            "use strict";

            function r() {
                this._rootNodeID && p.updateWrapper(this)
            }

            function o(e) {
                var t = this._currentElement.props,
                    n = s.executeOnChange(t, e);
                l.asap(r, this);
                var o = t.name;
                if ("radio" === t.type && null != o) {
                    for (var i = u.getNodeFromInstance(this), a = i; a.parentNode;) a = a.parentNode;
                    for (var p = a.querySelectorAll("input[name=" + JSON.stringify("" + o) + '][type="radio"]'), d = 0; d < p.length; d++) {
                        var f = p[d];
                        if (f !== i && f.form === i.form) {
                            var h = u.getInstanceFromNode(f);
                            h ? void 0 : c(!1), l.asap(r, h)
                        }
                    }
                }
                return n
            }
            var i = e(177),
                a = e(11),
                s = e(23),
                u = e(42),
                l = e(99),
                c = e(168),
                p = (e(176), {
                    getNativeProps: function(e, t) {
                        var n = s.getValue(t),
                            r = s.getChecked(t),
                            o = i({
                                type: void 0
                            }, t, {
                                defaultChecked: void 0,
                                defaultValue: void 0,
                                value: null != n ? n : e._wrapperState.initialValue,
                                checked: null != r ? r : e._wrapperState.initialChecked,
                                onChange: e._wrapperState.onChange
                            });
                        return o
                    },
                    mountWrapper: function(e, t) {
                        var n = t.defaultValue;
                        e._wrapperState = {
                            initialChecked: t.defaultChecked || !1,
                            initialValue: null != n ? n : null,
                            listeners: null,
                            onChange: o.bind(e)
                        }
                    },
                    updateWrapper: function(e) {
                        var t = e._currentElement.props,
                            n = t.checked;
                        null != n && a.setValueForProperty(u.getNodeFromInstance(e), "checked", n || !1);
                        var r = s.getValue(t);
                        null != r && a.setValueForProperty(u.getNodeFromInstance(e), "value", "" + r)
                    }
                });
            t.exports = p
        }, {
            11: 11,
            168: 168,
            176: 176,
            177: 177,
            23: 23,
            42: 42,
            99: 99
        }],
        50: [function(e, t, n) {
            "use strict";
            var r = e(44);
            t.exports = {
                debugTool: r
            }
        }, {
            44: 44
        }],
        51: [function(e, t, n) {
            "use strict";
            var r = e(177),
                o = e(30),
                i = e(42),
                a = e(52),
                s = (e(176), {
                    mountWrapper: function(e, t, n) {
                        var r = null;
                        null != n && "select" === n._tag && (r = a.getSelectValueContext(n));
                        var o = null;
                        if (null != r)
                            if (o = !1, Array.isArray(r)) {
                                for (var i = 0; i < r.length; i++)
                                    if ("" + r[i] == "" + t.value) {
                                        o = !0;
                                        break
                                    }
                            } else o = "" + r == "" + t.value;
                        e._wrapperState = {
                            selected: o
                        }
                    },
                    postMountWrapper: function(e) {
                        var t = e._currentElement.props;
                        if (null != t.value) {
                            var n = i.getNodeFromInstance(e);
                            n.setAttribute("value", t.value)
                        }
                    },
                    getNativeProps: function(e, t) {
                        var n = r({
                            selected: void 0,
                            children: void 0
                        }, t);
                        null != e._wrapperState.selected && (n.selected = e._wrapperState.selected);
                        var i = "";
                        return o.forEach(t.children, function(e) {
                            null != e && ("string" != typeof e && "number" != typeof e || (i += e))
                        }), i && (n.children = i), n
                    }
                });
            t.exports = s
        }, {
            176: 176,
            177: 177,
            30: 30,
            42: 42,
            52: 52
        }],
        52: [function(e, t, n) {
            "use strict";

            function r() {
                if (this._rootNodeID && this._wrapperState.pendingUpdate) {
                    this._wrapperState.pendingUpdate = !1;
                    var e = this._currentElement.props,
                        t = s.getValue(e);
                    null != t && o(this, Boolean(e.multiple), t)
                }
            }

            function o(e, t, n) {
                var r, o, i = u.getNodeFromInstance(e).options;
                if (t) {
                    for (r = {}, o = 0; o < n.length; o++) r["" + n[o]] = !0;
                    for (o = 0; o < i.length; o++) {
                        var a = r.hasOwnProperty(i[o].value);
                        i[o].selected !== a && (i[o].selected = a)
                    }
                } else {
                    for (r = "" + n, o = 0; o < i.length; o++)
                        if (i[o].value === r) return void(i[o].selected = !0);
                    i.length && (i[0].selected = !0)
                }
            }

            function i(e) {
                var t = this._currentElement.props,
                    n = s.executeOnChange(t, e);
                return this._rootNodeID && (this._wrapperState.pendingUpdate = !0), l.asap(r, this), n
            }
            var a = e(177),
                s = e(23),
                u = e(42),
                l = e(99),
                c = (e(176), !1),
                p = {
                    getNativeProps: function(e, t) {
                        return a({}, t, {
                            onChange: e._wrapperState.onChange,
                            value: void 0
                        })
                    },
                    mountWrapper: function(e, t) {
                        var n = s.getValue(t);
                        e._wrapperState = {
                            pendingUpdate: !1,
                            initialValue: null != n ? n : t.defaultValue,
                            listeners: null,
                            onChange: i.bind(e),
                            wasMultiple: Boolean(t.multiple)
                        }, void 0 === t.value || void 0 === t.defaultValue || c || (c = !0)
                    },
                    getSelectValueContext: function(e) {
                        return e._wrapperState.initialValue
                    },
                    postUpdateWrapper: function(e) {
                        var t = e._currentElement.props;
                        e._wrapperState.initialValue = void 0;
                        var n = e._wrapperState.wasMultiple;
                        e._wrapperState.wasMultiple = Boolean(t.multiple);
                        var r = s.getValue(t);
                        null != r ? (e._wrapperState.pendingUpdate = !1, o(e, Boolean(t.multiple), r)) : n !== Boolean(t.multiple) && (null != t.defaultValue ? o(e, Boolean(t.multiple), t.defaultValue) : o(e, Boolean(t.multiple), t.multiple ? [] : ""))
                    }
                };
            t.exports = p
        }, {
            176: 176,
            177: 177,
            23: 23,
            42: 42,
            99: 99
        }],
        53: [function(e, t, n) {
            "use strict";

            function r(e, t, n, r) {
                return e === n && t === r
            }

            function o(e) {
                var t = document.selection,
                    n = t.createRange(),
                    r = n.text.length,
                    o = n.duplicate();
                o.moveToElementText(e), o.setEndPoint("EndToStart", n);
                var i = o.text.length,
                    a = i + r;
                return {
                    start: i,
                    end: a
                }
            }

            function i(e) {
                var t = window.getSelection && window.getSelection();
                if (!t || 0 === t.rangeCount) return null;
                var n = t.anchorNode,
                    o = t.anchorOffset,
                    i = t.focusNode,
                    a = t.focusOffset,
                    s = t.getRangeAt(0);
                try {
                    s.startContainer.nodeType, s.endContainer.nodeType
                } catch (u) {
                    return null
                }
                var l = r(t.anchorNode, t.anchorOffset, t.focusNode, t.focusOffset),
                    c = l ? 0 : s.toString().length,
                    p = s.cloneRange();
                p.selectNodeContents(e), p.setEnd(s.startContainer, s.startOffset);
                var d = r(p.startContainer, p.startOffset, p.endContainer, p.endOffset),
                    f = d ? 0 : p.toString().length,
                    h = f + c,
                    v = document.createRange();
                v.setStart(n, o), v.setEnd(i, a);
                var m = v.collapsed;
                return {
                    start: m ? h : f,
                    end: m ? f : h
                }
            }

            function a(e, t) {
                var n, r, o = document.selection.createRange().duplicate();
                void 0 === t.end ? (n = t.start, r = n) : t.start > t.end ? (n = t.end, r = t.start) : (n = t.start, r = t.end), o.moveToElementText(e), o.moveStart("character", n), o.setEndPoint("EndToStart", o), o.moveEnd("character", r - n), o.select()
            }

            function s(e, t) {
                if (window.getSelection) {
                    var n = window.getSelection(),
                        r = e[c()].length,
                        o = Math.min(t.start, r),
                        i = void 0 === t.end ? o : Math.min(t.end, r);
                    if (!n.extend && o > i) {
                        var a = i;
                        i = o, o = a
                    }
                    var s = l(e, o),
                        u = l(e, i);
                    if (s && u) {
                        var p = document.createRange();
                        p.setStart(s.node, s.offset), n.removeAllRanges(), o > i ? (n.addRange(p), n.extend(u.node, u.offset)) : (p.setEnd(u.node, u.offset), n.addRange(p))
                    }
                }
            }
            var u = e(154),
                l = e(136),
                c = e(137),
                p = u.canUseDOM && "selection" in document && !("getSelection" in window),
                d = {
                    getOffsets: p ? o : i,
                    setOffsets: p ? a : s
                };
            t.exports = d
        }, {
            136: 136,
            137: 137,
            154: 154
        }],
        54: [function(e, t, n) {
            "use strict";
            var r = e(61),
                o = e(92),
                i = e(100);
            r.inject();
            var a = {
                renderToString: o.renderToString,
                renderToStaticMarkup: o.renderToStaticMarkup,
                version: i
            };
            t.exports = a
        }, {
            100: 100,
            61: 61,
            92: 92
        }],
        55: [function(e, t, n) {
            "use strict";
            var r = e(177),
                o = e(7),
                i = e(8),
                a = e(42),
                s = e(84),
                u = e(126),
                l = e(168),
                c = (e(151), function(e) {
                    this._currentElement = e, this._stringText = "" + e, this._nativeNode = null, this._nativeParent = null, this._domID = null, this._mountIndex = 0, this._closingComment = null, this._commentNodes = null
                });
            r(c.prototype, {
                mountComponent: function(e, t, n, r) {
                    var o = n._idCounter++,
                        s = " react-text: " + o + " ",
                        l = " /react-text ";
                    if (this._domID = o, this._nativeParent = t, e.useCreateElement) {
                        var c = n._ownerDocument,
                            p = c.createComment(s),
                            d = c.createComment(l),
                            f = i(c.createDocumentFragment());
                        return i.queueChild(f, i(p)), this._stringText && i.queueChild(f, i(c.createTextNode(this._stringText))), i.queueChild(f, i(d)), a.precacheNode(this, p), this._closingComment = d, f
                    }
                    var h = u(this._stringText);
                    return e.renderToStaticMarkup ? h : "<!--" + s + "-->" + h + "<!--" + l + "-->"
                },
                receiveComponent: function(e, t) {
                    if (e !== this._currentElement) {
                        this._currentElement = e;
                        var n = "" + e;
                        if (n !== this._stringText) {
                            this._stringText = n;
                            var r = this.getNativeNode();
                            o.replaceDelimitedText(r[0], r[1], n)
                        }
                    }
                },
                getNativeNode: function() {
                    var e = this._commentNodes;
                    if (e) return e;
                    if (!this._closingComment)
                        for (var t = a.getNodeFromInstance(this), n = t.nextSibling;;) {
                            if (null == n ? l(!1) : void 0, 8 === n.nodeType && " /react-text " === n.nodeValue) {
                                this._closingComment = n;
                                break
                            }
                            n = n.nextSibling
                        }
                    return e = [this._nativeNode, this._closingComment], this._commentNodes = e, e
                },
                unmountComponent: function() {
                    this._closingComment = null, this._commentNodes = null, a.uncacheNode(this)
                }
            }), s.measureMethods(c.prototype, "ReactDOMTextComponent", {
                mountComponent: "mountComponent",
                receiveComponent: "receiveComponent"
            }), t.exports = c
        }, {
            126: 126,
            151: 151,
            168: 168,
            177: 177,
            42: 42,
            7: 7,
            8: 8,
            84: 84
        }],
        56: [function(e, t, n) {
            "use strict";

            function r() {
                this._rootNodeID && p.updateWrapper(this)
            }

            function o(e) {
                var t = this._currentElement.props,
                    n = s.executeOnChange(t, e);
                return l.asap(r, this), n
            }
            var i = e(177),
                a = e(11),
                s = e(23),
                u = e(42),
                l = e(99),
                c = e(168),
                p = (e(176), {
                    getNativeProps: function(e, t) {
                        null != t.dangerouslySetInnerHTML ? c(!1) : void 0;
                        var n = i({}, t, {
                            defaultValue: void 0,
                            value: void 0,
                            children: e._wrapperState.initialValue,
                            onChange: e._wrapperState.onChange
                        });
                        return n
                    },
                    mountWrapper: function(e, t) {
                        var n = t.defaultValue,
                            r = t.children;
                        null != r && (null != n ? c(!1) : void 0, Array.isArray(r) && (r.length <= 1 ? void 0 : c(!1), r = r[0]), n = "" + r), null == n && (n = "");
                        var i = s.getValue(t);
                        e._wrapperState = {
                            initialValue: "" + (null != i ? i : n),
                            listeners: null,
                            onChange: o.bind(e)
                        }
                    },
                    updateWrapper: function(e) {
                        var t = e._currentElement.props,
                            n = s.getValue(t);
                        null != n && a.setValueForProperty(u.getNodeFromInstance(e), "value", "" + n)
                    }
                });
            t.exports = p
        }, {
            11: 11,
            168: 168,
            176: 176,
            177: 177,
            23: 23,
            42: 42,
            99: 99
        }],
        57: [function(e, t, n) {
            "use strict";

            function r(e, t) {
                "_nativeNode" in e ? void 0 : u(!1), "_nativeNode" in t ? void 0 : u(!1);
                for (var n = 0, r = e; r; r = r._nativeParent) n++;
                for (var o = 0, i = t; i; i = i._nativeParent) o++;
                for (; n - o > 0;) e = e._nativeParent, n--;
                for (; o - n > 0;) t = t._nativeParent, o--;
                for (var a = n; a--;) {
                    if (e === t) return e;
                    e = e._nativeParent, t = t._nativeParent
                }
                return null
            }

            function o(e, t) {
                "_nativeNode" in e ? void 0 : u(!1), "_nativeNode" in t ? void 0 : u(!1);
                for (; t;) {
                    if (t === e) return !0;
                    t = t._nativeParent
                }
                return !1
            }

            function i(e) {
                return "_nativeNode" in e ? void 0 : u(!1), e._nativeParent
            }

            function a(e, t, n) {
                for (var r = []; e;) r.push(e), e = e._nativeParent;
                var o;
                for (o = r.length; o-- > 0;) t(r[o], !1, n);
                for (o = 0; o < r.length; o++) t(r[o], !0, n)
            }

            function s(e, t, n, o, i) {
                for (var a = e && t ? r(e, t) : null, s = []; e && e !== a;) s.push(e), e = e._nativeParent;
                for (var u = []; t && t !== a;) u.push(t), t = t._nativeParent;
                var l;
                for (l = 0; l < s.length; l++) n(s[l], !0, o);
                for (l = u.length; l-- > 0;) n(u[l], !1, i)
            }
            var u = e(168);
            t.exports = {
                isAncestor: o,
                getLowestCommonAncestor: r,
                getParentInstance: i,
                traverseTwoPhase: a,
                traverseEnterLeave: s
            }
        }, {
            168: 168
        }],
        58: [function(e, t, n) {
            "use strict";
            var r, o = (e(10), e(17), e(176), {
                onCreateMarkupForProperty: function(e, t) {
                    r(e)
                },
                onSetValueForProperty: function(e, t, n) {
                    r(t)
                },
                onDeleteValueForProperty: function(e, t) {
                    r(t)
                }
            });
            t.exports = o
        }, {
            10: 10,
            17: 17,
            176: 176
        }],
        59: [function(e, t, n) {
            "use strict";

            function r(e, t, n, r, o, i) {}
            var o = e(74),
                i = (e(176), []),
                a = {
                    addDevtool: function(e) {
                        i.push(e)
                    },
                    removeDevtool: function(e) {
                        for (var t = 0; t < i.length; t++) i[t] === e && (i.splice(t, 1), t--)
                    },
                    onBeginProcessingChildContext: function() {
                        r("onBeginProcessingChildContext")
                    },
                    onEndProcessingChildContext: function() {
                        r("onEndProcessingChildContext")
                    },
                    onSetState: function() {
                        r("onSetState")
                    },
                    onMountRootComponent: function(e) {
                        r("onMountRootComponent", e)
                    },
                    onMountComponent: function(e) {
                        r("onMountComponent", e)
                    },
                    onUpdateComponent: function(e) {
                        r("onUpdateComponent", e)
                    },
                    onUnmountComponent: function(e) {
                        r("onUnmountComponent", e)
                    }
                };
            a.addDevtool(o), t.exports = a
        }, {
            176: 176,
            74: 74
        }],
        60: [function(e, t, n) {
            "use strict";

            function r() {
                this.reinitializeTransaction()
            }
            var o = e(177),
                i = e(99),
                a = e(119),
                s = e(160),
                u = {
                    initialize: s,
                    close: function() {
                        d.isBatchingUpdates = !1
                    }
                },
                l = {
                    initialize: s,
                    close: i.flushBatchedUpdates.bind(i)
                },
                c = [l, u];
            o(r.prototype, a.Mixin, {
                getTransactionWrappers: function() {
                    return c
                }
            });
            var p = new r,
                d = {
                    isBatchingUpdates: !1,
                    batchedUpdates: function(e, t, n, r, o, i) {
                        var a = d.isBatchingUpdates;
                        d.isBatchingUpdates = !0, a ? e(t, n, r, o, i) : p.perform(e, null, t, n, r, o, i)
                    }
                };
            t.exports = d
        }, {
            119: 119,
            160: 160,
            177: 177,
            99: 99
        }],
        61: [function(e, t, n) {
            "use strict";

            function r() {
                E || (E = !0, g.EventEmitter.injectReactEventListener(m), g.EventPluginHub.injectEventPluginOrder(a), g.EventPluginUtils.injectComponentTree(p), g.EventPluginUtils.injectTreeTraversal(f), g.EventPluginHub.injectEventPluginsByName({
                    SimpleEventPlugin: _,
                    EnterLeaveEventPlugin: s,
                    ChangeEventPlugin: i,
                    SelectEventPlugin: b,
                    BeforeInputEventPlugin: o
                }), g.NativeComponent.injectGenericComponentClass(c), g.NativeComponent.injectTextComponentClass(h), g.DOMProperty.injectDOMPropertyConfig(u), g.DOMProperty.injectDOMPropertyConfig(C), g.EmptyComponent.injectEmptyComponentFactory(function(e) {
                    return new d(e)
                }), g.Updates.injectReconcileTransaction(y), g.Updates.injectBatchingStrategy(v), g.Component.injectEnvironment(l))
            }
            var o = e(2),
                i = e(6),
                a = e(13),
                s = e(14),
                u = (e(154), e(21)),
                l = e(33),
                c = e(40),
                p = e(42),
                d = e(45),
                f = e(57),
                h = e(55),
                v = e(60),
                m = e(67),
                g = e(70),
                y = e(88),
                C = e(103),
                b = e(104),
                _ = e(105),
                E = !1;
            t.exports = {
                inject: r
            }
        }, {
            103: 103,
            104: 104,
            105: 105,
            13: 13,
            14: 14,
            154: 154,
            2: 2,
            21: 21,
            33: 33,
            40: 40,
            42: 42,
            45: 45,
            55: 55,
            57: 57,
            6: 6,
            60: 60,
            67: 67,
            70: 70,
            88: 88
        }],
        62: [function(e, t, n) {
            "use strict";
            var r = e(177),
                o = e(37),
                i = (e(176), e(123), "function" == typeof Symbol && Symbol["for"] && Symbol["for"]("react.element") || 60103),
                a = {
                    key: !0,
                    ref: !0,
                    __self: !0,
                    __source: !0
                },
                s = function(e, t, n, r, o, a, s) {
                    var u = {
                        $$typeof: i,
                        type: e,
                        key: t,
                        ref: n,
                        props: s,
                        _owner: a
                    };
                    return u
                };
            s.createElement = function(e, t, n) {
                var r, i = {},
                    u = null,
                    l = null,
                    c = null,
                    p = null;
                if (null != t) {
                    l = void 0 === t.ref ? null : t.ref, u = void 0 === t.key ? null : "" + t.key, c = void 0 === t.__self ? null : t.__self, p = void 0 === t.__source ? null : t.__source;
                    for (r in t) t.hasOwnProperty(r) && !a.hasOwnProperty(r) && (i[r] = t[r])
                }
                var d = arguments.length - 2;
                if (1 === d) i.children = n;
                else if (d > 1) {
                    for (var f = Array(d), h = 0; d > h; h++) f[h] = arguments[h + 2];
                    i.children = f
                }
                if (e && e.defaultProps) {
                    var v = e.defaultProps;
                    for (r in v) void 0 === i[r] && (i[r] = v[r])
                }
                return s(e, u, l, c, p, o.current, i)
            }, s.createFactory = function(e) {
                var t = s.createElement.bind(null, e);
                return t.type = e, t
            }, s.cloneAndReplaceKey = function(e, t) {
                var n = s(e.type, t, e.ref, e._self, e._source, e._owner, e.props);
                return n
            }, s.cloneElement = function(e, t, n) {
                var i, u = r({}, e.props),
                    l = e.key,
                    c = e.ref,
                    p = e._self,
                    d = e._source,
                    f = e._owner;
                if (null != t) {
                    void 0 !== t.ref && (c = t.ref, f = o.current), void 0 !== t.key && (l = "" + t.key);
                    var h;
                    e.type && e.type.defaultProps && (h = e.type.defaultProps);
                    for (i in t) t.hasOwnProperty(i) && !a.hasOwnProperty(i) && (void 0 === t[i] && void 0 !== h ? u[i] = h[i] : u[i] = t[i])
                }
                var v = arguments.length - 2;
                if (1 === v) u.children = n;
                else if (v > 1) {
                    for (var m = Array(v), g = 0; v > g; g++) m[g] = arguments[g + 2];
                    u.children = m
                }
                return s(e.type, l, c, p, d, f, u)
            }, s.isValidElement = function(e) {
                return "object" == typeof e && null !== e && e.$$typeof === i
            }, t.exports = s
        }, {
            123: 123,
            176: 176,
            177: 177,
            37: 37
        }],
        63: [function(e, t, n) {
            "use strict";

            function r() {
                if (p.current) {
                    var e = p.current.getName();
                    if (e) return " Check the render method of `" + e + "`."
                }
                return ""
            }

            function o(e, t) {
                e._store && !e._store.validated && null == e.key && (e._store.validated = !0, i("uniqueKey", e, t))
            }

            function i(e, t, n) {
                var o = r();
                if (!o) {
                    var i = "string" == typeof n ? n : n.displayName || n.name;
                    i && (o = " Check the top-level render call using <" + i + ">.")
                }
                var a = h[e] || (h[e] = {});
                if (a[o]) return null;
                a[o] = !0;
                var s = {
                    parentOrOwner: o,
                    url: " See https://fb.me/react-warning-keys for more information.",
                    childOwner: null
                };
                return t && t._owner && t._owner !== p.current && (s.childOwner = " It was passed a child from " + t._owner.getName() + "."), s
            }

            function a(e, t) {
                if ("object" == typeof e)
                    if (Array.isArray(e))
                        for (var n = 0; n < e.length; n++) {
                            var r = e[n];
                            l.isValidElement(r) && o(r, t)
                        } else if (l.isValidElement(e)) e._store && (e._store.validated = !0);
                        else if (e) {
                    var i = d(e);
                    if (i && i !== e.entries)
                        for (var a, s = i.call(e); !(a = s.next()).done;) l.isValidElement(a.value) && o(a.value, t)
                }
            }

            function s(e, t, n, o) {
                for (var i in t)
                    if (t.hasOwnProperty(i)) {
                        var a;
                        try {
                            "function" != typeof t[i] ? f(!1) : void 0, a = t[i](n, i, e, o)
                        } catch (s) {
                            a = s
                        }
                        a instanceof Error && !(a.message in v) && (v[a.message] = !0, r())
                    }
            }

            function u(e) {
                var t = e.type;
                if ("function" == typeof t) {
                    var n = t.displayName || t.name;
                    t.propTypes && s(n, t.propTypes, e.props, c.prop), "function" == typeof t.getDefaultProps
                }
            }
            var l = e(62),
                c = e(86),
                p = (e(85), e(37)),
                d = (e(123), e(134)),
                f = e(168),
                h = (e(176), {}),
                v = {},
                m = {
                    createElement: function(e, t, n) {
                        var r = "string" == typeof e || "function" == typeof e,
                            o = l.createElement.apply(this, arguments);
                        if (null == o) return o;
                        if (r)
                            for (var i = 2; i < arguments.length; i++) a(arguments[i], e);
                        return u(o), o
                    },
                    createFactory: function(e) {
                        var t = m.createElement.bind(null, e);
                        return t.type = e, t
                    },
                    cloneElement: function(e, t, n) {
                        for (var r = l.cloneElement.apply(this, arguments), o = 2; o < arguments.length; o++) a(arguments[o], r.type);
                        return u(r), r
                    }
                };
            t.exports = m
        }, {
            123: 123,
            134: 134,
            168: 168,
            176: 176,
            37: 37,
            62: 62,
            85: 85,
            86: 86
        }],
        64: [function(e, t, n) {
            "use strict";
            var r, o = {
                    injectEmptyComponentFactory: function(e) {
                        r = e
                    }
                },
                i = {
                    create: function(e) {
                        return r(e)
                    }
                };
            i.injection = o, t.exports = i
        }, {}],
        65: [function(e, t, n) {
            "use strict";

            function r(e, t, n, r) {
                try {
                    return t(n, r)
                } catch (i) {
                    return void(null === o && (o = i))
                }
            }
            var o = null,
                i = {
                    invokeGuardedCallback: r,
                    invokeGuardedCallbackWithCatch: r,
                    rethrowCaughtError: function() {
                        if (o) {
                            var e = o;
                            throw o = null, e
                        }
                    }
                };
            t.exports = i
        }, {}],
        66: [function(e, t, n) {
            "use strict";

            function r(e) {
                o.enqueueEvents(e), o.processEventQueue(!1)
            }
            var o = e(16),
                i = {
                    handleTopLevel: function(e, t, n, i) {
                        var a = o.extractEvents(e, t, n, i);
                        r(a)
                    }
                };
            t.exports = i
        }, {
            16: 16
        }],
        67: [function(e, t, n) {
            "use strict";

            function r(e) {
                for (; e._nativeParent;) e = e._nativeParent;
                var t = p.getNodeFromInstance(e),
                    n = t.parentNode;
                return p.getClosestInstanceFromNode(n)
            }

            function o(e, t) {
                this.topLevelType = e, this.nativeEvent = t, this.ancestors = []
            }

            function i(e) {
                var t = f(e.nativeEvent),
                    n = p.getClosestInstanceFromNode(t),
                    o = n;
                do e.ancestors.push(o), o = o && r(o); while (o);
                for (var i = 0; i < e.ancestors.length; i++) n = e.ancestors[i], v._handleTopLevel(e.topLevelType, n, e.nativeEvent, f(e.nativeEvent))
            }

            function a(e) {
                var t = h(window);
                e(t)
            }
            var s = e(177),
                u = e(153),
                l = e(154),
                c = e(24),
                p = e(42),
                d = e(99),
                f = e(133),
                h = e(165);
            s(o.prototype, {
                destructor: function() {
                    this.topLevelType = null, this.nativeEvent = null, this.ancestors.length = 0
                }
            }), c.addPoolingTo(o, c.twoArgumentPooler);
            var v = {
                _enabled: !0,
                _handleTopLevel: null,
                WINDOW_HANDLE: l.canUseDOM ? window : null,
                setHandleTopLevel: function(e) {
                    v._handleTopLevel = e
                },
                setEnabled: function(e) {
                    v._enabled = !!e
                },
                isEnabled: function() {
                    return v._enabled
                },
                trapBubbledEvent: function(e, t, n) {
                    var r = n;
                    return r ? u.listen(r, t, v.dispatchEvent.bind(null, e)) : null
                },
                trapCapturedEvent: function(e, t, n) {
                    var r = n;
                    return r ? u.capture(r, t, v.dispatchEvent.bind(null, e)) : null
                },
                monitorScrollValue: function(e) {
                    var t = a.bind(null, e);
                    u.listen(window, "scroll", t)
                },
                dispatchEvent: function(e, t) {
                    if (v._enabled) {
                        var n = o.getPooled(e, t);
                        try {
                            d.batchedUpdates(i, n)
                        } finally {
                            o.release(n)
                        }
                    }
                }
            };
            t.exports = v
        }, {
            133: 133,
            153: 153,
            154: 154,
            165: 165,
            177: 177,
            24: 24,
            42: 42,
            99: 99
        }],
        68: [function(e, t, n) {
            "use strict";
            var r = {
                logTopLevelRenders: !1
            };
            t.exports = r
        }, {}],
        69: [function(e, t, n) {
            "use strict";
            var r = e(30),
                o = e(62),
                i = e(160),
                a = e(168),
                s = (e(176), {
                    create: function(e) {
                        if ("object" != typeof e || !e || Array.isArray(e)) return e;
                        if (o.isValidElement(e)) return e;
                        1 === e.nodeType ? a(!1) : void 0;
                        var t = [];
                        for (var n in e) r.mapIntoWithKeyPrefixInternal(e[n], t, n, i.thatReturnsArgument);
                        return t
                    }
                });
            t.exports = s
        }, {
            160: 160,
            168: 168,
            176: 176,
            30: 30,
            62: 62
        }],
        70: [function(e, t, n) {
            "use strict";
            var r = e(10),
                o = e(16),
                i = e(18),
                a = e(34),
                s = e(31),
                u = e(64),
                l = e(26),
                c = e(80),
                p = e(84),
                d = e(99),
                f = {
                    Component: a.injection,
                    Class: s.injection,
                    DOMProperty: r.injection,
                    EmptyComponent: u.injection,
                    EventPluginHub: o.injection,
                    EventPluginUtils: i.injection,
                    EventEmitter: l.injection,
                    NativeComponent: c.injection,
                    Perf: p.injection,
                    Updates: d.injection
                };
            t.exports = f
        }, {
            10: 10,
            16: 16,
            18: 18,
            26: 26,
            31: 31,
            34: 34,
            64: 64,
            80: 80,
            84: 84,
            99: 99
        }],
        71: [function(e, t, n) {
            "use strict";

            function r(e) {
                return i(document.documentElement, e)
            }
            var o = e(53),
                i = e(157),
                a = e(162),
                s = e(163),
                u = {
                    hasSelectionCapabilities: function(e) {
                        var t = e && e.nodeName && e.nodeName.toLowerCase();
                        return t && ("input" === t && "text" === e.type || "textarea" === t || "true" === e.contentEditable)
                    },
                    getSelectionInformation: function() {
                        var e = s();
                        return {
                            focusedElem: e,
                            selectionRange: u.hasSelectionCapabilities(e) ? u.getSelection(e) : null
                        }
                    },
                    restoreSelection: function(e) {
                        var t = s(),
                            n = e.focusedElem,
                            o = e.selectionRange;
                        t !== n && r(n) && (u.hasSelectionCapabilities(n) && u.setSelection(n, o), a(n))
                    },
                    getSelection: function(e) {
                        var t;
                        if ("selectionStart" in e) t = {
                            start: e.selectionStart,
                            end: e.selectionEnd
                        };
                        else if (document.selection && e.nodeName && "input" === e.nodeName.toLowerCase()) {
                            var n = document.selection.createRange();
                            n.parentElement() === e && (t = {
                                start: -n.moveStart("character", -e.value.length),
                                end: -n.moveEnd("character", -e.value.length)
                            })
                        } else t = o.getOffsets(e);
                        return t || {
                            start: 0,
                            end: 0
                        }
                    },
                    setSelection: function(e, t) {
                        var n = t.start,
                            r = t.end;
                        if (void 0 === r && (r = n), "selectionStart" in e) e.selectionStart = n, e.selectionEnd = Math.min(r, e.value.length);
                        else if (document.selection && e.nodeName && "input" === e.nodeName.toLowerCase()) {
                            var i = e.createTextRange();
                            i.collapse(!0), i.moveStart("character", n), i.moveEnd("character", r - n), i.select()
                        } else o.setOffsets(e, t)
                    }
                };
            t.exports = u
        }, {
            157: 157,
            162: 162,
            163: 163,
            53: 53
        }],
        72: [function(e, t, n) {
            "use strict";
            var r = {
                remove: function(e) {
                    e._reactInternalInstance = void 0
                },
                get: function(e) {
                    return e._reactInternalInstance
                },
                has: function(e) {
                    return void 0 !== e._reactInternalInstance
                },
                set: function(e, t) {
                    e._reactInternalInstance = t
                }
            };
            t.exports = r
        }, {}],
        73: [function(e, t, n) {
            "use strict";
            var r = e(59);
            t.exports = {
                debugTool: r
            }
        }, {
            59: 59
        }],
        74: [function(e, t, n) {
            "use strict";
            var r, o, i = (e(176), {
                onBeginProcessingChildContext: function() {
                    r = !0
                },
                onEndProcessingChildContext: function() {
                    r = !1
                },
                onSetState: function() {
                    o()
                }
            });
            t.exports = i
        }, {
            176: 176
        }],
        75: [function(e, t, n) {
            "use strict";

            function r(e, t) {
                this.value = e, this.requestChange = t
            }

            function o(e) {
                var t = {
                    value: void 0 === e ? i.PropTypes.any.isRequired : e.isRequired,
                    requestChange: i.PropTypes.func.isRequired
                };
                return i.PropTypes.shape(t)
            }
            var i = e(25);
            r.PropTypes = {
                link: o
            }, t.exports = r
        }, {
            25: 25
        }],
        76: [function(e, t, n) {
            "use strict";
            var r = e(122),
                o = /\/?>/,
                i = /^<\!\-\-/,
                a = {
                    CHECKSUM_ATTR_NAME: "data-react-checksum",
                    addChecksumToMarkup: function(e) {
                        var t = r(e);
                        return i.test(e) ? e : e.replace(o, " " + a.CHECKSUM_ATTR_NAME + '="' + t + '"$&')
                    },
                    canReuseMarkup: function(e, t) {
                        var n = t.getAttribute(a.CHECKSUM_ATTR_NAME);
                        n = n && parseInt(n, 10);
                        var o = r(e);
                        return o === n
                    }
                };
            t.exports = a
        }, {
            122: 122
        }],
        77: [function(e, t, n) {
            "use strict";

            function r(e, t) {
                for (var n = Math.min(e.length, t.length), r = 0; n > r; r++)
                    if (e.charAt(r) !== t.charAt(r)) return r;
                return e.length === t.length ? -1 : n
            }

            function o(e) {
                return e ? e.nodeType === A ? e.documentElement : e.firstChild : null
            }

            function i(e) {
                return e.getAttribute && e.getAttribute(k) || ""
            }

            function a(e, t, n, r, o) {
                var i;
                if (C.logTopLevelRenders) {
                    var a = e._currentElement.props,
                        s = a.type;
                    i = "React mount: " + ("string" == typeof s ? s : s.displayName || s.name), console.time(i)
                }
                var u = E.mountComponent(e, n, null, m(e, t), o);
                i && console.timeEnd(i), e._renderedComponent._topLevelWrapper = e, F._mountImageIntoNode(u, t, e, r, n)
            }

            function s(e, t, n, r) {
                var o = x.ReactReconcileTransaction.getPooled(!n && g.useCreateElement);
                o.perform(a, null, e, t, o, n, r), x.ReactReconcileTransaction.release(o)
            }

            function u(e, t, n) {
                for (E.unmountComponent(e, n), t.nodeType === A && (t = t.documentElement); t.lastChild;) t.removeChild(t.lastChild)
            }

            function l(e) {
                var t = o(e);
                if (t) {
                    var n = v.getInstanceFromNode(t);
                    return !(!n || !n._nativeParent)
                }
            }

            function c(e) {
                var t = o(e),
                    n = t && v.getInstanceFromNode(t);
                return n && !n._nativeParent ? n : null
            }

            function p(e) {
                var t = c(e);
                return t ? t._nativeContainerInfo._topLevelWrapper : null
            }
            var d = e(8),
                f = e(10),
                h = e(26),
                v = (e(37), e(42)),
                m = e(43),
                g = e(47),
                y = e(62),
                C = e(68),
                b = (e(73), e(76)),
                _ = e(84),
                E = e(89),
                T = e(98),
                x = e(99),
                P = e(161),
                N = e(139),
                w = e(168),
                S = e(145),
                M = e(148),
                k = (e(176), f.ID_ATTRIBUTE_NAME),
                R = f.ROOT_ATTRIBUTE_NAME,
                D = 1,
                A = 9,
                I = 11,
                O = {},
                L = 1,
                U = function() {
                    this.rootID = L++
                };
            U.prototype.isReactComponent = {}, U.prototype.render = function() {
                return this.props
            };
            var F = {
                TopLevelWrapper: U,
                _instancesByReactRootID: O,
                scrollMonitor: function(e, t) {
                    t()
                },
                _updateRootComponent: function(e, t, n, r) {
                    return F.scrollMonitor(n, function() {
                        T.enqueueElementInternal(e, t), r && T.enqueueCallbackInternal(e, r)
                    }), e
                },
                _renderNewRootComponent: function(e, t, n, r) {
                    !t || t.nodeType !== D && t.nodeType !== A && t.nodeType !== I ? w(!1) : void 0, h.ensureScrollValueMonitoring();
                    var o = N(e);
                    x.batchedUpdates(s, o, t, n, r);
                    var i = o._instance.rootID;
                    return O[i] = o, o
                },
                renderSubtreeIntoContainer: function(e, t, n, r) {
                    return null == e || null == e._reactInternalInstance ? w(!1) : void 0, F._renderSubtreeIntoContainer(e, t, n, r)
                },
                _renderSubtreeIntoContainer: function(e, t, n, r) {
                    T.validateCallback(r, "ReactDOM.render"), y.isValidElement(t) ? void 0 : w(!1);
                    var a = y(U, null, null, null, null, null, t),
                        s = p(n);
                    if (s) {
                        var u = s._currentElement,
                            c = u.props;
                        if (M(c, t)) {
                            var d = s._renderedComponent.getPublicInstance(),
                                f = r && function() {
                                    r.call(d)
                                };
                            return F._updateRootComponent(s, a, n, f), d
                        }
                        F.unmountComponentAtNode(n)
                    }
                    var h = o(n),
                        v = h && !!i(h),
                        m = l(n),
                        g = v && !s && !m,
                        C = F._renderNewRootComponent(a, n, g, null != e ? e._reactInternalInstance._processChildContext(e._reactInternalInstance._context) : P)._renderedComponent.getPublicInstance();
                    return r && r.call(C), C
                },
                render: function(e, t, n) {
                    return F._renderSubtreeIntoContainer(null, e, t, n)
                },
                unmountComponentAtNode: function(e) {
                    !e || e.nodeType !== D && e.nodeType !== A && e.nodeType !== I ? w(!1) : void 0;
                    var t = p(e);
                    return t ? (delete O[t._instance.rootID], x.batchedUpdates(u, t, e, !1), !0) : (l(e), 1 === e.nodeType && e.hasAttribute(R), !1)
                },
                _mountImageIntoNode: function(e, t, n, i, a) {
                    if (!t || t.nodeType !== D && t.nodeType !== A && t.nodeType !== I ? w(!1) : void 0, i) {
                        var s = o(t);
                        if (b.canReuseMarkup(e, s)) return void v.precacheNode(n, s);
                        var u = s.getAttribute(b.CHECKSUM_ATTR_NAME);
                        s.removeAttribute(b.CHECKSUM_ATTR_NAME);
                        var l = s.outerHTML;
                        s.setAttribute(b.CHECKSUM_ATTR_NAME, u);
                        var c = e,
                            p = r(c, l);
                        " (client) " + c.substring(p - 20, p + 20) + "\n (server) " + l.substring(p - 20, p + 20), t.nodeType === A ? w(!1) : void 0
                    }
                    if (t.nodeType === A ? w(!1) : void 0, a.useCreateElement) {
                        for (; t.lastChild;) t.removeChild(t.lastChild);
                        d.insertTreeBefore(t, e, null)
                    } else S(t, e), v.precacheNode(n, t.firstChild)
                }
            };
            _.measureMethods(F, "ReactMount", {
                _renderNewRootComponent: "_renderNewRootComponent",
                _mountImageIntoNode: "_mountImageIntoNode"
            }), t.exports = F
        }, {
            10: 10,
            139: 139,
            145: 145,
            148: 148,
            161: 161,
            168: 168,
            176: 176,
            26: 26,
            37: 37,
            42: 42,
            43: 43,
            47: 47,
            62: 62,
            68: 68,
            73: 73,
            76: 76,
            8: 8,
            84: 84,
            89: 89,
            98: 98,
            99: 99
        }],
        78: [function(e, t, n) {
            "use strict";

            function r(e, t, n) {
                return {
                    type: p.INSERT_MARKUP,
                    content: e,
                    fromIndex: null,
                    fromNode: null,
                    toIndex: n,
                    afterNode: t
                }
            }

            function o(e, t, n) {
                return {
                    type: p.MOVE_EXISTING,
                    content: null,
                    fromIndex: e._mountIndex,
                    fromNode: d.getNativeNode(e),
                    toIndex: n,
                    afterNode: t
                }
            }

            function i(e, t) {
                return {
                    type: p.REMOVE_NODE,
                    content: null,
                    fromIndex: e._mountIndex,
                    fromNode: t,
                    toIndex: null,
                    afterNode: null
                }
            }

            function a(e) {
                return {
                    type: p.SET_MARKUP,
                    content: e,
                    fromIndex: null,
                    fromNode: null,
                    toIndex: null,
                    afterNode: null
                }
            }

            function s(e) {
                return {
                    type: p.TEXT_CONTENT,
                    content: e,
                    fromIndex: null,
                    fromNode: null,
                    toIndex: null,
                    afterNode: null
                }
            }

            function u(e, t) {
                return t && (e = e || [], e.push(t)), e
            }

            function l(e, t) {
                c.processChildrenUpdates(e, t)
            }
            var c = e(34),
                p = e(79),
                d = (e(37), e(89)),
                f = e(29),
                h = e(128),
                v = e(168),
                m = {
                    Mixin: {
                        _reconcilerInstantiateChildren: function(e, t, n) {
                            return f.instantiateChildren(e, t, n)
                        },
                        _reconcilerUpdateChildren: function(e, t, n, r, o) {
                            var i;
                            return i = h(t), f.updateChildren(e, i, n, r, o), i
                        },
                        mountChildren: function(e, t, n) {
                            var r = this._reconcilerInstantiateChildren(e, t, n);
                            this._renderedChildren = r;
                            var o = [],
                                i = 0;
                            for (var a in r)
                                if (r.hasOwnProperty(a)) {
                                    var s = r[a],
                                        u = d.mountComponent(s, t, this, this._nativeContainerInfo, n);
                                    s._mountIndex = i++, o.push(u)
                                }
                            return o
                        },
                        updateTextContent: function(e) {
                            var t = this._renderedChildren;
                            f.unmountChildren(t, !1);
                            for (var n in t) t.hasOwnProperty(n) && v(!1);
                            var r = [s(e)];
                            l(this, r)
                        },
                        updateMarkup: function(e) {
                            var t = this._renderedChildren;
                            f.unmountChildren(t, !1);
                            for (var n in t) t.hasOwnProperty(n) && v(!1);
                            var r = [a(e)];
                            l(this, r)
                        },
                        updateChildren: function(e, t, n) {
                            this._updateChildren(e, t, n)
                        },
                        _updateChildren: function(e, t, n) {
                            var r = this._renderedChildren,
                                o = {},
                                i = this._reconcilerUpdateChildren(r, e, o, t, n);
                            if (i || r) {
                                var a, s = null,
                                    c = 0,
                                    p = 0,
                                    f = null;
                                for (a in i)
                                    if (i.hasOwnProperty(a)) {
                                        var h = r && r[a],
                                            v = i[a];
                                        h === v ? (s = u(s, this.moveChild(h, f, p, c)), c = Math.max(h._mountIndex, c), h._mountIndex = p) : (h && (c = Math.max(h._mountIndex, c)), s = u(s, this._mountChildAtIndex(v, f, p, t, n))), p++, f = d.getNativeNode(v);
                                    }
                                for (a in o) o.hasOwnProperty(a) && (s = u(s, this._unmountChild(r[a], o[a])));
                                s && l(this, s), this._renderedChildren = i
                            }
                        },
                        unmountChildren: function(e) {
                            var t = this._renderedChildren;
                            f.unmountChildren(t, e), this._renderedChildren = null
                        },
                        moveChild: function(e, t, n, r) {
                            return e._mountIndex < r ? o(e, t, n) : void 0
                        },
                        createChild: function(e, t, n) {
                            return r(n, t, e._mountIndex)
                        },
                        removeChild: function(e, t) {
                            return i(e, t)
                        },
                        _mountChildAtIndex: function(e, t, n, r, o) {
                            var i = d.mountComponent(e, r, this, this._nativeContainerInfo, o);
                            return e._mountIndex = n, this.createChild(e, t, i)
                        },
                        _unmountChild: function(e, t) {
                            var n = this.removeChild(e, t);
                            return e._mountIndex = null, n
                        }
                    }
                };
            t.exports = m
        }, {
            128: 128,
            168: 168,
            29: 29,
            34: 34,
            37: 37,
            79: 79,
            89: 89
        }],
        79: [function(e, t, n) {
            "use strict";
            var r = e(171),
                o = r({
                    INSERT_MARKUP: null,
                    MOVE_EXISTING: null,
                    REMOVE_NODE: null,
                    SET_MARKUP: null,
                    TEXT_CONTENT: null
                });
            t.exports = o
        }, {
            171: 171
        }],
        80: [function(e, t, n) {
            "use strict";

            function r(e) {
                if ("function" == typeof e.type) return e.type;
                var t = e.type,
                    n = p[t];
                return null == n && (p[t] = n = l(t)), n
            }

            function o(e) {
                return c ? void 0 : u(!1), new c(e)
            }

            function i(e) {
                return new d(e)
            }

            function a(e) {
                return e instanceof d
            }
            var s = e(177),
                u = e(168),
                l = null,
                c = null,
                p = {},
                d = null,
                f = {
                    injectGenericComponentClass: function(e) {
                        c = e
                    },
                    injectTextComponentClass: function(e) {
                        d = e
                    },
                    injectComponentClasses: function(e) {
                        s(p, e)
                    }
                },
                h = {
                    getComponentClassForElement: r,
                    createInternalComponent: o,
                    createInstanceForText: i,
                    isTextComponent: a,
                    injection: f
                };
            t.exports = h
        }, {
            168: 168,
            177: 177
        }],
        81: [function(e, t, n) {
            "use strict";
            var r = e(62),
                o = e(168),
                i = {
                    NATIVE: 0,
                    COMPOSITE: 1,
                    EMPTY: 2,
                    getType: function(e) {
                        return null === e || e === !1 ? i.EMPTY : r.isValidElement(e) ? "function" == typeof e.type ? i.COMPOSITE : i.NATIVE : void o(!1)
                    }
                };
            t.exports = i
        }, {
            168: 168,
            62: 62
        }],
        82: [function(e, t, n) {
            "use strict";

            function r(e, t) {}
            var o = (e(176), {
                isMounted: function(e) {
                    return !1
                },
                enqueueCallback: function(e, t) {},
                enqueueForceUpdate: function(e) {
                    r(e, "forceUpdate")
                },
                enqueueReplaceState: function(e, t) {
                    r(e, "replaceState")
                },
                enqueueSetState: function(e, t) {
                    r(e, "setState")
                }
            });
            t.exports = o
        }, {
            176: 176
        }],
        83: [function(e, t, n) {
            "use strict";
            var r = e(168),
                o = {
                    isValidOwner: function(e) {
                        return !(!e || "function" != typeof e.attachRef || "function" != typeof e.detachRef)
                    },
                    addComponentAsRefTo: function(e, t, n) {
                        o.isValidOwner(n) ? void 0 : r(!1), n.attachRef(t, e)
                    },
                    removeComponentAsRefFrom: function(e, t, n) {
                        o.isValidOwner(n) ? void 0 : r(!1);
                        var i = n.getPublicInstance();
                        i && i.refs[t] === e.getPublicInstance() && n.detachRef(t)
                    }
                };
            t.exports = o
        }, {
            168: 168
        }],
        84: [function(e, t, n) {
            "use strict";

            function r(e, t, n) {
                return n
            }
            var o = {
                enableMeasure: !1,
                storedMeasure: r,
                measureMethods: function(e, t, n) {},
                measure: function(e, t, n) {
                    return n
                },
                injection: {
                    injectMeasure: function(e) {
                        o.storedMeasure = e
                    }
                }
            };
            t.exports = o
        }, {}],
        85: [function(e, t, n) {
            "use strict";
            var r = {};
            t.exports = r
        }, {}],
        86: [function(e, t, n) {
            "use strict";
            var r = e(171),
                o = r({
                    prop: null,
                    context: null,
                    childContext: null
                });
            t.exports = o
        }, {
            171: 171
        }],
        87: [function(e, t, n) {
            "use strict";

            function r(e, t) {
                return e === t ? 0 !== e || 1 / e === 1 / t : e !== e && t !== t
            }

            function o(e) {
                function t(t, n, r, o, i, a) {
                    if (o = o || T, a = a || r, null == n[r]) {
                        var s = b[i];
                        return t ? new Error("Required " + s + " `" + a + "` was not specified in " + ("`" + o + "`.")) : null
                    }
                    return e(n, r, o, i, a)
                }
                var n = t.bind(null, !1);
                return n.isRequired = t.bind(null, !0), n
            }

            function i(e) {
                function t(t, n, r, o, i) {
                    var a = t[n],
                        s = m(a);
                    if (s !== e) {
                        var u = b[o],
                            l = g(a);
                        return new Error("Invalid " + u + " `" + i + "` of type " + ("`" + l + "` supplied to `" + r + "`, expected ") + ("`" + e + "`."))
                    }
                    return null
                }
                return o(t)
            }

            function a() {
                return o(_.thatReturns(null))
            }

            function s(e) {
                function t(t, n, r, o, i) {
                    if ("function" != typeof e) return new Error("Property `" + i + "` of component `" + r + "` has invalid PropType notation inside arrayOf.");
                    var a = t[n];
                    if (!Array.isArray(a)) {
                        var s = b[o],
                            u = m(a);
                        return new Error("Invalid " + s + " `" + i + "` of type " + ("`" + u + "` supplied to `" + r + "`, expected an array."))
                    }
                    for (var l = 0; l < a.length; l++) {
                        var c = e(a, l, r, o, i + "[" + l + "]");
                        if (c instanceof Error) return c
                    }
                    return null
                }
                return o(t)
            }

            function u() {
                function e(e, t, n, r, o) {
                    if (!C.isValidElement(e[t])) {
                        var i = b[r];
                        return new Error("Invalid " + i + " `" + o + "` supplied to " + ("`" + n + "`, expected a single ReactElement."))
                    }
                    return null
                }
                return o(e)
            }

            function l(e) {
                function t(t, n, r, o, i) {
                    if (!(t[n] instanceof e)) {
                        var a = b[o],
                            s = e.name || T,
                            u = y(t[n]);
                        return new Error("Invalid " + a + " `" + i + "` of type " + ("`" + u + "` supplied to `" + r + "`, expected ") + ("instance of `" + s + "`."))
                    }
                    return null
                }
                return o(t)
            }

            function c(e) {
                function t(t, n, o, i, a) {
                    for (var s = t[n], u = 0; u < e.length; u++)
                        if (r(s, e[u])) return null;
                    var l = b[i],
                        c = JSON.stringify(e);
                    return new Error("Invalid " + l + " `" + a + "` of value `" + s + "` " + ("supplied to `" + o + "`, expected one of " + c + "."))
                }
                return o(Array.isArray(e) ? t : function() {
                    return new Error("Invalid argument supplied to oneOf, expected an instance of array.")
                })
            }

            function p(e) {
                function t(t, n, r, o, i) {
                    if ("function" != typeof e) return new Error("Property `" + i + "` of component `" + r + "` has invalid PropType notation inside objectOf.");
                    var a = t[n],
                        s = m(a);
                    if ("object" !== s) {
                        var u = b[o];
                        return new Error("Invalid " + u + " `" + i + "` of type " + ("`" + s + "` supplied to `" + r + "`, expected an object."))
                    }
                    for (var l in a)
                        if (a.hasOwnProperty(l)) {
                            var c = e(a, l, r, o, i + "." + l);
                            if (c instanceof Error) return c
                        }
                    return null
                }
                return o(t)
            }

            function d(e) {
                function t(t, n, r, o, i) {
                    for (var a = 0; a < e.length; a++) {
                        var s = e[a];
                        if (null == s(t, n, r, o, i)) return null
                    }
                    var u = b[o];
                    return new Error("Invalid " + u + " `" + i + "` supplied to " + ("`" + r + "`."))
                }
                return o(Array.isArray(e) ? t : function() {
                    return new Error("Invalid argument supplied to oneOfType, expected an instance of array.")
                })
            }

            function f() {
                function e(e, t, n, r, o) {
                    if (!v(e[t])) {
                        var i = b[r];
                        return new Error("Invalid " + i + " `" + o + "` supplied to " + ("`" + n + "`, expected a ReactNode."))
                    }
                    return null
                }
                return o(e)
            }

            function h(e) {
                function t(t, n, r, o, i) {
                    var a = t[n],
                        s = m(a);
                    if ("object" !== s) {
                        var u = b[o];
                        return new Error("Invalid " + u + " `" + i + "` of type `" + s + "` " + ("supplied to `" + r + "`, expected `object`."))
                    }
                    for (var l in e) {
                        var c = e[l];
                        if (c) {
                            var p = c(a, l, r, o, i + "." + l);
                            if (p) return p
                        }
                    }
                    return null
                }
                return o(t)
            }

            function v(e) {
                switch (typeof e) {
                    case "number":
                    case "string":
                    case "undefined":
                        return !0;
                    case "boolean":
                        return !e;
                    case "object":
                        if (Array.isArray(e)) return e.every(v);
                        if (null === e || C.isValidElement(e)) return !0;
                        var t = E(e);
                        if (!t) return !1;
                        var n, r = t.call(e);
                        if (t !== e.entries) {
                            for (; !(n = r.next()).done;)
                                if (!v(n.value)) return !1
                        } else
                            for (; !(n = r.next()).done;) {
                                var o = n.value;
                                if (o && !v(o[1])) return !1
                            }
                        return !0;
                    default:
                        return !1
                }
            }

            function m(e) {
                var t = typeof e;
                return Array.isArray(e) ? "array" : e instanceof RegExp ? "object" : t
            }

            function g(e) {
                var t = m(e);
                if ("object" === t) {
                    if (e instanceof Date) return "date";
                    if (e instanceof RegExp) return "regexp"
                }
                return t
            }

            function y(e) {
                return e.constructor && e.constructor.name ? e.constructor.name : T
            }
            var C = e(62),
                b = e(85),
                _ = e(160),
                E = e(134),
                T = "<<anonymous>>",
                x = {
                    array: i("array"),
                    bool: i("boolean"),
                    func: i("function"),
                    number: i("number"),
                    object: i("object"),
                    string: i("string"),
                    any: a(),
                    arrayOf: s,
                    element: u(),
                    instanceOf: l,
                    node: f(),
                    objectOf: p,
                    oneOf: c,
                    oneOfType: d,
                    shape: h
                };
            t.exports = x
        }, {
            134: 134,
            160: 160,
            62: 62,
            85: 85
        }],
        88: [function(e, t, n) {
            "use strict";

            function r(e) {
                this.reinitializeTransaction(), this.renderToStaticMarkup = !1, this.reactMountReady = i.getPooled(null), this.useCreateElement = e
            }
            var o = e(177),
                i = e(5),
                a = e(24),
                s = e(26),
                u = e(71),
                l = e(119),
                c = {
                    initialize: u.getSelectionInformation,
                    close: u.restoreSelection
                },
                p = {
                    initialize: function() {
                        var e = s.isEnabled();
                        return s.setEnabled(!1), e
                    },
                    close: function(e) {
                        s.setEnabled(e)
                    }
                },
                d = {
                    initialize: function() {
                        this.reactMountReady.reset()
                    },
                    close: function() {
                        this.reactMountReady.notifyAll()
                    }
                },
                f = [c, p, d],
                h = {
                    getTransactionWrappers: function() {
                        return f
                    },
                    getReactMountReady: function() {
                        return this.reactMountReady
                    },
                    checkpoint: function() {
                        return this.reactMountReady.checkpoint()
                    },
                    rollback: function(e) {
                        this.reactMountReady.rollback(e)
                    },
                    destructor: function() {
                        i.release(this.reactMountReady), this.reactMountReady = null
                    }
                };
            o(r.prototype, l.Mixin, h), a.addPoolingTo(r), t.exports = r
        }, {
            119: 119,
            177: 177,
            24: 24,
            26: 26,
            5: 5,
            71: 71
        }],
        89: [function(e, t, n) {
            "use strict";

            function r() {
                o.attachRefs(this, this._currentElement)
            }
            var o = e(90),
                i = (e(73), {
                    mountComponent: function(e, t, n, o, i) {
                        var a = e.mountComponent(t, n, o, i);
                        return e._currentElement && null != e._currentElement.ref && t.getReactMountReady().enqueue(r, e), a
                    },
                    getNativeNode: function(e) {
                        return e.getNativeNode()
                    },
                    unmountComponent: function(e, t) {
                        o.detachRefs(e, e._currentElement), e.unmountComponent(t)
                    },
                    receiveComponent: function(e, t, n, i) {
                        var a = e._currentElement;
                        if (t !== a || i !== e._context) {
                            var s = o.shouldUpdateRefs(a, t);
                            s && o.detachRefs(e, a), e.receiveComponent(t, n, i), s && e._currentElement && null != e._currentElement.ref && n.getReactMountReady().enqueue(r, e)
                        }
                    },
                    performUpdateIfNecessary: function(e, t) {
                        e.performUpdateIfNecessary(t)
                    }
                });
            t.exports = i
        }, {
            73: 73,
            90: 90
        }],
        90: [function(e, t, n) {
            "use strict";

            function r(e, t, n) {
                "function" == typeof e ? e(t.getPublicInstance()) : i.addComponentAsRefTo(t, e, n)
            }

            function o(e, t, n) {
                "function" == typeof e ? e(null) : i.removeComponentAsRefFrom(t, e, n)
            }
            var i = e(83),
                a = {};
            a.attachRefs = function(e, t) {
                if (null !== t && t !== !1) {
                    var n = t.ref;
                    null != n && r(n, e, t._owner)
                }
            }, a.shouldUpdateRefs = function(e, t) {
                var n = null === e || e === !1,
                    r = null === t || t === !1;
                return n || r || t._owner !== e._owner || t.ref !== e.ref
            }, a.detachRefs = function(e, t) {
                if (null !== t && t !== !1) {
                    var n = t.ref;
                    null != n && o(n, e, t._owner)
                }
            }, t.exports = a
        }, {
            83: 83
        }],
        91: [function(e, t, n) {
            "use strict";
            var r = {
                isBatchingUpdates: !1,
                batchedUpdates: function(e) {}
            };
            t.exports = r
        }, {}],
        92: [function(e, t, n) {
            "use strict";

            function r(e, t) {
                var n;
                try {
                    return d.injection.injectBatchingStrategy(c), n = p.getPooled(t), n.perform(function() {
                        var r = h(e),
                            o = r.mountComponent(n, null, a(), f);
                        return t || (o = l.addChecksumToMarkup(o)), o
                    }, null)
                } finally {
                    p.release(n), d.injection.injectBatchingStrategy(s)
                }
            }

            function o(e) {
                return u.isValidElement(e) ? void 0 : v(!1), r(e, !1)
            }

            function i(e) {
                return u.isValidElement(e) ? void 0 : v(!1), r(e, !0)
            }
            var a = e(43),
                s = e(60),
                u = e(62),
                l = e(76),
                c = e(91),
                p = e(93),
                d = e(99),
                f = e(161),
                h = e(139),
                v = e(168);
            t.exports = {
                renderToString: o,
                renderToStaticMarkup: i
            }
        }, {
            139: 139,
            161: 161,
            168: 168,
            43: 43,
            60: 60,
            62: 62,
            76: 76,
            91: 91,
            93: 93,
            99: 99
        }],
        93: [function(e, t, n) {
            "use strict";

            function r(e) {
                this.reinitializeTransaction(), this.renderToStaticMarkup = e, this.useCreateElement = !1
            }
            var o = e(177),
                i = e(24),
                a = e(119),
                s = [],
                u = {
                    enqueue: function() {}
                },
                l = {
                    getTransactionWrappers: function() {
                        return s
                    },
                    getReactMountReady: function() {
                        return u
                    },
                    destructor: function() {}
                };
            o(r.prototype, a.Mixin, l), i.addPoolingTo(r), t.exports = r
        }, {
            119: 119,
            177: 177,
            24: 24
        }],
        94: [function(e, t, n) {
            "use strict";

            function r(e, t) {
                var n = {};
                return function(r) {
                    n[t] = r, e.setState(n)
                }
            }
            var o = {
                createStateSetter: function(e, t) {
                    return function(n, r, o, i, a, s) {
                        var u = t.call(e, n, r, o, i, a, s);
                        u && e.setState(u)
                    }
                },
                createStateKeySetter: function(e, t) {
                    var n = e.__keySetters || (e.__keySetters = {});
                    return n[t] || (n[t] = r(e, t))
                }
            };
            o.Mixin = {
                createStateSetter: function(e) {
                    return o.createStateSetter(this, e)
                },
                createStateKeySetter: function(e) {
                    return o.createStateKeySetter(this, e)
                }
            }, t.exports = o
        }, {}],
        95: [function(e, t, n) {
            "use strict";
            var r = e(128),
                o = {
                    getChildMapping: function(e) {
                        return e ? r(e) : e
                    },
                    mergeChildMappings: function(e, t) {
                        function n(n) {
                            return t.hasOwnProperty(n) ? t[n] : e[n]
                        }
                        e = e || {}, t = t || {};
                        var r = {},
                            o = [];
                        for (var i in e) t.hasOwnProperty(i) ? o.length && (r[i] = o, o = []) : o.push(i);
                        var a, s = {};
                        for (var u in t) {
                            if (r.hasOwnProperty(u))
                                for (a = 0; a < r[u].length; a++) {
                                    var l = r[u][a];
                                    s[r[u][a]] = n(l)
                                }
                            s[u] = n(u)
                        }
                        for (a = 0; a < o.length; a++) s[o[a]] = n(o[a]);
                        return s
                    }
                };
            t.exports = o
        }, {
            128: 128
        }],
        96: [function(e, t, n) {
            "use strict";

            function r() {
                var e = s("animationend"),
                    t = s("transitionend");
                e && u.push(e), t && u.push(t)
            }

            function o(e, t, n) {
                e.addEventListener(t, n, !1)
            }

            function i(e, t, n) {
                e.removeEventListener(t, n, !1)
            }
            var a = e(154),
                s = e(138),
                u = [];
            a.canUseDOM && r();
            var l = {
                addEndEventListener: function(e, t) {
                    return 0 === u.length ? void window.setTimeout(t, 0) : void u.forEach(function(n) {
                        o(e, n, t)
                    })
                },
                removeEndEventListener: function(e, t) {
                    0 !== u.length && u.forEach(function(n) {
                        i(e, n, t)
                    })
                }
            };
            t.exports = l
        }, {
            138: 138,
            154: 154
        }],
        97: [function(e, t, n) {
            "use strict";
            var r = e(177),
                o = e(25),
                i = e(95),
                a = e(160),
                s = o.createClass({
                    displayName: "ReactTransitionGroup",
                    propTypes: {
                        component: o.PropTypes.any,
                        childFactory: o.PropTypes.func
                    },
                    getDefaultProps: function() {
                        return {
                            component: "span",
                            childFactory: a.thatReturnsArgument
                        }
                    },
                    getInitialState: function() {
                        return {
                            children: i.getChildMapping(this.props.children)
                        }
                    },
                    componentWillMount: function() {
                        this.currentlyTransitioningKeys = {}, this.keysToEnter = [], this.keysToLeave = []
                    },
                    componentDidMount: function() {
                        var e = this.state.children;
                        for (var t in e) e[t] && this.performAppear(t)
                    },
                    componentWillReceiveProps: function(e) {
                        var t = i.getChildMapping(e.children),
                            n = this.state.children;
                        this.setState({
                            children: i.mergeChildMappings(n, t)
                        });
                        var r;
                        for (r in t) {
                            var o = n && n.hasOwnProperty(r);
                            !t[r] || o || this.currentlyTransitioningKeys[r] || this.keysToEnter.push(r)
                        }
                        for (r in n) {
                            var a = t && t.hasOwnProperty(r);
                            !n[r] || a || this.currentlyTransitioningKeys[r] || this.keysToLeave.push(r)
                        }
                    },
                    componentDidUpdate: function() {
                        var e = this.keysToEnter;
                        this.keysToEnter = [], e.forEach(this.performEnter);
                        var t = this.keysToLeave;
                        this.keysToLeave = [], t.forEach(this.performLeave)
                    },
                    performAppear: function(e) {
                        this.currentlyTransitioningKeys[e] = !0;
                        var t = this.refs[e];
                        t.componentWillAppear ? t.componentWillAppear(this._handleDoneAppearing.bind(this, e)) : this._handleDoneAppearing(e)
                    },
                    _handleDoneAppearing: function(e) {
                        var t = this.refs[e];
                        t.componentDidAppear && t.componentDidAppear(), delete this.currentlyTransitioningKeys[e];
                        var n = i.getChildMapping(this.props.children);
                        n && n.hasOwnProperty(e) || this.performLeave(e)
                    },
                    performEnter: function(e) {
                        this.currentlyTransitioningKeys[e] = !0;
                        var t = this.refs[e];
                        t.componentWillEnter ? t.componentWillEnter(this._handleDoneEntering.bind(this, e)) : this._handleDoneEntering(e)
                    },
                    _handleDoneEntering: function(e) {
                        var t = this.refs[e];
                        t.componentDidEnter && t.componentDidEnter(), delete this.currentlyTransitioningKeys[e];
                        var n = i.getChildMapping(this.props.children);
                        n && n.hasOwnProperty(e) || this.performLeave(e)
                    },
                    performLeave: function(e) {
                        this.currentlyTransitioningKeys[e] = !0;
                        var t = this.refs[e];
                        t.componentWillLeave ? t.componentWillLeave(this._handleDoneLeaving.bind(this, e)) : this._handleDoneLeaving(e)
                    },
                    _handleDoneLeaving: function(e) {
                        var t = this.refs[e];
                        t.componentDidLeave && t.componentDidLeave(), delete this.currentlyTransitioningKeys[e];
                        var n = i.getChildMapping(this.props.children);
                        n && n.hasOwnProperty(e) ? this.performEnter(e) : this.setState(function(t) {
                            var n = r({}, t.children);
                            return delete n[e], {
                                children: n
                            }
                        })
                    },
                    render: function() {
                        var e = [];
                        for (var t in this.state.children) {
                            var n = this.state.children[t];
                            n && e.push(o.cloneElement(this.props.childFactory(n), {
                                ref: t,
                                key: t
                            }))
                        }
                        return o.createElement(this.props.component, this.props, e)
                    }
                });
            t.exports = s
        }, {
            160: 160,
            177: 177,
            25: 25,
            95: 95
        }],
        98: [function(e, t, n) {
            "use strict";

            function r(e) {
                a.enqueueUpdate(e)
            }

            function o(e, t) {
                var n = i.get(e);
                return n ? n : null
            }
            var i = (e(37), e(72)),
                a = e(99),
                s = e(168),
                u = (e(176), {
                    isMounted: function(e) {
                        var t = i.get(e);
                        return t ? !!t._renderedComponent : !1
                    },
                    enqueueCallback: function(e, t, n) {
                        u.validateCallback(t, n);
                        var i = o(e);
                        return i ? (i._pendingCallbacks ? i._pendingCallbacks.push(t) : i._pendingCallbacks = [t], void r(i)) : null
                    },
                    enqueueCallbackInternal: function(e, t) {
                        e._pendingCallbacks ? e._pendingCallbacks.push(t) : e._pendingCallbacks = [t], r(e)
                    },
                    enqueueForceUpdate: function(e) {
                        var t = o(e, "forceUpdate");
                        t && (t._pendingForceUpdate = !0, r(t))
                    },
                    enqueueReplaceState: function(e, t) {
                        var n = o(e, "replaceState");
                        n && (n._pendingStateQueue = [t], n._pendingReplaceState = !0, r(n))
                    },
                    enqueueSetState: function(e, t) {
                        var n = o(e, "setState");
                        if (n) {
                            var i = n._pendingStateQueue || (n._pendingStateQueue = []);
                            i.push(t), r(n)
                        }
                    },
                    enqueueElementInternal: function(e, t) {
                        e._pendingElement = t, r(e)
                    },
                    validateCallback: function(e, t) {
                        e && "function" != typeof e ? s(!1) : void 0
                    }
                });
            t.exports = u
        }, {
            168: 168,
            176: 176,
            37: 37,
            72: 72,
            99: 99
        }],
        99: [function(e, t, n) {
            "use strict";

            function r() {
                w.ReactReconcileTransaction && _ ? void 0 : g(!1)
            }

            function o() {
                this.reinitializeTransaction(), this.dirtyComponentsLength = null, this.callbackQueue = p.getPooled(), this.reconcileTransaction = w.ReactReconcileTransaction.getPooled(!0)
            }

            function i(e, t, n, o, i, a) {
                r(), _.batchedUpdates(e, t, n, o, i, a)
            }

            function a(e, t) {
                return e._mountOrder - t._mountOrder
            }

            function s(e) {
                var t = e.dirtyComponentsLength;
                t !== y.length ? g(!1) : void 0, y.sort(a);
                for (var n = 0; t > n; n++) {
                    var r = y[n],
                        o = r._pendingCallbacks;
                    r._pendingCallbacks = null;
                    var i;
                    if (f.logTopLevelRenders) {
                        var s = r;
                        r._currentElement.props === r._renderedComponent._currentElement && (s = r._renderedComponent), i = "React update: " + s.getName(), console.time(i)
                    }
                    if (v.performUpdateIfNecessary(r, e.reconcileTransaction), i && console.timeEnd(i), o)
                        for (var u = 0; u < o.length; u++) e.callbackQueue.enqueue(o[u], r.getPublicInstance())
                }
            }

            function u(e) {
                return r(), _.isBatchingUpdates ? void y.push(e) : void _.batchedUpdates(u, e)
            }

            function l(e, t) {
                _.isBatchingUpdates ? void 0 : g(!1), C.enqueue(e, t), b = !0
            }
            var c = e(177),
                p = e(5),
                d = e(24),
                f = e(68),
                h = e(84),
                v = e(89),
                m = e(119),
                g = e(168),
                y = [],
                C = p.getPooled(),
                b = !1,
                _ = null,
                E = {
                    initialize: function() {
                        this.dirtyComponentsLength = y.length
                    },
                    close: function() {
                        this.dirtyComponentsLength !== y.length ? (y.splice(0, this.dirtyComponentsLength), P()) : y.length = 0
                    }
                },
                T = {
                    initialize: function() {
                        this.callbackQueue.reset()
                    },
                    close: function() {
                        this.callbackQueue.notifyAll()
                    }
                },
                x = [E, T];
            c(o.prototype, m.Mixin, {
                getTransactionWrappers: function() {
                    return x
                },
                destructor: function() {
                    this.dirtyComponentsLength = null, p.release(this.callbackQueue), this.callbackQueue = null, w.ReactReconcileTransaction.release(this.reconcileTransaction), this.reconcileTransaction = null
                },
                perform: function(e, t, n) {
                    return m.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, e, t, n)
                }
            }), d.addPoolingTo(o);
            var P = function() {
                for (; y.length || b;) {
                    if (y.length) {
                        var e = o.getPooled();
                        e.perform(s, null, e), o.release(e)
                    }
                    if (b) {
                        b = !1;
                        var t = C;
                        C = p.getPooled(), t.notifyAll(), p.release(t)
                    }
                }
            };
            P = h.measure("ReactUpdates", "flushBatchedUpdates", P);
            var N = {
                    injectReconcileTransaction: function(e) {
                        e ? void 0 : g(!1), w.ReactReconcileTransaction = e
                    },
                    injectBatchingStrategy: function(e) {
                        e ? void 0 : g(!1), "function" != typeof e.batchedUpdates ? g(!1) : void 0, "boolean" != typeof e.isBatchingUpdates ? g(!1) : void 0, _ = e
                    }
                },
                w = {
                    ReactReconcileTransaction: null,
                    batchedUpdates: i,
                    enqueueUpdate: u,
                    flushBatchedUpdates: P,
                    injection: N,
                    asap: l
                };
            t.exports = w
        }, {
            119: 119,
            168: 168,
            177: 177,
            24: 24,
            5: 5,
            68: 68,
            84: 84,
            89: 89
        }],
        100: [function(e, t, n) {
            "use strict";
            t.exports = "15.0.1"
        }, {}],
        101: [function(e, t, n) {
            "use strict";
            var r = e(22),
                o = e(25),
                i = e(35),
                a = e(27),
                s = e(69),
                u = e(97),
                l = e(147),
                c = e(150);
            o.addons = {
                CSSTransitionGroup: a,
                LinkedStateMixin: r,
                PureRenderMixin: i,
                TransitionGroup: u,
                createFragment: s.create,
                shallowCompare: l,
                update: c
            }, t.exports = o
        }, {
            147: 147,
            150: 150,
            22: 22,
            25: 25,
            27: 27,
            35: 35,
            69: 69,
            97: 97
        }],
        102: [function(e, t, n) {
            "use strict";
            var r = e(177),
                o = e(38),
                i = e(54),
                a = e(101),
                s = r({
                    __SECRET_DOM_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: o,
                    __SECRET_DOM_SERVER_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: i
                }, a);
            t.exports = s
        }, {
            101: 101,
            177: 177,
            38: 38,
            54: 54
        }],
        103: [function(e, t, n) {
            "use strict";
            var r = {
                    xlink: "http://www.w3.org/1999/xlink",
                    xml: "http://www.w3.org/XML/1998/namespace"
                },
                o = {
                    accentHeight: "accent-height",
                    accumulate: 0,
                    additive: 0,
                    alignmentBaseline: "alignment-baseline",
                    allowReorder: "allowReorder",
                    alphabetic: 0,
                    amplitude: 0,
                    arabicForm: "arabic-form",
                    ascent: 0,
                    attributeName: "attributeName",
                    attributeType: "attributeType",
                    autoReverse: "autoReverse",
                    azimuth: 0,
                    baseFrequency: "baseFrequency",
                    baseProfile: "baseProfile",
                    baselineShift: "baseline-shift",
                    bbox: 0,
                    begin: 0,
                    bias: 0,
                    by: 0,
                    calcMode: "calcMode",
                    capHeight: "cap-height",
                    clip: 0,
                    clipPath: "clip-path",
                    clipRule: "clip-rule",
                    clipPathUnits: "clipPathUnits",
                    colorInterpolation: "color-interpolation",
                    colorInterpolationFilters: "color-interpolation-filters",
                    colorProfile: "color-profile",
                    colorRendering: "color-rendering",
                    contentScriptType: "contentScriptType",
                    contentStyleType: "contentStyleType",
                    cursor: 0,
                    cx: 0,
                    cy: 0,
                    d: 0,
                    decelerate: 0,
                    descent: 0,
                    diffuseConstant: "diffuseConstant",
                    direction: 0,
                    display: 0,
                    divisor: 0,
                    dominantBaseline: "dominant-baseline",
                    dur: 0,
                    dx: 0,
                    dy: 0,
                    edgeMode: "edgeMode",
                    elevation: 0,
                    enableBackground: "enable-background",
                    end: 0,
                    exponent: 0,
                    externalResourcesRequired: "externalResourcesRequired",
                    fill: 0,
                    fillOpacity: "fill-opacity",
                    fillRule: "fill-rule",
                    filter: 0,
                    filterRes: "filterRes",
                    filterUnits: "filterUnits",
                    floodColor: "flood-color",
                    floodOpacity: "flood-opacity",
                    focusable: 0,
                    fontFamily: "font-family",
                    fontSize: "font-size",
                    fontSizeAdjust: "font-size-adjust",
                    fontStretch: "font-stretch",
                    fontStyle: "font-style",
                    fontVariant: "font-variant",
                    fontWeight: "font-weight",
                    format: 0,
                    from: 0,
                    fx: 0,
                    fy: 0,
                    g1: 0,
                    g2: 0,
                    glyphName: "glyph-name",
                    glyphOrientationHorizontal: "glyph-orientation-horizontal",
                    glyphOrientationVertical: "glyph-orientation-vertical",
                    glyphRef: "glyphRef",
                    gradientTransform: "gradientTransform",
                    gradientUnits: "gradientUnits",
                    hanging: 0,
                    horizAdvX: "horiz-adv-x",
                    horizOriginX: "horiz-origin-x",
                    ideographic: 0,
                    imageRendering: "image-rendering",
                    "in": 0,
                    in2: 0,
                    intercept: 0,
                    k: 0,
                    k1: 0,
                    k2: 0,
                    k3: 0,
                    k4: 0,
                    kernelMatrix: "kernelMatrix",
                    kernelUnitLength: "kernelUnitLength",
                    kerning: 0,
                    keyPoints: "keyPoints",
                    keySplines: "keySplines",
                    keyTimes: "keyTimes",
                    lengthAdjust: "lengthAdjust",
                    letterSpacing: "letter-spacing",
                    lightingColor: "lighting-color",
                    limitingConeAngle: "limitingConeAngle",
                    local: 0,
                    markerEnd: "marker-end",
                    markerMid: "marker-mid",
                    markerStart: "marker-start",
                    markerHeight: "markerHeight",
                    markerUnits: "markerUnits",
                    markerWidth: "markerWidth",
                    mask: 0,
                    maskContentUnits: "maskContentUnits",
                    maskUnits: "maskUnits",
                    mathematical: 0,
                    mode: 0,
                    numOctaves: "numOctaves",
                    offset: 0,
                    opacity: 0,
                    operator: 0,
                    order: 0,
                    orient: 0,
                    orientation: 0,
                    origin: 0,
                    overflow: 0,
                    overlinePosition: "overline-position",
                    overlineThickness: "overline-thickness",
                    paintOrder: "paint-order",
                    panose1: "panose-1",
                    pathLength: "pathLength",
                    patternContentUnits: "patternContentUnits",
                    patternTransform: "patternTransform",
                    patternUnits: "patternUnits",
                    pointerEvents: "pointer-events",
                    points: 0,
                    pointsAtX: "pointsAtX",
                    pointsAtY: "pointsAtY",
                    pointsAtZ: "pointsAtZ",
                    preserveAlpha: "preserveAlpha",
                    preserveAspectRatio: "preserveAspectRatio",
                    primitiveUnits: "primitiveUnits",
                    r: 0,
                    radius: 0,
                    refX: "refX",
                    refY: "refY",
                    renderingIntent: "rendering-intent",
                    repeatCount: "repeatCount",
                    repeatDur: "repeatDur",
                    requiredExtensions: "requiredExtensions",
                    requiredFeatures: "requiredFeatures",
                    restart: 0,
                    result: 0,
                    rotate: 0,
                    rx: 0,
                    ry: 0,
                    scale: 0,
                    seed: 0,
                    shapeRendering: "shape-rendering",
                    slope: 0,
                    spacing: 0,
                    specularConstant: "specularConstant",
                    specularExponent: "specularExponent",
                    speed: 0,
                    spreadMethod: "spreadMethod",
                    startOffset: "startOffset",
                    stdDeviation: "stdDeviation",
                    stemh: 0,
                    stemv: 0,
                    stitchTiles: "stitchTiles",
                    stopColor: "stop-color",
                    stopOpacity: "stop-opacity",
                    strikethroughPosition: "strikethrough-position",
                    strikethroughThickness: "strikethrough-thickness",
                    string: 0,
                    stroke: 0,
                    strokeDasharray: "stroke-dasharray",
                    strokeDashoffset: "stroke-dashoffset",
                    strokeLinecap: "stroke-linecap",
                    strokeLinejoin: "stroke-linejoin",
                    strokeMiterlimit: "stroke-miterlimit",
                    strokeOpacity: "stroke-opacity",
                    strokeWidth: "stroke-width",
                    surfaceScale: "surfaceScale",
                    systemLanguage: "systemLanguage",
                    tableValues: "tableValues",
                    targetX: "targetX",
                    targetY: "targetY",
                    textAnchor: "text-anchor",
                    textDecoration: "text-decoration",
                    textRendering: "text-rendering",
                    textLength: "textLength",
                    to: 0,
                    transform: 0,
                    u1: 0,
                    u2: 0,
                    underlinePosition: "underline-position",
                    underlineThickness: "underline-thickness",
                    unicode: 0,
                    unicodeBidi: "unicode-bidi",
                    unicodeRange: "unicode-range",
                    unitsPerEm: "units-per-em",
                    vAlphabetic: "v-alphabetic",
                    vHanging: "v-hanging",
                    vIdeographic: "v-ideographic",
                    vMathematical: "v-mathematical",
                    values: 0,
                    vectorEffect: "vector-effect",
                    version: 0,
                    vertAdvY: "vert-adv-y",
                    vertOriginX: "vert-origin-x",
                    vertOriginY: "vert-origin-y",
                    viewBox: "viewBox",
                    viewTarget: "viewTarget",
                    visibility: 0,
                    widths: 0,
                    wordSpacing: "word-spacing",
                    writingMode: "writing-mode",
                    x: 0,
                    xHeight: "x-height",
                    x1: 0,
                    x2: 0,
                    xChannelSelector: "xChannelSelector",
                    xlinkActuate: "xlink:actuate",
                    xlinkArcrole: "xlink:arcrole",
                    xlinkHref: "xlink:href",
                    xlinkRole: "xlink:role",
                    xlinkShow: "xlink:show",
                    xlinkTitle: "xlink:title",
                    xlinkType: "xlink:type",
                    xmlBase: "xml:base",
                    xmlLang: "xml:lang",
                    xmlSpace: "xml:space",
                    y: 0,
                    y1: 0,
                    y2: 0,
                    yChannelSelector: "yChannelSelector",
                    z: 0,
                    zoomAndPan: "zoomAndPan"
                },
                i = {
                    Properties: {},
                    DOMAttributeNamespaces: {
                        xlinkActuate: r.xlink,
                        xlinkArcrole: r.xlink,
                        xlinkHref: r.xlink,
                        xlinkRole: r.xlink,
                        xlinkShow: r.xlink,
                        xlinkTitle: r.xlink,
                        xlinkType: r.xlink,
                        xmlBase: r.xml,
                        xmlLang: r.xml,
                        xmlSpace: r.xml
                    },
                    DOMAttributeNames: {}
                };
            Object.keys(o).map(function(e) {
                i.Properties[e] = 0, o[e] && (i.DOMAttributeNames[e] = o[e])
            }), t.exports = i
        }, {}],
        104: [function(e, t, n) {
            "use strict";

            function r(e) {
                if ("selectionStart" in e && l.hasSelectionCapabilities(e)) return {
                    start: e.selectionStart,
                    end: e.selectionEnd
                };
                if (window.getSelection) {
                    var t = window.getSelection();
                    return {
                        anchorNode: t.anchorNode,
                        anchorOffset: t.anchorOffset,
                        focusNode: t.focusNode,
                        focusOffset: t.focusOffset
                    }
                }
                if (document.selection) {
                    var n = document.selection.createRange();
                    return {
                        parentElement: n.parentElement(),
                        text: n.text,
                        top: n.boundingTop,
                        left: n.boundingLeft
                    }
                }
            }

            function o(e, t) {
                if (_ || null == y || y !== p()) return null;
                var n = r(y);
                if (!b || !h(b, n)) {
                    b = n;
                    var o = c.getPooled(g.select, C, e, t);
                    return o.type = "select", o.target = y, a.accumulateTwoPhaseDispatches(o), o
                }
                return null
            }
            var i = e(15),
                a = e(19),
                s = e(154),
                u = e(42),
                l = e(71),
                c = e(110),
                p = e(163),
                d = e(141),
                f = e(172),
                h = e(175),
                v = i.topLevelTypes,
                m = s.canUseDOM && "documentMode" in document && document.documentMode <= 11,
                g = {
                    select: {
                        phasedRegistrationNames: {
                            bubbled: f({
                                onSelect: null
                            }),
                            captured: f({
                                onSelectCapture: null
                            })
                        },
                        dependencies: [v.topBlur, v.topContextMenu, v.topFocus, v.topKeyDown, v.topMouseDown, v.topMouseUp, v.topSelectionChange]
                    }
                },
                y = null,
                C = null,
                b = null,
                _ = !1,
                E = !1,
                T = f({
                    onSelect: null
                }),
                x = {
                    eventTypes: g,
                    extractEvents: function(e, t, n, r) {
                        if (!E) return null;
                        var i = t ? u.getNodeFromInstance(t) : window;
                        switch (e) {
                            case v.topFocus:
                                (d(i) || "true" === i.contentEditable) && (y = i, C = t, b = null);
                                break;
                            case v.topBlur:
                                y = null, C = null, b = null;
                                break;
                            case v.topMouseDown:
                                _ = !0;
                                break;
                            case v.topContextMenu:
                            case v.topMouseUp:
                                return _ = !1, o(n, r);
                            case v.topSelectionChange:
                                if (m) break;
                            case v.topKeyDown:
                            case v.topKeyUp:
                                return o(n, r)
                        }
                        return null
                    },
                    didPutListener: function(e, t, n) {
                        t === T && (E = !0)
                    }
                };
            t.exports = x
        }, {
            110: 110,
            141: 141,
            15: 15,
            154: 154,
            163: 163,
            172: 172,
            175: 175,
            19: 19,
            42: 42,
            71: 71
        }],
        105: [function(e, t, n) {
            "use strict";
            var r = e(15),
                o = e(153),
                i = e(19),
                a = e(42),
                s = e(106),
                u = e(107),
                l = e(110),
                c = e(111),
                p = e(113),
                d = e(114),
                f = e(109),
                h = e(115),
                v = e(116),
                m = e(117),
                g = e(118),
                y = e(160),
                C = e(130),
                b = e(168),
                _ = e(172),
                E = r.topLevelTypes,
                T = {
                    abort: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onAbort: !0
                            }),
                            captured: _({
                                onAbortCapture: !0
                            })
                        }
                    },
                    animationEnd: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onAnimationEnd: !0
                            }),
                            captured: _({
                                onAnimationEndCapture: !0
                            })
                        }
                    },
                    animationIteration: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onAnimationIteration: !0
                            }),
                            captured: _({
                                onAnimationIterationCapture: !0
                            })
                        }
                    },
                    animationStart: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onAnimationStart: !0
                            }),
                            captured: _({
                                onAnimationStartCapture: !0
                            })
                        }
                    },
                    blur: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onBlur: !0
                            }),
                            captured: _({
                                onBlurCapture: !0
                            })
                        }
                    },
                    canPlay: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onCanPlay: !0
                            }),
                            captured: _({
                                onCanPlayCapture: !0
                            })
                        }
                    },
                    canPlayThrough: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onCanPlayThrough: !0
                            }),
                            captured: _({
                                onCanPlayThroughCapture: !0
                            })
                        }
                    },
                    click: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onClick: !0
                            }),
                            captured: _({
                                onClickCapture: !0
                            })
                        }
                    },
                    contextMenu: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onContextMenu: !0
                            }),
                            captured: _({
                                onContextMenuCapture: !0
                            })
                        }
                    },
                    copy: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onCopy: !0
                            }),
                            captured: _({
                                onCopyCapture: !0
                            })
                        }
                    },
                    cut: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onCut: !0
                            }),
                            captured: _({
                                onCutCapture: !0
                            })
                        }
                    },
                    doubleClick: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onDoubleClick: !0
                            }),
                            captured: _({
                                onDoubleClickCapture: !0
                            })
                        }
                    },
                    drag: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onDrag: !0
                            }),
                            captured: _({
                                onDragCapture: !0
                            })
                        }
                    },
                    dragEnd: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onDragEnd: !0
                            }),
                            captured: _({
                                onDragEndCapture: !0
                            })
                        }
                    },
                    dragEnter: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onDragEnter: !0
                            }),
                            captured: _({
                                onDragEnterCapture: !0
                            })
                        }
                    },
                    dragExit: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onDragExit: !0
                            }),
                            captured: _({
                                onDragExitCapture: !0
                            })
                        }
                    },
                    dragLeave: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onDragLeave: !0
                            }),
                            captured: _({
                                onDragLeaveCapture: !0
                            })
                        }
                    },
                    dragOver: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onDragOver: !0
                            }),
                            captured: _({
                                onDragOverCapture: !0
                            })
                        }
                    },
                    dragStart: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onDragStart: !0
                            }),
                            captured: _({
                                onDragStartCapture: !0
                            })
                        }
                    },
                    drop: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onDrop: !0
                            }),
                            captured: _({
                                onDropCapture: !0
                            })
                        }
                    },
                    durationChange: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onDurationChange: !0
                            }),
                            captured: _({
                                onDurationChangeCapture: !0
                            })
                        }
                    },
                    emptied: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onEmptied: !0
                            }),
                            captured: _({
                                onEmptiedCapture: !0
                            })
                        }
                    },
                    encrypted: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onEncrypted: !0
                            }),
                            captured: _({
                                onEncryptedCapture: !0
                            })
                        }
                    },
                    ended: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onEnded: !0
                            }),
                            captured: _({
                                onEndedCapture: !0
                            })
                        }
                    },
                    error: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onError: !0
                            }),
                            captured: _({
                                onErrorCapture: !0
                            })
                        }
                    },
                    focus: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onFocus: !0
                            }),
                            captured: _({
                                onFocusCapture: !0
                            })
                        }
                    },
                    input: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onInput: !0
                            }),
                            captured: _({
                                onInputCapture: !0
                            })
                        }
                    },
                    invalid: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onInvalid: !0
                            }),
                            captured: _({
                                onInvalidCapture: !0
                            })
                        }
                    },
                    keyDown: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onKeyDown: !0
                            }),
                            captured: _({
                                onKeyDownCapture: !0
                            })
                        }
                    },
                    keyPress: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onKeyPress: !0
                            }),
                            captured: _({
                                onKeyPressCapture: !0
                            })
                        }
                    },
                    keyUp: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onKeyUp: !0
                            }),
                            captured: _({
                                onKeyUpCapture: !0
                            })
                        }
                    },
                    load: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onLoad: !0
                            }),
                            captured: _({
                                onLoadCapture: !0
                            })
                        }
                    },
                    loadedData: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onLoadedData: !0
                            }),
                            captured: _({
                                onLoadedDataCapture: !0
                            })
                        }
                    },
                    loadedMetadata: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onLoadedMetadata: !0
                            }),
                            captured: _({
                                onLoadedMetadataCapture: !0
                            })
                        }
                    },
                    loadStart: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onLoadStart: !0
                            }),
                            captured: _({
                                onLoadStartCapture: !0
                            })
                        }
                    },
                    mouseDown: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onMouseDown: !0
                            }),
                            captured: _({
                                onMouseDownCapture: !0
                            })
                        }
                    },
                    mouseMove: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onMouseMove: !0
                            }),
                            captured: _({
                                onMouseMoveCapture: !0
                            })
                        }
                    },
                    mouseOut: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onMouseOut: !0
                            }),
                            captured: _({
                                onMouseOutCapture: !0
                            })
                        }
                    },
                    mouseOver: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onMouseOver: !0
                            }),
                            captured: _({
                                onMouseOverCapture: !0
                            })
                        }
                    },
                    mouseUp: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onMouseUp: !0
                            }),
                            captured: _({
                                onMouseUpCapture: !0
                            })
                        }
                    },
                    paste: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onPaste: !0
                            }),
                            captured: _({
                                onPasteCapture: !0
                            })
                        }
                    },
                    pause: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onPause: !0
                            }),
                            captured: _({
                                onPauseCapture: !0
                            })
                        }
                    },
                    play: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onPlay: !0
                            }),
                            captured: _({
                                onPlayCapture: !0
                            })
                        }
                    },
                    playing: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onPlaying: !0
                            }),
                            captured: _({
                                onPlayingCapture: !0
                            })
                        }
                    },
                    progress: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onProgress: !0
                            }),
                            captured: _({
                                onProgressCapture: !0
                            })
                        }
                    },
                    rateChange: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onRateChange: !0
                            }),
                            captured: _({
                                onRateChangeCapture: !0
                            })
                        }
                    },
                    reset: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onReset: !0
                            }),
                            captured: _({
                                onResetCapture: !0
                            })
                        }
                    },
                    scroll: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onScroll: !0
                            }),
                            captured: _({
                                onScrollCapture: !0
                            })
                        }
                    },
                    seeked: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onSeeked: !0
                            }),
                            captured: _({
                                onSeekedCapture: !0
                            })
                        }
                    },
                    seeking: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onSeeking: !0
                            }),
                            captured: _({
                                onSeekingCapture: !0
                            })
                        }
                    },
                    stalled: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onStalled: !0
                            }),
                            captured: _({
                                onStalledCapture: !0
                            })
                        }
                    },
                    submit: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onSubmit: !0
                            }),
                            captured: _({
                                onSubmitCapture: !0
                            })
                        }
                    },
                    suspend: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onSuspend: !0
                            }),
                            captured: _({
                                onSuspendCapture: !0
                            })
                        }
                    },
                    timeUpdate: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onTimeUpdate: !0
                            }),
                            captured: _({
                                onTimeUpdateCapture: !0
                            })
                        }
                    },
                    touchCancel: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onTouchCancel: !0
                            }),
                            captured: _({
                                onTouchCancelCapture: !0
                            })
                        }
                    },
                    touchEnd: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onTouchEnd: !0
                            }),
                            captured: _({
                                onTouchEndCapture: !0
                            })
                        }
                    },
                    touchMove: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onTouchMove: !0
                            }),
                            captured: _({
                                onTouchMoveCapture: !0
                            })
                        }
                    },
                    touchStart: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onTouchStart: !0
                            }),
                            captured: _({
                                onTouchStartCapture: !0
                            })
                        }
                    },
                    transitionEnd: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onTransitionEnd: !0
                            }),
                            captured: _({
                                onTransitionEndCapture: !0
                            })
                        }
                    },
                    volumeChange: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onVolumeChange: !0
                            }),
                            captured: _({
                                onVolumeChangeCapture: !0
                            })
                        }
                    },
                    waiting: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onWaiting: !0
                            }),
                            captured: _({
                                onWaitingCapture: !0
                            })
                        }
                    },
                    wheel: {
                        phasedRegistrationNames: {
                            bubbled: _({
                                onWheel: !0
                            }),
                            captured: _({
                                onWheelCapture: !0
                            })
                        }
                    }
                },
                x = {
                    topAbort: T.abort,
                    topAnimationEnd: T.animationEnd,
                    topAnimationIteration: T.animationIteration,
                    topAnimationStart: T.animationStart,
                    topBlur: T.blur,
                    topCanPlay: T.canPlay,
                    topCanPlayThrough: T.canPlayThrough,
                    topClick: T.click,
                    topContextMenu: T.contextMenu,
                    topCopy: T.copy,
                    topCut: T.cut,
                    topDoubleClick: T.doubleClick,
                    topDrag: T.drag,
                    topDragEnd: T.dragEnd,
                    topDragEnter: T.dragEnter,
                    topDragExit: T.dragExit,
                    topDragLeave: T.dragLeave,
                    topDragOver: T.dragOver,
                    topDragStart: T.dragStart,
                    topDrop: T.drop,
                    topDurationChange: T.durationChange,
                    topEmptied: T.emptied,
                    topEncrypted: T.encrypted,
                    topEnded: T.ended,
                    topError: T.error,
                    topFocus: T.focus,
                    topInput: T.input,
                    topInvalid: T.invalid,
                    topKeyDown: T.keyDown,
                    topKeyPress: T.keyPress,
                    topKeyUp: T.keyUp,
                    topLoad: T.load,
                    topLoadedData: T.loadedData,
                    topLoadedMetadata: T.loadedMetadata,
                    topLoadStart: T.loadStart,
                    topMouseDown: T.mouseDown,
                    topMouseMove: T.mouseMove,
                    topMouseOut: T.mouseOut,
                    topMouseOver: T.mouseOver,
                    topMouseUp: T.mouseUp,
                    topPaste: T.paste,
                    topPause: T.pause,
                    topPlay: T.play,
                    topPlaying: T.playing,
                    topProgress: T.progress,
                    topRateChange: T.rateChange,
                    topReset: T.reset,
                    topScroll: T.scroll,
                    topSeeked: T.seeked,
                    topSeeking: T.seeking,
                    topStalled: T.stalled,
                    topSubmit: T.submit,
                    topSuspend: T.suspend,
                    topTimeUpdate: T.timeUpdate,
                    topTouchCancel: T.touchCancel,
                    topTouchEnd: T.touchEnd,
                    topTouchMove: T.touchMove,
                    topTouchStart: T.touchStart,
                    topTransitionEnd: T.transitionEnd,
                    topVolumeChange: T.volumeChange,
                    topWaiting: T.waiting,
                    topWheel: T.wheel
                };
            for (var P in x) x[P].dependencies = [P];
            var N = _({
                    onClick: null
                }),
                w = {},
                S = {
                    eventTypes: T,
                    extractEvents: function(e, t, n, r) {
                        var o = x[e];
                        if (!o) return null;
                        var a;
                        switch (e) {
                            case E.topAbort:
                            case E.topCanPlay:
                            case E.topCanPlayThrough:
                            case E.topDurationChange:
                            case E.topEmptied:
                            case E.topEncrypted:
                            case E.topEnded:
                            case E.topError:
                            case E.topInput:
                            case E.topInvalid:
                            case E.topLoad:
                            case E.topLoadedData:
                            case E.topLoadedMetadata:
                            case E.topLoadStart:
                            case E.topPause:
                            case E.topPlay:
                            case E.topPlaying:
                            case E.topProgress:
                            case E.topRateChange:
                            case E.topReset:
                            case E.topSeeked:
                            case E.topSeeking:
                            case E.topStalled:
                            case E.topSubmit:
                            case E.topSuspend:
                            case E.topTimeUpdate:
                            case E.topVolumeChange:
                            case E.topWaiting:
                                a = l;
                                break;
                            case E.topKeyPress:
                                if (0 === C(n)) return null;
                            case E.topKeyDown:
                            case E.topKeyUp:
                                a = p;
                                break;
                            case E.topBlur:
                            case E.topFocus:
                                a = c;
                                break;
                            case E.topClick:
                                if (2 === n.button) return null;
                            case E.topContextMenu:
                            case E.topDoubleClick:
                            case E.topMouseDown:
                            case E.topMouseMove:
                            case E.topMouseOut:
                            case E.topMouseOver:
                            case E.topMouseUp:
                                a = d;
                                break;
                            case E.topDrag:
                            case E.topDragEnd:
                            case E.topDragEnter:
                            case E.topDragExit:
                            case E.topDragLeave:
                            case E.topDragOver:
                            case E.topDragStart:
                            case E.topDrop:
                                a = f;
                                break;
                            case E.topTouchCancel:
                            case E.topTouchEnd:
                            case E.topTouchMove:
                            case E.topTouchStart:
                                a = h;
                                break;
                            case E.topAnimationEnd:
                            case E.topAnimationIteration:
                            case E.topAnimationStart:
                                a = s;
                                break;
                            case E.topTransitionEnd:
                                a = v;
                                break;
                            case E.topScroll:
                                a = m;
                                break;
                            case E.topWheel:
                                a = g;
                                break;
                            case E.topCopy:
                            case E.topCut:
                            case E.topPaste:
                                a = u
                        }
                        a ? void 0 : b(!1);
                        var y = a.getPooled(o, t, n, r);
                        return i.accumulateTwoPhaseDispatches(y), y
                    },
                    didPutListener: function(e, t, n) {
                        if (t === N) {
                            var r = e._rootNodeID,
                                i = a.getNodeFromInstance(e);
                            w[r] || (w[r] = o.listen(i, "click", y))
                        }
                    },
                    willDeleteListener: function(e, t) {
                        if (t === N) {
                            var n = e._rootNodeID;
                            w[n].remove(), delete w[n]
                        }
                    }
                };
            t.exports = S
        }, {
            106: 106,
            107: 107,
            109: 109,
            110: 110,
            111: 111,
            113: 113,
            114: 114,
            115: 115,
            116: 116,
            117: 117,
            118: 118,
            130: 130,
            15: 15,
            153: 153,
            160: 160,
            168: 168,
            172: 172,
            19: 19,
            42: 42
        }],
        106: [function(e, t, n) {
            "use strict";

            function r(e, t, n, r) {
                return o.call(this, e, t, n, r)
            }
            var o = e(110),
                i = {
                    animationName: null,
                    elapsedTime: null,
                    pseudoElement: null
                };
            o.augmentClass(r, i), t.exports = r
        }, {
            110: 110
        }],
        107: [function(e, t, n) {
            "use strict";

            function r(e, t, n, r) {
                return o.call(this, e, t, n, r)
            }
            var o = e(110),
                i = {
                    clipboardData: function(e) {
                        return "clipboardData" in e ? e.clipboardData : window.clipboardData
                    }
                };
            o.augmentClass(r, i), t.exports = r
        }, {
            110: 110
        }],
        108: [function(e, t, n) {
            "use strict";

            function r(e, t, n, r) {
                return o.call(this, e, t, n, r)
            }
            var o = e(110),
                i = {
                    data: null
                };
            o.augmentClass(r, i), t.exports = r
        }, {
            110: 110
        }],
        109: [function(e, t, n) {
            "use strict";

            function r(e, t, n, r) {
                return o.call(this, e, t, n, r)
            }
            var o = e(114),
                i = {
                    dataTransfer: null
                };
            o.augmentClass(r, i), t.exports = r
        }, {
            114: 114
        }],
        110: [function(e, t, n) {
            "use strict";

            function r(e, t, n, r) {
                this.dispatchConfig = e, this._targetInst = t, this.nativeEvent = n;
                var o = this.constructor.Interface;
                for (var i in o)
                    if (o.hasOwnProperty(i)) {
                        var s = o[i];
                        s ? this[i] = s(n) : "target" === i ? this.target = r : this[i] = n[i]
                    }
                var u = null != n.defaultPrevented ? n.defaultPrevented : n.returnValue === !1;
                return u ? this.isDefaultPrevented = a.thatReturnsTrue : this.isDefaultPrevented = a.thatReturnsFalse, this.isPropagationStopped = a.thatReturnsFalse, this
            }
            var o = e(177),
                i = e(24),
                a = e(160),
                s = (e(176), "function" == typeof Proxy, ["dispatchConfig", "_targetInst", "nativeEvent", "isDefaultPrevented", "isPropagationStopped", "_dispatchListeners", "_dispatchInstances"]),
                u = {
                    type: null,
                    target: null,
                    currentTarget: a.thatReturnsNull,
                    eventPhase: null,
                    bubbles: null,
                    cancelable: null,
                    timeStamp: function(e) {
                        return e.timeStamp || Date.now()
                    },
                    defaultPrevented: null,
                    isTrusted: null
                };
            o(r.prototype, {
                preventDefault: function() {
                    this.defaultPrevented = !0;
                    var e = this.nativeEvent;
                    e && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, this.isDefaultPrevented = a.thatReturnsTrue)
                },
                stopPropagation: function() {
                    var e = this.nativeEvent;
                    e && (e.stopPropagation ? e.stopPropagation() : e.cancelBubble = !0, this.isPropagationStopped = a.thatReturnsTrue)
                },
                persist: function() {
                    this.isPersistent = a.thatReturnsTrue
                },
                isPersistent: a.thatReturnsFalse,
                destructor: function() {
                    var e = this.constructor.Interface;
                    for (var t in e) this[t] = null;
                    for (var n = 0; n < s.length; n++) this[s[n]] = null
                }
            }), r.Interface = u, r.augmentClass = function(e, t) {
                var n = this,
                    r = function() {};
                r.prototype = n.prototype;
                var a = new r;
                o(a, e.prototype), e.prototype = a, e.prototype.constructor = e, e.Interface = o({}, n.Interface, t), e.augmentClass = n.augmentClass, i.addPoolingTo(e, i.fourArgumentPooler)
            }, i.addPoolingTo(r, i.fourArgumentPooler), t.exports = r
        }, {
            160: 160,
            176: 176,
            177: 177,
            24: 24
        }],
        111: [function(e, t, n) {
            "use strict";

            function r(e, t, n, r) {
                return o.call(this, e, t, n, r)
            }
            var o = e(117),
                i = {
                    relatedTarget: null
                };
            o.augmentClass(r, i), t.exports = r
        }, {
            117: 117
        }],
        112: [function(e, t, n) {
            "use strict";

            function r(e, t, n, r) {
                return o.call(this, e, t, n, r)
            }
            var o = e(110),
                i = {
                    data: null
                };
            o.augmentClass(r, i), t.exports = r
        }, {
            110: 110
        }],
        113: [function(e, t, n) {
            "use strict";

            function r(e, t, n, r) {
                return o.call(this, e, t, n, r)
            }
            var o = e(117),
                i = e(130),
                a = e(131),
                s = e(132),
                u = {
                    key: a,
                    location: null,
                    ctrlKey: null,
                    shiftKey: null,
                    altKey: null,
                    metaKey: null,
                    repeat: null,
                    locale: null,
                    getModifierState: s,
                    charCode: function(e) {
                        return "keypress" === e.type ? i(e) : 0
                    },
                    keyCode: function(e) {
                        return "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0
                    },
                    which: function(e) {
                        return "keypress" === e.type ? i(e) : "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0
                    }
                };
            o.augmentClass(r, u), t.exports = r
        }, {
            117: 117,
            130: 130,
            131: 131,
            132: 132
        }],
        114: [function(e, t, n) {
            "use strict";

            function r(e, t, n, r) {
                return o.call(this, e, t, n, r)
            }
            var o = e(117),
                i = e(120),
                a = e(132),
                s = {
                    screenX: null,
                    screenY: null,
                    clientX: null,
                    clientY: null,
                    ctrlKey: null,
                    shiftKey: null,
                    altKey: null,
                    metaKey: null,
                    getModifierState: a,
                    button: function(e) {
                        var t = e.button;
                        return "which" in e ? t : 2 === t ? 2 : 4 === t ? 1 : 0
                    },
                    buttons: null,
                    relatedTarget: function(e) {
                        return e.relatedTarget || (e.fromElement === e.srcElement ? e.toElement : e.fromElement)
                    },
                    pageX: function(e) {
                        return "pageX" in e ? e.pageX : e.clientX + i.currentScrollLeft
                    },
                    pageY: function(e) {
                        return "pageY" in e ? e.pageY : e.clientY + i.currentScrollTop
                    }
                };
            o.augmentClass(r, s), t.exports = r
        }, {
            117: 117,
            120: 120,
            132: 132
        }],
        115: [function(e, t, n) {
            "use strict";

            function r(e, t, n, r) {
                return o.call(this, e, t, n, r)
            }
            var o = e(117),
                i = e(132),
                a = {
                    touches: null,
                    targetTouches: null,
                    changedTouches: null,
                    altKey: null,
                    metaKey: null,
                    ctrlKey: null,
                    shiftKey: null,
                    getModifierState: i
                };
            o.augmentClass(r, a), t.exports = r
        }, {
            117: 117,
            132: 132
        }],
        116: [function(e, t, n) {
            "use strict";

            function r(e, t, n, r) {
                return o.call(this, e, t, n, r)
            }
            var o = e(110),
                i = {
                    propertyName: null,
                    elapsedTime: null,
                    pseudoElement: null
                };
            o.augmentClass(r, i), t.exports = r
        }, {
            110: 110
        }],
        117: [function(e, t, n) {
            "use strict";

            function r(e, t, n, r) {
                return o.call(this, e, t, n, r)
            }
            var o = e(110),
                i = e(133),
                a = {
                    view: function(e) {
                        if (e.view) return e.view;
                        var t = i(e);
                        if (null != t && t.window === t) return t;
                        var n = t.ownerDocument;
                        return n ? n.defaultView || n.parentWindow : window
                    },
                    detail: function(e) {
                        return e.detail || 0
                    }
                };
            o.augmentClass(r, a), t.exports = r
        }, {
            110: 110,
            133: 133
        }],
        118: [function(e, t, n) {
            "use strict";

            function r(e, t, n, r) {
                return o.call(this, e, t, n, r)
            }
            var o = e(114),
                i = {
                    deltaX: function(e) {
                        return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0
                    },
                    deltaY: function(e) {
                        return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0
                    },
                    deltaZ: null,
                    deltaMode: null
                };
            o.augmentClass(r, i), t.exports = r
        }, {
            114: 114
        }],
        119: [function(e, t, n) {
            "use strict";
            var r = e(168),
                o = {
                    reinitializeTransaction: function() {
                        this.transactionWrappers = this.getTransactionWrappers(), this.wrapperInitData ? this.wrapperInitData.length = 0 : this.wrapperInitData = [], this._isInTransaction = !1
                    },
                    _isInTransaction: !1,
                    getTransactionWrappers: null,
                    isInTransaction: function() {
                        return !!this._isInTransaction
                    },
                    perform: function(e, t, n, o, i, a, s, u) {
                        this.isInTransaction() ? r(!1) : void 0;
                        var l, c;
                        try {
                            this._isInTransaction = !0, l = !0, this.initializeAll(0), c = e.call(t, n, o, i, a, s, u), l = !1
                        } finally {
                            try {
                                if (l) try {
                                    this.closeAll(0)
                                } catch (p) {} else this.closeAll(0)
                            } finally {
                                this._isInTransaction = !1
                            }
                        }
                        return c
                    },
                    initializeAll: function(e) {
                        for (var t = this.transactionWrappers, n = e; n < t.length; n++) {
                            var r = t[n];
                            try {
                                this.wrapperInitData[n] = i.OBSERVED_ERROR, this.wrapperInitData[n] = r.initialize ? r.initialize.call(this) : null
                            } finally {
                                if (this.wrapperInitData[n] === i.OBSERVED_ERROR) try {
                                    this.initializeAll(n + 1)
                                } catch (o) {}
                            }
                        }
                    },
                    closeAll: function(e) {
                        this.isInTransaction() ? void 0 : r(!1);
                        for (var t = this.transactionWrappers, n = e; n < t.length; n++) {
                            var o, a = t[n],
                                s = this.wrapperInitData[n];
                            try {
                                o = !0, s !== i.OBSERVED_ERROR && a.close && a.close.call(this, s), o = !1
                            } finally {
                                if (o) try {
                                    this.closeAll(n + 1)
                                } catch (u) {}
                            }
                        }
                        this.wrapperInitData.length = 0
                    }
                },
                i = {
                    Mixin: o,
                    OBSERVED_ERROR: {}
                };
            t.exports = i
        }, {
            168: 168
        }],
        120: [function(e, t, n) {
            "use strict";
            var r = {
                currentScrollLeft: 0,
                currentScrollTop: 0,
                refreshScrollValues: function(e) {
                    r.currentScrollLeft = e.x, r.currentScrollTop = e.y
                }
            };
            t.exports = r
        }, {}],
        121: [function(e, t, n) {
            "use strict";

            function r(e, t) {
                if (null == t ? o(!1) : void 0, null == e) return t;
                var n = Array.isArray(e),
                    r = Array.isArray(t);
                return n && r ? (e.push.apply(e, t), e) : n ? (e.push(t), e) : r ? [e].concat(t) : [e, t]
            }
            var o = e(168);
            t.exports = r
        }, {
            168: 168
        }],
        122: [function(e, t, n) {
            "use strict";

            function r(e) {
                for (var t = 1, n = 0, r = 0, i = e.length, a = -4 & i; a > r;) {
                    for (var s = Math.min(r + 4096, a); s > r; r += 4) n += (t += e.charCodeAt(r)) + (t += e.charCodeAt(r + 1)) + (t += e.charCodeAt(r + 2)) + (t += e.charCodeAt(r + 3));
                    t %= o, n %= o
                }
                for (; i > r; r++) n += t += e.charCodeAt(r);
                return t %= o, n %= o, t | n << 16
            }
            var o = 65521;
            t.exports = r
        }, {}],
        123: [function(e, t, n) {
            "use strict";
            var r = !1;
            t.exports = r
        }, {}],
        124: [function(e, t, n) {
            "use strict";
            var r = function(e) {
                return "undefined" != typeof MSApp && MSApp.execUnsafeLocalFunction ? function(t, n, r, o) {
                    MSApp.execUnsafeLocalFunction(function() {
                        return e(t, n, r, o)
                    })
                } : e
            };
            t.exports = r
        }, {}],
        125: [function(e, t, n) {
            "use strict";

            function r(e, t, n) {
                var r = null == t || "boolean" == typeof t || "" === t;
                if (r) return "";
                var o = isNaN(t);
                return o || 0 === t || i.hasOwnProperty(e) && i[e] ? "" + t : ("string" == typeof t && (t = t.trim()), t + "px")
            }
            var o = e(3),
                i = (e(176), o.isUnitlessNumber);
            t.exports = r
        }, {
            176: 176,
            3: 3
        }],
        126: [function(e, t, n) {
            "use strict";

            function r(e) {
                return i[e]
            }

            function o(e) {
                return ("" + e).replace(a, r)
            }
            var i = {
                    "&": "&amp;",
                    ">": "&gt;",
                    "<": "&lt;",
                    '"': "&quot;",
                    "'": "&#x27;"
                },
                a = /[&><"']/g;
            t.exports = o
        }, {}],
        127: [function(e, t, n) {
            "use strict";

            function r(e) {
                if (null == e) return null;
                if (1 === e.nodeType) return e;
                var t = i.get(e);
                return t ? (t = a(t), t ? o.getNodeFromInstance(t) : null) : void s(("function" == typeof e.render, !1))
            }
            var o = (e(37), e(42)),
                i = e(72),
                a = e(135),
                s = e(168);
            e(176);
            t.exports = r
        }, {
            135: 135,
            168: 168,
            176: 176,
            37: 37,
            42: 42,
            72: 72
        }],
        128: [function(e, t, n) {
            "use strict";

            function r(e, t, n) {
                var r = e,
                    o = void 0 === r[n];
                o && null != t && (r[n] = t)
            }

            function o(e) {
                if (null == e) return e;
                var t = {};
                return i(e, r, t), t
            }
            var i = e(149);
            e(176);
            t.exports = o
        }, {
            149: 149,
            176: 176
        }],
        129: [function(e, t, n) {
            "use strict";
            var r = function(e, t, n) {
                Array.isArray(e) ? e.forEach(t, n) : e && t.call(n, e)
            };
            t.exports = r
        }, {}],
        130: [function(e, t, n) {
            "use strict";

            function r(e) {
                var t, n = e.keyCode;
                return "charCode" in e ? (t = e.charCode, 0 === t && 13 === n && (t = 13)) : t = n, t >= 32 || 13 === t ? t : 0
            }
            t.exports = r
        }, {}],
        131: [function(e, t, n) {
            "use strict";

            function r(e) {
                if (e.key) {
                    var t = i[e.key] || e.key;
                    if ("Unidentified" !== t) return t
                }
                if ("keypress" === e.type) {
                    var n = o(e);
                    return 13 === n ? "Enter" : String.fromCharCode(n)
                }
                return "keydown" === e.type || "keyup" === e.type ? a[e.keyCode] || "Unidentified" : ""
            }
            var o = e(130),
                i = {
                    Esc: "Escape",
                    Spacebar: " ",
                    Left: "ArrowLeft",
                    Up: "ArrowUp",
                    Right: "ArrowRight",
                    Down: "ArrowDown",
                    Del: "Delete",
                    Win: "OS",
                    Menu: "ContextMenu",
                    Apps: "ContextMenu",
                    Scroll: "ScrollLock",
                    MozPrintableKey: "Unidentified"
                },
                a = {
                    8: "Backspace",
                    9: "Tab",
                    12: "Clear",
                    13: "Enter",
                    16: "Shift",
                    17: "Control",
                    18: "Alt",
                    19: "Pause",
                    20: "CapsLock",
                    27: "Escape",
                    32: " ",
                    33: "PageUp",
                    34: "PageDown",
                    35: "End",
                    36: "Home",
                    37: "ArrowLeft",
                    38: "ArrowUp",
                    39: "ArrowRight",
                    40: "ArrowDown",
                    45: "Insert",
                    46: "Delete",
                    112: "F1",
                    113: "F2",
                    114: "F3",
                    115: "F4",
                    116: "F5",
                    117: "F6",
                    118: "F7",
                    119: "F8",
                    120: "F9",
                    121: "F10",
                    122: "F11",
                    123: "F12",
                    144: "NumLock",
                    145: "ScrollLock",
                    224: "Meta"
                };
            t.exports = r
        }, {
            130: 130
        }],
        132: [function(e, t, n) {
            "use strict";

            function r(e) {
                var t = this,
                    n = t.nativeEvent;
                if (n.getModifierState) return n.getModifierState(e);
                var r = i[e];
                return r ? !!n[r] : !1
            }

            function o(e) {
                return r
            }
            var i = {
                Alt: "altKey",
                Control: "ctrlKey",
                Meta: "metaKey",
                Shift: "shiftKey"
            };
            t.exports = o
        }, {}],
        133: [function(e, t, n) {
            "use strict";

            function r(e) {
                var t = e.target || e.srcElement || window;
                return t.correspondingUseElement && (t = t.correspondingUseElement), 3 === t.nodeType ? t.parentNode : t
            }
            t.exports = r
        }, {}],
        134: [function(e, t, n) {
            "use strict";

            function r(e) {
                var t = e && (o && e[o] || e[i]);
                return "function" == typeof t ? t : void 0
            }
            var o = "function" == typeof Symbol && Symbol.iterator,
                i = "@@iterator";
            t.exports = r
        }, {}],
        135: [function(e, t, n) {
            "use strict";

            function r(e) {
                for (var t;
                    (t = e._renderedNodeType) === o.COMPOSITE;) e = e._renderedComponent;
                return t === o.NATIVE ? e._renderedComponent : t === o.EMPTY ? null : void 0
            }
            var o = e(81);
            t.exports = r
        }, {
            81: 81
        }],
        136: [function(e, t, n) {
            "use strict";

            function r(e) {
                for (; e && e.firstChild;) e = e.firstChild;
                return e
            }

            function o(e) {
                for (; e;) {
                    if (e.nextSibling) return e.nextSibling;
                    e = e.parentNode
                }
            }

            function i(e, t) {
                for (var n = r(e), i = 0, a = 0; n;) {
                    if (3 === n.nodeType) {
                        if (a = i + n.textContent.length, t >= i && a >= t) return {
                            node: n,
                            offset: t - i
                        };
                        i = a
                    }
                    n = r(o(n))
                }
            }
            t.exports = i
        }, {}],
        137: [function(e, t, n) {
            "use strict";

            function r() {
                return !i && o.canUseDOM && (i = "textContent" in document.documentElement ? "textContent" : "innerText"), i
            }
            var o = e(154),
                i = null;
            t.exports = r
        }, {
            154: 154
        }],
        138: [function(e, t, n) {
            "use strict";

            function r(e, t) {
                var n = {};
                return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n["ms" + e] = "MS" + t, n["O" + e] = "o" + t.toLowerCase(), n
            }

            function o(e) {
                if (s[e]) return s[e];
                if (!a[e]) return e;
                var t = a[e];
                for (var n in t)
                    if (t.hasOwnProperty(n) && n in u) return s[e] = t[n];
                return ""
            }
            var i = e(154),
                a = {
                    animationend: r("Animation", "AnimationEnd"),
                    animationiteration: r("Animation", "AnimationIteration"),
                    animationstart: r("Animation", "AnimationStart"),
                    transitionend: r("Transition", "TransitionEnd")
                },
                s = {},
                u = {};
            i.canUseDOM && (u = document.createElement("div").style, "AnimationEvent" in window || (delete a.animationend.animation, delete a.animationiteration.animation, delete a.animationstart.animation), "TransitionEvent" in window || delete a.transitionend.transition), t.exports = o
        }, {
            154: 154
        }],
        139: [function(e, t, n) {
            "use strict";

            function r(e) {
                return "function" == typeof e && "undefined" != typeof e.prototype && "function" == typeof e.prototype.mountComponent && "function" == typeof e.prototype.receiveComponent
            }

            function o(e) {
                var t;
                if (null === e || e === !1) t = s.create(o);
                else if ("object" == typeof e) {
                    var n = e;
                    !n || "function" != typeof n.type && "string" != typeof n.type ? l(!1) : void 0, t = "string" == typeof n.type ? u.createInternalComponent(n) : r(n.type) ? new n.type(n) : new c(n)
                } else "string" == typeof e || "number" == typeof e ? t = u.createInstanceForText(e) : l(!1);
                return t._mountIndex = 0, t._mountImage = null, t
            }
            var i = e(177),
                a = e(36),
                s = e(64),
                u = e(80),
                l = e(168),
                c = (e(176), function(e) {
                    this.construct(e)
                });
            i(c.prototype, a.Mixin, {
                _instantiateReactComponent: o
            }), t.exports = o
        }, {
            168: 168,
            176: 176,
            177: 177,
            36: 36,
            64: 64,
            80: 80
        }],
        140: [function(e, t, n) {
            "use strict";

            function r(e, t) {
                if (!i.canUseDOM || t && !("addEventListener" in document)) return !1;
                var n = "on" + e,
                    r = n in document;
                if (!r) {
                    var a = document.createElement("div");
                    a.setAttribute(n, "return;"), r = "function" == typeof a[n]
                }
                return !r && o && "wheel" === e && (r = document.implementation.hasFeature("Events.wheel", "3.0")), r
            }
            var o, i = e(154);
            i.canUseDOM && (o = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== !0), t.exports = r
        }, {
            154: 154
        }],
        141: [function(e, t, n) {
            "use strict";

            function r(e) {
                var t = e && e.nodeName && e.nodeName.toLowerCase();
                return t && ("input" === t && o[e.type] || "textarea" === t)
            }
            var o = {
                color: !0,
                date: !0,
                datetime: !0,
                "datetime-local": !0,
                email: !0,
                month: !0,
                number: !0,
                password: !0,
                range: !0,
                search: !0,
                tel: !0,
                text: !0,
                time: !0,
                url: !0,
                week: !0
            };
            t.exports = r
        }, {}],
        142: [function(e, t, n) {
            "use strict";

            function r(e) {
                return o.isValidElement(e) ? void 0 : i(!1), e
            }
            var o = e(62),
                i = e(168);
            t.exports = r
        }, {
            168: 168,
            62: 62
        }],
        143: [function(e, t, n) {
            "use strict";

            function r(e) {
                return '"' + o(e) + '"'
            }
            var o = e(126);
            t.exports = r
        }, {
            126: 126
        }],
        144: [function(e, t, n) {
            "use strict";
            var r = e(77);
            t.exports = r.renderSubtreeIntoContainer
        }, {
            77: 77
        }],
        145: [function(e, t, n) {
            "use strict";
            var r = e(154),
                o = /^[ \r\n\t\f]/,
                i = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/,
                a = e(124),
                s = a(function(e, t) {
                    e.innerHTML = t
                });
            if (r.canUseDOM) {
                var u = document.createElement("div");
                u.innerHTML = " ", "" === u.innerHTML && (s = function(e, t) {
                    if (e.parentNode && e.parentNode.replaceChild(e, e), o.test(t) || "<" === t[0] && i.test(t)) {
                        e.innerHTML = String.fromCharCode(65279) + t;
                        var n = e.firstChild;
                        1 === n.data.length ? e.removeChild(n) : n.deleteData(0, 1)
                    } else e.innerHTML = t
                }), u = null
            }
            t.exports = s
        }, {
            124: 124,
            154: 154
        }],
        146: [function(e, t, n) {
            "use strict";
            var r = e(154),
                o = e(126),
                i = e(145),
                a = function(e, t) {
                    e.textContent = t
                };
            r.canUseDOM && ("textContent" in document.documentElement || (a = function(e, t) {
                i(e, o(t))
            })), t.exports = a
        }, {
            126: 126,
            145: 145,
            154: 154
        }],
        147: [function(e, t, n) {
            "use strict";

            function r(e, t, n) {
                return !o(e.props, t) || !o(e.state, n)
            }
            var o = e(175);
            t.exports = r
        }, {
            175: 175
        }],
        148: [function(e, t, n) {
            "use strict";

            function r(e, t) {
                var n = null === e || e === !1,
                    r = null === t || t === !1;
                if (n || r) return n === r;
                var o = typeof e,
                    i = typeof t;
                return "string" === o || "number" === o ? "string" === i || "number" === i : "object" === i && e.type === t.type && e.key === t.key
            }
            t.exports = r
        }, {}],
        149: [function(e, t, n) {
            "use strict";

            function r(e) {
                return h[e]
            }

            function o(e, t) {
                return e && "object" == typeof e && null != e.key ? a(e.key) : t.toString(36)
            }

            function i(e) {
                return ("" + e).replace(v, r)
            }

            function a(e) {
                return "$" + i(e)
            }

            function s(e, t, n, r) {
                var i = typeof e;
                if ("undefined" !== i && "boolean" !== i || (e = null), null === e || "string" === i || "number" === i || l.isValidElement(e)) return n(r, e, "" === t ? d + o(e, 0) : t), 1;
                var u, h, v = 0,
                    m = "" === t ? d : t + f;
                if (Array.isArray(e))
                    for (var g = 0; g < e.length; g++) u = e[g], h = m + o(u, g), v += s(u, h, n, r);
                else {
                    var y = c(e);
                    if (y) {
                        var C, b = y.call(e);
                        if (y !== e.entries)
                            for (var _ = 0; !(C = b.next()).done;) u = C.value, h = m + o(u, _++), v += s(u, h, n, r);
                        else
                            for (; !(C = b.next()).done;) {
                                var E = C.value;
                                E && (u = E[1], h = m + a(E[0]) + f + o(u, 0), v += s(u, h, n, r))
                            }
                    } else "object" === i && (String(e), p(!1))
                }
                return v
            }

            function u(e, t, n) {
                return null == e ? 0 : s(e, "", t, n)
            }
            var l = (e(37), e(62)),
                c = e(134),
                p = e(168),
                d = (e(176), "."),
                f = ":",
                h = {
                    "=": "=0",
                    ":": "=2"
                },
                v = /[=:]/g;
            t.exports = u
        }, {
            134: 134,
            168: 168,
            176: 176,
            37: 37,
            62: 62
        }],
        150: [function(e, t, n) {
            "use strict";

            function r(e) {
                return Array.isArray(e) ? e.concat() : e && "object" == typeof e ? a(new e.constructor, e) : e
            }

            function o(e, t, n) {
                Array.isArray(e) ? void 0 : u(!1);
                var r = t[n];
                Array.isArray(r) ? void 0 : u(!1)
            }

            function i(e, t) {
                if ("object" != typeof t ? u(!1) : void 0, l.call(t, f)) return 1 !== Object.keys(t).length ? u(!1) : void 0, t[f];
                var n = r(e);
                if (l.call(t, h)) {
                    var s = t[h];
                    s && "object" == typeof s ? void 0 : u(!1), n && "object" == typeof n ? void 0 : u(!1), a(n, t[h])
                }
                l.call(t, c) && (o(e, t, c), t[c].forEach(function(e) {
                    n.push(e)
                })), l.call(t, p) && (o(e, t, p), t[p].forEach(function(e) {
                    n.unshift(e)
                })), l.call(t, d) && (Array.isArray(e) ? void 0 : u(!1), Array.isArray(t[d]) ? void 0 : u(!1), t[d].forEach(function(e) {
                    Array.isArray(e) ? void 0 : u(!1), n.splice.apply(n, e)
                })), l.call(t, v) && ("function" != typeof t[v] ? u(!1) : void 0, n = t[v](n));
                for (var m in t) g.hasOwnProperty(m) && g[m] || (n[m] = i(e[m], t[m]));
                return n
            }
            var a = e(177),
                s = e(172),
                u = e(168),
                l = {}.hasOwnProperty,
                c = s({
                    $push: null
                }),
                p = s({
                    $unshift: null
                }),
                d = s({
                    $splice: null
                }),
                f = s({
                    $set: null
                }),
                h = s({
                    $merge: null
                }),
                v = s({
                    $apply: null
                }),
                m = [c, p, d, f, h, v],
                g = {};
            m.forEach(function(e) {
                g[e] = !0
            }), t.exports = i
        }, {
            168: 168,
            172: 172,
            177: 177
        }],
        151: [function(e, t, n) {
            "use strict";
            var r = (e(177), e(160)),
                o = (e(176), r);
            t.exports = o
        }, {
            160: 160,
            176: 176,
            177: 177
        }],
        152: [function(e, t, n) {
            "use strict";

            function r(e, t) {
                for (var n = e; n.parentNode;) n = n.parentNode;
                var r = n.querySelectorAll(t);
                return -1 !== Array.prototype.indexOf.call(r, e)
            }
            var o = e(168),
                i = {
                    addClass: function(e, t) {
                        return /\s/.test(t) ? o(!1) : void 0, t && (e.classList ? e.classList.add(t) : i.hasClass(e, t) || (e.className = e.className + " " + t)), e
                    },
                    removeClass: function(e, t) {
                        return /\s/.test(t) ? o(!1) : void 0, t && (e.classList ? e.classList.remove(t) : i.hasClass(e, t) && (e.className = e.className.replace(new RegExp("(^|\\s)" + t + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, ""))), e
                    },
                    conditionClass: function(e, t, n) {
                        return (n ? i.addClass : i.removeClass)(e, t)
                    },
                    hasClass: function(e, t) {
                        return /\s/.test(t) ? o(!1) : void 0, e.classList ? !!t && e.classList.contains(t) : (" " + e.className + " ").indexOf(" " + t + " ") > -1
                    },
                    matchesSelector: function(e, t) {
                        var n = e.matches || e.webkitMatchesSelector || e.mozMatchesSelector || e.msMatchesSelector || function(t) {
                            return r(e, t)
                        };
                        return n.call(e, t)
                    }
                };
            t.exports = i
        }, {
            168: 168
        }],
        153: [function(e, t, n) {
            "use strict";
            var r = e(160),
                o = {
                    listen: function(e, t, n) {
                        return e.addEventListener ? (e.addEventListener(t, n, !1), {
                            remove: function() {
                                e.removeEventListener(t, n, !1)
                            }
                        }) : e.attachEvent ? (e.attachEvent("on" + t, n), {
                            remove: function() {
                                e.detachEvent("on" + t, n)
                            }
                        }) : void 0
                    },
                    capture: function(e, t, n) {
                        return e.addEventListener ? (e.addEventListener(t, n, !0), {
                            remove: function() {
                                e.removeEventListener(t, n, !0)
                            }
                        }) : {
                            remove: r
                        }
                    },
                    registerDefault: function() {}
                };
            t.exports = o
        }, {
            160: 160
        }],
        154: [function(e, t, n) {
            "use strict";
            var r = !("undefined" == typeof window || !window.document || !window.document.createElement),
                o = {
                    canUseDOM: r,
                    canUseWorkers: "undefined" != typeof Worker,
                    canUseEventListeners: r && !(!window.addEventListener && !window.attachEvent),
                    canUseViewport: r && !!window.screen,
                    isInWorker: !r
                };
            t.exports = o
        }, {}],
        155: [function(e, t, n) {
            "use strict";

            function r(e) {
                return e.replace(o, function(e, t) {
                    return t.toUpperCase()
                })
            }
            var o = /-(.)/g;
            t.exports = r
        }, {}],
        156: [function(e, t, n) {
            "use strict";

            function r(e) {
                return o(e.replace(i, "ms-"))
            }
            var o = e(155),
                i = /^-ms-/;
            t.exports = r
        }, {
            155: 155
        }],
        157: [function(e, t, n) {
            "use strict";

            function r(e, t) {
                return e && t ? e === t ? !0 : o(e) ? !1 : o(t) ? r(e, t.parentNode) : e.contains ? e.contains(t) : e.compareDocumentPosition ? !!(16 & e.compareDocumentPosition(t)) : !1 : !1
            }
            var o = e(170);
            t.exports = r
        }, {
            170: 170
        }],
        158: [function(e, t, n) {
            "use strict";

            function r(e) {
                var t = e.length;
                if (Array.isArray(e) || "object" != typeof e && "function" != typeof e ? a(!1) : void 0, "number" != typeof t ? a(!1) : void 0, 0 === t || t - 1 in e ? void 0 : a(!1), "function" == typeof e.callee ? a(!1) : void 0, e.hasOwnProperty) try {
                    return Array.prototype.slice.call(e)
                } catch (n) {}
                for (var r = Array(t), o = 0; t > o; o++) r[o] = e[o];
                return r
            }

            function o(e) {
                return !!e && ("object" == typeof e || "function" == typeof e) && "length" in e && !("setInterval" in e) && "number" != typeof e.nodeType && (Array.isArray(e) || "callee" in e || "item" in e)
            }

            function i(e) {
                return o(e) ? Array.isArray(e) ? e.slice() : r(e) : [e]
            }
            var a = e(168);
            t.exports = i
        }, {
            168: 168
        }],
        159: [function(e, t, n) {
            "use strict";

            function r(e) {
                var t = e.match(c);
                return t && t[1].toLowerCase()
            }

            function o(e, t) {
                var n = l;
                l ? void 0 : u(!1);
                var o = r(e),
                    i = o && s(o);
                if (i) {
                    n.innerHTML = i[1] + e + i[2];
                    for (var c = i[0]; c--;) n = n.lastChild
                } else n.innerHTML = e;
                var p = n.getElementsByTagName("script");
                p.length && (t ? void 0 : u(!1), a(p).forEach(t));
                for (var d = Array.from(n.childNodes); n.lastChild;) n.removeChild(n.lastChild);
                return d
            }
            var i = e(154),
                a = e(158),
                s = e(164),
                u = e(168),
                l = i.canUseDOM ? document.createElement("div") : null,
                c = /^\s*<(\w+)/;
            t.exports = o
        }, {
            154: 154,
            158: 158,
            164: 164,
            168: 168
        }],
        160: [function(e, t, n) {
            "use strict";

            function r(e) {
                return function() {
                    return e
                }
            }

            function o() {}
            o.thatReturns = r, o.thatReturnsFalse = r(!1), o.thatReturnsTrue = r(!0), o.thatReturnsNull = r(null), o.thatReturnsThis = function() {
                return this
            }, o.thatReturnsArgument = function(e) {
                return e
            }, t.exports = o
        }, {}],
        161: [function(e, t, n) {
            "use strict";
            var r = {};
            t.exports = r
        }, {}],
        162: [function(e, t, n) {
            "use strict";

            function r(e) {
                try {
                    e.focus()
                } catch (t) {}
            }
            t.exports = r
        }, {}],
        163: [function(e, t, n) {
            "use strict";

            function r() {
                if ("undefined" == typeof document) return null;
                try {
                    return document.activeElement || document.body
                } catch (e) {
                    return document.body
                }
            }
            t.exports = r
        }, {}],
        164: [function(e, t, n) {
            "use strict";

            function r(e) {
                return a ? void 0 : i(!1), d.hasOwnProperty(e) || (e = "*"), s.hasOwnProperty(e) || ("*" === e ? a.innerHTML = "<link />" : a.innerHTML = "<" + e + "></" + e + ">", s[e] = !a.firstChild), s[e] ? d[e] : null
            }
            var o = e(154),
                i = e(168),
                a = o.canUseDOM ? document.createElement("div") : null,
                s = {},
                u = [1, '<select multiple="true">', "</select>"],
                l = [1, "<table>", "</table>"],
                c = [3, "<table><tbody><tr>", "</tr></tbody></table>"],
                p = [1, '<svg xmlns="http://www.w3.org/2000/svg">', "</svg>"],
                d = {
                    "*": [1, "?<div>", "</div>"],
                    area: [1, "<map>", "</map>"],
                    col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
                    legend: [1, "<fieldset>", "</fieldset>"],
                    param: [1, "<object>", "</object>"],
                    tr: [2, "<table><tbody>", "</tbody></table>"],
                    optgroup: u,
                    option: u,
                    caption: l,
                    colgroup: l,
                    tbody: l,
                    tfoot: l,
                    thead: l,
                    td: c,
                    th: c
                },
                f = ["circle", "clipPath", "defs", "ellipse", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "text", "tspan"];
            f.forEach(function(e) {
                d[e] = p, s[e] = !0
            }), t.exports = r
        }, {
            154: 154,
            168: 168
        }],
        165: [function(e, t, n) {
            "use strict";

            function r(e) {
                return e === window ? {
                    x: window.pageXOffset || document.documentElement.scrollLeft,
                    y: window.pageYOffset || document.documentElement.scrollTop
                } : {
                    x: e.scrollLeft,
                    y: e.scrollTop
                }
            }
            t.exports = r
        }, {}],
        166: [function(e, t, n) {
            "use strict";

            function r(e) {
                return e.replace(o, "-$1").toLowerCase()
            }
            var o = /([A-Z])/g;
            t.exports = r
        }, {}],
        167: [function(e, t, n) {
            "use strict";

            function r(e) {
                return o(e).replace(i, "-ms-")
            }
            var o = e(166),
                i = /^ms-/;
            t.exports = r
        }, {
            166: 166
        }],
        168: [function(e, t, n) {
            "use strict";

            function r(e, t, n, r, o, i, a, s) {
                if (!e) {
                    var u;
                    if (void 0 === t) u = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
                    else {
                        var l = [n, r, o, i, a, s],
                            c = 0;
                        u = new Error(t.replace(/%s/g, function() {
                            return l[c++]
                        })), u.name = "Invariant Violation"
                    }
                    throw u.framesToPop = 1, u
                }
            }
            t.exports = r
        }, {}],
        169: [function(e, t, n) {
            "use strict";

            function r(e) {
                return !(!e || !("function" == typeof Node ? e instanceof Node : "object" == typeof e && "number" == typeof e.nodeType && "string" == typeof e.nodeName))
            }
            t.exports = r
        }, {}],
        170: [function(e, t, n) {
            "use strict";

            function r(e) {
                return o(e) && 3 == e.nodeType
            }
            var o = e(169);
            t.exports = r
        }, {
            169: 169
        }],
        171: [function(e, t, n) {
            "use strict";
            var r = e(168),
                o = function(e) {
                    var t, n = {};
                    e instanceof Object && !Array.isArray(e) ? void 0 : r(!1);
                    for (t in e) e.hasOwnProperty(t) && (n[t] = t);
                    return n
                };
            t.exports = o
        }, {
            168: 168
        }],
        172: [function(e, t, n) {
            "use strict";
            var r = function(e) {
                var t;
                for (t in e)
                    if (e.hasOwnProperty(t)) return t;
                return null
            };
            t.exports = r
        }, {}],
        173: [function(e, t, n) {
            "use strict";

            function r(e, t, n) {
                if (!e) return null;
                var r = {};
                for (var i in e) o.call(e, i) && (r[i] = t.call(n, e[i], i, e));
                return r
            }
            var o = Object.prototype.hasOwnProperty;
            t.exports = r
        }, {}],
        174: [function(e, t, n) {
            "use strict";

            function r(e) {
                var t = {};
                return function(n) {
                    return t.hasOwnProperty(n) || (t[n] = e.call(this, n)), t[n]
                }
            }
            t.exports = r
        }, {}],
        175: [function(e, t, n) {
            "use strict";

            function r(e, t) {
                return e === t ? 0 !== e || 1 / e === 1 / t : e !== e && t !== t
            }

            function o(e, t) {
                if (r(e, t)) return !0;
                if ("object" != typeof e || null === e || "object" != typeof t || null === t) return !1;
                var n = Object.keys(e),
                    o = Object.keys(t);
                if (n.length !== o.length) return !1;
                for (var a = 0; a < n.length; a++)
                    if (!i.call(t, n[a]) || !r(e[n[a]], t[n[a]])) return !1;
                return !0
            }
            var i = Object.prototype.hasOwnProperty;
            t.exports = o
        }, {}],
        176: [function(e, t, n) {
            "use strict";
            var r = e(160),
                o = r;
            t.exports = o
        }, {
            160: 160
        }],
        177: [function(e, t, n) {
            "use strict";

            function r(e) {
                if (null === e || void 0 === e) throw new TypeError("Object.assign cannot be called with null or undefined");
                return Object(e)
            }
            var o = Object.prototype.hasOwnProperty,
                i = Object.prototype.propertyIsEnumerable;
            t.exports = Object.assign || function(e, t) {
                for (var n, a, s = r(e), u = 1; u < arguments.length; u++) {
                    n = Object(arguments[u]);
                    for (var l in n) o.call(n, l) && (s[l] = n[l]);
                    if (Object.getOwnPropertySymbols) {
                        a = Object.getOwnPropertySymbols(n);
                        for (var c = 0; c < a.length; c++) i.call(n, a[c]) && (s[a[c]] = n[a[c]])
                    }
                }
                return s
            }
        }, {}]
    }, {}, [102])(102)
});
/**
 * ReactDOM v15.0.1
 *
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */
! function(e) {
    if ("object" == typeof exports && "undefined" != typeof module) module.exports = e(require("react"));
    else if ("function" == typeof define && define.amd) define(["react"], e);
    else {
        var f;
        f = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, f.ReactDOM = e(f.React)
    }
}(function(e) {
    return e.__SECRET_DOM_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
});
/**
 *  Copyright (c) 2014-2015, Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree. An additional grant
 *  of patent rights can be found in the PATENTS file in the same directory.
 */
! function(t, e) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : t.Immutable = e()
}(this, function() {
    "use strict";

    function t(t, e) {
        e && (t.prototype = Object.create(e.prototype)), t.prototype.constructor = t
    }

    function e(t) {
        return o(t) ? t : O(t)
    }

    function r(t) {
        return u(t) ? t : x(t)
    }

    function n(t) {
        return s(t) ? t : k(t)
    }

    function i(t) {
        return o(t) && !a(t) ? t : A(t)
    }

    function o(t) {
        return !(!t || !t[ar])
    }

    function u(t) {
        return !(!t || !t[hr])
    }

    function s(t) {
        return !(!t || !t[fr])
    }

    function a(t) {
        return u(t) || s(t)
    }

    function h(t) {
        return !(!t || !t[cr])
    }

    function f(t) {
        return t.value = !1, t
    }

    function c(t) {
        t && (t.value = !0)
    }

    function _() {}

    function p(t, e) {
        e = e || 0;
        for (var r = Math.max(0, t.length - e), n = Array(r), i = 0; r > i; i++) n[i] = t[i + e];
        return n
    }

    function v(t) {
        return void 0 === t.size && (t.size = t.__iterate(y)), t.size
    }

    function l(t, e) {
        if ("number" != typeof e) {
            var r = e >>> 0;
            if ("" + r !== e || 4294967295 === r) return NaN;
            e = r
        }
        return 0 > e ? v(t) + e : e
    }

    function y() {
        return !0
    }

    function d(t, e, r) {
        return (0 === t || void 0 !== r && -r >= t) && (void 0 === e || void 0 !== r && e >= r)
    }

    function m(t, e) {
        return w(t, e, 0)
    }

    function g(t, e) {
        return w(t, e, e)
    }

    function w(t, e, r) {
        return void 0 === t ? r : 0 > t ? Math.max(0, e + t) : void 0 === e ? t : Math.min(e, t)
    }

    function S(t) {
        this.next = t
    }

    function z(t, e, r, n) {
        var i = 0 === t ? e : 1 === t ? r : [e, r];
        return n ? n.value = i : n = {
            value: i,
            done: !1
        }, n
    }

    function I() {
        return {
            value: void 0,
            done: !0
        }
    }

    function b(t) {
        return !!M(t)
    }

    function q(t) {
        return t && "function" == typeof t.next
    }

    function D(t) {
        var e = M(t);
        return e && e.call(t)
    }

    function M(t) {
        var e = t && (zr && t[zr] || t[Ir]);
        return "function" == typeof e ? e : void 0
    }

    function E(t) {
        return t && "number" == typeof t.length
    }

    function O(t) {
        return null === t || void 0 === t ? T() : o(t) ? t.toSeq() : C(t)
    }

    function x(t) {
        return null === t || void 0 === t ? T().toKeyedSeq() : o(t) ? u(t) ? t.toSeq() : t.fromEntrySeq() : B(t)
    }

    function k(t) {
        return null === t || void 0 === t ? T() : o(t) ? u(t) ? t.entrySeq() : t.toIndexedSeq() : W(t)
    }

    function A(t) {
        return (null === t || void 0 === t ? T() : o(t) ? u(t) ? t.entrySeq() : t : W(t)).toSetSeq()
    }

    function j(t) {
        this._array = t, this.size = t.length
    }

    function R(t) {
        var e = Object.keys(t);
        this._object = t, this._keys = e,
            this.size = e.length
    }

    function U(t) {
        this._iterable = t, this.size = t.length || t.size
    }

    function K(t) {
        this._iterator = t, this._iteratorCache = []
    }

    function L(t) {
        return !(!t || !t[qr])
    }

    function T() {
        return Dr || (Dr = new j([]))
    }

    function B(t) {
        var e = Array.isArray(t) ? new j(t).fromEntrySeq() : q(t) ? new K(t).fromEntrySeq() : b(t) ? new U(t).fromEntrySeq() : "object" == typeof t ? new R(t) : void 0;
        if (!e) throw new TypeError("Expected Array or iterable object of [k, v] entries, or keyed object: " + t);
        return e
    }

    function W(t) {
        var e = J(t);
        if (!e) throw new TypeError("Expected Array or iterable object of values: " + t);
        return e
    }

    function C(t) {
        var e = J(t) || "object" == typeof t && new R(t);
        if (!e) throw new TypeError("Expected Array or iterable object of values, or keyed object: " + t);
        return e
    }

    function J(t) {
        return E(t) ? new j(t) : q(t) ? new K(t) : b(t) ? new U(t) : void 0
    }

    function N(t, e, r, n) {
        var i = t._cache;
        if (i) {
            for (var o = i.length - 1, u = 0; o >= u; u++) {
                var s = i[r ? o - u : u];
                if (e(s[1], n ? s[0] : u, t) === !1) return u + 1
            }
            return u
        }
        return t.__iterateUncached(e, r)
    }

    function P(t, e, r, n) {
        var i = t._cache;
        if (i) {
            var o = i.length - 1,
                u = 0;
            return new S(function() {
                var t = i[r ? o - u : u];
                return u++ > o ? I() : z(e, n ? t[0] : u - 1, t[1])
            })
        }
        return t.__iteratorUncached(e, r)
    }

    function H(t, e) {
        return e ? V(e, t, "", {
            "": t
        }) : Y(t)
    }

    function V(t, e, r, n) {
        return Array.isArray(e) ? t.call(n, r, k(e).map(function(r, n) {
            return V(t, r, n, e)
        })) : Q(e) ? t.call(n, r, x(e).map(function(r, n) {
            return V(t, r, n, e)
        })) : e
    }

    function Y(t) {
        return Array.isArray(t) ? k(t).map(Y).toList() : Q(t) ? x(t).map(Y).toMap() : t
    }

    function Q(t) {
        return t && (t.constructor === Object || void 0 === t.constructor)
    }

    function X(t, e) {
        if (t === e || t !== t && e !== e) return !0;
        if (!t || !e) return !1;
        if ("function" == typeof t.valueOf && "function" == typeof e.valueOf) {
            if (t = t.valueOf(), e = e.valueOf(), t === e || t !== t && e !== e) return !0;
            if (!t || !e) return !1
        }
        return "function" == typeof t.equals && "function" == typeof e.equals && t.equals(e) ? !0 : !1
    }

    function F(t, e) {
        if (t === e) return !0;
        if (!o(e) || void 0 !== t.size && void 0 !== e.size && t.size !== e.size || void 0 !== t.__hash && void 0 !== e.__hash && t.__hash !== e.__hash || u(t) !== u(e) || s(t) !== s(e) || h(t) !== h(e)) return !1;
        if (0 === t.size && 0 === e.size) return !0;
        var r = !a(t);
        if (h(t)) {
            var n = t.entries();
            return e.every(function(t, e) {
                var i = n.next().value;
                return i && X(i[1], t) && (r || X(i[0], e))
            }) && n.next().done
        }
        var i = !1;
        if (void 0 === t.size)
            if (void 0 === e.size) "function" == typeof t.cacheResult && t.cacheResult();
            else {
                i = !0;
                var f = t;
                t = e, e = f
            }
        var c = !0,
            _ = e.__iterate(function(e, n) {
                return (r ? t.has(e) : i ? X(e, t.get(n, yr)) : X(t.get(n, yr), e)) ? void 0 : (c = !1, !1)
            });
        return c && t.size === _
    }

    function G(t, e) {
        if (!(this instanceof G)) return new G(t, e);
        if (this._value = t, this.size = void 0 === e ? 1 / 0 : Math.max(0, e), 0 === this.size) {
            if (Mr) return Mr;
            Mr = this
        }
    }

    function Z(t, e) {
        if (!t) throw Error(e)
    }

    function $(t, e, r) {
        if (!(this instanceof $)) return new $(t, e, r);
        if (Z(0 !== r, "Cannot step a Range by 0"), t = t || 0, void 0 === e && (e = 1 / 0), r = void 0 === r ? 1 : Math.abs(r), t > e && (r = -r), this._start = t, this._end = e, this._step = r, this.size = Math.max(0, Math.ceil((e - t) / r - 1) + 1), 0 === this.size) {
            if (Er) return Er;
            Er = this
        }
    }

    function tt() {
        throw TypeError("Abstract")
    }

    function et() {}

    function rt() {}

    function nt() {}

    function it(t) {
        return t >>> 1 & 1073741824 | 3221225471 & t
    }

    function ot(t) {
        if (t === !1 || null === t || void 0 === t) return 0;
        if ("function" == typeof t.valueOf && (t = t.valueOf(), t === !1 || null === t || void 0 === t)) return 0;
        if (t === !0) return 1;
        var e = typeof t;
        if ("number" === e) {
            if (t !== t || t === 1 / 0) return 0;
            var r = 0 | t;
            for (r !== t && (r ^= 4294967295 * t); t > 4294967295;) t /= 4294967295, r ^= t;
            return it(r)
        }
        if ("string" === e) return t.length > Kr ? ut(t) : st(t);
        if ("function" == typeof t.hashCode) return t.hashCode();
        if ("object" === e) return at(t);
        if ("function" == typeof t.toString) return st("" + t);
        throw Error("Value type " + e + " cannot be hashed.")
    }

    function ut(t) {
        var e = Br[t];
        return void 0 === e && (e = st(t), Tr === Lr && (Tr = 0, Br = {}), Tr++, Br[t] = e), e
    }

    function st(t) {
        for (var e = 0, r = 0; t.length > r; r++) e = 31 * e + t.charCodeAt(r) | 0;
        return it(e)
    }

    function at(t) {
        var e;
        if (jr && (e = Or.get(t), void 0 !== e)) return e;
        if (e = t[Ur], void 0 !== e) return e;
        if (!Ar) {
            if (e = t.propertyIsEnumerable && t.propertyIsEnumerable[Ur], void 0 !== e) return e;
            if (e = ht(t), void 0 !== e) return e
        }
        if (e = ++Rr, 1073741824 & Rr && (Rr = 0), jr) Or.set(t, e);
        else {
            if (void 0 !== kr && kr(t) === !1) throw Error("Non-extensible objects are not allowed as keys.");
            if (Ar) Object.defineProperty(t, Ur, {
                enumerable: !1,
                configurable: !1,
                writable: !1,
                value: e
            });
            else if (void 0 !== t.propertyIsEnumerable && t.propertyIsEnumerable === t.constructor.prototype.propertyIsEnumerable) t.propertyIsEnumerable = function() {
                return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments)
            }, t.propertyIsEnumerable[Ur] = e;
            else {
                if (void 0 === t.nodeType) throw Error("Unable to set a non-enumerable property on object.");
                t[Ur] = e
            }
        }
        return e
    }

    function ht(t) {
        if (t && t.nodeType > 0) switch (t.nodeType) {
            case 1:
                return t.uniqueID;
            case 9:
                return t.documentElement && t.documentElement.uniqueID
        }
    }

    function ft(t) {
        Z(t !== 1 / 0, "Cannot perform this action with an infinite size.")
    }

    function ct(t) {
        return null === t || void 0 === t ? zt() : _t(t) && !h(t) ? t : zt().withMutations(function(e) {
            var n = r(t);
            ft(n.size), n.forEach(function(t, r) {
                return e.set(r, t)
            })
        })
    }

    function _t(t) {
        return !(!t || !t[Wr])
    }

    function pt(t, e) {
        this.ownerID = t, this.entries = e
    }

    function vt(t, e, r) {
        this.ownerID = t, this.bitmap = e, this.nodes = r
    }

    function lt(t, e, r) {
        this.ownerID = t, this.count = e, this.nodes = r
    }

    function yt(t, e, r) {
        this.ownerID = t, this.keyHash = e, this.entries = r
    }

    function dt(t, e, r) {
        this.ownerID = t, this.keyHash = e, this.entry = r
    }

    function mt(t, e, r) {
        this._type = e, this._reverse = r, this._stack = t._root && wt(t._root)
    }

    function gt(t, e) {
        return z(t, e[0], e[1])
    }

    function wt(t, e) {
        return {
            node: t,
            index: 0,
            __prev: e
        }
    }

    function St(t, e, r, n) {
        var i = Object.create(Cr);
        return i.size = t, i._root = e, i.__ownerID = r, i.__hash = n, i.__altered = !1, i
    }

    function zt() {
        return Jr || (Jr = St(0))
    }

    function It(t, e, r) {
        var n, i;
        if (t._root) {
            var o = f(dr),
                u = f(mr);
            if (n = bt(t._root, t.__ownerID, 0, void 0, e, r, o, u), !u.value) return t;
            i = t.size + (o.value ? r === yr ? -1 : 1 : 0)
        } else {
            if (r === yr) return t;
            i = 1, n = new pt(t.__ownerID, [
                [e, r]
            ])
        }
        return t.__ownerID ? (t.size = i, t._root = n, t.__hash = void 0, t.__altered = !0, t) : n ? St(i, n) : zt()
    }

    function bt(t, e, r, n, i, o, u, s) {
        return t ? t.update(e, r, n, i, o, u, s) : o === yr ? t : (c(s), c(u), new dt(e, n, [i, o]))
    }

    function qt(t) {
        return t.constructor === dt || t.constructor === yt
    }

    function Dt(t, e, r, n, i) {
        if (t.keyHash === n) return new yt(e, n, [t.entry, i]);
        var o, u = (0 === r ? t.keyHash : t.keyHash >>> r) & lr,
            s = (0 === r ? n : n >>> r) & lr,
            a = u === s ? [Dt(t, e, r + pr, n, i)] : (o = new dt(e, n, i),
                s > u ? [t, o] : [o, t]);
        return new vt(e, 1 << u | 1 << s, a)
    }

    function Mt(t, e, r, n) {
        t || (t = new _);
        for (var i = new dt(t, ot(r), [r, n]), o = 0; e.length > o; o++) {
            var u = e[o];
            i = i.update(t, 0, void 0, u[0], u[1])
        }
        return i
    }

    function Et(t, e, r, n) {
        for (var i = 0, o = 0, u = Array(r), s = 0, a = 1, h = e.length; h > s; s++, a <<= 1) {
            var f = e[s];
            void 0 !== f && s !== n && (i |= a, u[o++] = f)
        }
        return new vt(t, i, u)
    }

    function Ot(t, e, r, n, i) {
        for (var o = 0, u = Array(vr), s = 0; 0 !== r; s++, r >>>= 1) u[s] = 1 & r ? e[o++] : void 0;
        return u[n] = i, new lt(t, o + 1, u)
    }

    function xt(t, e, n) {
        for (var i = [], u = 0; n.length > u; u++) {
            var s = n[u],
                a = r(s);
            o(s) || (a = a.map(function(t) {
                return H(t)
            })), i.push(a)
        }
        return jt(t, e, i)
    }

    function kt(t, e, r) {
        return t && t.mergeDeep && o(e) ? t.mergeDeep(e) : X(t, e) ? t : e
    }

    function At(t) {
        return function(e, r, n) {
            if (e && e.mergeDeepWith && o(r)) return e.mergeDeepWith(t, r);
            var i = t(e, r, n);
            return X(e, i) ? e : i
        }
    }

    function jt(t, e, r) {
        return r = r.filter(function(t) {
            return 0 !== t.size
        }), 0 === r.length ? t : 0 !== t.size || t.__ownerID || 1 !== r.length ? t.withMutations(function(t) {
            for (var n = e ? function(r, n) {
                    t.update(n, yr, function(t) {
                        return t === yr ? r : e(t, r, n)
                    })
                } : function(e, r) {
                    t.set(r, e)
                }, i = 0; r.length > i; i++) r[i].forEach(n)
        }) : t.constructor(r[0])
    }

    function Rt(t, e, r, n) {
        var i = t === yr,
            o = e.next();
        if (o.done) {
            var u = i ? r : t,
                s = n(u);
            return s === u ? t : s
        }
        Z(i || t && t.set, "invalid keyPath");
        var a = o.value,
            h = i ? yr : t.get(a, yr),
            f = Rt(h, e, r, n);
        return f === h ? t : f === yr ? t.remove(a) : (i ? zt() : t).set(a, f)
    }

    function Ut(t) {
        return t -= t >> 1 & 1431655765, t = (858993459 & t) + (t >> 2 & 858993459), t = t + (t >> 4) & 252645135, t += t >> 8, t += t >> 16, 127 & t
    }

    function Kt(t, e, r, n) {
        var i = n ? t : p(t);
        return i[e] = r, i
    }

    function Lt(t, e, r, n) {
        var i = t.length + 1;
        if (n && e + 1 === i) return t[e] = r, t;
        for (var o = Array(i), u = 0, s = 0; i > s; s++) s === e ? (o[s] = r, u = -1) : o[s] = t[s + u];
        return o
    }

    function Tt(t, e, r) {
        var n = t.length - 1;
        if (r && e === n) return t.pop(), t;
        for (var i = Array(n), o = 0, u = 0; n > u; u++) u === e && (o = 1), i[u] = t[u + o];
        return i
    }

    function Bt(t) {
        var e = Pt();
        if (null === t || void 0 === t) return e;
        if (Wt(t)) return t;
        var r = n(t),
            i = r.size;
        return 0 === i ? e : (ft(i), i > 0 && vr > i ? Nt(0, i, pr, null, new Ct(r.toArray())) : e.withMutations(function(t) {
            t.setSize(i), r.forEach(function(e, r) {
                return t.set(r, e)
            })
        }))
    }

    function Wt(t) {
        return !(!t || !t[Vr])
    }

    function Ct(t, e) {
        this.array = t, this.ownerID = e
    }

    function Jt(t, e) {
        function r(t, e, r) {
            return 0 === e ? n(t, r) : i(t, e, r)
        }

        function n(t, r) {
            var n = r === s ? a && a.array : t && t.array,
                i = r > o ? 0 : o - r,
                h = u - r;
            return h > vr && (h = vr),
                function() {
                    if (i === h) return Xr;
                    var t = e ? --h : i++;
                    return n && n[t]
                }
        }

        function i(t, n, i) {
            var s, a = t && t.array,
                h = i > o ? 0 : o - i >> n,
                f = (u - i >> n) + 1;
            return f > vr && (f = vr),
                function() {
                    for (;;) {
                        if (s) {
                            var t = s();
                            if (t !== Xr) return t;
                            s = null
                        }
                        if (h === f) return Xr;
                        var o = e ? --f : h++;
                        s = r(a && a[o], n - pr, i + (o << n))
                    }
                }
        }
        var o = t._origin,
            u = t._capacity,
            s = Gt(u),
            a = t._tail;
        return r(t._root, t._level, 0)
    }

    function Nt(t, e, r, n, i, o, u) {
        var s = Object.create(Yr);
        return s.size = e - t, s._origin = t, s._capacity = e, s._level = r, s._root = n, s._tail = i, s.__ownerID = o, s.__hash = u, s.__altered = !1, s
    }

    function Pt() {
        return Qr || (Qr = Nt(0, 0, pr))
    }

    function Ht(t, e, r) {
        if (e = l(t, e), e !== e) return t;
        if (e >= t.size || 0 > e) return t.withMutations(function(t) {
            0 > e ? Xt(t, e).set(0, r) : Xt(t, 0, e + 1).set(e, r)
        });
        e += t._origin;
        var n = t._tail,
            i = t._root,
            o = f(mr);
        return e >= Gt(t._capacity) ? n = Vt(n, t.__ownerID, 0, e, r, o) : i = Vt(i, t.__ownerID, t._level, e, r, o), o.value ? t.__ownerID ? (t._root = i, t._tail = n, t.__hash = void 0, t.__altered = !0, t) : Nt(t._origin, t._capacity, t._level, i, n) : t
    }

    function Vt(t, e, r, n, i, o) {
        var u = n >>> r & lr,
            s = t && t.array.length > u;
        if (!s && void 0 === i) return t;
        var a;
        if (r > 0) {
            var h = t && t.array[u],
                f = Vt(h, e, r - pr, n, i, o);
            return f === h ? t : (a = Yt(t, e), a.array[u] = f, a)
        }
        return s && t.array[u] === i ? t : (c(o), a = Yt(t, e), void 0 === i && u === a.array.length - 1 ? a.array.pop() : a.array[u] = i, a)
    }

    function Yt(t, e) {
        return e && t && e === t.ownerID ? t : new Ct(t ? t.array.slice() : [], e)
    }

    function Qt(t, e) {
        if (e >= Gt(t._capacity)) return t._tail;
        if (1 << t._level + pr > e) {
            for (var r = t._root, n = t._level; r && n > 0;) r = r.array[e >>> n & lr], n -= pr;
            return r
        }
    }

    function Xt(t, e, r) {
        void 0 !== e && (e = 0 | e), void 0 !== r && (r = 0 | r);
        var n = t.__ownerID || new _,
            i = t._origin,
            o = t._capacity,
            u = i + e,
            s = void 0 === r ? o : 0 > r ? o + r : i + r;
        if (u === i && s === o) return t;
        if (u >= s) return t.clear();
        for (var a = t._level, h = t._root, f = 0; 0 > u + f;) h = new Ct(h && h.array.length ? [void 0, h] : [], n), a += pr, f += 1 << a;
        f && (u += f, i += f, s += f, o += f);
        for (var c = Gt(o), p = Gt(s); p >= 1 << a + pr;) h = new Ct(h && h.array.length ? [h] : [], n),
            a += pr;
        var v = t._tail,
            l = c > p ? Qt(t, s - 1) : p > c ? new Ct([], n) : v;
        if (v && p > c && o > u && v.array.length) {
            h = Yt(h, n);
            for (var y = h, d = a; d > pr; d -= pr) {
                var m = c >>> d & lr;
                y = y.array[m] = Yt(y.array[m], n)
            }
            y.array[c >>> pr & lr] = v
        }
        if (o > s && (l = l && l.removeAfter(n, 0, s)), u >= p) u -= p, s -= p, a = pr, h = null, l = l && l.removeBefore(n, 0, u);
        else if (u > i || c > p) {
            for (f = 0; h;) {
                var g = u >>> a & lr;
                if (g !== p >>> a & lr) break;
                g && (f += (1 << a) * g), a -= pr, h = h.array[g]
            }
            h && u > i && (h = h.removeBefore(n, a, u - f)), h && c > p && (h = h.removeAfter(n, a, p - f)), f && (u -= f, s -= f)
        }
        return t.__ownerID ? (t.size = s - u, t._origin = u, t._capacity = s, t._level = a, t._root = h, t._tail = l, t.__hash = void 0, t.__altered = !0, t) : Nt(u, s, a, h, l)
    }

    function Ft(t, e, r) {
        for (var i = [], u = 0, s = 0; r.length > s; s++) {
            var a = r[s],
                h = n(a);
            h.size > u && (u = h.size), o(a) || (h = h.map(function(t) {
                return H(t)
            })), i.push(h)
        }
        return u > t.size && (t = t.setSize(u)), jt(t, e, i)
    }

    function Gt(t) {
        return vr > t ? 0 : t - 1 >>> pr << pr
    }

    function Zt(t) {
        return null === t || void 0 === t ? ee() : $t(t) ? t : ee().withMutations(function(e) {
            var n = r(t);
            ft(n.size), n.forEach(function(t, r) {
                return e.set(r, t)
            })
        })
    }

    function $t(t) {
        return _t(t) && h(t)
    }

    function te(t, e, r, n) {
        var i = Object.create(Zt.prototype);
        return i.size = t ? t.size : 0, i._map = t, i._list = e, i.__ownerID = r, i.__hash = n, i
    }

    function ee() {
        return Fr || (Fr = te(zt(), Pt()))
    }

    function re(t, e, r) {
        var n, i, o = t._map,
            u = t._list,
            s = o.get(e),
            a = void 0 !== s;
        if (r === yr) {
            if (!a) return t;
            u.size >= vr && u.size >= 2 * o.size ? (i = u.filter(function(t, e) {
                return void 0 !== t && s !== e
            }), n = i.toKeyedSeq().map(function(t) {
                return t[0]
            }).flip().toMap(), t.__ownerID && (n.__ownerID = i.__ownerID = t.__ownerID)) : (n = o.remove(e), i = s === u.size - 1 ? u.pop() : u.set(s, void 0))
        } else if (a) {
            if (r === u.get(s)[1]) return t;
            n = o, i = u.set(s, [e, r])
        } else n = o.set(e, u.size), i = u.set(u.size, [e, r]);
        return t.__ownerID ? (t.size = n.size, t._map = n, t._list = i, t.__hash = void 0, t) : te(n, i)
    }

    function ne(t, e) {
        this._iter = t, this._useKeys = e, this.size = t.size
    }

    function ie(t) {
        this._iter = t, this.size = t.size
    }

    function oe(t) {
        this._iter = t, this.size = t.size
    }

    function ue(t) {
        this._iter = t, this.size = t.size
    }

    function se(t) {
        var e = Ee(t);
        return e._iter = t, e.size = t.size, e.flip = function() {
            return t
        }, e.reverse = function() {
            var e = t.reverse.apply(this);
            return e.flip = function() {
                return t.reverse()
            }, e
        }, e.has = function(e) {
            return t.includes(e)
        }, e.includes = function(e) {
            return t.has(e)
        }, e.cacheResult = Oe, e.__iterateUncached = function(e, r) {
            var n = this;
            return t.__iterate(function(t, r) {
                return e(r, t, n) !== !1
            }, r)
        }, e.__iteratorUncached = function(e, r) {
            if (e === Sr) {
                var n = t.__iterator(e, r);
                return new S(function() {
                    var t = n.next();
                    if (!t.done) {
                        var e = t.value[0];
                        t.value[0] = t.value[1], t.value[1] = e
                    }
                    return t
                })
            }
            return t.__iterator(e === wr ? gr : wr, r)
        }, e
    }

    function ae(t, e, r) {
        var n = Ee(t);
        return n.size = t.size, n.has = function(e) {
            return t.has(e)
        }, n.get = function(n, i) {
            var o = t.get(n, yr);
            return o === yr ? i : e.call(r, o, n, t)
        }, n.__iterateUncached = function(n, i) {
            var o = this;
            return t.__iterate(function(t, i, u) {
                return n(e.call(r, t, i, u), i, o) !== !1
            }, i)
        }, n.__iteratorUncached = function(n, i) {
            var o = t.__iterator(Sr, i);
            return new S(function() {
                var i = o.next();
                if (i.done) return i;
                var u = i.value,
                    s = u[0];
                return z(n, s, e.call(r, u[1], s, t), i)
            })
        }, n
    }

    function he(t, e) {
        var r = Ee(t);
        return r._iter = t, r.size = t.size, r.reverse = function() {
            return t
        }, t.flip && (r.flip = function() {
            var e = se(t);
            return e.reverse = function() {
                return t.flip()
            }, e
        }), r.get = function(r, n) {
            return t.get(e ? r : -1 - r, n)
        }, r.has = function(r) {
            return t.has(e ? r : -1 - r)
        }, r.includes = function(e) {
            return t.includes(e)
        }, r.cacheResult = Oe, r.__iterate = function(e, r) {
            var n = this;
            return t.__iterate(function(t, r) {
                return e(t, r, n)
            }, !r)
        }, r.__iterator = function(e, r) {
            return t.__iterator(e, !r)
        }, r
    }

    function fe(t, e, r, n) {
        var i = Ee(t);
        return n && (i.has = function(n) {
            var i = t.get(n, yr);
            return i !== yr && !!e.call(r, i, n, t)
        }, i.get = function(n, i) {
            var o = t.get(n, yr);
            return o !== yr && e.call(r, o, n, t) ? o : i
        }), i.__iterateUncached = function(i, o) {
            var u = this,
                s = 0;
            return t.__iterate(function(t, o, a) {
                return e.call(r, t, o, a) ? (s++, i(t, n ? o : s - 1, u)) : void 0
            }, o), s
        }, i.__iteratorUncached = function(i, o) {
            var u = t.__iterator(Sr, o),
                s = 0;
            return new S(function() {
                for (;;) {
                    var o = u.next();
                    if (o.done) return o;
                    var a = o.value,
                        h = a[0],
                        f = a[1];
                    if (e.call(r, f, h, t)) return z(i, n ? h : s++, f, o)
                }
            })
        }, i
    }

    function ce(t, e, r) {
        var n = ct().asMutable();
        return t.__iterate(function(i, o) {
            n.update(e.call(r, i, o, t), 0, function(t) {
                return t + 1
            })
        }), n.asImmutable()
    }

    function _e(t, e, r) {
        var n = u(t),
            i = (h(t) ? Zt() : ct()).asMutable();
        t.__iterate(function(o, u) {
            i.update(e.call(r, o, u, t), function(t) {
                return t = t || [], t.push(n ? [u, o] : o), t
            })
        });
        var o = Me(t);
        return i.map(function(e) {
            return be(t, o(e))
        })
    }

    function pe(t, e, r, n) {
        var i = t.size;
        if (void 0 !== e && (e = 0 | e), void 0 !== r && (r = r === 1 / 0 ? i : 0 | r), d(e, r, i)) return t;
        var o = m(e, i),
            u = g(r, i);
        if (o !== o || u !== u) return pe(t.toSeq().cacheResult(), e, r, n);
        var s, a = u - o;
        a === a && (s = 0 > a ? 0 : a);
        var h = Ee(t);
        return h.size = 0 === s ? s : t.size && s || void 0, !n && L(t) && s >= 0 && (h.get = function(e, r) {
            return e = l(this, e), e >= 0 && s > e ? t.get(e + o, r) : r
        }), h.__iterateUncached = function(e, r) {
            var i = this;
            if (0 === s) return 0;
            if (r) return this.cacheResult().__iterate(e, r);
            var u = 0,
                a = !0,
                h = 0;
            return t.__iterate(function(t, r) {
                return a && (a = u++ < o) ? void 0 : (h++, e(t, n ? r : h - 1, i) !== !1 && h !== s)
            }), h
        }, h.__iteratorUncached = function(e, r) {
            if (0 !== s && r) return this.cacheResult().__iterator(e, r);
            var i = 0 !== s && t.__iterator(e, r),
                u = 0,
                a = 0;
            return new S(function() {
                for (; u++ < o;) i.next();
                if (++a > s) return I();
                var t = i.next();
                return n || e === wr ? t : e === gr ? z(e, a - 1, void 0, t) : z(e, a - 1, t.value[1], t)
            })
        }, h
    }

    function ve(t, e, r) {
        var n = Ee(t);
        return n.__iterateUncached = function(n, i) {
            var o = this;
            if (i) return this.cacheResult().__iterate(n, i);
            var u = 0;
            return t.__iterate(function(t, i, s) {
                return e.call(r, t, i, s) && ++u && n(t, i, o)
            }), u
        }, n.__iteratorUncached = function(n, i) {
            var o = this;
            if (i) return this.cacheResult().__iterator(n, i);
            var u = t.__iterator(Sr, i),
                s = !0;
            return new S(function() {
                if (!s) return I();
                var t = u.next();
                if (t.done) return t;
                var i = t.value,
                    a = i[0],
                    h = i[1];
                return e.call(r, h, a, o) ? n === Sr ? t : z(n, a, h, t) : (s = !1, I())
            })
        }, n
    }

    function le(t, e, r, n) {
        var i = Ee(t);
        return i.__iterateUncached = function(i, o) {
            var u = this;
            if (o) return this.cacheResult().__iterate(i, o);
            var s = !0,
                a = 0;
            return t.__iterate(function(t, o, h) {
                return s && (s = e.call(r, t, o, h)) ? void 0 : (a++, i(t, n ? o : a - 1, u))
            }), a
        }, i.__iteratorUncached = function(i, o) {
            var u = this;
            if (o) return this.cacheResult().__iterator(i, o);
            var s = t.__iterator(Sr, o),
                a = !0,
                h = 0;
            return new S(function() {
                var t, o, f;
                do {
                    if (t = s.next(), t.done) return n || i === wr ? t : i === gr ? z(i, h++, void 0, t) : z(i, h++, t.value[1], t);
                    var c = t.value;
                    o = c[0], f = c[1], a && (a = e.call(r, f, o, u))
                } while (a);
                return i === Sr ? t : z(i, o, f, t)
            })
        }, i
    }

    function ye(t, e) {
        var n = u(t),
            i = [t].concat(e).map(function(t) {
                return o(t) ? n && (t = r(t)) : t = n ? B(t) : W(Array.isArray(t) ? t : [t]), t
            }).filter(function(t) {
                return 0 !== t.size
            });
        if (0 === i.length) return t;
        if (1 === i.length) {
            var a = i[0];
            if (a === t || n && u(a) || s(t) && s(a)) return a
        }
        var h = new j(i);
        return n ? h = h.toKeyedSeq() : s(t) || (h = h.toSetSeq()), h = h.flatten(!0), h.size = i.reduce(function(t, e) {
            if (void 0 !== t) {
                var r = e.size;
                if (void 0 !== r) return t + r
            }
        }, 0), h
    }

    function de(t, e, r) {
        var n = Ee(t);
        return n.__iterateUncached = function(n, i) {
            function u(t, h) {
                var f = this;
                t.__iterate(function(t, i) {
                    return (!e || e > h) && o(t) ? u(t, h + 1) : n(t, r ? i : s++, f) === !1 && (a = !0), !a
                }, i)
            }
            var s = 0,
                a = !1;
            return u(t, 0), s
        }, n.__iteratorUncached = function(n, i) {
            var u = t.__iterator(n, i),
                s = [],
                a = 0;
            return new S(function() {
                for (; u;) {
                    var t = u.next();
                    if (t.done === !1) {
                        var h = t.value;
                        if (n === Sr && (h = h[1]), e && !(e > s.length) || !o(h)) return r ? t : z(n, a++, h, t);
                        s.push(u), u = h.__iterator(n, i)
                    } else u = s.pop()
                }
                return I()
            })
        }, n
    }

    function me(t, e, r) {
        var n = Me(t);
        return t.toSeq().map(function(i, o) {
            return n(e.call(r, i, o, t))
        }).flatten(!0)
    }

    function ge(t, e) {
        var r = Ee(t);
        return r.size = t.size && 2 * t.size - 1, r.__iterateUncached = function(r, n) {
            var i = this,
                o = 0;
            return t.__iterate(function(t, n) {
                return (!o || r(e, o++, i) !== !1) && r(t, o++, i) !== !1
            }, n), o
        }, r.__iteratorUncached = function(r, n) {
            var i, o = t.__iterator(wr, n),
                u = 0;
            return new S(function() {
                return (!i || u % 2) && (i = o.next(), i.done) ? i : u % 2 ? z(r, u++, e) : z(r, u++, i.value, i)
            })
        }, r
    }

    function we(t, e, r) {
        e || (e = xe);
        var n = u(t),
            i = 0,
            o = t.toSeq().map(function(e, n) {
                return [n, e, i++, r ? r(e, n, t) : e]
            }).toArray();
        return o.sort(function(t, r) {
            return e(t[3], r[3]) || t[2] - r[2]
        }).forEach(n ? function(t, e) {
            o[e].length = 2
        } : function(t, e) {
            o[e] = t[1]
        }), n ? x(o) : s(t) ? k(o) : A(o)
    }

    function Se(t, e, r) {
        if (e || (e = xe), r) {
            var n = t.toSeq().map(function(e, n) {
                return [e, r(e, n, t)]
            }).reduce(function(t, r) {
                return ze(e, t[1], r[1]) ? r : t
            });
            return n && n[0]
        }
        return t.reduce(function(t, r) {
            return ze(e, t, r) ? r : t
        })
    }

    function ze(t, e, r) {
        var n = t(r, e);
        return 0 === n && r !== e && (void 0 === r || null === r || r !== r) || n > 0
    }

    function Ie(t, r, n) {
        var i = Ee(t);
        return i.size = new j(n).map(function(t) {
            return t.size
        }).min(), i.__iterate = function(t, e) {
            for (var r, n = this.__iterator(wr, e), i = 0; !(r = n.next()).done && t(r.value, i++, this) !== !1;);
            return i
        }, i.__iteratorUncached = function(t, i) {
            var o = n.map(function(t) {
                    return t = e(t), D(i ? t.reverse() : t)
                }),
                u = 0,
                s = !1;
            return new S(function() {
                var e;
                return s || (e = o.map(function(t) {
                    return t.next()
                }), s = e.some(function(t) {
                    return t.done
                })), s ? I() : z(t, u++, r.apply(null, e.map(function(t) {
                    return t.value
                })))
            })
        }, i
    }

    function be(t, e) {
        return L(t) ? e : t.constructor(e)
    }

    function qe(t) {
        if (t !== Object(t)) throw new TypeError("Expected [K, V] tuple: " + t)
    }

    function De(t) {
        return ft(t.size), v(t)
    }

    function Me(t) {
        return u(t) ? r : s(t) ? n : i
    }

    function Ee(t) {
        return Object.create((u(t) ? x : s(t) ? k : A).prototype)
    }

    function Oe() {
        return this._iter.cacheResult ? (this._iter.cacheResult(), this.size = this._iter.size, this) : O.prototype.cacheResult.call(this)
    }

    function xe(t, e) {
        return t > e ? 1 : e > t ? -1 : 0
    }

    function ke(t) {
        var r = D(t);
        if (!r) {
            if (!E(t)) throw new TypeError("Expected iterable or array-like: " + t);
            r = D(e(t))
        }
        return r
    }

    function Ae(t, e) {
        var r, n = function(o) {
                if (o instanceof n) return o;
                if (!(this instanceof n)) return new n(o);
                if (!r) {
                    r = !0;
                    var u = Object.keys(t);
                    Ue(i, u), i.size = u.length, i._name = e, i._keys = u, i._defaultValues = t
                }
                this._map = ct(o)
            },
            i = n.prototype = Object.create(Gr);
        return i.constructor = n, n
    }

    function je(t, e, r) {
        var n = Object.create(Object.getPrototypeOf(t));
        return n._map = e, n.__ownerID = r, n
    }

    function Re(t) {
        return t._name || t.constructor.name || "Record"
    }

    function Ue(t, e) {
        try {
            e.forEach(Ke.bind(void 0, t))
        } catch (r) {}
    }

    function Ke(t, e) {
        Object.defineProperty(t, e, {
            get: function() {
                return this.get(e)
            },
            set: function(t) {
                Z(this.__ownerID, "Cannot set on an immutable record."), this.set(e, t)
            }
        })
    }

    function Le(t) {
        return null === t || void 0 === t ? Ce() : Te(t) && !h(t) ? t : Ce().withMutations(function(e) {
            var r = i(t);
            ft(r.size), r.forEach(function(t) {
                return e.add(t)
            })
        })
    }

    function Te(t) {
        return !(!t || !t[Zr])
    }

    function Be(t, e) {
        return t.__ownerID ? (t.size = e.size, t._map = e, t) : e === t._map ? t : 0 === e.size ? t.__empty() : t.__make(e)
    }

    function We(t, e) {
        var r = Object.create($r);
        return r.size = t ? t.size : 0, r._map = t, r.__ownerID = e, r
    }

    function Ce() {
        return tn || (tn = We(zt()))
    }

    function Je(t) {
        return null === t || void 0 === t ? He() : Ne(t) ? t : He().withMutations(function(e) {
            var r = i(t);
            ft(r.size), r.forEach(function(t) {
                return e.add(t)
            })
        })
    }

    function Ne(t) {
        return Te(t) && h(t)
    }

    function Pe(t, e) {
        var r = Object.create(en);
        return r.size = t ? t.size : 0, r._map = t, r.__ownerID = e, r
    }

    function He() {
        return rn || (rn = Pe(ee()))
    }

    function Ve(t) {
        return null === t || void 0 === t ? Xe() : Ye(t) ? t : Xe().unshiftAll(t)
    }

    function Ye(t) {
        return !(!t || !t[nn])
    }

    function Qe(t, e, r, n) {
        var i = Object.create(on);
        return i.size = t, i._head = e, i.__ownerID = r, i.__hash = n, i.__altered = !1, i
    }

    function Xe() {
        return un || (un = Qe(0))
    }

    function Fe(t, e) {
        var r = function(r) {
            t.prototype[r] = e[r]
        };
        return Object.keys(e).forEach(r), Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(e).forEach(r), t
    }

    function Ge(t, e) {
        return e
    }

    function Ze(t, e) {
        return [e, t]
    }

    function $e(t) {
        return function() {
            return !t.apply(this, arguments)
        }
    }

    function tr(t) {
        return function() {
            return -t.apply(this, arguments)
        }
    }

    function er(t) {
        return "string" == typeof t ? JSON.stringify(t) : t + ""
    }

    function rr() {
        return p(arguments)
    }

    function nr(t, e) {
        return e > t ? 1 : t > e ? -1 : 0
    }

    function ir(t) {
        if (t.size === 1 / 0) return 0;
        var e = h(t),
            r = u(t),
            n = e ? 1 : 0,
            i = t.__iterate(r ? e ? function(t, e) {
                n = 31 * n + ur(ot(t), ot(e)) | 0
            } : function(t, e) {
                n = n + ur(ot(t), ot(e)) | 0
            } : e ? function(t) {
                n = 31 * n + ot(t) | 0
            } : function(t) {
                n = n + ot(t) | 0
            });
        return or(i, n)
    }

    function or(t, e) {
        return e = xr(e, 3432918353), e = xr(e << 15 | e >>> -15, 461845907), e = xr(e << 13 | e >>> -13, 5), e = (e + 3864292196 | 0) ^ t, e = xr(e ^ e >>> 16, 2246822507), e = xr(e ^ e >>> 13, 3266489909), e = it(e ^ e >>> 16)
    }

    function ur(t, e) {
        return t ^ e + 2654435769 + (t << 6) + (t >> 2) | 0
    }
    var sr = Array.prototype.slice;
    t(r, e), t(n, e), t(i, e), e.isIterable = o, e.isKeyed = u, e.isIndexed = s, e.isAssociative = a, e.isOrdered = h, e.Keyed = r, e.Indexed = n, e.Set = i;
    var ar = "@@__IMMUTABLE_ITERABLE__@@",
        hr = "@@__IMMUTABLE_KEYED__@@",
        fr = "@@__IMMUTABLE_INDEXED__@@",
        cr = "@@__IMMUTABLE_ORDERED__@@",
        _r = "delete",
        pr = 5,
        vr = 1 << pr,
        lr = vr - 1,
        yr = {},
        dr = {
            value: !1
        },
        mr = {
            value: !1
        },
        gr = 0,
        wr = 1,
        Sr = 2,
        zr = "function" == typeof Symbol && Symbol.iterator,
        Ir = "@@iterator",
        br = zr || Ir;
    S.prototype.toString = function() {
        return "[Iterator]"
    }, S.KEYS = gr, S.VALUES = wr, S.ENTRIES = Sr, S.prototype.inspect = S.prototype.toSource = function() {
        return "" + this
    }, S.prototype[br] = function() {
        return this
    }, t(O, e), O.of = function() {
        return O(arguments)
    }, O.prototype.toSeq = function() {
        return this
    }, O.prototype.toString = function() {
        return this.__toString("Seq {", "}")
    }, O.prototype.cacheResult = function() {
        return !this._cache && this.__iterateUncached && (this._cache = this.entrySeq().toArray(), this.size = this._cache.length), this
    }, O.prototype.__iterate = function(t, e) {
        return N(this, t, e, !0)
    }, O.prototype.__iterator = function(t, e) {
        return P(this, t, e, !0)
    }, t(x, O), x.prototype.toKeyedSeq = function() {
        return this
    }, t(k, O), k.of = function() {
        return k(arguments)
    }, k.prototype.toIndexedSeq = function() {
        return this
    }, k.prototype.toString = function() {
        return this.__toString("Seq [", "]")
    }, k.prototype.__iterate = function(t, e) {
        return N(this, t, e, !1)
    }, k.prototype.__iterator = function(t, e) {
        return P(this, t, e, !1)
    }, t(A, O), A.of = function() {
        return A(arguments)
    }, A.prototype.toSetSeq = function() {
        return this
    }, O.isSeq = L, O.Keyed = x, O.Set = A, O.Indexed = k;
    var qr = "@@__IMMUTABLE_SEQ__@@";
    O.prototype[qr] = !0, t(j, k), j.prototype.get = function(t, e) {
        return this.has(t) ? this._array[l(this, t)] : e
    }, j.prototype.__iterate = function(t, e) {
        for (var r = this._array, n = r.length - 1, i = 0; n >= i; i++)
            if (t(r[e ? n - i : i], i, this) === !1) return i + 1;
        return i
    }, j.prototype.__iterator = function(t, e) {
        var r = this._array,
            n = r.length - 1,
            i = 0;
        return new S(function() {
            return i > n ? I() : z(t, i, r[e ? n - i++ : i++])
        })
    }, t(R, x), R.prototype.get = function(t, e) {
        return void 0 === e || this.has(t) ? this._object[t] : e
    }, R.prototype.has = function(t) {
        return this._object.hasOwnProperty(t)
    }, R.prototype.__iterate = function(t, e) {
        for (var r = this._object, n = this._keys, i = n.length - 1, o = 0; i >= o; o++) {
            var u = n[e ? i - o : o];
            if (t(r[u], u, this) === !1) return o + 1
        }
        return o
    }, R.prototype.__iterator = function(t, e) {
        var r = this._object,
            n = this._keys,
            i = n.length - 1,
            o = 0;
        return new S(function() {
            var u = n[e ? i - o : o];
            return o++ > i ? I() : z(t, u, r[u])
        })
    }, R.prototype[cr] = !0, t(U, k), U.prototype.__iterateUncached = function(t, e) {
        if (e) return this.cacheResult().__iterate(t, e);
        var r = this._iterable,
            n = D(r),
            i = 0;
        if (q(n))
            for (var o; !(o = n.next()).done && t(o.value, i++, this) !== !1;);
        return i
    }, U.prototype.__iteratorUncached = function(t, e) {
        if (e) return this.cacheResult().__iterator(t, e);
        var r = this._iterable,
            n = D(r);
        if (!q(n)) return new S(I);
        var i = 0;
        return new S(function() {
            var e = n.next();
            return e.done ? e : z(t, i++, e.value)
        })
    }, t(K, k), K.prototype.__iterateUncached = function(t, e) {
        if (e) return this.cacheResult().__iterate(t, e);
        for (var r = this._iterator, n = this._iteratorCache, i = 0; n.length > i;)
            if (t(n[i], i++, this) === !1) return i;
        for (var o; !(o = r.next()).done;) {
            var u = o.value;
            if (n[i] = u, t(u, i++, this) === !1) break
        }
        return i
    }, K.prototype.__iteratorUncached = function(t, e) {
        if (e) return this.cacheResult().__iterator(t, e);
        var r = this._iterator,
            n = this._iteratorCache,
            i = 0;
        return new S(function() {
            if (i >= n.length) {
                var e = r.next();
                if (e.done) return e;
                n[i] = e.value
            }
            return z(t, i, n[i++])
        })
    };
    var Dr;
    t(G, k), G.prototype.toString = function() {
        return 0 === this.size ? "Repeat []" : "Repeat [ " + this._value + " " + this.size + " times ]"
    }, G.prototype.get = function(t, e) {
        return this.has(t) ? this._value : e
    }, G.prototype.includes = function(t) {
        return X(this._value, t)
    }, G.prototype.slice = function(t, e) {
        var r = this.size;
        return d(t, e, r) ? this : new G(this._value, g(e, r) - m(t, r))
    }, G.prototype.reverse = function() {
        return this
    }, G.prototype.indexOf = function(t) {
        return X(this._value, t) ? 0 : -1
    }, G.prototype.lastIndexOf = function(t) {
        return X(this._value, t) ? this.size : -1
    }, G.prototype.__iterate = function(t, e) {
        for (var r = 0; this.size > r; r++)
            if (t(this._value, r, this) === !1) return r + 1;
        return r
    }, G.prototype.__iterator = function(t, e) {
        var r = this,
            n = 0;
        return new S(function() {
            return r.size > n ? z(t, n++, r._value) : I()
        })
    }, G.prototype.equals = function(t) {
        return t instanceof G ? X(this._value, t._value) : F(t)
    };
    var Mr;
    t($, k), $.prototype.toString = function() {
        return 0 === this.size ? "Range []" : "Range [ " + this._start + "..." + this._end + (1 !== this._step ? " by " + this._step : "") + " ]"
    }, $.prototype.get = function(t, e) {
        return this.has(t) ? this._start + l(this, t) * this._step : e
    }, $.prototype.includes = function(t) {
        var e = (t - this._start) / this._step;
        return e >= 0 && this.size > e && e === Math.floor(e);
    }, $.prototype.slice = function(t, e) {
        return d(t, e, this.size) ? this : (t = m(t, this.size), e = g(e, this.size), t >= e ? new $(0, 0) : new $(this.get(t, this._end), this.get(e, this._end), this._step))
    }, $.prototype.indexOf = function(t) {
        var e = t - this._start;
        if (e % this._step === 0) {
            var r = e / this._step;
            if (r >= 0 && this.size > r) return r
        }
        return -1
    }, $.prototype.lastIndexOf = function(t) {
        return this.indexOf(t)
    }, $.prototype.__iterate = function(t, e) {
        for (var r = this.size - 1, n = this._step, i = e ? this._start + r * n : this._start, o = 0; r >= o; o++) {
            if (t(i, o, this) === !1) return o + 1;
            i += e ? -n : n
        }
        return o
    }, $.prototype.__iterator = function(t, e) {
        var r = this.size - 1,
            n = this._step,
            i = e ? this._start + r * n : this._start,
            o = 0;
        return new S(function() {
            var u = i;
            return i += e ? -n : n, o > r ? I() : z(t, o++, u)
        })
    }, $.prototype.equals = function(t) {
        return t instanceof $ ? this._start === t._start && this._end === t._end && this._step === t._step : F(this, t)
    };
    var Er;
    t(tt, e), t(et, tt), t(rt, tt), t(nt, tt), tt.Keyed = et, tt.Indexed = rt, tt.Set = nt;
    var Or, xr = "function" == typeof Math.imul && -2 === Math.imul(4294967295, 2) ? Math.imul : function(t, e) {
            t = 0 | t, e = 0 | e;
            var r = 65535 & t,
                n = 65535 & e;
            return r * n + ((t >>> 16) * n + r * (e >>> 16) << 16 >>> 0) | 0
        },
        kr = Object.isExtensible,
        Ar = function() {
            try {
                return Object.defineProperty({}, "@", {}), !0
            } catch (t) {
                return !1
            }
        }(),
        jr = "function" == typeof WeakMap;
    jr && (Or = new WeakMap);
    var Rr = 0,
        Ur = "__immutablehash__";
    "function" == typeof Symbol && (Ur = Symbol(Ur));
    var Kr = 16,
        Lr = 255,
        Tr = 0,
        Br = {};
    t(ct, et), ct.of = function() {
        var t = sr.call(arguments, 0);
        return zt().withMutations(function(e) {
            for (var r = 0; t.length > r; r += 2) {
                if (r + 1 >= t.length) throw Error("Missing value for key: " + t[r]);
                e.set(t[r], t[r + 1])
            }
        })
    }, ct.prototype.toString = function() {
        return this.__toString("Map {", "}")
    }, ct.prototype.get = function(t, e) {
        return this._root ? this._root.get(0, void 0, t, e) : e
    }, ct.prototype.set = function(t, e) {
        return It(this, t, e)
    }, ct.prototype.setIn = function(t, e) {
        return this.updateIn(t, yr, function() {
            return e
        })
    }, ct.prototype.remove = function(t) {
        return It(this, t, yr)
    }, ct.prototype.deleteIn = function(t) {
        return this.updateIn(t, function() {
            return yr
        })
    }, ct.prototype.update = function(t, e, r) {
        return 1 === arguments.length ? t(this) : this.updateIn([t], e, r);
    }, ct.prototype.updateIn = function(t, e, r) {
        r || (r = e, e = void 0);
        var n = Rt(this, ke(t), e, r);
        return n === yr ? void 0 : n
    }, ct.prototype.clear = function() {
        return 0 === this.size ? this : this.__ownerID ? (this.size = 0, this._root = null, this.__hash = void 0, this.__altered = !0, this) : zt()
    }, ct.prototype.merge = function() {
        return xt(this, void 0, arguments)
    }, ct.prototype.mergeWith = function(t) {
        var e = sr.call(arguments, 1);
        return xt(this, t, e)
    }, ct.prototype.mergeIn = function(t) {
        var e = sr.call(arguments, 1);
        return this.updateIn(t, zt(), function(t) {
            return "function" == typeof t.merge ? t.merge.apply(t, e) : e[e.length - 1]
        })
    }, ct.prototype.mergeDeep = function() {
        return xt(this, kt, arguments)
    }, ct.prototype.mergeDeepWith = function(t) {
        var e = sr.call(arguments, 1);
        return xt(this, At(t), e)
    }, ct.prototype.mergeDeepIn = function(t) {
        var e = sr.call(arguments, 1);
        return this.updateIn(t, zt(), function(t) {
            return "function" == typeof t.mergeDeep ? t.mergeDeep.apply(t, e) : e[e.length - 1]
        })
    }, ct.prototype.sort = function(t) {
        return Zt(we(this, t))
    }, ct.prototype.sortBy = function(t, e) {
        return Zt(we(this, e, t))
    }, ct.prototype.withMutations = function(t) {
        var e = this.asMutable();
        return t(e), e.wasAltered() ? e.__ensureOwner(this.__ownerID) : this
    }, ct.prototype.asMutable = function() {
        return this.__ownerID ? this : this.__ensureOwner(new _)
    }, ct.prototype.asImmutable = function() {
        return this.__ensureOwner()
    }, ct.prototype.wasAltered = function() {
        return this.__altered
    }, ct.prototype.__iterator = function(t, e) {
        return new mt(this, t, e)
    }, ct.prototype.__iterate = function(t, e) {
        var r = this,
            n = 0;
        return this._root && this._root.iterate(function(e) {
            return n++, t(e[1], e[0], r)
        }, e), n
    }, ct.prototype.__ensureOwner = function(t) {
        return t === this.__ownerID ? this : t ? St(this.size, this._root, t, this.__hash) : (this.__ownerID = t, this.__altered = !1, this)
    }, ct.isMap = _t;
    var Wr = "@@__IMMUTABLE_MAP__@@",
        Cr = ct.prototype;
    Cr[Wr] = !0, Cr[_r] = Cr.remove, Cr.removeIn = Cr.deleteIn, pt.prototype.get = function(t, e, r, n) {
        for (var i = this.entries, o = 0, u = i.length; u > o; o++)
            if (X(r, i[o][0])) return i[o][1];
        return n
    }, pt.prototype.update = function(t, e, r, n, i, o, u) {
        for (var s = i === yr, a = this.entries, h = 0, f = a.length; f > h && !X(n, a[h][0]); h++);
        var _ = f > h;
        if (_ ? a[h][1] === i : s) return this;
        if (c(u), (s || !_) && c(o), !s || 1 !== a.length) {
            if (!_ && !s && a.length >= Nr) return Mt(t, a, n, i);
            var v = t && t === this.ownerID,
                l = v ? a : p(a);
            return _ ? s ? h === f - 1 ? l.pop() : l[h] = l.pop() : l[h] = [n, i] : l.push([n, i]), v ? (this.entries = l, this) : new pt(t, l)
        }
    }, vt.prototype.get = function(t, e, r, n) {
        void 0 === e && (e = ot(r));
        var i = 1 << ((0 === t ? e : e >>> t) & lr),
            o = this.bitmap;
        return 0 === (o & i) ? n : this.nodes[Ut(o & i - 1)].get(t + pr, e, r, n)
    }, vt.prototype.update = function(t, e, r, n, i, o, u) {
        void 0 === r && (r = ot(n));
        var s = (0 === e ? r : r >>> e) & lr,
            a = 1 << s,
            h = this.bitmap,
            f = 0 !== (h & a);
        if (!f && i === yr) return this;
        var c = Ut(h & a - 1),
            _ = this.nodes,
            p = f ? _[c] : void 0,
            v = bt(p, t, e + pr, r, n, i, o, u);
        if (v === p) return this;
        if (!f && v && _.length >= Pr) return Ot(t, _, h, s, v);
        if (f && !v && 2 === _.length && qt(_[1 ^ c])) return _[1 ^ c];
        if (f && v && 1 === _.length && qt(v)) return v;
        var l = t && t === this.ownerID,
            y = f ? v ? h : h ^ a : h | a,
            d = f ? v ? Kt(_, c, v, l) : Tt(_, c, l) : Lt(_, c, v, l);
        return l ? (this.bitmap = y, this.nodes = d, this) : new vt(t, y, d)
    }, lt.prototype.get = function(t, e, r, n) {
        void 0 === e && (e = ot(r));
        var i = (0 === t ? e : e >>> t) & lr,
            o = this.nodes[i];
        return o ? o.get(t + pr, e, r, n) : n
    }, lt.prototype.update = function(t, e, r, n, i, o, u) {
        void 0 === r && (r = ot(n));
        var s = (0 === e ? r : r >>> e) & lr,
            a = i === yr,
            h = this.nodes,
            f = h[s];
        if (a && !f) return this;
        var c = bt(f, t, e + pr, r, n, i, o, u);
        if (c === f) return this;
        var _ = this.count;
        if (f) {
            if (!c && (_--, Hr > _)) return Et(t, h, _, s)
        } else _++;
        var p = t && t === this.ownerID,
            v = Kt(h, s, c, p);
        return p ? (this.count = _, this.nodes = v, this) : new lt(t, _, v)
    }, yt.prototype.get = function(t, e, r, n) {
        for (var i = this.entries, o = 0, u = i.length; u > o; o++)
            if (X(r, i[o][0])) return i[o][1];
        return n
    }, yt.prototype.update = function(t, e, r, n, i, o, u) {
        void 0 === r && (r = ot(n));
        var s = i === yr;
        if (r !== this.keyHash) return s ? this : (c(u), c(o), Dt(this, t, e, r, [n, i]));
        for (var a = this.entries, h = 0, f = a.length; f > h && !X(n, a[h][0]); h++);
        var _ = f > h;
        if (_ ? a[h][1] === i : s) return this;
        if (c(u), (s || !_) && c(o), s && 2 === f) return new dt(t, this.keyHash, a[1 ^ h]);
        var v = t && t === this.ownerID,
            l = v ? a : p(a);
        return _ ? s ? h === f - 1 ? l.pop() : l[h] = l.pop() : l[h] = [n, i] : l.push([n, i]), v ? (this.entries = l, this) : new yt(t, this.keyHash, l)
    }, dt.prototype.get = function(t, e, r, n) {
        return X(r, this.entry[0]) ? this.entry[1] : n;
    }, dt.prototype.update = function(t, e, r, n, i, o, u) {
        var s = i === yr,
            a = X(n, this.entry[0]);
        return (a ? i === this.entry[1] : s) ? this : (c(u), s ? void c(o) : a ? t && t === this.ownerID ? (this.entry[1] = i, this) : new dt(t, this.keyHash, [n, i]) : (c(o), Dt(this, t, e, ot(n), [n, i])))
    }, pt.prototype.iterate = yt.prototype.iterate = function(t, e) {
        for (var r = this.entries, n = 0, i = r.length - 1; i >= n; n++)
            if (t(r[e ? i - n : n]) === !1) return !1
    }, vt.prototype.iterate = lt.prototype.iterate = function(t, e) {
        for (var r = this.nodes, n = 0, i = r.length - 1; i >= n; n++) {
            var o = r[e ? i - n : n];
            if (o && o.iterate(t, e) === !1) return !1
        }
    }, dt.prototype.iterate = function(t, e) {
        return t(this.entry)
    }, t(mt, S), mt.prototype.next = function() {
        for (var t = this._type, e = this._stack; e;) {
            var r, n = e.node,
                i = e.index++;
            if (n.entry) {
                if (0 === i) return gt(t, n.entry)
            } else if (n.entries) {
                if (r = n.entries.length - 1, r >= i) return gt(t, n.entries[this._reverse ? r - i : i])
            } else if (r = n.nodes.length - 1, r >= i) {
                var o = n.nodes[this._reverse ? r - i : i];
                if (o) {
                    if (o.entry) return gt(t, o.entry);
                    e = this._stack = wt(o, e)
                }
                continue
            }
            e = this._stack = this._stack.__prev
        }
        return I()
    };
    var Jr, Nr = vr / 4,
        Pr = vr / 2,
        Hr = vr / 4;
    t(Bt, rt), Bt.of = function() {
        return this(arguments)
    }, Bt.prototype.toString = function() {
        return this.__toString("List [", "]")
    }, Bt.prototype.get = function(t, e) {
        if (t = l(this, t), t >= 0 && this.size > t) {
            t += this._origin;
            var r = Qt(this, t);
            return r && r.array[t & lr]
        }
        return e
    }, Bt.prototype.set = function(t, e) {
        return Ht(this, t, e)
    }, Bt.prototype.remove = function(t) {
        return this.has(t) ? 0 === t ? this.shift() : t === this.size - 1 ? this.pop() : this.splice(t, 1) : this
    }, Bt.prototype.insert = function(t, e) {
        return this.splice(t, 0, e)
    }, Bt.prototype.clear = function() {
        return 0 === this.size ? this : this.__ownerID ? (this.size = this._origin = this._capacity = 0, this._level = pr, this._root = this._tail = null, this.__hash = void 0, this.__altered = !0, this) : Pt()
    }, Bt.prototype.push = function() {
        var t = arguments,
            e = this.size;
        return this.withMutations(function(r) {
            Xt(r, 0, e + t.length);
            for (var n = 0; t.length > n; n++) r.set(e + n, t[n])
        })
    }, Bt.prototype.pop = function() {
        return Xt(this, 0, -1)
    }, Bt.prototype.unshift = function() {
        var t = arguments;
        return this.withMutations(function(e) {
            Xt(e, -t.length);
            for (var r = 0; t.length > r; r++) e.set(r, t[r]);
        })
    }, Bt.prototype.shift = function() {
        return Xt(this, 1)
    }, Bt.prototype.merge = function() {
        return Ft(this, void 0, arguments)
    }, Bt.prototype.mergeWith = function(t) {
        var e = sr.call(arguments, 1);
        return Ft(this, t, e)
    }, Bt.prototype.mergeDeep = function() {
        return Ft(this, kt, arguments)
    }, Bt.prototype.mergeDeepWith = function(t) {
        var e = sr.call(arguments, 1);
        return Ft(this, At(t), e)
    }, Bt.prototype.setSize = function(t) {
        return Xt(this, 0, t)
    }, Bt.prototype.slice = function(t, e) {
        var r = this.size;
        return d(t, e, r) ? this : Xt(this, m(t, r), g(e, r))
    }, Bt.prototype.__iterator = function(t, e) {
        var r = 0,
            n = Jt(this, e);
        return new S(function() {
            var e = n();
            return e === Xr ? I() : z(t, r++, e)
        })
    }, Bt.prototype.__iterate = function(t, e) {
        for (var r, n = 0, i = Jt(this, e);
            (r = i()) !== Xr && t(r, n++, this) !== !1;);
        return n
    }, Bt.prototype.__ensureOwner = function(t) {
        return t === this.__ownerID ? this : t ? Nt(this._origin, this._capacity, this._level, this._root, this._tail, t, this.__hash) : (this.__ownerID = t, this)
    }, Bt.isList = Wt;
    var Vr = "@@__IMMUTABLE_LIST__@@",
        Yr = Bt.prototype;
    Yr[Vr] = !0, Yr[_r] = Yr.remove, Yr.setIn = Cr.setIn, Yr.deleteIn = Yr.removeIn = Cr.removeIn, Yr.update = Cr.update, Yr.updateIn = Cr.updateIn, Yr.mergeIn = Cr.mergeIn, Yr.mergeDeepIn = Cr.mergeDeepIn, Yr.withMutations = Cr.withMutations, Yr.asMutable = Cr.asMutable, Yr.asImmutable = Cr.asImmutable, Yr.wasAltered = Cr.wasAltered, Ct.prototype.removeBefore = function(t, e, r) {
        if (r === e ? 1 << e : 0 === this.array.length) return this;
        var n = r >>> e & lr;
        if (n >= this.array.length) return new Ct([], t);
        var i, o = 0 === n;
        if (e > 0) {
            var u = this.array[n];
            if (i = u && u.removeBefore(t, e - pr, r), i === u && o) return this
        }
        if (o && !i) return this;
        var s = Yt(this, t);
        if (!o)
            for (var a = 0; n > a; a++) s.array[a] = void 0;
        return i && (s.array[n] = i), s
    }, Ct.prototype.removeAfter = function(t, e, r) {
        if (r === (e ? 1 << e : 0) || 0 === this.array.length) return this;
        var n = r - 1 >>> e & lr;
        if (n >= this.array.length) return this;
        var i;
        if (e > 0) {
            var o = this.array[n];
            if (i = o && o.removeAfter(t, e - pr, r), i === o && n === this.array.length - 1) return this
        }
        var u = Yt(this, t);
        return u.array.splice(n + 1), i && (u.array[n] = i), u
    };
    var Qr, Xr = {};
    t(Zt, ct), Zt.of = function() {
        return this(arguments)
    }, Zt.prototype.toString = function() {
        return this.__toString("OrderedMap {", "}");
    }, Zt.prototype.get = function(t, e) {
        var r = this._map.get(t);
        return void 0 !== r ? this._list.get(r)[1] : e
    }, Zt.prototype.clear = function() {
        return 0 === this.size ? this : this.__ownerID ? (this.size = 0, this._map.clear(), this._list.clear(), this) : ee()
    }, Zt.prototype.set = function(t, e) {
        return re(this, t, e)
    }, Zt.prototype.remove = function(t) {
        return re(this, t, yr)
    }, Zt.prototype.wasAltered = function() {
        return this._map.wasAltered() || this._list.wasAltered()
    }, Zt.prototype.__iterate = function(t, e) {
        var r = this;
        return this._list.__iterate(function(e) {
            return e && t(e[1], e[0], r)
        }, e)
    }, Zt.prototype.__iterator = function(t, e) {
        return this._list.fromEntrySeq().__iterator(t, e)
    }, Zt.prototype.__ensureOwner = function(t) {
        if (t === this.__ownerID) return this;
        var e = this._map.__ensureOwner(t),
            r = this._list.__ensureOwner(t);
        return t ? te(e, r, t, this.__hash) : (this.__ownerID = t, this._map = e, this._list = r, this)
    }, Zt.isOrderedMap = $t, Zt.prototype[cr] = !0, Zt.prototype[_r] = Zt.prototype.remove;
    var Fr;
    t(ne, x), ne.prototype.get = function(t, e) {
        return this._iter.get(t, e)
    }, ne.prototype.has = function(t) {
        return this._iter.has(t)
    }, ne.prototype.valueSeq = function() {
        return this._iter.valueSeq()
    }, ne.prototype.reverse = function() {
        var t = this,
            e = he(this, !0);
        return this._useKeys || (e.valueSeq = function() {
            return t._iter.toSeq().reverse()
        }), e
    }, ne.prototype.map = function(t, e) {
        var r = this,
            n = ae(this, t, e);
        return this._useKeys || (n.valueSeq = function() {
            return r._iter.toSeq().map(t, e)
        }), n
    }, ne.prototype.__iterate = function(t, e) {
        var r, n = this;
        return this._iter.__iterate(this._useKeys ? function(e, r) {
            return t(e, r, n)
        } : (r = e ? De(this) : 0, function(i) {
            return t(i, e ? --r : r++, n)
        }), e)
    }, ne.prototype.__iterator = function(t, e) {
        if (this._useKeys) return this._iter.__iterator(t, e);
        var r = this._iter.__iterator(wr, e),
            n = e ? De(this) : 0;
        return new S(function() {
            var i = r.next();
            return i.done ? i : z(t, e ? --n : n++, i.value, i)
        })
    }, ne.prototype[cr] = !0, t(ie, k), ie.prototype.includes = function(t) {
        return this._iter.includes(t)
    }, ie.prototype.__iterate = function(t, e) {
        var r = this,
            n = 0;
        return this._iter.__iterate(function(e) {
            return t(e, n++, r)
        }, e)
    }, ie.prototype.__iterator = function(t, e) {
        var r = this._iter.__iterator(wr, e),
            n = 0;
        return new S(function() {
            var e = r.next();
            return e.done ? e : z(t, n++, e.value, e)
        })
    }, t(oe, A), oe.prototype.has = function(t) {
        return this._iter.includes(t)
    }, oe.prototype.__iterate = function(t, e) {
        var r = this;
        return this._iter.__iterate(function(e) {
            return t(e, e, r)
        }, e)
    }, oe.prototype.__iterator = function(t, e) {
        var r = this._iter.__iterator(wr, e);
        return new S(function() {
            var e = r.next();
            return e.done ? e : z(t, e.value, e.value, e)
        })
    }, t(ue, x), ue.prototype.entrySeq = function() {
        return this._iter.toSeq()
    }, ue.prototype.__iterate = function(t, e) {
        var r = this;
        return this._iter.__iterate(function(e) {
            if (e) {
                qe(e);
                var n = o(e);
                return t(n ? e.get(1) : e[1], n ? e.get(0) : e[0], r)
            }
        }, e)
    }, ue.prototype.__iterator = function(t, e) {
        var r = this._iter.__iterator(wr, e);
        return new S(function() {
            for (;;) {
                var e = r.next();
                if (e.done) return e;
                var n = e.value;
                if (n) {
                    qe(n);
                    var i = o(n);
                    return z(t, i ? n.get(0) : n[0], i ? n.get(1) : n[1], e)
                }
            }
        })
    }, ie.prototype.cacheResult = ne.prototype.cacheResult = oe.prototype.cacheResult = ue.prototype.cacheResult = Oe, t(Ae, et), Ae.prototype.toString = function() {
        return this.__toString(Re(this) + " {", "}")
    }, Ae.prototype.has = function(t) {
        return this._defaultValues.hasOwnProperty(t)
    }, Ae.prototype.get = function(t, e) {
        if (!this.has(t)) return e;
        var r = this._defaultValues[t];
        return this._map ? this._map.get(t, r) : r
    }, Ae.prototype.clear = function() {
        if (this.__ownerID) return this._map && this._map.clear(), this;
        var t = this.constructor;
        return t._empty || (t._empty = je(this, zt()))
    }, Ae.prototype.set = function(t, e) {
        if (!this.has(t)) throw Error('Cannot set unknown key "' + t + '" on ' + Re(this));
        if (this._map && !this._map.has(t)) {
            var r = this._defaultValues[t];
            if (e === r) return this
        }
        var n = this._map && this._map.set(t, e);
        return this.__ownerID || n === this._map ? this : je(this, n)
    }, Ae.prototype.remove = function(t) {
        if (!this.has(t)) return this;
        var e = this._map && this._map.remove(t);
        return this.__ownerID || e === this._map ? this : je(this, e)
    }, Ae.prototype.wasAltered = function() {
        return this._map.wasAltered()
    }, Ae.prototype.__iterator = function(t, e) {
        var n = this;
        return r(this._defaultValues).map(function(t, e) {
            return n.get(e)
        }).__iterator(t, e)
    }, Ae.prototype.__iterate = function(t, e) {
        var n = this;
        return r(this._defaultValues).map(function(t, e) {
            return n.get(e)
        }).__iterate(t, e)
    }, Ae.prototype.__ensureOwner = function(t) {
        if (t === this.__ownerID) return this;
        var e = this._map && this._map.__ensureOwner(t);
        return t ? je(this, e, t) : (this.__ownerID = t, this._map = e, this)
    };
    var Gr = Ae.prototype;
    Gr[_r] = Gr.remove, Gr.deleteIn = Gr.removeIn = Cr.removeIn, Gr.merge = Cr.merge, Gr.mergeWith = Cr.mergeWith, Gr.mergeIn = Cr.mergeIn, Gr.mergeDeep = Cr.mergeDeep, Gr.mergeDeepWith = Cr.mergeDeepWith, Gr.mergeDeepIn = Cr.mergeDeepIn, Gr.setIn = Cr.setIn, Gr.update = Cr.update, Gr.updateIn = Cr.updateIn, Gr.withMutations = Cr.withMutations, Gr.asMutable = Cr.asMutable, Gr.asImmutable = Cr.asImmutable, t(Le, nt), Le.of = function() {
            return this(arguments)
        }, Le.fromKeys = function(t) {
            return this(r(t).keySeq())
        }, Le.prototype.toString = function() {
            return this.__toString("Set {", "}")
        }, Le.prototype.has = function(t) {
            return this._map.has(t)
        }, Le.prototype.add = function(t) {
            return Be(this, this._map.set(t, !0))
        }, Le.prototype.remove = function(t) {
            return Be(this, this._map.remove(t))
        }, Le.prototype.clear = function() {
            return Be(this, this._map.clear())
        }, Le.prototype.union = function() {
            var t = sr.call(arguments, 0);
            return t = t.filter(function(t) {
                return 0 !== t.size
            }), 0 === t.length ? this : 0 !== this.size || this.__ownerID || 1 !== t.length ? this.withMutations(function(e) {
                for (var r = 0; t.length > r; r++) i(t[r]).forEach(function(t) {
                    return e.add(t)
                })
            }) : this.constructor(t[0])
        }, Le.prototype.intersect = function() {
            var t = sr.call(arguments, 0);
            if (0 === t.length) return this;
            t = t.map(function(t) {
                return i(t)
            });
            var e = this;
            return this.withMutations(function(r) {
                e.forEach(function(e) {
                    t.every(function(t) {
                        return t.includes(e)
                    }) || r.remove(e)
                })
            })
        }, Le.prototype.subtract = function() {
            var t = sr.call(arguments, 0);
            if (0 === t.length) return this;
            t = t.map(function(t) {
                return i(t)
            });
            var e = this;
            return this.withMutations(function(r) {
                e.forEach(function(e) {
                    t.some(function(t) {
                        return t.includes(e)
                    }) && r.remove(e)
                })
            })
        }, Le.prototype.merge = function() {
            return this.union.apply(this, arguments)
        }, Le.prototype.mergeWith = function(t) {
            var e = sr.call(arguments, 1);
            return this.union.apply(this, e)
        },
        Le.prototype.sort = function(t) {
            return Je(we(this, t))
        }, Le.prototype.sortBy = function(t, e) {
            return Je(we(this, e, t))
        }, Le.prototype.wasAltered = function() {
            return this._map.wasAltered()
        }, Le.prototype.__iterate = function(t, e) {
            var r = this;
            return this._map.__iterate(function(e, n) {
                return t(n, n, r)
            }, e)
        }, Le.prototype.__iterator = function(t, e) {
            return this._map.map(function(t, e) {
                return e
            }).__iterator(t, e)
        }, Le.prototype.__ensureOwner = function(t) {
            if (t === this.__ownerID) return this;
            var e = this._map.__ensureOwner(t);
            return t ? this.__make(e, t) : (this.__ownerID = t, this._map = e, this)
        }, Le.isSet = Te;
    var Zr = "@@__IMMUTABLE_SET__@@",
        $r = Le.prototype;
    $r[Zr] = !0, $r[_r] = $r.remove, $r.mergeDeep = $r.merge, $r.mergeDeepWith = $r.mergeWith, $r.withMutations = Cr.withMutations, $r.asMutable = Cr.asMutable, $r.asImmutable = Cr.asImmutable, $r.__empty = Ce, $r.__make = We;
    var tn;
    t(Je, Le), Je.of = function() {
        return this(arguments)
    }, Je.fromKeys = function(t) {
        return this(r(t).keySeq())
    }, Je.prototype.toString = function() {
        return this.__toString("OrderedSet {", "}")
    }, Je.isOrderedSet = Ne;
    var en = Je.prototype;
    en[cr] = !0, en.__empty = He, en.__make = Pe;
    var rn;
    t(Ve, rt), Ve.of = function() {
        return this(arguments)
    }, Ve.prototype.toString = function() {
        return this.__toString("Stack [", "]")
    }, Ve.prototype.get = function(t, e) {
        var r = this._head;
        for (t = l(this, t); r && t--;) r = r.next;
        return r ? r.value : e
    }, Ve.prototype.peek = function() {
        return this._head && this._head.value
    }, Ve.prototype.push = function() {
        if (0 === arguments.length) return this;
        for (var t = this.size + arguments.length, e = this._head, r = arguments.length - 1; r >= 0; r--) e = {
            value: arguments[r],
            next: e
        };
        return this.__ownerID ? (this.size = t, this._head = e, this.__hash = void 0, this.__altered = !0, this) : Qe(t, e)
    }, Ve.prototype.pushAll = function(t) {
        if (t = n(t), 0 === t.size) return this;
        ft(t.size);
        var e = this.size,
            r = this._head;
        return t.reverse().forEach(function(t) {
            e++, r = {
                value: t,
                next: r
            }
        }), this.__ownerID ? (this.size = e, this._head = r, this.__hash = void 0, this.__altered = !0, this) : Qe(e, r)
    }, Ve.prototype.pop = function() {
        return this.slice(1)
    }, Ve.prototype.unshift = function() {
        return this.push.apply(this, arguments)
    }, Ve.prototype.unshiftAll = function(t) {
        return this.pushAll(t)
    }, Ve.prototype.shift = function() {
        return this.pop.apply(this, arguments)
    }, Ve.prototype.clear = function() {
        return 0 === this.size ? this : this.__ownerID ? (this.size = 0, this._head = void 0, this.__hash = void 0, this.__altered = !0, this) : Xe()
    }, Ve.prototype.slice = function(t, e) {
        if (d(t, e, this.size)) return this;
        var r = m(t, this.size),
            n = g(e, this.size);
        if (n !== this.size) return rt.prototype.slice.call(this, t, e);
        for (var i = this.size - r, o = this._head; r--;) o = o.next;
        return this.__ownerID ? (this.size = i, this._head = o, this.__hash = void 0, this.__altered = !0, this) : Qe(i, o)
    }, Ve.prototype.__ensureOwner = function(t) {
        return t === this.__ownerID ? this : t ? Qe(this.size, this._head, t, this.__hash) : (this.__ownerID = t, this.__altered = !1, this)
    }, Ve.prototype.__iterate = function(t, e) {
        if (e) return this.reverse().__iterate(t);
        for (var r = 0, n = this._head; n && t(n.value, r++, this) !== !1;) n = n.next;
        return r
    }, Ve.prototype.__iterator = function(t, e) {
        if (e) return this.reverse().__iterator(t);
        var r = 0,
            n = this._head;
        return new S(function() {
            if (n) {
                var e = n.value;
                return n = n.next, z(t, r++, e)
            }
            return I()
        })
    }, Ve.isStack = Ye;
    var nn = "@@__IMMUTABLE_STACK__@@",
        on = Ve.prototype;
    on[nn] = !0, on.withMutations = Cr.withMutations, on.asMutable = Cr.asMutable, on.asImmutable = Cr.asImmutable, on.wasAltered = Cr.wasAltered;
    var un;
    e.Iterator = S, Fe(e, {
        toArray: function() {
            ft(this.size);
            var t = Array(this.size || 0);
            return this.valueSeq().__iterate(function(e, r) {
                t[r] = e
            }), t
        },
        toIndexedSeq: function() {
            return new ie(this)
        },
        toJS: function() {
            return this.toSeq().map(function(t) {
                return t && "function" == typeof t.toJS ? t.toJS() : t
            }).__toJS()
        },
        toJSON: function() {
            return this.toSeq().map(function(t) {
                return t && "function" == typeof t.toJSON ? t.toJSON() : t
            }).__toJS()
        },
        toKeyedSeq: function() {
            return new ne(this, !0)
        },
        toMap: function() {
            return ct(this.toKeyedSeq())
        },
        toObject: function() {
            ft(this.size);
            var t = {};
            return this.__iterate(function(e, r) {
                t[r] = e
            }), t
        },
        toOrderedMap: function() {
            return Zt(this.toKeyedSeq())
        },
        toOrderedSet: function() {
            return Je(u(this) ? this.valueSeq() : this)
        },
        toSet: function() {
            return Le(u(this) ? this.valueSeq() : this)
        },
        toSetSeq: function() {
            return new oe(this);
        },
        toSeq: function() {
            return s(this) ? this.toIndexedSeq() : u(this) ? this.toKeyedSeq() : this.toSetSeq()
        },
        toStack: function() {
            return Ve(u(this) ? this.valueSeq() : this)
        },
        toList: function() {
            return Bt(u(this) ? this.valueSeq() : this)
        },
        toString: function() {
            return "[Iterable]"
        },
        __toString: function(t, e) {
            return 0 === this.size ? t + e : t + " " + this.toSeq().map(this.__toStringMapper).join(", ") + " " + e
        },
        concat: function() {
            var t = sr.call(arguments, 0);
            return be(this, ye(this, t))
        },
        includes: function(t) {
            return this.some(function(e) {
                return X(e, t)
            })
        },
        entries: function() {
            return this.__iterator(Sr)
        },
        every: function(t, e) {
            ft(this.size);
            var r = !0;
            return this.__iterate(function(n, i, o) {
                return t.call(e, n, i, o) ? void 0 : (r = !1, !1)
            }), r
        },
        filter: function(t, e) {
            return be(this, fe(this, t, e, !0))
        },
        find: function(t, e, r) {
            var n = this.findEntry(t, e);
            return n ? n[1] : r
        },
        forEach: function(t, e) {
            return ft(this.size), this.__iterate(e ? t.bind(e) : t)
        },
        join: function(t) {
            ft(this.size), t = void 0 !== t ? "" + t : ",";
            var e = "",
                r = !0;
            return this.__iterate(function(n) {
                r ? r = !1 : e += t, e += null !== n && void 0 !== n ? "" + n : ""
            }), e
        },
        keys: function() {
            return this.__iterator(gr)
        },
        map: function(t, e) {
            return be(this, ae(this, t, e))
        },
        reduce: function(t, e, r) {
            ft(this.size);
            var n, i;
            return arguments.length < 2 ? i = !0 : n = e, this.__iterate(function(e, o, u) {
                i ? (i = !1, n = e) : n = t.call(r, n, e, o, u)
            }), n
        },
        reduceRight: function(t, e, r) {
            var n = this.toKeyedSeq().reverse();
            return n.reduce.apply(n, arguments)
        },
        reverse: function() {
            return be(this, he(this, !0))
        },
        slice: function(t, e) {
            return be(this, pe(this, t, e, !0))
        },
        some: function(t, e) {
            return !this.every($e(t), e)
        },
        sort: function(t) {
            return be(this, we(this, t))
        },
        values: function() {
            return this.__iterator(wr)
        },
        butLast: function() {
            return this.slice(0, -1)
        },
        isEmpty: function() {
            return void 0 !== this.size ? 0 === this.size : !this.some(function() {
                return !0
            })
        },
        count: function(t, e) {
            return v(t ? this.toSeq().filter(t, e) : this)
        },
        countBy: function(t, e) {
            return ce(this, t, e)
        },
        equals: function(t) {
            return F(this, t)
        },
        entrySeq: function() {
            var t = this;
            if (t._cache) return new j(t._cache);
            var e = t.toSeq().map(Ze).toIndexedSeq();
            return e.fromEntrySeq = function() {
                return t.toSeq()
            }, e
        },
        filterNot: function(t, e) {
            return this.filter($e(t), e)
        },
        findEntry: function(t, e, r) {
            var n = r;
            return this.__iterate(function(r, i, o) {
                return t.call(e, r, i, o) ? (n = [i, r], !1) : void 0
            }), n
        },
        findKey: function(t, e) {
            var r = this.findEntry(t, e);
            return r && r[0]
        },
        findLast: function(t, e, r) {
            return this.toKeyedSeq().reverse().find(t, e, r)
        },
        findLastEntry: function(t, e, r) {
            return this.toKeyedSeq().reverse().findEntry(t, e, r)
        },
        findLastKey: function(t, e) {
            return this.toKeyedSeq().reverse().findKey(t, e)
        },
        first: function() {
            return this.find(y)
        },
        flatMap: function(t, e) {
            return be(this, me(this, t, e))
        },
        flatten: function(t) {
            return be(this, de(this, t, !0))
        },
        fromEntrySeq: function() {
            return new ue(this)
        },
        get: function(t, e) {
            return this.find(function(e, r) {
                return X(r, t)
            }, void 0, e)
        },
        getIn: function(t, e) {
            for (var r, n = this, i = ke(t); !(r = i.next()).done;) {
                var o = r.value;
                if (n = n && n.get ? n.get(o, yr) : yr, n === yr) return e
            }
            return n
        },
        groupBy: function(t, e) {
            return _e(this, t, e)
        },
        has: function(t) {
            return this.get(t, yr) !== yr
        },
        hasIn: function(t) {
            return this.getIn(t, yr) !== yr
        },
        isSubset: function(t) {
            return t = "function" == typeof t.includes ? t : e(t), this.every(function(e) {
                return t.includes(e)
            })
        },
        isSuperset: function(t) {
            return t = "function" == typeof t.isSubset ? t : e(t), t.isSubset(this)
        },
        keyOf: function(t) {
            return this.findKey(function(e) {
                return X(e, t)
            })
        },
        keySeq: function() {
            return this.toSeq().map(Ge).toIndexedSeq()
        },
        last: function() {
            return this.toSeq().reverse().first()
        },
        lastKeyOf: function(t) {
            return this.toKeyedSeq().reverse().keyOf(t)
        },
        max: function(t) {
            return Se(this, t)
        },
        maxBy: function(t, e) {
            return Se(this, e, t)
        },
        min: function(t) {
            return Se(this, t ? tr(t) : nr)
        },
        minBy: function(t, e) {
            return Se(this, e ? tr(e) : nr, t)
        },
        rest: function() {
            return this.slice(1)
        },
        skip: function(t) {
            return this.slice(Math.max(0, t))
        },
        skipLast: function(t) {
            return be(this, this.toSeq().reverse().skip(t).reverse())
        },
        skipWhile: function(t, e) {
            return be(this, le(this, t, e, !0))
        },
        skipUntil: function(t, e) {
            return this.skipWhile($e(t), e)
        },
        sortBy: function(t, e) {
            return be(this, we(this, e, t))
        },
        take: function(t) {
            return this.slice(0, Math.max(0, t))
        },
        takeLast: function(t) {
            return be(this, this.toSeq().reverse().take(t).reverse());
        },
        takeWhile: function(t, e) {
            return be(this, ve(this, t, e))
        },
        takeUntil: function(t, e) {
            return this.takeWhile($e(t), e)
        },
        valueSeq: function() {
            return this.toIndexedSeq()
        },
        hashCode: function() {
            return this.__hash || (this.__hash = ir(this))
        }
    });
    var sn = e.prototype;
    sn[ar] = !0, sn[br] = sn.values, sn.__toJS = sn.toArray, sn.__toStringMapper = er, sn.inspect = sn.toSource = function() {
        return "" + this
    }, sn.chain = sn.flatMap, sn.contains = sn.includes, Fe(r, {
        flip: function() {
            return be(this, se(this))
        },
        mapEntries: function(t, e) {
            var r = this,
                n = 0;
            return be(this, this.toSeq().map(function(i, o) {
                return t.call(e, [o, i], n++, r)
            }).fromEntrySeq())
        },
        mapKeys: function(t, e) {
            var r = this;
            return be(this, this.toSeq().flip().map(function(n, i) {
                return t.call(e, n, i, r)
            }).flip())
        }
    });
    var an = r.prototype;
    an[hr] = !0, an[br] = sn.entries, an.__toJS = sn.toObject, an.__toStringMapper = function(t, e) {
        return JSON.stringify(e) + ": " + er(t)
    }, Fe(n, {
        toKeyedSeq: function() {
            return new ne(this, !1)
        },
        filter: function(t, e) {
            return be(this, fe(this, t, e, !1))
        },
        findIndex: function(t, e) {
            var r = this.findEntry(t, e);
            return r ? r[0] : -1
        },
        indexOf: function(t) {
            var e = this.keyOf(t);
            return void 0 === e ? -1 : e
        },
        lastIndexOf: function(t) {
            var e = this.lastKeyOf(t);
            return void 0 === e ? -1 : e
        },
        reverse: function() {
            return be(this, he(this, !1))
        },
        slice: function(t, e) {
            return be(this, pe(this, t, e, !1))
        },
        splice: function(t, e) {
            var r = arguments.length;
            if (e = Math.max(0 | e, 0), 0 === r || 2 === r && !e) return this;
            t = m(t, 0 > t ? this.count() : this.size);
            var n = this.slice(0, t);
            return be(this, 1 === r ? n : n.concat(p(arguments, 2), this.slice(t + e)))
        },
        findLastIndex: function(t, e) {
            var r = this.findLastEntry(t, e);
            return r ? r[0] : -1
        },
        first: function() {
            return this.get(0)
        },
        flatten: function(t) {
            return be(this, de(this, t, !1))
        },
        get: function(t, e) {
            return t = l(this, t), 0 > t || this.size === 1 / 0 || void 0 !== this.size && t > this.size ? e : this.find(function(e, r) {
                return r === t
            }, void 0, e)
        },
        has: function(t) {
            return t = l(this, t), t >= 0 && (void 0 !== this.size ? this.size === 1 / 0 || this.size > t : -1 !== this.indexOf(t))
        },
        interpose: function(t) {
            return be(this, ge(this, t))
        },
        interleave: function() {
            var t = [this].concat(p(arguments)),
                e = Ie(this.toSeq(), k.of, t),
                r = e.flatten(!0);
            return e.size && (r.size = e.size * t.length),
                be(this, r)
        },
        keySeq: function() {
            return $(0, this.size)
        },
        last: function() {
            return this.get(-1)
        },
        skipWhile: function(t, e) {
            return be(this, le(this, t, e, !1))
        },
        zip: function() {
            var t = [this].concat(p(arguments));
            return be(this, Ie(this, rr, t))
        },
        zipWith: function(t) {
            var e = p(arguments);
            return e[0] = this, be(this, Ie(this, t, e))
        }
    }), n.prototype[fr] = !0, n.prototype[cr] = !0, Fe(i, {
        get: function(t, e) {
            return this.has(t) ? t : e
        },
        includes: function(t) {
            return this.has(t)
        },
        keySeq: function() {
            return this.valueSeq()
        }
    }), i.prototype.has = sn.includes, i.prototype.contains = i.prototype.includes, Fe(x, r.prototype), Fe(k, n.prototype), Fe(A, i.prototype), Fe(et, r.prototype), Fe(rt, n.prototype), Fe(nt, i.prototype);
    var hn = {
        Iterable: e,
        Seq: O,
        Collection: tt,
        Map: ct,
        OrderedMap: Zt,
        List: Bt,
        Stack: Ve,
        Set: Le,
        OrderedSet: Je,
        Record: Ae,
        Range: $,
        Repeat: G,
        is: X,
        fromJS: H
    };
    return hn
});
/*!
 * Bootstrap v3.3.6 (http://getbootstrap.com)
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under the MIT license
 */
if ("undefined" == typeof jQuery) throw new Error("Bootstrap's JavaScript requires jQuery"); + function(a) {
    "use strict";
    var b = a.fn.jquery.split(" ")[0].split(".");
    if (b[0] < 2 && b[1] < 9 || 1 == b[0] && 9 == b[1] && b[2] < 1 || b[0] > 2) throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower than version 3")
}(jQuery), + function(a) {
    "use strict";

    function b() {
        var a = document.createElement("bootstrap"),
            b = {
                WebkitTransition: "webkitTransitionEnd",
                MozTransition: "transitionend",
                OTransition: "oTransitionEnd otransitionend",
                transition: "transitionend"
            };
        for (var c in b)
            if (void 0 !== a.style[c]) return {
                end: b[c]
            };
        return !1
    }
    a.fn.emulateTransitionEnd = function(b) {
        var c = !1,
            d = this;
        a(this).one("bsTransitionEnd", function() {
            c = !0
        });
        var e = function() {
            c || a(d).trigger(a.support.transition.end)
        };
        return setTimeout(e, b), this
    }, a(function() {
        a.support.transition = b(), a.support.transition && (a.event.special.bsTransitionEnd = {
            bindType: a.support.transition.end,
            delegateType: a.support.transition.end,
            handle: function(b) {
                return a(b.target).is(this) ? b.handleObj.handler.apply(this, arguments) : void 0
            }
        })
    })
}(jQuery), + function(a) {
    "use strict";

    function b(b) {
        return this.each(function() {
            var c = a(this),
                e = c.data("bs.alert");
            e || c.data("bs.alert", e = new d(this)), "string" == typeof b && e[b].call(c)
        })
    }
    var c = '[data-dismiss="alert"]',
        d = function(b) {
            a(b).on("click", c, this.close)
        };
    d.VERSION = "3.3.6", d.TRANSITION_DURATION = 150, d.prototype.close = function(b) {
        function c() {
            g.detach().trigger("closed.bs.alert").remove()
        }
        var e = a(this),
            f = e.attr("data-target");
        f || (f = e.attr("href"), f = f && f.replace(/.*(?=#[^\s]*$)/, ""));
        var g = a(f);
        b && b.preventDefault(), g.length || (g = e.closest(".alert")), g.trigger(b = a.Event("close.bs.alert")), b.isDefaultPrevented() || (g.removeClass("in"), a.support.transition && g.hasClass("fade") ? g.one("bsTransitionEnd", c).emulateTransitionEnd(d.TRANSITION_DURATION) : c())
    };
    var e = a.fn.alert;
    a.fn.alert = b, a.fn.alert.Constructor = d, a.fn.alert.noConflict = function() {
        return a.fn.alert = e, this
    }, a(document).on("click.bs.alert.data-api", c, d.prototype.close)
}(jQuery), + function(a) {
    "use strict";

    function b(b) {
        return this.each(function() {
            var d = a(this),
                e = d.data("bs.button"),
                f = "object" == typeof b && b;
            e || d.data("bs.button", e = new c(this, f)), "toggle" == b ? e.toggle() : b && e.setState(b)
        })
    }
    var c = function(b, d) {
        this.$element = a(b), this.options = a.extend({}, c.DEFAULTS, d), this.isLoading = !1
    };
    c.VERSION = "3.3.6", c.DEFAULTS = {
        loadingText: "loading..."
    }, c.prototype.setState = function(b) {
        var c = "disabled",
            d = this.$element,
            e = d.is("input") ? "val" : "html",
            f = d.data();
        b += "Text", null == f.resetText && d.data("resetText", d[e]()), setTimeout(a.proxy(function() {
            d[e](null == f[b] ? this.options[b] : f[b]), "loadingText" == b ? (this.isLoading = !0, d.addClass(c).attr(c, c)) : this.isLoading && (this.isLoading = !1, d.removeClass(c).removeAttr(c))
        }, this), 0)
    }, c.prototype.toggle = function() {
        var a = !0,
            b = this.$element.closest('[data-toggle="buttons"]');
        if (b.length) {
            var c = this.$element.find("input");
            "radio" == c.prop("type") ? (c.prop("checked") && (a = !1), b.find(".active").removeClass("active"), this.$element.addClass("active")) : "checkbox" == c.prop("type") && (c.prop("checked") !== this.$element.hasClass("active") && (a = !1), this.$element.toggleClass("active")), c.prop("checked", this.$element.hasClass("active")), a && c.trigger("change")
        } else this.$element.attr("aria-pressed", !this.$element.hasClass("active")), this.$element.toggleClass("active")
    };
    var d = a.fn.button;
    a.fn.button = b, a.fn.button.Constructor = c, a.fn.button.noConflict = function() {
        return a.fn.button = d, this
    }, a(document).on("click.bs.button.data-api", '[data-toggle^="button"]', function(c) {
        var d = a(c.target);
        d.hasClass("btn") || (d = d.closest(".btn")), b.call(d, "toggle"), a(c.target).is('input[type="radio"]') || a(c.target).is('input[type="checkbox"]') || c.preventDefault()
    }).on("focus.bs.button.data-api blur.bs.button.data-api", '[data-toggle^="button"]', function(b) {
        a(b.target).closest(".btn").toggleClass("focus", /^focus(in)?$/.test(b.type))
    })
}(jQuery), + function(a) {
    "use strict";

    function b(b) {
        return this.each(function() {
            var d = a(this),
                e = d.data("bs.carousel"),
                f = a.extend({}, c.DEFAULTS, d.data(), "object" == typeof b && b),
                g = "string" == typeof b ? b : f.slide;
            e || d.data("bs.carousel", e = new c(this, f)), "number" == typeof b ? e.to(b) : g ? e[g]() : f.interval && e.pause().cycle()
        })
    }
    var c = function(b, c) {
        this.$element = a(b), this.$indicators = this.$element.find(".carousel-indicators"), this.options = c, this.paused = null, this.sliding = null, this.interval = null, this.$active = null, this.$items = null, this.options.keyboard && this.$element.on("keydown.bs.carousel", a.proxy(this.keydown, this)), "hover" == this.options.pause && !("ontouchstart" in document.documentElement) && this.$element.on("mouseenter.bs.carousel", a.proxy(this.pause, this)).on("mouseleave.bs.carousel", a.proxy(this.cycle, this))
    };
    c.VERSION = "3.3.6", c.TRANSITION_DURATION = 600, c.DEFAULTS = {
        interval: 5e3,
        pause: "hover",
        wrap: !0,
        keyboard: !0
    }, c.prototype.keydown = function(a) {
        if (!/input|textarea/i.test(a.target.tagName)) {
            switch (a.which) {
                case 37:
                    this.prev();
                    break;
                case 39:
                    this.next();
                    break;
                default:
                    return
            }
            a.preventDefault()
        }
    }, c.prototype.cycle = function(b) {
        return b || (this.paused = !1), this.interval && clearInterval(this.interval), this.options.interval && !this.paused && (this.interval = setInterval(a.proxy(this.next, this), this.options.interval)), this
    }, c.prototype.getItemIndex = function(a) {
        return this.$items = a.parent().children(".item"), this.$items.index(a || this.$active)
    }, c.prototype.getItemForDirection = function(a, b) {
        var c = this.getItemIndex(b),
            d = "prev" == a && 0 === c || "next" == a && c == this.$items.length - 1;
        if (d && !this.options.wrap) return b;
        var e = "prev" == a ? -1 : 1,
            f = (c + e) % this.$items.length;
        return this.$items.eq(f)
    }, c.prototype.to = function(a) {
        var b = this,
            c = this.getItemIndex(this.$active = this.$element.find(".item.active"));
        return a > this.$items.length - 1 || 0 > a ? void 0 : this.sliding ? this.$element.one("slid.bs.carousel", function() {
            b.to(a)
        }) : c == a ? this.pause().cycle() : this.slide(a > c ? "next" : "prev", this.$items.eq(a))
    }, c.prototype.pause = function(b) {
        return b || (this.paused = !0), this.$element.find(".next, .prev").length && a.support.transition && (this.$element.trigger(a.support.transition.end), this.cycle(!0)), this.interval = clearInterval(this.interval), this
    }, c.prototype.next = function() {
        return this.sliding ? void 0 : this.slide("next")
    }, c.prototype.prev = function() {
        return this.sliding ? void 0 : this.slide("prev")
    }, c.prototype.slide = function(b, d) {
        var e = this.$element.find(".item.active"),
            f = d || this.getItemForDirection(b, e),
            g = this.interval,
            h = "next" == b ? "left" : "right",
            i = this;
        if (f.hasClass("active")) return this.sliding = !1;
        var j = f[0],
            k = a.Event("slide.bs.carousel", {
                relatedTarget: j,
                direction: h
            });
        if (this.$element.trigger(k), !k.isDefaultPrevented()) {
            if (this.sliding = !0, g && this.pause(), this.$indicators.length) {
                this.$indicators.find(".active").removeClass("active");
                var l = a(this.$indicators.children()[this.getItemIndex(f)]);
                l && l.addClass("active")
            }
            var m = a.Event("slid.bs.carousel", {
                relatedTarget: j,
                direction: h
            });
            return a.support.transition && this.$element.hasClass("slide") ? (f.addClass(b), f[0].offsetWidth, e.addClass(h), f.addClass(h), e.one("bsTransitionEnd", function() {
                f.removeClass([b, h].join(" ")).addClass("active"), e.removeClass(["active", h].join(" ")), i.sliding = !1, setTimeout(function() {
                    i.$element.trigger(m)
                }, 0)
            }).emulateTransitionEnd(c.TRANSITION_DURATION)) : (e.removeClass("active"), f.addClass("active"), this.sliding = !1, this.$element.trigger(m)), g && this.cycle(), this
        }
    };
    var d = a.fn.carousel;
    a.fn.carousel = b, a.fn.carousel.Constructor = c, a.fn.carousel.noConflict = function() {
        return a.fn.carousel = d, this
    };
    var e = function(c) {
        var d, e = a(this),
            f = a(e.attr("data-target") || (d = e.attr("href")) && d.replace(/.*(?=#[^\s]+$)/, ""));
        if (f.hasClass("carousel")) {
            var g = a.extend({}, f.data(), e.data()),
                h = e.attr("data-slide-to");
            h && (g.interval = !1), b.call(f, g), h && f.data("bs.carousel").to(h), c.preventDefault()
        }
    };
    a(document).on("click.bs.carousel.data-api", "[data-slide]", e).on("click.bs.carousel.data-api", "[data-slide-to]", e), a(window).on("load", function() {
        a('[data-ride="carousel"]').each(function() {
            var c = a(this);
            b.call(c, c.data())
        })
    })
}(jQuery), + function(a) {
    "use strict";

    function b(b) {
        var c, d = b.attr("data-target") || (c = b.attr("href")) && c.replace(/.*(?=#[^\s]+$)/, "");
        return a(d)
    }

    function c(b) {
        return this.each(function() {
            var c = a(this),
                e = c.data("bs.collapse"),
                f = a.extend({}, d.DEFAULTS, c.data(), "object" == typeof b && b);
            !e && f.toggle && /show|hide/.test(b) && (f.toggle = !1), e || c.data("bs.collapse", e = new d(this, f)), "string" == typeof b && e[b]()
        })
    }
    var d = function(b, c) {
        this.$element = a(b), this.options = a.extend({}, d.DEFAULTS, c), this.$trigger = a('[data-toggle="collapse"][href="#' + b.id + '"],[data-toggle="collapse"][data-target="#' + b.id + '"]'), this.transitioning = null, this.options.parent ? this.$parent = this.getParent() : this.addAriaAndCollapsedClass(this.$element, this.$trigger), this.options.toggle && this.toggle()
    };
    d.VERSION = "3.3.6", d.TRANSITION_DURATION = 350, d.DEFAULTS = {
        toggle: !0
    }, d.prototype.dimension = function() {
        var a = this.$element.hasClass("width");
        return a ? "width" : "height"
    }, d.prototype.show = function() {
        if (!this.transitioning && !this.$element.hasClass("in")) {
            var b, e = this.$parent && this.$parent.children(".panel").children(".in, .collapsing");
            if (!(e && e.length && (b = e.data("bs.collapse"), b && b.transitioning))) {
                var f = a.Event("show.bs.collapse");
                if (this.$element.trigger(f), !f.isDefaultPrevented()) {
                    e && e.length && (c.call(e, "hide"), b || e.data("bs.collapse", null));
                    var g = this.dimension();
                    this.$element.removeClass("collapse").addClass("collapsing")[g](0).attr("aria-expanded", !0), this.$trigger.removeClass("collapsed").attr("aria-expanded", !0), this.transitioning = 1;
                    var h = function() {
                        this.$element.removeClass("collapsing").addClass("collapse in")[g](""), this.transitioning = 0, this.$element.trigger("shown.bs.collapse")
                    };
                    if (!a.support.transition) return h.call(this);
                    var i = a.camelCase(["scroll", g].join("-"));
                    this.$element.one("bsTransitionEnd", a.proxy(h, this)).emulateTransitionEnd(d.TRANSITION_DURATION)[g](this.$element[0][i])
                }
            }
        }
    }, d.prototype.hide = function() {
        if (!this.transitioning && this.$element.hasClass("in")) {
            var b = a.Event("hide.bs.collapse");
            if (this.$element.trigger(b), !b.isDefaultPrevented()) {
                var c = this.dimension();
                this.$element[c](this.$element[c]())[0].offsetHeight, this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded", !1), this.$trigger.addClass("collapsed").attr("aria-expanded", !1), this.transitioning = 1;
                var e = function() {
                    this.transitioning = 0, this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse")
                };
                return a.support.transition ? void this.$element[c](0).one("bsTransitionEnd", a.proxy(e, this)).emulateTransitionEnd(d.TRANSITION_DURATION) : e.call(this)
            }
        }
    }, d.prototype.toggle = function() {
        this[this.$element.hasClass("in") ? "hide" : "show"]()
    }, d.prototype.getParent = function() {
        return a(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each(a.proxy(function(c, d) {
            var e = a(d);
            this.addAriaAndCollapsedClass(b(e), e)
        }, this)).end()
    }, d.prototype.addAriaAndCollapsedClass = function(a, b) {
        var c = a.hasClass("in");
        a.attr("aria-expanded", c), b.toggleClass("collapsed", !c).attr("aria-expanded", c)
    };
    var e = a.fn.collapse;
    a.fn.collapse = c, a.fn.collapse.Constructor = d, a.fn.collapse.noConflict = function() {
        return a.fn.collapse = e, this
    }, a(document).on("click.bs.collapse.data-api", '[data-toggle="collapse"]', function(d) {
        var e = a(this);
        e.attr("data-target") || d.preventDefault();
        var f = b(e),
            g = f.data("bs.collapse"),
            h = g ? "toggle" : e.data();
        c.call(f, h)
    })
}(jQuery), + function(a) {
    "use strict";

    function b(b) {
        var c = b.attr("data-target");
        c || (c = b.attr("href"), c = c && /#[A-Za-z]/.test(c) && c.replace(/.*(?=#[^\s]*$)/, ""));
        var d = c && a(c);
        return d && d.length ? d : b.parent()
    }

    function c(c) {
        c && 3 === c.which || (a(e).remove(), a(f).each(function() {
            var d = a(this),
                e = b(d),
                f = {
                    relatedTarget: this
                };
            e.hasClass("open") && (c && "click" == c.type && /input|textarea/i.test(c.target.tagName) && a.contains(e[0], c.target) || (e.trigger(c = a.Event("hide.bs.dropdown", f)), c.isDefaultPrevented() || (d.attr("aria-expanded", "false"), e.removeClass("open").trigger(a.Event("hidden.bs.dropdown", f)))))
        }))
    }

    function d(b) {
        return this.each(function() {
            var c = a(this),
                d = c.data("bs.dropdown");
            d || c.data("bs.dropdown", d = new g(this)), "string" == typeof b && d[b].call(c)
        })
    }
    var e = ".dropdown-backdrop",
        f = '[data-toggle="dropdown"]',
        g = function(b) {
            a(b).on("click.bs.dropdown", this.toggle)
        };
    g.VERSION = "3.3.6", g.prototype.toggle = function(d) {
        var e = a(this);
        if (!e.is(".disabled, :disabled")) {
            var f = b(e),
                g = f.hasClass("open");
            if (c(), !g) {
                "ontouchstart" in document.documentElement && !f.closest(".navbar-nav").length && a(document.createElement("div")).addClass("dropdown-backdrop").insertAfter(a(this)).on("click", c);
                var h = {
                    relatedTarget: this
                };
                if (f.trigger(d = a.Event("show.bs.dropdown", h)), d.isDefaultPrevented()) return;
                e.trigger("focus").attr("aria-expanded", "true"), f.toggleClass("open").trigger(a.Event("shown.bs.dropdown", h))
            }
            return !1
        }
    }, g.prototype.keydown = function(c) {
        if (/(38|40|27|32)/.test(c.which) && !/input|textarea/i.test(c.target.tagName)) {
            var d = a(this);
            if (c.preventDefault(), c.stopPropagation(), !d.is(".disabled, :disabled")) {
                var e = b(d),
                    g = e.hasClass("open");
                if (!g && 27 != c.which || g && 27 == c.which) return 27 == c.which && e.find(f).trigger("focus"), d.trigger("click");
                var h = " li:not(.disabled):visible a",
                    i = e.find(".dropdown-menu" + h);
                if (i.length) {
                    var j = i.index(c.target);
                    38 == c.which && j > 0 && j--, 40 == c.which && j < i.length - 1 && j++, ~j || (j = 0), i.eq(j).trigger("focus")
                }
            }
        }
    };
    var h = a.fn.dropdown;
    a.fn.dropdown = d, a.fn.dropdown.Constructor = g, a.fn.dropdown.noConflict = function() {
        return a.fn.dropdown = h, this
    }, a(document).on("click.bs.dropdown.data-api", c).on("click.bs.dropdown.data-api", ".dropdown form", function(a) {
        a.stopPropagation()
    }).on("click.bs.dropdown.data-api", f, g.prototype.toggle).on("keydown.bs.dropdown.data-api", f, g.prototype.keydown).on("keydown.bs.dropdown.data-api", ".dropdown-menu", g.prototype.keydown)
}(jQuery), + function(a) {
    "use strict";

    function b(b, d) {
        return this.each(function() {
            var e = a(this),
                f = e.data("bs.modal"),
                g = a.extend({}, c.DEFAULTS, e.data(), "object" == typeof b && b);
            f || e.data("bs.modal", f = new c(this, g)), "string" == typeof b ? f[b](d) : g.show && f.show(d)
        })
    }
    var c = function(b, c) {
        this.options = c, this.$body = a(document.body), this.$element = a(b), this.$dialog = this.$element.find(".modal-dialog"), this.$backdrop = null, this.isShown = null, this.originalBodyPad = null, this.scrollbarWidth = 0, this.ignoreBackdropClick = !1, this.options.remote && this.$element.find(".modal-content").load(this.options.remote, a.proxy(function() {
            this.$element.trigger("loaded.bs.modal")
        }, this))
    };
    c.VERSION = "3.3.6", c.TRANSITION_DURATION = 300, c.BACKDROP_TRANSITION_DURATION = 150, c.DEFAULTS = {
        backdrop: !0,
        keyboard: !0,
        show: !0
    }, c.prototype.toggle = function(a) {
        return this.isShown ? this.hide() : this.show(a)
    }, c.prototype.show = function(b) {
        var d = this,
            e = a.Event("show.bs.modal", {
                relatedTarget: b
            });
        this.$element.trigger(e), this.isShown || e.isDefaultPrevented() || (this.isShown = !0, this.checkScrollbar(), this.setScrollbar(), this.$body.addClass("modal-open"), this.escape(), this.resize(), this.$element.on("click.dismiss.bs.modal", '[data-dismiss="modal"]', a.proxy(this.hide, this)), this.$dialog.on("mousedown.dismiss.bs.modal", function() {
            d.$element.one("mouseup.dismiss.bs.modal", function(b) {
                a(b.target).is(d.$element) && (d.ignoreBackdropClick = !0)
            })
        }), this.backdrop(function() {
            var e = a.support.transition && d.$element.hasClass("fade");
            d.$element.parent().length || d.$element.appendTo(d.$body), d.$element.show().scrollTop(0), d.adjustDialog(), e && d.$element[0].offsetWidth, d.$element.addClass("in"), d.enforceFocus();
            var f = a.Event("shown.bs.modal", {
                relatedTarget: b
            });
            e ? d.$dialog.one("bsTransitionEnd", function() {
                d.$element.trigger("focus").trigger(f)
            }).emulateTransitionEnd(c.TRANSITION_DURATION) : d.$element.trigger("focus").trigger(f)
        }))
    }, c.prototype.hide = function(b) {
        b && b.preventDefault(), b = a.Event("hide.bs.modal"), this.$element.trigger(b), this.isShown && !b.isDefaultPrevented() && (this.isShown = !1, this.escape(), this.resize(), a(document).off("focusin.bs.modal"), this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal"), this.$dialog.off("mousedown.dismiss.bs.modal"), a.support.transition && this.$element.hasClass("fade") ? this.$element.one("bsTransitionEnd", a.proxy(this.hideModal, this)).emulateTransitionEnd(c.TRANSITION_DURATION) : this.hideModal())
    }, c.prototype.enforceFocus = function() {
        a(document).off("focusin.bs.modal").on("focusin.bs.modal", a.proxy(function(a) {
            this.$element[0] === a.target || this.$element.has(a.target).length || this.$element.trigger("focus")
        }, this))
    }, c.prototype.escape = function() {
        this.isShown && this.options.keyboard ? this.$element.on("keydown.dismiss.bs.modal", a.proxy(function(a) {
            27 == a.which && this.hide()
        }, this)) : this.isShown || this.$element.off("keydown.dismiss.bs.modal")
    }, c.prototype.resize = function() {
        this.isShown ? a(window).on("resize.bs.modal", a.proxy(this.handleUpdate, this)) : a(window).off("resize.bs.modal")
    }, c.prototype.hideModal = function() {
        var a = this;
        this.$element.hide(), this.backdrop(function() {
            a.$body.removeClass("modal-open"), a.resetAdjustments(), a.resetScrollbar(), a.$element.trigger("hidden.bs.modal")
        })
    }, c.prototype.removeBackdrop = function() {
        this.$backdrop && this.$backdrop.remove(), this.$backdrop = null
    }, c.prototype.backdrop = function(b) {
        var d = this,
            e = this.$element.hasClass("fade") ? "fade" : "";
        if (this.isShown && this.options.backdrop) {
            var f = a.support.transition && e;
            if (this.$backdrop = a(document.createElement("div")).addClass("modal-backdrop " + e).appendTo(this.$body), this.$element.on("click.dismiss.bs.modal", a.proxy(function(a) {
                    return this.ignoreBackdropClick ? void(this.ignoreBackdropClick = !1) : void(a.target === a.currentTarget && ("static" == this.options.backdrop ? this.$element[0].focus() : this.hide()))
                }, this)), f && this.$backdrop[0].offsetWidth, this.$backdrop.addClass("in"), !b) return;
            f ? this.$backdrop.one("bsTransitionEnd", b).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION) : b()
        } else if (!this.isShown && this.$backdrop) {
            this.$backdrop.removeClass("in");
            var g = function() {
                d.removeBackdrop(), b && b()
            };
            a.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one("bsTransitionEnd", g).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION) : g()
        } else b && b()
    }, c.prototype.handleUpdate = function() {
        this.adjustDialog()
    }, c.prototype.adjustDialog = function() {
        var a = this.$element[0].scrollHeight > document.documentElement.clientHeight;
        this.$element.css({
            paddingLeft: !this.bodyIsOverflowing && a ? this.scrollbarWidth : "",
            paddingRight: this.bodyIsOverflowing && !a ? this.scrollbarWidth : ""
        })
    }, c.prototype.resetAdjustments = function() {
        this.$element.css({
            paddingLeft: "",
            paddingRight: ""
        })
    }, c.prototype.checkScrollbar = function() {
        var a = window.innerWidth;
        if (!a) {
            var b = document.documentElement.getBoundingClientRect();
            a = b.right - Math.abs(b.left)
        }
        this.bodyIsOverflowing = document.body.clientWidth < a, this.scrollbarWidth = this.measureScrollbar()
    }, c.prototype.setScrollbar = function() {
        var a = parseInt(this.$body.css("padding-right") || 0, 10);
        this.originalBodyPad = document.body.style.paddingRight || "", this.bodyIsOverflowing && this.$body.css("padding-right", a + this.scrollbarWidth)
    }, c.prototype.resetScrollbar = function() {
        this.$body.css("padding-right", this.originalBodyPad)
    }, c.prototype.measureScrollbar = function() {
        var a = document.createElement("div");
        a.className = "modal-scrollbar-measure", this.$body.append(a);
        var b = a.offsetWidth - a.clientWidth;
        return this.$body[0].removeChild(a), b
    };
    var d = a.fn.modal;
    a.fn.modal = b, a.fn.modal.Constructor = c, a.fn.modal.noConflict = function() {
        return a.fn.modal = d, this
    }, a(document).on("click.bs.modal.data-api", '[data-toggle="modal"]', function(c) {
        var d = a(this),
            e = d.attr("href"),
            f = a(d.attr("data-target") || e && e.replace(/.*(?=#[^\s]+$)/, "")),
            g = f.data("bs.modal") ? "toggle" : a.extend({
                remote: !/#/.test(e) && e
            }, f.data(), d.data());
        d.is("a") && c.preventDefault(), f.one("show.bs.modal", function(a) {
            a.isDefaultPrevented() || f.one("hidden.bs.modal", function() {
                d.is(":visible") && d.trigger("focus")
            })
        }), b.call(f, g, this)
    })
}(jQuery), + function(a) {
    "use strict";

    function b(b) {
        return this.each(function() {
            var d = a(this),
                e = d.data("bs.tooltip"),
                f = "object" == typeof b && b;
            (e || !/destroy|hide/.test(b)) && (e || d.data("bs.tooltip", e = new c(this, f)), "string" == typeof b && e[b]())
        })
    }
    var c = function(a, b) {
        this.type = null, this.options = null, this.enabled = null, this.timeout = null, this.hoverState = null, this.$element = null, this.inState = null, this.init("tooltip", a, b)
    };
    c.VERSION = "3.3.6", c.TRANSITION_DURATION = 150, c.DEFAULTS = {
        animation: !0,
        placement: "top",
        selector: !1,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: "hover focus",
        title: "",
        delay: 0,
        html: !1,
        container: !1,
        viewport: {
            selector: "body",
            padding: 0
        }
    }, c.prototype.init = function(b, c, d) {
        if (this.enabled = !0, this.type = b, this.$element = a(c), this.options = this.getOptions(d), this.$viewport = this.options.viewport && a(a.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : this.options.viewport.selector || this.options.viewport), this.inState = {
                click: !1,
                hover: !1,
                focus: !1
            }, this.$element[0] instanceof document.constructor && !this.options.selector) throw new Error("`selector` option must be specified when initializing " + this.type + " on the window.document object!");
        for (var e = this.options.trigger.split(" "), f = e.length; f--;) {
            var g = e[f];
            if ("click" == g) this.$element.on("click." + this.type, this.options.selector, a.proxy(this.toggle, this));
            else if ("manual" != g) {
                var h = "hover" == g ? "mouseenter" : "focusin",
                    i = "hover" == g ? "mouseleave" : "focusout";
                this.$element.on(h + "." + this.type, this.options.selector, a.proxy(this.enter, this)), this.$element.on(i + "." + this.type, this.options.selector, a.proxy(this.leave, this))
            }
        }
        this.options.selector ? this._options = a.extend({}, this.options, {
            trigger: "manual",
            selector: ""
        }) : this.fixTitle()
    }, c.prototype.getDefaults = function() {
        return c.DEFAULTS
    }, c.prototype.getOptions = function(b) {
        return b = a.extend({}, this.getDefaults(), this.$element.data(), b), b.delay && "number" == typeof b.delay && (b.delay = {
            show: b.delay,
            hide: b.delay
        }), b
    }, c.prototype.getDelegateOptions = function() {
        var b = {},
            c = this.getDefaults();
        return this._options && a.each(this._options, function(a, d) {
            c[a] != d && (b[a] = d)
        }), b
    }, c.prototype.enter = function(b) {
        var c = b instanceof this.constructor ? b : a(b.currentTarget).data("bs." + this.type);
        return c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data("bs." + this.type, c)), b instanceof a.Event && (c.inState["focusin" == b.type ? "focus" : "hover"] = !0), c.tip().hasClass("in") || "in" == c.hoverState ? void(c.hoverState = "in") : (clearTimeout(c.timeout), c.hoverState = "in", c.options.delay && c.options.delay.show ? void(c.timeout = setTimeout(function() {
            "in" == c.hoverState && c.show()
        }, c.options.delay.show)) : c.show())
    }, c.prototype.isInStateTrue = function() {
        for (var a in this.inState)
            if (this.inState[a]) return !0;
        return !1
    }, c.prototype.leave = function(b) {
        var c = b instanceof this.constructor ? b : a(b.currentTarget).data("bs." + this.type);
        return c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data("bs." + this.type, c)), b instanceof a.Event && (c.inState["focusout" == b.type ? "focus" : "hover"] = !1), c.isInStateTrue() ? void 0 : (clearTimeout(c.timeout), c.hoverState = "out", c.options.delay && c.options.delay.hide ? void(c.timeout = setTimeout(function() {
            "out" == c.hoverState && c.hide()
        }, c.options.delay.hide)) : c.hide())
    }, c.prototype.show = function() {
        var b = a.Event("show.bs." + this.type);
        if (this.hasContent() && this.enabled) {
            this.$element.trigger(b);
            var d = a.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
            if (b.isDefaultPrevented() || !d) return;
            var e = this,
                f = this.tip(),
                g = this.getUID(this.type);
            this.setContent(), f.attr("id", g), this.$element.attr("aria-describedby", g), this.options.animation && f.addClass("fade");
            var h = "function" == typeof this.options.placement ? this.options.placement.call(this, f[0], this.$element[0]) : this.options.placement,
                i = /\s?auto?\s?/i,
                j = i.test(h);
            j && (h = h.replace(i, "") || "top"), f.detach().css({
                top: 0,
                left: 0,
                display: "block"
            }).addClass(h).data("bs." + this.type, this), this.options.container ? f.appendTo(this.options.container) : f.insertAfter(this.$element), this.$element.trigger("inserted.bs." + this.type);
            var k = this.getPosition(),
                l = f[0].offsetWidth,
                m = f[0].offsetHeight;
            if (j) {
                var n = h,
                    o = this.getPosition(this.$viewport);
                h = "bottom" == h && k.bottom + m > o.bottom ? "top" : "top" == h && k.top - m < o.top ? "bottom" : "right" == h && k.right + l > o.width ? "left" : "left" == h && k.left - l < o.left ? "right" : h, f.removeClass(n).addClass(h)
            }
            var p = this.getCalculatedOffset(h, k, l, m);
            this.applyPlacement(p, h);
            var q = function() {
                var a = e.hoverState;
                e.$element.trigger("shown.bs." + e.type), e.hoverState = null, "out" == a && e.leave(e)
            };
            a.support.transition && this.$tip.hasClass("fade") ? f.one("bsTransitionEnd", q).emulateTransitionEnd(c.TRANSITION_DURATION) : q()
        }
    }, c.prototype.applyPlacement = function(b, c) {
        var d = this.tip(),
            e = d[0].offsetWidth,
            f = d[0].offsetHeight,
            g = parseInt(d.css("margin-top"), 10),
            h = parseInt(d.css("margin-left"), 10);
        isNaN(g) && (g = 0), isNaN(h) && (h = 0), b.top += g, b.left += h, a.offset.setOffset(d[0], a.extend({
            using: function(a) {
                d.css({
                    top: Math.round(a.top),
                    left: Math.round(a.left)
                })
            }
        }, b), 0), d.addClass("in");
        var i = d[0].offsetWidth,
            j = d[0].offsetHeight;
        "top" == c && j != f && (b.top = b.top + f - j);
        var k = this.getViewportAdjustedDelta(c, b, i, j);
        k.left ? b.left += k.left : b.top += k.top;
        var l = /top|bottom/.test(c),
            m = l ? 2 * k.left - e + i : 2 * k.top - f + j,
            n = l ? "offsetWidth" : "offsetHeight";
        d.offset(b), this.replaceArrow(m, d[0][n], l)
    }, c.prototype.replaceArrow = function(a, b, c) {
        this.arrow().css(c ? "left" : "top", 50 * (1 - a / b) + "%").css(c ? "top" : "left", "")
    }, c.prototype.setContent = function() {
        var a = this.tip(),
            b = this.getTitle();
        a.find(".tooltip-inner")[this.options.html ? "html" : "text"](b), a.removeClass("fade in top bottom left right")
    }, c.prototype.hide = function(b) {
        function d() {
            "in" != e.hoverState && f.detach(), e.$element.removeAttr("aria-describedby").trigger("hidden.bs." + e.type), b && b()
        }
        var e = this,
            f = a(this.$tip),
            g = a.Event("hide.bs." + this.type);
        return this.$element.trigger(g), g.isDefaultPrevented() ? void 0 : (f.removeClass("in"), a.support.transition && f.hasClass("fade") ? f.one("bsTransitionEnd", d).emulateTransitionEnd(c.TRANSITION_DURATION) : d(), this.hoverState = null, this)
    }, c.prototype.fixTitle = function() {
        var a = this.$element;
        (a.attr("title") || "string" != typeof a.attr("data-original-title")) && a.attr("data-original-title", a.attr("title") || "").attr("title", "")
    }, c.prototype.hasContent = function() {
        return this.getTitle()
    }, c.prototype.getPosition = function(b) {
        b = b || this.$element;
        var c = b[0],
            d = "BODY" == c.tagName,
            e = c.getBoundingClientRect();
        null == e.width && (e = a.extend({}, e, {
            width: e.right - e.left,
            height: e.bottom - e.top
        }));
        var f = d ? {
                top: 0,
                left: 0
            } : b.offset(),
            g = {
                scroll: d ? document.documentElement.scrollTop || document.body.scrollTop : b.scrollTop()
            },
            h = d ? {
                width: a(window).width(),
                height: a(window).height()
            } : null;
        return a.extend({}, e, g, h, f)
    }, c.prototype.getCalculatedOffset = function(a, b, c, d) {
        return "bottom" == a ? {
            top: b.top + b.height,
            left: b.left + b.width / 2 - c / 2
        } : "top" == a ? {
            top: b.top - d,
            left: b.left + b.width / 2 - c / 2
        } : "left" == a ? {
            top: b.top + b.height / 2 - d / 2,
            left: b.left - c
        } : {
            top: b.top + b.height / 2 - d / 2,
            left: b.left + b.width
        }
    }, c.prototype.getViewportAdjustedDelta = function(a, b, c, d) {
        var e = {
            top: 0,
            left: 0
        };
        if (!this.$viewport) return e;
        var f = this.options.viewport && this.options.viewport.padding || 0,
            g = this.getPosition(this.$viewport);
        if (/right|left/.test(a)) {
            var h = b.top - f - g.scroll,
                i = b.top + f - g.scroll + d;
            h < g.top ? e.top = g.top - h : i > g.top + g.height && (e.top = g.top + g.height - i)
        } else {
            var j = b.left - f,
                k = b.left + f + c;
            j < g.left ? e.left = g.left - j : k > g.right && (e.left = g.left + g.width - k)
        }
        return e
    }, c.prototype.getTitle = function() {
        var a, b = this.$element,
            c = this.options;
        return a = b.attr("data-original-title") || ("function" == typeof c.title ? c.title.call(b[0]) : c.title)
    }, c.prototype.getUID = function(a) {
        do a += ~~(1e6 * Math.random()); while (document.getElementById(a));
        return a
    }, c.prototype.tip = function() {
        if (!this.$tip && (this.$tip = a(this.options.template), 1 != this.$tip.length)) throw new Error(this.type + " `template` option must consist of exactly 1 top-level element!");
        return this.$tip
    }, c.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow")
    }, c.prototype.enable = function() {
        this.enabled = !0
    }, c.prototype.disable = function() {
        this.enabled = !1
    }, c.prototype.toggleEnabled = function() {
        this.enabled = !this.enabled
    }, c.prototype.toggle = function(b) {
        var c = this;
        b && (c = a(b.currentTarget).data("bs." + this.type), c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data("bs." + this.type, c))), b ? (c.inState.click = !c.inState.click, c.isInStateTrue() ? c.enter(c) : c.leave(c)) : c.tip().hasClass("in") ? c.leave(c) : c.enter(c)
    }, c.prototype.destroy = function() {
        var a = this;
        clearTimeout(this.timeout), this.hide(function() {
            a.$element.off("." + a.type).removeData("bs." + a.type), a.$tip && a.$tip.detach(), a.$tip = null, a.$arrow = null, a.$viewport = null
        })
    };
    var d = a.fn.tooltip;
    a.fn.tooltip = b, a.fn.tooltip.Constructor = c, a.fn.tooltip.noConflict = function() {
        return a.fn.tooltip = d, this
    }
}(jQuery), + function(a) {
    "use strict";

    function b(b) {
        return this.each(function() {
            var d = a(this),
                e = d.data("bs.popover"),
                f = "object" == typeof b && b;
            (e || !/destroy|hide/.test(b)) && (e || d.data("bs.popover", e = new c(this, f)), "string" == typeof b && e[b]())
        })
    }
    var c = function(a, b) {
        this.init("popover", a, b)
    };
    if (!a.fn.tooltip) throw new Error("Popover requires tooltip.js");
    c.VERSION = "3.3.6", c.DEFAULTS = a.extend({}, a.fn.tooltip.Constructor.DEFAULTS, {
        placement: "right",
        trigger: "click",
        content: "",
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
    }), c.prototype = a.extend({}, a.fn.tooltip.Constructor.prototype), c.prototype.constructor = c, c.prototype.getDefaults = function() {
        return c.DEFAULTS
    }, c.prototype.setContent = function() {
        var a = this.tip(),
            b = this.getTitle(),
            c = this.getContent();
        a.find(".popover-title")[this.options.html ? "html" : "text"](b), a.find(".popover-content").children().detach().end()[this.options.html ? "string" == typeof c ? "html" : "append" : "text"](c), a.removeClass("fade top bottom left right in"), a.find(".popover-title").html() || a.find(".popover-title").hide()
    }, c.prototype.hasContent = function() {
        return this.getTitle() || this.getContent()
    }, c.prototype.getContent = function() {
        var a = this.$element,
            b = this.options;
        return a.attr("data-content") || ("function" == typeof b.content ? b.content.call(a[0]) : b.content)
    }, c.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find(".arrow")
    };
    var d = a.fn.popover;
    a.fn.popover = b, a.fn.popover.Constructor = c, a.fn.popover.noConflict = function() {
        return a.fn.popover = d, this
    }
}(jQuery), + function(a) {
    "use strict";

    function b(c, d) {
        this.$body = a(document.body), this.$scrollElement = a(a(c).is(document.body) ? window : c), this.options = a.extend({}, b.DEFAULTS, d), this.selector = (this.options.target || "") + " .nav li > a", this.offsets = [], this.targets = [], this.activeTarget = null, this.scrollHeight = 0, this.$scrollElement.on("scroll.bs.scrollspy", a.proxy(this.process, this)), this.refresh(), this.process()
    }

    function c(c) {
        return this.each(function() {
            var d = a(this),
                e = d.data("bs.scrollspy"),
                f = "object" == typeof c && c;
            e || d.data("bs.scrollspy", e = new b(this, f)), "string" == typeof c && e[c]()
        })
    }
    b.VERSION = "3.3.6", b.DEFAULTS = {
        offset: 10
    }, b.prototype.getScrollHeight = function() {
        return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
    }, b.prototype.refresh = function() {
        var b = this,
            c = "offset",
            d = 0;
        this.offsets = [], this.targets = [], this.scrollHeight = this.getScrollHeight(), a.isWindow(this.$scrollElement[0]) || (c = "position", d = this.$scrollElement.scrollTop()), this.$body.find(this.selector).map(function() {
            var b = a(this),
                e = b.data("target") || b.attr("href"),
                f = /^#./.test(e) && a(e);
            return f && f.length && f.is(":visible") && [
                [f[c]().top + d, e]
            ] || null
        }).sort(function(a, b) {
            return a[0] - b[0]
        }).each(function() {
            b.offsets.push(this[0]), b.targets.push(this[1])
        })
    }, b.prototype.process = function() {
        var a, b = this.$scrollElement.scrollTop() + this.options.offset,
            c = this.getScrollHeight(),
            d = this.options.offset + c - this.$scrollElement.height(),
            e = this.offsets,
            f = this.targets,
            g = this.activeTarget;
        if (this.scrollHeight != c && this.refresh(), b >= d) return g != (a = f[f.length - 1]) && this.activate(a);
        if (g && b < e[0]) return this.activeTarget = null, this.clear();
        for (a = e.length; a--;) g != f[a] && b >= e[a] && (void 0 === e[a + 1] || b < e[a + 1]) && this.activate(f[a])
    }, b.prototype.activate = function(b) {
        this.activeTarget = b, this.clear();
        var c = this.selector + '[data-target="' + b + '"],' + this.selector + '[href="' + b + '"]',
            d = a(c).parents("li").addClass("active");
        d.parent(".dropdown-menu").length && (d = d.closest("li.dropdown").addClass("active")), d.trigger("activate.bs.scrollspy")
    }, b.prototype.clear = function() {
        a(this.selector).parentsUntil(this.options.target, ".active").removeClass("active")
    };
    var d = a.fn.scrollspy;
    a.fn.scrollspy = c, a.fn.scrollspy.Constructor = b, a.fn.scrollspy.noConflict = function() {
        return a.fn.scrollspy = d, this
    }, a(window).on("load.bs.scrollspy.data-api", function() {
        a('[data-spy="scroll"]').each(function() {
            var b = a(this);
            c.call(b, b.data())
        })
    })
}(jQuery), + function(a) {
    "use strict";

    function b(b) {
        return this.each(function() {
            var d = a(this),
                e = d.data("bs.tab");
            e || d.data("bs.tab", e = new c(this)), "string" == typeof b && e[b]()
        })
    }
    var c = function(b) {
        this.element = a(b)
    };
    c.VERSION = "3.3.6", c.TRANSITION_DURATION = 150, c.prototype.show = function() {
        var b = this.element,
            c = b.closest("ul:not(.dropdown-menu)"),
            d = b.data("target");
        if (d || (d = b.attr("href"), d = d && d.replace(/.*(?=#[^\s]*$)/, "")), !b.parent("li").hasClass("active")) {
            var e = c.find(".active:last a"),
                f = a.Event("hide.bs.tab", {
                    relatedTarget: b[0]
                }),
                g = a.Event("show.bs.tab", {
                    relatedTarget: e[0]
                });
            if (e.trigger(f), b.trigger(g), !g.isDefaultPrevented() && !f.isDefaultPrevented()) {
                var h = a(d);
                this.activate(b.closest("li"), c), this.activate(h, h.parent(), function() {
                    e.trigger({
                        type: "hidden.bs.tab",
                        relatedTarget: b[0]
                    }), b.trigger({
                        type: "shown.bs.tab",
                        relatedTarget: e[0]
                    })
                })
            }
        }
    }, c.prototype.activate = function(b, d, e) {
        function f() {
            g.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !1), b.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded", !0), h ? (b[0].offsetWidth, b.addClass("in")) : b.removeClass("fade"), b.parent(".dropdown-menu").length && b.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !0), e && e()
        }
        var g = d.find("> .active"),
            h = e && a.support.transition && (g.length && g.hasClass("fade") || !!d.find("> .fade").length);
        g.length && h ? g.one("bsTransitionEnd", f).emulateTransitionEnd(c.TRANSITION_DURATION) : f(), g.removeClass("in")
    };
    var d = a.fn.tab;
    a.fn.tab = b, a.fn.tab.Constructor = c, a.fn.tab.noConflict = function() {
        return a.fn.tab = d, this
    };
    var e = function(c) {
        c.preventDefault(), b.call(a(this), "show")
    };
    a(document).on("click.bs.tab.data-api", '[data-toggle="tab"]', e).on("click.bs.tab.data-api", '[data-toggle="pill"]', e)
}(jQuery), + function(a) {
    "use strict";

    function b(b) {
        return this.each(function() {
            var d = a(this),
                e = d.data("bs.affix"),
                f = "object" == typeof b && b;
            e || d.data("bs.affix", e = new c(this, f)), "string" == typeof b && e[b]()
        })
    }
    var c = function(b, d) {
        this.options = a.extend({}, c.DEFAULTS, d), this.$target = a(this.options.target).on("scroll.bs.affix.data-api", a.proxy(this.checkPosition, this)).on("click.bs.affix.data-api", a.proxy(this.checkPositionWithEventLoop, this)), this.$element = a(b), this.affixed = null, this.unpin = null, this.pinnedOffset = null, this.checkPosition()
    };
    c.VERSION = "3.3.6", c.RESET = "affix affix-top affix-bottom", c.DEFAULTS = {
        offset: 0,
        target: window
    }, c.prototype.getState = function(a, b, c, d) {
        var e = this.$target.scrollTop(),
            f = this.$element.offset(),
            g = this.$target.height();
        if (null != c && "top" == this.affixed) return c > e ? "top" : !1;
        if ("bottom" == this.affixed) return null != c ? e + this.unpin <= f.top ? !1 : "bottom" : a - d >= e + g ? !1 : "bottom";
        var h = null == this.affixed,
            i = h ? e : f.top,
            j = h ? g : b;
        return null != c && c >= e ? "top" : null != d && i + j >= a - d ? "bottom" : !1
    }, c.prototype.getPinnedOffset = function() {
        if (this.pinnedOffset) return this.pinnedOffset;
        this.$element.removeClass(c.RESET).addClass("affix");
        var a = this.$target.scrollTop(),
            b = this.$element.offset();
        return this.pinnedOffset = b.top - a
    }, c.prototype.checkPositionWithEventLoop = function() {
        setTimeout(a.proxy(this.checkPosition, this), 1)
    }, c.prototype.checkPosition = function() {
        if (this.$element.is(":visible")) {
            var b = this.$element.height(),
                d = this.options.offset,
                e = d.top,
                f = d.bottom,
                g = Math.max(a(document).height(), a(document.body).height());
            "object" != typeof d && (f = e = d), "function" == typeof e && (e = d.top(this.$element)), "function" == typeof f && (f = d.bottom(this.$element));
            var h = this.getState(g, b, e, f);
            if (this.affixed != h) {
                null != this.unpin && this.$element.css("top", "");
                var i = "affix" + (h ? "-" + h : ""),
                    j = a.Event(i + ".bs.affix");
                if (this.$element.trigger(j), j.isDefaultPrevented()) return;
                this.affixed = h, this.unpin = "bottom" == h ? this.getPinnedOffset() : null, this.$element.removeClass(c.RESET).addClass(i).trigger(i.replace("affix", "affixed") + ".bs.affix")
            }
            "bottom" == h && this.$element.offset({
                top: g - b - f
            })
        }
    };
    var d = a.fn.affix;
    a.fn.affix = b, a.fn.affix.Constructor = c, a.fn.affix.noConflict = function() {
        return a.fn.affix = d, this
    }, a(window).on("load", function() {
        a('[data-spy="affix"]').each(function() {
            var c = a(this),
                d = c.data();
            d.offset = d.offset || {}, null != d.offsetBottom && (d.offset.bottom = d.offsetBottom), null != d.offsetTop && (d.offset.top = d.offsetTop), b.call(c, d)
        })
    })
}(jQuery);

(function() {
    function D() {
        var a, b = arguments,
            c, d = {},
            e = function(a, b) {
                var c, d;
                typeof a !== "object" && (a = {});
                for (d in b) b.hasOwnProperty(d) && (c = b[d], a[d] = c && typeof c === "object" && Object.prototype.toString.call(c) !== "[object Array]" && d !== "renderTo" && typeof c.nodeType !== "number" ? e(a[d] || {}, c) : b[d]);
                return a
            };
        b[0] === !0 && (d = b[1], b = Array.prototype.slice.call(b, 2));
        c = b.length;
        for (a = 0; a < c; a++) d = e(d, b[a]);
        return d
    }

    function G(a, b) {
        return parseInt(a, b || 10)
    }

    function Ba(a) {
        return typeof a === "string"
    }

    function da(a) {
        return a && typeof a === "object"
    }

    function Ga(a) {
        return Object.prototype.toString.call(a) === "[object Array]"
    }

    function qa(a) {
        return typeof a === "number"
    }

    function Ca(a) {
        return V.log(a) / V.LN10
    }

    function ia(a) {
        return V.pow(10, a)
    }

    function ja(a, b) {
        for (var c = a.length; c--;)
            if (a[c] === b) {
                a.splice(c, 1);
                break
            }
    }

    function q(a) {
        return a !== x && a !== null
    }

    function K(a, b, c) {
        var d, e;
        if (Ba(b)) q(c) ? a.setAttribute(b, c) : a && a.getAttribute && (e = a.getAttribute(b));
        else if (q(b) && da(b))
            for (d in b) a.setAttribute(d, b[d]);
        return e
    }

    function ra(a) {
        return Ga(a) ? a : [a]
    }

    function M(a, b) {
        if (sa && !ca && b && b.opacity !== x) b.filter = "alpha(opacity=" + b.opacity * 100 + ")";
        t(a.style, b)
    }

    function $(a, b, c, d, e) {
        a = C.createElement(a);
        b && t(a, b);
        e && M(a, {
            padding: 0,
            border: P,
            margin: 0
        });
        c && M(a, c);
        d && d.appendChild(a);
        return a
    }

    function ka(a, b) {
        var c = function() {
            return x
        };
        c.prototype = new a;
        t(c.prototype, b);
        return c
    }

    function Ha(a, b) {
        return Array((b || 2) + 1 - String(a).length).join(0) + a
    }

    function Wa(a) {
        return (db && db(a) || nb || 0) * 6E4
    }

    function Ia(a, b) {
        for (var c = "{", d = !1, e, f, g, h, i, j = [];
            (c = a.indexOf(c)) !== -1;) {
            e = a.slice(0, c);
            if (d) {
                f = e.split(":");
                g = f.shift().split(".");
                i = g.length;
                e = b;
                for (h = 0; h < i; h++) e = e[g[h]];
                if (f.length) f = f.join(":"), g = /\.([0-9])/, h = S.lang, i = void 0, /f$/.test(f) ? (i = (i = f.match(g)) ? i[1] : -1, e !== null && (e = B.numberFormat(e, i, h.decimalPoint, f.indexOf(",") > -1 ? h.thousandsSep : ""))) : e = Na(f, e)
            }
            j.push(e);
            a = a.slice(c + 1);
            c = (d = !d) ? "}" : "{"
        }
        j.push(a);
        return j.join("")
    }

    function ob(a) {
        return V.pow(10, T(V.log(a) / V.LN10))
    }

    function pb(a, b, c, d, e) {
        var f, g = a,
            c = p(c, 1);
        f = a / c;
        b || (b = [1, 2, 2.5, 5, 10], d === !1 && (c === 1 ? b = [1, 2, 5, 10] : c <= 0.1 && (b = [1 / c])));
        for (d = 0; d < b.length; d++)
            if (g = b[d], e && g * c >= a || !e && f <= (b[d] + (b[d + 1] || b[d])) / 2) break;
        g *= c;
        return g
    }

    function qb(a, b) {
        var c = a.length,
            d, e;
        for (e = 0; e < c; e++) a[e].ss_i = e;
        a.sort(function(a, c) {
            d = b(a, c);
            return d === 0 ? a.ss_i - c.ss_i : d
        });
        for (e = 0; e < c; e++) delete a[e].ss_i
    }

    function Oa(a) {
        for (var b = a.length, c = a[0]; b--;) a[b] < c && (c = a[b]);
        return c
    }

    function Da(a) {
        for (var b = a.length, c = a[0]; b--;) a[b] > c && (c = a[b]);
        return c
    }

    function Pa(a, b) {
        for (var c in a) a[c] && a[c] !== b && a[c].destroy && a[c].destroy(), delete a[c]
    }

    function Qa(a) {
        eb || (eb = $(Ja));
        a && eb.appendChild(a);
        eb.innerHTML = ""
    }

    function la(a, b) {
        var c = "Highcharts error #" + a + ": www.highcharts.com/errors/" + a;
        if (b) throw c;
        L.console && console.log(c)
    }

    function ea(a, b) {
        return parseFloat(a.toPrecision(b || 14))
    }

    function Ra(a, b) {
        b.renderer.globalAnimation = p(a, b.animation)
    }

    function Cb() {
        var a = S.global,
            b = a.useUTC,
            c = b ? "getUTC" : "get",
            d = b ? "setUTC" : "set";
        ya = a.Date || window.Date;
        nb = b && a.timezoneOffset;
        db = b && a.getTimezoneOffset;
        fb = function(a, c, d, h, i, j) {
            var k;
            b ? (k = ya.UTC.apply(0, arguments), k += Wa(k)) : k = (new ya(a, c, p(d, 1), p(h, 0), p(i, 0), p(j, 0))).getTime();
            return k
        };
        rb = c + "Minutes";
        sb = c + "Hours";
        tb = c + "Day";
        Xa = c + "Date";
        Ya = c + "Month";
        Za = c + "FullYear";
        Db = d + "Milliseconds";
        Eb = d + "Seconds";
        Fb = d + "Minutes";
        Gb = d + "Hours";
        ub = d + "Date";
        vb = d + "Month";
        wb = d + "FullYear"
    }

    function Q() {}

    function Sa(a, b, c, d) {
        this.axis = a;
        this.pos = b;
        this.type = c || "";
        this.isNew = !0;
        !c && !d && this.addLabel()
    }

    function Hb(a, b, c, d, e) {
        var f = a.chart.inverted;
        this.axis = a;
        this.isNegative = c;
        this.options = b;
        this.x = d;
        this.total = null;
        this.points = {};
        this.stack = e;
        this.alignOptions = {
            align: b.align || (f ? c ? "left" : "right" : "center"),
            verticalAlign: b.verticalAlign || (f ? "middle" : c ? "bottom" : "top"),
            y: p(b.y, f ? 4 : c ? 14 : -6),
            x: p(b.x, f ? c ? -6 : 6 : 0)
        };
        this.textAlign = b.textAlign || (f ? c ? "right" : "left" : "center")
    }
    var x, C = document,
        L = window,
        V = Math,
        w = V.round,
        T = V.floor,
        ta = V.ceil,
        s = V.max,
        z = V.min,
        O = V.abs,
        W = V.cos,
        aa = V.sin,
        ma = V.PI,
        ga = ma * 2 / 360,
        za = navigator.userAgent,
        Ib = L.opera,
        sa = /(msie|trident|edge)/i.test(za) && !Ib,
        gb = C.documentMode === 8,
        hb = !sa && /AppleWebKit/.test(za),
        Ka = /Firefox/.test(za),
        Jb = /(Mobile|Android|Windows Phone)/.test(za),
        Ea = "http://www.w3.org/2000/svg",
        ca = !!C.createElementNS && !!C.createElementNS(Ea, "svg").createSVGRect,
        Nb = Ka && parseInt(za.split("Firefox/")[1], 10) < 4,
        fa = !ca && !sa && !!C.createElement("canvas").getContext,
        $a, ab, Kb = {},
        xb = 0,
        eb, S, Na, yb, F, ua = function() {
            return x
        },
        X = [],
        bb = 0,
        Ja = "div",
        P = "none",
        Ob = /^[0-9]+$/,
        ib = ["plotTop", "marginRight", "marginBottom", "plotLeft"],
        Pb = "stroke-width",
        ya, fb, nb, db, rb, sb, tb, Xa, Ya, Za, Db, Eb, Fb, Gb, ub, vb, wb, N = {},
        B;
    B = L.Highcharts = L.Highcharts ? la(16, !0) : {};
    B.seriesTypes = N;
    var t = B.extend = function(a, b) {
            var c;
            a || (a = {});
            for (c in b) a[c] = b[c];
            return a
        },
        p = B.pick = function() {
            var a = arguments,
                b, c, d = a.length;
            for (b = 0; b < d; b++)
                if (c = a[b], c !== x && c !== null) return c
        },
        Ta = B.wrap = function(a, b, c) {
            var d = a[b];
            a[b] = function() {
                var a = Array.prototype.slice.call(arguments);
                a.unshift(d);
                return c.apply(this, a)
            }
        };
    Na = function(a, b, c) {
        if (!q(b) || isNaN(b)) return S.lang.invalidDate || "";
        var a = p(a, "%Y-%m-%d %H:%M:%S"),
            d = new ya(b - Wa(b)),
            e, f = d[sb](),
            g = d[tb](),
            h = d[Xa](),
            i = d[Ya](),
            j = d[Za](),
            k = S.lang,
            m = k.weekdays,
            d = t({
                a: m[g].substr(0, 3),
                A: m[g],
                d: Ha(h),
                e: h,
                w: g,
                b: k.shortMonths[i],
                B: k.months[i],
                m: Ha(i + 1),
                y: j.toString().substr(2, 2),
                Y: j,
                H: Ha(f),
                k: f,
                I: Ha(f % 12 || 12),
                l: f % 12 || 12,
                M: Ha(d[rb]()),
                p: f < 12 ? "AM" : "PM",
                P: f < 12 ? "am" : "pm",
                S: Ha(d.getSeconds()),
                L: Ha(w(b % 1E3), 3)
            }, B.dateFormats);
        for (e in d)
            for (; a.indexOf("%" + e) !== -1;) a = a.replace("%" + e, typeof d[e] === "function" ? d[e](b) : d[e]);
        return c ? a.substr(0, 1).toUpperCase() + a.substr(1) : a
    };
    F = {
        millisecond: 1,
        second: 1E3,
        minute: 6E4,
        hour: 36E5,
        day: 864E5,
        week: 6048E5,
        month: 24192E5,
        year: 314496E5
    };
    B.numberFormat = function(a, b, c, d) {
        var e = S.lang,
            a = +a || 0,
            f = b === -1 ? z((a.toString().split(".")[1] || "").length, 20) : isNaN(b = O(b)) ? 2 : b,
            b = c === void 0 ? e.decimalPoint : c,
            d = d === void 0 ? e.thousandsSep : d,
            e = a < 0 ? "-" : "",
            c = String(G(a = O(a).toFixed(f))),
            g = c.length > 3 ? c.length % 3 : 0;
        return e + (g ? c.substr(0, g) + d : "") + c.substr(g).replace(/(\d{3})(?=\d)/g, "$1" + d) + (f ? b + O(a - c).toFixed(f).slice(2) : "")
    };
    yb = {
        init: function(a, b, c) {
            var b = b || "",
                d = a.shift,
                e = b.indexOf("C") > -1,
                f = e ? 7 : 3,
                g, b = b.split(" "),
                c = [].concat(c),
                h, i, j = function(a) {
                    for (g = a.length; g--;) a[g] === "M" && a.splice(g + 1, 0, a[g + 1], a[g + 2], a[g + 1], a[g + 2])
                };
            e && (j(b), j(c));
            a.isArea && (h = b.splice(b.length - 6, 6), i = c.splice(c.length - 6, 6));
            if (d <= c.length / f && b.length === c.length)
                for (; d--;) c = [].concat(c).splice(0, f).concat(c);
            a.shift = 0;
            if (b.length)
                for (a = c.length; b.length < a;) d = [].concat(b).splice(b.length - f, f), e && (d[f - 6] = d[f - 2], d[f - 5] = d[f - 1]), b = b.concat(d);
            h && (b = b.concat(h), c = c.concat(i));
            return [b, c]
        },
        step: function(a, b, c, d) {
            var e = [],
                f = a.length;
            if (c === 1) e = d;
            else if (f === b.length && c < 1)
                for (; f--;) d = parseFloat(a[f]), e[f] = isNaN(d) ? a[f] : c * parseFloat(b[f] - d) + d;
            else e = b;
            return e
        }
    };
    (function(a) {
        L.HighchartsAdapter = L.HighchartsAdapter || a && {
            init: function(b) {
                var c = a.fx;
                a.extend(a.easing, {
                    easeOutQuad: function(a, b, c, g, h) {
                        return -g * (b /= h) * (b - 2) + c
                    }
                });
                a.each(["cur", "_default", "width", "height", "opacity"], function(b, e) {
                    var f = c.step,
                        g;
                    e === "cur" ? f = c.prototype : e === "_default" && a.Tween && (f = a.Tween.propHooks[e], e = "set");
                    (g = f[e]) && (f[e] = function(a) {
                        var c, a = b ? a : this;
                        if (a.prop !== "align") return c = a.elem, c.attr ? c.attr(a.prop, e === "cur" ? x : a.now) : g.apply(this, arguments)
                    })
                });
                Ta(a.cssHooks.opacity, "get", function(a, b, c) {
                    return b.attr ? b.opacity || 0 : a.call(this, b, c)
                });
                this.addAnimSetter("d", function(a) {
                    var c = a.elem,
                        f;
                    if (!a.started) f = b.init(c, c.d, c.toD), a.start = f[0], a.end = f[1], a.started = !0;
                    c.attr("d", b.step(a.start, a.end, a.pos, c.toD))
                });
                this.each = Array.prototype.forEach ? function(a, b) {
                    return Array.prototype.forEach.call(a, b)
                } : function(a, b) {
                    var c, g = a.length;
                    for (c = 0; c < g; c++)
                        if (b.call(a[c], a[c], c, a) === !1) return c
                };
                a.fn.highcharts = function() {
                    var a = "Chart",
                        b = arguments,
                        c, g;
                    if (this[0]) {
                        Ba(b[0]) && (a = b[0], b = Array.prototype.slice.call(b, 1));
                        c = b[0];
                        if (c !== x) c.chart = c.chart || {}, c.chart.renderTo = this[0], new B[a](c, b[1]), g = this;
                        c === x && (g = X[K(this[0], "data-highcharts-chart")])
                    }
                    return g
                }
            },
            addAnimSetter: function(b, c) {
                a.Tween ? a.Tween.propHooks[b] = {
                    set: c
                } : a.fx.step[b] = c
            },
            getScript: a.getScript,
            inArray: a.inArray,
            adapterRun: function(b, c) {
                return a(b)[c]()
            },
            grep: a.grep,
            map: function(a, c) {
                for (var d = [], e = 0, f = a.length; e < f; e++) d[e] = c.call(a[e], a[e], e, a);
                return d
            },
            offset: function(b) {
                return a(b).offset()
            },
            addEvent: function(b, c, d) {
                a(b).bind(c, d)
            },
            removeEvent: function(b, c, d) {
                var e = C.removeEventListener ? "removeEventListener" : "detachEvent";
                C[e] && b && !b[e] && (b[e] = function() {});
                a(b).unbind(c, d)
            },
            fireEvent: function(b, c, d, e) {
                var f = a.Event(c),
                    g = "detached" + c,
                    h;
                !sa && d && (delete d.layerX, delete d.layerY, delete d.returnValue);
                t(f, d);
                b[c] && (b[g] = b[c], b[c] = null);
                a.each(["preventDefault", "stopPropagation"], function(a, b) {
                    var c = f[b];
                    f[b] = function() {
                        try {
                            c.call(f)
                        } catch (a) {
                            b === "preventDefault" && (h = !0)
                        }
                    }
                });
                a(b).trigger(f);
                b[g] && (b[c] = b[g], b[g] = null);
                e && !f.isDefaultPrevented() && !h && e(f)
            },
            washMouseEvent: function(a) {
                var c = a.originalEvent || a;
                if (c.pageX === x) c.pageX = a.pageX, c.pageY = a.pageY;
                return c
            },
            animate: function(b, c, d) {
                var e = a(b);
                if (!b.style) b.style = {};
                if (c.d) b.toD = c.d, c.d = 1;
                e.stop();
                c.opacity !== x && b.attr && (c.opacity += "px");
                b.hasAnim = 1;
                e.animate(c, d)
            },
            stop: function(b) {
                b.hasAnim && a(b).stop()
            }
        }
    })(L.jQuery);
    var U = L.HighchartsAdapter,
        E = U || {};
    U && U.init.call(U, yb);
    var jb = E.adapterRun,
        Qb = E.getScript,
        La = E.inArray,
        o = B.each = E.each,
        kb = E.grep,
        Rb = E.offset,
        Ua = E.map,
        I = E.addEvent,
        Y = E.removeEvent,
        J = E.fireEvent,
        Sb = E.washMouseEvent,
        lb = E.animate,
        cb = E.stop;
    S = {
        colors: "#7cb5ec,#434348,#90ed7d,#f7a35c,#8085e9,#f15c80,#e4d354,#2b908f,#f45b5b,#91e8e1".split(","),
        symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
        lang: {
            loading: "Loading...",
            months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
            shortMonths: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
            weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
            decimalPoint: ".",
            numericSymbols: "k,M,G,T,P,E".split(","),
            resetZoom: "Reset zoom",
            resetZoomTitle: "Reset zoom level 1:1",
            thousandsSep: " "
        },
        global: {
            useUTC: !0,
            canvasToolsURL: "http://code.highcharts.com/4.1.9/modules/canvas-tools.js",
            VMLRadialGradientURL: "http://code.highcharts.com/4.1.9/gfx/vml-radial-gradient.png"
        },
        chart: {
            borderColor: "#4572A7",
            borderRadius: 0,
            defaultSeriesType: "line",
            ignoreHiddenSeries: !0,
            spacing: [10, 10, 15, 10],
            backgroundColor: "#FFFFFF",
            plotBorderColor: "#C0C0C0",
            resetZoomButton: {
                theme: {
                    zIndex: 20
                },
                position: {
                    align: "right",
                    x: -10,
                    y: 10
                }
            }
        },
        title: {
            text: "Chart title",
            align: "center",
            margin: 15,
            style: {
                color: "#333333",
                fontSize: "18px"
            }
        },
        subtitle: {
            text: "",
            align: "center",
            style: {
                color: "#555555"
            }
        },
        plotOptions: {
            line: {
                allowPointSelect: !1,
                showCheckbox: !1,
                animation: {
                    duration: 1E3
                },
                events: {},
                lineWidth: 2,
                marker: {
                    lineWidth: 0,
                    radius: 4,
                    lineColor: "#FFFFFF",
                    states: {
                        hover: {
                            enabled: !0,
                            lineWidthPlus: 1,
                            radiusPlus: 2
                        },
                        select: {
                            fillColor: "#FFFFFF",
                            lineColor: "#000000",
                            lineWidth: 2
                        }
                    }
                },
                point: {
                    events: {}
                },
                dataLabels: {
                    align: "center",
                    formatter: function() {
                        return this.y === null ? "" : B.numberFormat(this.y, -1)
                    },
                    style: {
                        color: "contrast",
                        fontSize: "11px",
                        fontWeight: "bold",
                        textShadow: "0 0 6px contrast, 0 0 3px contrast"
                    },
                    verticalAlign: "bottom",
                    x: 0,
                    y: 0,
                    padding: 5
                },
                cropThreshold: 300,
                pointRange: 0,
                softThreshold: !0,
                states: {
                    hover: {
                        lineWidthPlus: 1,
                        marker: {},
                        halo: {
                            size: 10,
                            opacity: 0.25
                        }
                    },
                    select: {
                        marker: {}
                    }
                },
                stickyTracking: !0,
                turboThreshold: 1E3
            }
        },
        labels: {
            style: {
                position: "absolute",
                color: "#3E576F"
            }
        },
        legend: {
            enabled: !0,
            align: "center",
            layout: "horizontal",
            labelFormatter: function() {
                return this.name
            },
            borderColor: "#909090",
            borderRadius: 0,
            navigation: {
                activeColor: "#274b6d",
                inactiveColor: "#CCC"
            },
            shadow: !1,
            itemStyle: {
                color: "#333333",
                fontSize: "12px",
                fontWeight: "bold"
            },
            itemHoverStyle: {
                color: "#000"
            },
            itemHiddenStyle: {
                color: "#CCC"
            },
            itemCheckboxStyle: {
                position: "absolute",
                width: "13px",
                height: "13px"
            },
            symbolPadding: 5,
            verticalAlign: "bottom",
            x: 0,
            y: 0,
            title: {
                style: {
                    fontWeight: "bold"
                }
            }
        },
        loading: {
            labelStyle: {
                fontWeight: "bold",
                position: "relative",
                top: "45%"
            },
            style: {
                position: "absolute",
                backgroundColor: "white",
                opacity: 0.5,
                textAlign: "center"
            }
        },
        tooltip: {
            enabled: !0,
            animation: ca,
            backgroundColor: "rgba(249, 249, 249, .85)",
            borderWidth: 1,
            borderRadius: 3,
            dateTimeLabelFormats: {
                millisecond: "%A, %b %e, %H:%M:%S.%L",
                second: "%A, %b %e, %H:%M:%S",
                minute: "%A, %b %e, %H:%M",
                hour: "%A, %b %e, %H:%M",
                day: "%A, %b %e, %Y",
                week: "Week from %A, %b %e, %Y",
                month: "%B %Y",
                year: "%Y"
            },
            footerFormat: "",
            headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
            pointFormat: '<span style="color:{point.color}">\u25cf</span> {series.name}: <b>{point.y}</b><br/>',
            shadow: !0,
            snap: Jb ? 25 : 10,
            style: {
                color: "#333333",
                cursor: "default",
                fontSize: "12px",
                padding: "8px",
                pointerEvents: "none",
                whiteSpace: "nowrap"
            }
        },
        credits: {
            enabled: !0,
            text: "Highcharts.com",
            href: "http://www.highcharts.com",
            position: {
                align: "right",
                x: -10,
                verticalAlign: "bottom",
                y: -5
            },
            style: {
                cursor: "pointer",
                color: "#909090",
                fontSize: "9px"
            }
        }
    };
    var ba = S.plotOptions,
        U = ba.line;
    Cb();
    var Tb = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
        Ub = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/,
        Vb = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
        na = function(a) {
            var b = [],
                c, d;
            (function(a) {
                a && a.stops ? d = Ua(a.stops, function(a) {
                    return na(a[1])
                }) : (c = Tb.exec(a)) ? b = [G(c[1]), G(c[2]), G(c[3]), parseFloat(c[4], 10)] : (c = Ub.exec(a)) ? b = [G(c[1], 16), G(c[2], 16), G(c[3], 16), 1] : (c = Vb.exec(a)) && (b = [G(c[1]), G(c[2]), G(c[3]), 1])
            })(a);
            return {
                get: function(c) {
                    var f;
                    d ? (f = D(a), f.stops = [].concat(f.stops), o(d, function(a, b) {
                        f.stops[b] = [f.stops[b][0], a.get(c)]
                    })) : f = b && !isNaN(b[0]) ? c === "rgb" ? "rgb(" + b[0] + "," + b[1] + "," + b[2] + ")" : c === "a" ? b[3] : "rgba(" + b.join(",") + ")" : a;
                    return f
                },
                brighten: function(a) {
                    if (d) o(d, function(b) {
                        b.brighten(a)
                    });
                    else if (qa(a) && a !== 0) {
                        var c;
                        for (c = 0; c < 3; c++) b[c] += G(a * 255), b[c] < 0 && (b[c] = 0), b[c] > 255 && (b[c] = 255)
                    }
                    return this
                },
                rgba: b,
                setOpacity: function(a) {
                    b[3] = a;
                    return this
                },
                raw: a
            }
        };
    Q.prototype = {
        opacity: 1,
        textProps: "fontSize,fontWeight,fontFamily,fontStyle,color,lineHeight,width,textDecoration,textOverflow,textShadow".split(","),
        init: function(a, b) {
            this.element = b === "span" ? $(b) : C.createElementNS(Ea, b);
            this.renderer = a
        },
        animate: function(a, b, c) {
            b = p(b, this.renderer.globalAnimation, !0);
            cb(this);
            if (b) {
                b = D(b, {});
                if (c) b.complete = c;
                lb(this, a, b)
            } else this.attr(a, null, c);
            return this
        },
        colorGradient: function(a, b, c) {
            var d = this.renderer,
                e, f, g, h, i, j, k, m, n, l, u, r = [];
            a.linearGradient ? f = "linearGradient" : a.radialGradient && (f = "radialGradient");
            if (f) {
                g = a[f];
                i = d.gradients;
                k = a.stops;
                l = c.radialReference;
                Ga(g) && (a[f] = g = {
                    x1: g[0],
                    y1: g[1],
                    x2: g[2],
                    y2: g[3],
                    gradientUnits: "userSpaceOnUse"
                });
                f === "radialGradient" && l && !q(g.gradientUnits) && (h = g, g = D(g, d.getRadialAttr(l, h), {
                    gradientUnits: "userSpaceOnUse"
                }));
                for (u in g) u !== "id" && r.push(u, g[u]);
                for (u in k) r.push(k[u]);
                r = r.join(",");
                i[r] ? a = i[r].attr("id") : (g.id = a = "highcharts-" + xb++, i[r] = j = d.createElement(f).attr(g).add(d.defs), j.radAttr = h, j.stops = [], o(k, function(a) {
                    a[1].indexOf("rgba") === 0 ? (e = na(a[1]), m = e.get("rgb"), n = e.get("a")) : (m = a[1], n = 1);
                    a = d.createElement("stop").attr({
                        offset: a[0],
                        "stop-color": m,
                        "stop-opacity": n
                    }).add(j);
                    j.stops.push(a)
                }));
                c.setAttribute(b, "url(" + d.url + "#" + a + ")");
                c.gradient = r
            }
        },
        applyTextShadow: function(a) {
            var b = this.element,
                c, d = a.indexOf("contrast") !== -1,
                e = {},
                f = this.renderer.forExport,
                g = f || b.style.textShadow !== x && !sa;
            if (d) e.textShadow = a = a.replace(/contrast/g, this.renderer.getContrast(b.style.fill));
            if (hb || f) e.textRendering = "geometricPrecision";
            g ? this.css(e) : (this.fakeTS = !0, this.ySetter = this.xSetter, c = [].slice.call(b.getElementsByTagName("tspan")), o(a.split(/\s?,\s?/g), function(a) {
                var d = b.firstChild,
                    e, f, a = a.split(" ");
                e = a[a.length - 1];
                (f = a[a.length - 2]) && o(c, function(a, c) {
                    var g;
                    c === 0 && (a.setAttribute("x", b.getAttribute("x")), c = b.getAttribute("y"), a.setAttribute("y", c || 0), c === null && b.setAttribute("y", 0));
                    g = a.cloneNode(1);
                    K(g, {
                        "class": "highcharts-text-shadow",
                        fill: e,
                        stroke: e,
                        "stroke-opacity": 1 / s(G(f), 3),
                        "stroke-width": f,
                        "stroke-linejoin": "round"
                    });
                    b.insertBefore(g, d)
                })
            }))
        },
        attr: function(a, b, c) {
            var d, e = this.element,
                f, g = this,
                h;
            typeof a === "string" && b !== x && (d = a, a = {}, a[d] = b);
            if (typeof a === "string") g = (this[a + "Getter"] || this._defaultGetter).call(this, a, e);
            else {
                for (d in a) {
                    b = a[d];
                    h = !1;
                    this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(d) && (f || (this.symbolAttr(a), f = !0), h = !0);
                    if (this.rotation && (d === "x" || d === "y")) this.doTransform = !0;
                    h || (this[d + "Setter"] || this._defaultSetter).call(this, b, d, e);
                    this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(d) && this.updateShadows(d, b)
                }
                if (this.doTransform) this.updateTransform(), this.doTransform = !1
            }
            c && c();
            return g
        },
        updateShadows: function(a, b) {
            for (var c = this.shadows, d = c.length; d--;) c[d].setAttribute(a, a === "height" ? s(b - (c[d].cutHeight || 0), 0) : a === "d" ? this.d : b)
        },
        addClass: function(a) {
            var b = this.element,
                c = K(b, "class") || "";
            c.indexOf(a) === -1 && K(b, "class", c + " " + a);
            return this
        },
        symbolAttr: function(a) {
            var b = this;
            o("x,y,r,start,end,width,height,innerR,anchorX,anchorY".split(","), function(c) {
                b[c] = p(a[c], b[c])
            });
            b.attr({
                d: b.renderer.symbols[b.symbolName](b.x, b.y, b.width, b.height, b)
            })
        },
        clip: function(a) {
            return this.attr("clip-path", a ? "url(" + this.renderer.url + "#" + a.id + ")" : P)
        },
        crisp: function(a) {
            var b, c = {},
                d, e = a.strokeWidth || this.strokeWidth || 0;
            d = w(e) % 2 / 2;
            a.x = T(a.x || this.x || 0) + d;
            a.y = T(a.y || this.y || 0) + d;
            a.width = T((a.width || this.width || 0) - 2 * d);
            a.height = T((a.height || this.height || 0) - 2 * d);
            a.strokeWidth = e;
            for (b in a) this[b] !== a[b] && (this[b] = c[b] = a[b]);
            return c
        },
        css: function(a) {
            var b = this.styles,
                c = {},
                d = this.element,
                e, f, g = "";
            e = !b;
            if (a && a.color) a.fill = a.color;
            if (b)
                for (f in a) a[f] !== b[f] && (c[f] = a[f], e = !0);
            if (e) {
                e = this.textWidth = a && a.width && d.nodeName.toLowerCase() === "text" && G(a.width) || this.textWidth;
                b && (a = t(b, c));
                this.styles = a;
                e && (fa || !ca && this.renderer.forExport) && delete a.width;
                if (sa && !ca) M(this.element, a);
                else {
                    b = function(a, b) {
                        return "-" + b.toLowerCase()
                    };
                    for (f in a) g += f.replace(/([A-Z])/g, b) + ":" + a[f] + ";";
                    K(d, "style", g)
                }
                e && this.added && this.renderer.buildText(this)
            }
            return this
        },
        on: function(a, b) {
            var c = this,
                d = c.element;
            ab && a === "click" ? (d.ontouchstart = function(a) {
                c.touchEventFired = ya.now();
                a.preventDefault();
                b.call(d, a)
            }, d.onclick = function(a) {
                (za.indexOf("Android") === -1 || ya.now() - (c.touchEventFired || 0) > 1100) && b.call(d, a)
            }) : d["on" + a] = b;
            return this
        },
        setRadialReference: function(a) {
            var b = this.renderer.gradients[this.element.gradient];
            this.element.radialReference = a;
            b && b.radAttr && b.animate(this.renderer.getRadialAttr(a, b.radAttr));
            return this
        },
        translate: function(a, b) {
            return this.attr({
                translateX: a,
                translateY: b
            })
        },
        invert: function() {
            this.inverted = !0;
            this.updateTransform();
            return this
        },
        updateTransform: function() {
            var a = this.translateX || 0,
                b = this.translateY || 0,
                c = this.scaleX,
                d = this.scaleY,
                e = this.inverted,
                f = this.rotation,
                g = this.element;
            e && (a += this.attr("width"), b += this.attr("height"));
            a = ["translate(" + a + "," + b + ")"];
            e ? a.push("rotate(90) scale(-1,1)") : f && a.push("rotate(" + f + " " + (g.getAttribute("x") || 0) + " " + (g.getAttribute("y") || 0) + ")");
            (q(c) || q(d)) && a.push("scale(" + p(c, 1) + " " + p(d, 1) + ")");
            a.length && g.setAttribute("transform", a.join(" "))
        },
        toFront: function() {
            var a = this.element;
            a.parentNode.appendChild(a);
            return this
        },
        align: function(a, b, c) {
            var d, e, f, g, h = {};
            e = this.renderer;
            f = e.alignedObjects;
            if (a) {
                if (this.alignOptions = a, this.alignByTranslate = b, !c || Ba(c)) this.alignTo = d = c || "renderer", ja(f, this), f.push(this), c = null
            } else a = this.alignOptions, b = this.alignByTranslate, d = this.alignTo;
            c = p(c, e[d], e);
            d = a.align;
            e = a.verticalAlign;
            f = (c.x || 0) + (a.x || 0);
            g = (c.y || 0) + (a.y || 0);
            if (d === "right" || d === "center") f += (c.width - (a.width || 0)) / {
                right: 1,
                center: 2
            }[d];
            h[b ? "translateX" : "x"] = w(f);
            if (e === "bottom" || e === "middle") g += (c.height -
                (a.height || 0)) / ({
                bottom: 1,
                middle: 2
            }[e] || 1);
            h[b ? "translateY" : "y"] = w(g);
            this[this.placed ? "animate" : "attr"](h);
            this.placed = !0;
            this.alignAttr = h;
            return this
        },
        getBBox: function(a) {
            var b, c = this.renderer,
                d, e = this.rotation,
                f = this.element,
                g = this.styles,
                h = e * ga;
            d = this.textStr;
            var i, j = f.style,
                k, m;
            d !== x && (m = ["", e || 0, g && g.fontSize, f.style.width].join(","), m = d === "" || Ob.test(d) ? "num:" + d.toString().length + m : d + m);
            m && !a && (b = c.cache[m]);
            if (!b) {
                if (f.namespaceURI === Ea || c.forExport) {
                    try {
                        k = this.fakeTS && function(a) {
                            o(f.querySelectorAll(".highcharts-text-shadow"), function(b) {
                                b.style.display = a
                            })
                        }, Ka && j.textShadow ? (i = j.textShadow, j.textShadow = "") : k && k(P), b = f.getBBox ? t({}, f.getBBox()) : {
                            width: f.offsetWidth,
                            height: f.offsetHeight
                        }, i ? j.textShadow = i : k && k("")
                    } catch (n) {}
                    if (!b || b.width < 0) b = {
                        width: 0,
                        height: 0
                    }
                } else b = this.htmlGetBBox();
                if (c.isSVG) {
                    a = b.width;
                    d = b.height;
                    if (sa && g && g.fontSize === "11px" && d.toPrecision(3) === "16.9") b.height = d = 14;
                    if (e) b.width = O(d * aa(h)) + O(a * W(h)), b.height = O(d * W(h)) + O(a * aa(h))
                }
                m && (c.cache[m] = b)
            }
            return b
        },
        show: function(a) {
            return this.attr({
                visibility: a ? "inherit" : "visible"
            })
        },
        hide: function() {
            return this.attr({
                visibility: "hidden"
            })
        },
        fadeOut: function(a) {
            var b = this;
            b.animate({
                opacity: 0
            }, {
                duration: a || 150,
                complete: function() {
                    b.attr({
                        y: -9999
                    })
                }
            })
        },
        add: function(a) {
            var b = this.renderer,
                c = this.element,
                d;
            if (a) this.parentGroup = a;
            this.parentInverted = a && a.inverted;
            this.textStr !== void 0 && b.buildText(this);
            this.added = !0;
            if (!a || a.handleZ || this.zIndex) d = this.zIndexSetter();
            d || (a ? a.element : b.box).appendChild(c);
            if (this.onAdd) this.onAdd();
            return this
        },
        safeRemoveChild: function(a) {
            var b = a.parentNode;
            b && b.removeChild(a)
        },
        destroy: function() {
            var a = this,
                b = a.element || {},
                c = a.shadows,
                d = a.renderer.isSVG && b.nodeName === "SPAN" && a.parentGroup,
                e, f;
            b.onclick = b.onmouseout = b.onmouseover = b.onmousemove = b.point = null;
            cb(a);
            if (a.clipPath) a.clipPath = a.clipPath.destroy();
            if (a.stops) {
                for (f = 0; f < a.stops.length; f++) a.stops[f] = a.stops[f].destroy();
                a.stops = null
            }
            a.safeRemoveChild(b);
            for (c && o(c, function(b) {
                    a.safeRemoveChild(b)
                }); d && d.div && d.div.childNodes.length === 0;) b = d.parentGroup, a.safeRemoveChild(d.div), delete d.div, d = b;
            a.alignTo && ja(a.renderer.alignedObjects, a);
            for (e in a) delete a[e];
            return null
        },
        shadow: function(a, b, c) {
            var d = [],
                e, f, g = this.element,
                h, i, j, k;
            if (a) {
                i = p(a.width, 3);
                j = (a.opacity || 0.15) / i;
                k = this.parentInverted ? "(-1,-1)" : "(" + p(a.offsetX, 1) + ", " + p(a.offsetY, 1) + ")";
                for (e = 1; e <= i; e++) {
                    f = g.cloneNode(0);
                    h = i * 2 + 1 - 2 * e;
                    K(f, {
                        isShadow: "true",
                        stroke: a.color || "black",
                        "stroke-opacity": j * e,
                        "stroke-width": h,
                        transform: "translate" + k,
                        fill: P
                    });
                    if (c) K(f, "height", s(K(f, "height") - h, 0)), f.cutHeight = h;
                    b ? b.element.appendChild(f) : g.parentNode.insertBefore(f, g);
                    d.push(f)
                }
                this.shadows = d
            }
            return this
        },
        xGetter: function(a) {
            this.element.nodeName === "circle" && (a = {
                x: "cx",
                y: "cy"
            }[a] || a);
            return this._defaultGetter(a)
        },
        _defaultGetter: function(a) {
            a = p(this[a], this.element ? this.element.getAttribute(a) : null, 0);
            /^[\-0-9\.]+$/.test(a) && (a = parseFloat(a));
            return a
        },
        dSetter: function(a, b, c) {
            a && a.join && (a = a.join(" "));
            /(NaN| {2}|^$)/.test(a) && (a = "M 0 0");
            c.setAttribute(b, a);
            this[b] = a
        },
        dashstyleSetter: function(a) {
            var b;
            if (a = a && a.toLowerCase()) {
                a = a.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
                for (b = a.length; b--;) a[b] = G(a[b]) * this["stroke-width"];
                a = a.join(",").replace("NaN", "none");
                this.element.setAttribute("stroke-dasharray", a)
            }
        },
        alignSetter: function(a) {
            this.element.setAttribute("text-anchor", {
                left: "start",
                center: "middle",
                right: "end"
            }[a])
        },
        opacitySetter: function(a, b, c) {
            this[b] = a;
            c.setAttribute(b, a)
        },
        titleSetter: function(a) {
            var b = this.element.getElementsByTagName("title")[0];
            b || (b = C.createElementNS(Ea, "title"), this.element.appendChild(b));
            b.appendChild(C.createTextNode(String(p(a), "").replace(/<[^>]*>/g, "")))
        },
        textSetter: function(a) {
            if (a !== this.textStr) delete this.bBox, this.textStr = a, this.added && this.renderer.buildText(this)
        },
        fillSetter: function(a, b, c) {
            typeof a === "string" ? c.setAttribute(b, a) : a && this.colorGradient(a, b, c)
        },
        visibilitySetter: function(a, b, c) {
            a === "inherit" ? c.removeAttribute(b) : c.setAttribute(b, a)
        },
        zIndexSetter: function(a, b) {
            var c = this.renderer,
                d = this.parentGroup,
                c = (d || c).element || c.box,
                e, f, g = this.element,
                h;
            e = this.added;
            var i;
            q(a) && (g.setAttribute(b, a), a = +a, this[b] === a && (e = !1), this[b] = a);
            if (e) {
                if ((a = this.zIndex) && d) d.handleZ = !0;
                d = c.childNodes;
                for (i = 0; i < d.length && !h; i++)
                    if (e = d[i], f = K(e, "zIndex"), e !== g && (G(f) > a || !q(a) && q(f))) c.insertBefore(g, e), h = !0;
                h || c.appendChild(g)
            }
            return h
        },
        _defaultSetter: function(a, b, c) {
            c.setAttribute(b, a)
        }
    };
    Q.prototype.yGetter = Q.prototype.xGetter;
    Q.prototype.translateXSetter = Q.prototype.translateYSetter = Q.prototype.rotationSetter = Q.prototype.verticalAlignSetter = Q.prototype.scaleXSetter = Q.prototype.scaleYSetter = function(a, b) {
        this[b] = a;
        this.doTransform = !0
    };
    Q.prototype["stroke-widthSetter"] = Q.prototype.strokeSetter = function(a, b, c) {
        this[b] = a;
        if (this.stroke && this["stroke-width"]) this.strokeWidth = this["stroke-width"], Q.prototype.fillSetter.call(this, this.stroke, "stroke", c), c.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0;
        else if (b === "stroke-width" && a === 0 && this.hasStroke) c.removeAttribute("stroke"), this.hasStroke = !1
    };
    var Aa = function() {
        this.init.apply(this, arguments)
    };
    Aa.prototype = {
        Element: Q,
        init: function(a, b, c, d, e, f) {
            var g = location,
                h, d = this.createElement("svg").attr({
                    version: "1.1"
                }).css(this.getStyle(d));
            h = d.element;
            a.appendChild(h);
            a.innerHTML.indexOf("xmlns") === -1 && K(h, "xmlns", Ea);
            this.isSVG = !0;
            this.box = h;
            this.boxWrapper = d;
            this.alignedObjects = [];
            this.url = (Ka || hb) && C.getElementsByTagName("base").length ? g.href.replace(/#.*?$/, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20") : "";
            this.createElement("desc").add().element.appendChild(C.createTextNode("Created with Highcharts 4.1.9"));
            this.defs = this.createElement("defs").add();
            this.allowHTML = f;
            this.forExport = e;
            this.gradients = {};
            this.cache = {};
            this.setSize(b, c, !1);
            var i;
            if (Ka && a.getBoundingClientRect) this.subPixelFix = b = function() {
                M(a, {
                    left: 0,
                    top: 0
                });
                i = a.getBoundingClientRect();
                M(a, {
                    left: ta(i.left) - i.left + "px",
                    top: ta(i.top) - i.top + "px"
                })
            }, b(), I(L, "resize", b)
        },
        getStyle: function(a) {
            return this.style = t({
                fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
                fontSize: "12px"
            }, a)
        },
        isHidden: function() {
            return !this.boxWrapper.getBBox().width
        },
        destroy: function() {
            var a = this.defs;
            this.box = null;
            this.boxWrapper = this.boxWrapper.destroy();
            Pa(this.gradients || {});
            this.gradients = null;
            if (a) this.defs = a.destroy();
            this.subPixelFix && Y(L, "resize", this.subPixelFix);
            return this.alignedObjects = null
        },
        createElement: function(a) {
            var b = new this.Element;
            b.init(this, a);
            return b
        },
        draw: function() {},
        getRadialAttr: function(a, b) {
            return {
                cx: a[0] - a[2] / 2 + b.cx * a[2],
                cy: a[1] - a[2] / 2 + b.cy * a[2],
                r: b.r * a[2]
            }
        },
        buildText: function(a) {
            for (var b = a.element, c = this, d = c.forExport, e = p(a.textStr, "").toString(), f = e.indexOf("<") !== -1, g = b.childNodes, h, i, j = K(b, "x"), k = a.styles, m = a.textWidth, n = k && k.lineHeight, l = k && k.textShadow, u = k && k.textOverflow === "ellipsis", r = g.length, Z = m && !a.added && this.box, A = function(a) {
                    return n ? G(n) : c.fontMetrics(/(px|em)$/.test(a && a.style.fontSize) ? a.style.fontSize : k && k.fontSize || c.style.fontSize || 12, a).h
                }, v = function(a) {
                    return a.replace(/&lt;/g, "<").replace(/&gt;/g, ">")
                }; r--;) b.removeChild(g[r]);
            !f && !l && !u && e.indexOf(" ") === -1 ? b.appendChild(C.createTextNode(v(e))) : (h = /<.*style="([^"]+)".*>/, i = /<.*href="(http[^"]+)".*>/, Z && Z.appendChild(b), e = f ? e.replace(/<(b|strong)>/g, '<span style="font-weight:bold">').replace(/<(i|em)>/g, '<span style="font-style:italic">').replace(/<a/g, "<span").replace(/<\/(b|strong|i|em|a)>/g, "</span>").split(/<br.*?>/g) : [e], e[e.length - 1] === "" && e.pop(), o(e, function(e, f) {
                var g, n = 0,
                    e = e.replace(/<span/g, "|||<span").replace(/<\/span>/g, "</span>|||");
                g = e.split("|||");
                o(g, function(e) {
                    if (e !== "" || g.length === 1) {
                        var l = {},
                            r = C.createElementNS(Ea, "tspan"),
                            p;
                        h.test(e) && (p = e.match(h)[1].replace(/(;| |^)color([ :])/, "$1fill$2"), K(r, "style", p));
                        i.test(e) && !d && (K(r, "onclick", 'location.href="' + e.match(i)[1] + '"'), M(r, {
                            cursor: "pointer"
                        }));
                        e = v(e.replace(/<(.|\n)*?>/g, "") || " ");
                        if (e !== " ") {
                            r.appendChild(C.createTextNode(e));
                            if (n) l.dx = 0;
                            else if (f && j !== null) l.x = j;
                            K(r, l);
                            b.appendChild(r);
                            !n && f && (!ca && d && M(r, {
                                display: "block"
                            }), K(r, "dy", A(r)));
                            if (m) {
                                for (var l = e.replace(/([^\^])-/g, "$1- ").split(" "), Z = g.length > 1 || f || l.length > 1 && k.whiteSpace !== "nowrap", o, y, q, s = [], x = A(r), t = 1, w = a.rotation, z = e, D = z.length;
                                    (Z || u) && (l.length || s.length);) a.rotation = 0, o = a.getBBox(!0), q = o.width, !ca && c.forExport && (q = c.measureSpanWidth(r.firstChild.data, a.styles)), o = q > m, y === void 0 && (y = o), u && y ? (D /= 2, z === "" || !o && D < 0.5 ? l = [] : (o && (y = !0), z = e.substring(0, z.length + (o ? -1 : 1) * ta(D)), l = [z + (m > 3 ? "\u2026" : "")], r.removeChild(r.firstChild))) : !o || l.length === 1 ? (l = s, s = [], l.length && (t++, r = C.createElementNS(Ea, "tspan"), K(r, {
                                    dy: x,
                                    x: j
                                }), p && K(r, "style", p), b.appendChild(r)), q > m && (m = q)) : (r.removeChild(r.firstChild), s.unshift(l.pop())), l.length && r.appendChild(C.createTextNode(l.join(" ").replace(/- /g, "-")));
                                y && a.attr("title", a.textStr);
                                a.rotation = w
                            }
                            n++
                        }
                    }
                })
            }), Z && Z.removeChild(b), l && a.applyTextShadow && a.applyTextShadow(l))
        },
        getContrast: function(a) {
            a = na(a).rgba;
            return a[0] + a[1] + a[2] > 384 ? "#000000" : "#FFFFFF"
        },
        button: function(a, b, c, d, e, f, g, h, i) {
            var j = this.label(a, b, c, i, null, null, null, null, "button"),
                k = 0,
                m, n, l, u, r, p, a = {
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 1
                },
                e = D({
                    "stroke-width": 1,
                    stroke: "#CCCCCC",
                    fill: {
                        linearGradient: a,
                        stops: [
                            [0, "#FEFEFE"],
                            [1, "#F6F6F6"]
                        ]
                    },
                    r: 2,
                    padding: 5,
                    style: {
                        color: "black"
                    }
                }, e);
            l = e.style;
            delete e.style;
            f = D(e, {
                stroke: "#68A",
                fill: {
                    linearGradient: a,
                    stops: [
                        [0, "#FFF"],
                        [1, "#ACF"]
                    ]
                }
            }, f);
            u = f.style;
            delete f.style;
            g = D(e, {
                stroke: "#68A",
                fill: {
                    linearGradient: a,
                    stops: [
                        [0, "#9BD"],
                        [1, "#CDF"]
                    ]
                }
            }, g);
            r = g.style;
            delete g.style;
            h = D(e, {
                style: {
                    color: "#CCC"
                }
            }, h);
            p = h.style;
            delete h.style;
            I(j.element, sa ? "mouseover" : "mouseenter", function() {
                k !== 3 && j.attr(f).css(u)
            });
            I(j.element, sa ? "mouseout" : "mouseleave", function() {
                k !== 3 && (m = [e, f, g][k], n = [l, u, r][k], j.attr(m).css(n))
            });
            j.setState = function(a) {
                (j.state = k = a) ? a === 2 ? j.attr(g).css(r) : a === 3 && j.attr(h).css(p): j.attr(e).css(l)
            };
            return j.on("click", function(a) {
                k !== 3 && d.call(j, a)
            }).attr(e).css(t({
                cursor: "default"
            }, l))
        },
        crispLine: function(a, b) {
            a[1] === a[4] && (a[1] = a[4] = w(a[1]) - b % 2 / 2);
            a[2] === a[5] && (a[2] = a[5] = w(a[2]) + b % 2 / 2);
            return a
        },
        path: function(a) {
            var b = {
                fill: P
            };
            Ga(a) ? b.d = a : da(a) && t(b, a);
            return this.createElement("path").attr(b)
        },
        circle: function(a, b, c) {
            a = da(a) ? a : {
                x: a,
                y: b,
                r: c
            };
            b = this.createElement("circle");
            b.xSetter = function(a) {
                this.element.setAttribute("cx", a)
            };
            b.ySetter = function(a) {
                this.element.setAttribute("cy", a)
            };
            return b.attr(a)
        },
        arc: function(a, b, c, d, e, f) {
            if (da(a)) b = a.y, c = a.r, d = a.innerR, e = a.start, f = a.end, a = a.x;
            a = this.symbol("arc", a || 0, b || 0, c || 0, c || 0, {
                innerR: d || 0,
                start: e || 0,
                end: f || 0
            });
            a.r = c;
            return a
        },
        rect: function(a, b, c, d, e, f) {
            var e = da(a) ? a.r : e,
                g = this.createElement("rect"),
                a = da(a) ? a : a === x ? {} : {
                    x: a,
                    y: b,
                    width: s(c, 0),
                    height: s(d, 0)
                };
            if (f !== x) a.strokeWidth = f, a = g.crisp(a);
            if (e) a.r = e;
            g.rSetter = function(a) {
                K(this.element, {
                    rx: a,
                    ry: a
                })
            };
            return g.attr(a)
        },
        setSize: function(a, b, c) {
            var d = this.alignedObjects,
                e = d.length;
            this.width = a;
            this.height = b;
            for (this.boxWrapper[p(c, !0) ? "animate" : "attr"]({
                    width: a,
                    height: b
                }); e--;) d[e].align()
        },
        g: function(a) {
            var b = this.createElement("g");
            return q(a) ? b.attr({
                "class": "highcharts-" + a
            }) : b
        },
        image: function(a, b, c, d, e) {
            var f = {
                preserveAspectRatio: P
            };
            arguments.length > 1 && t(f, {
                x: b,
                y: c,
                width: d,
                height: e
            });
            f = this.createElement("image").attr(f);
            f.element.setAttributeNS ? f.element.setAttributeNS("http://www.w3.org/1999/xlink", "href", a) : f.element.setAttribute("hc-svg-href", a);
            return f
        },
        symbol: function(a, b, c, d, e, f) {
            var g, h = this.symbols[a],
                h = h && h(w(b), w(c), d, e, f),
                i = /^url\((.*?)\)$/,
                j, k;
            if (h) g = this.path(h), t(g, {
                symbolName: a,
                x: b,
                y: c,
                width: d,
                height: e
            }), f && t(g, f);
            else if (i.test(a)) k = function(a, b) {
                a.element && (a.attr({
                    width: b[0],
                    height: b[1]
                }), a.alignByTranslate || a.translate(w((d - b[0]) / 2), w((e - b[1]) / 2)))
            }, j = a.match(i)[1], a = Kb[j] || f && f.width && f.height && [f.width, f.height], g = this.image(j).attr({
                x: b,
                y: c
            }), g.isImg = !0, a ? k(g, a) : (g.attr({
                width: 0,
                height: 0
            }), $("img", {
                onload: function() {
                    this.width === 0 && (M(this, {
                        position: "absolute",
                        top: "-999em"
                    }), document.body.appendChild(this));
                    k(g, Kb[j] = [this.width, this.height]);
                    this.parentNode && this.parentNode.removeChild(this)
                },
                src: j
            }));
            return g
        },
        symbols: {
            circle: function(a, b, c, d) {
                var e = 0.166 * c;
                return ["M", a + c / 2, b, "C", a + c + e, b, a + c + e, b + d, a + c / 2, b + d, "C", a - e, b + d, a - e, b, a + c / 2, b, "Z"]
            },
            square: function(a, b, c, d) {
                return ["M", a, b, "L", a + c, b, a + c, b + d, a, b + d, "Z"]
            },
            triangle: function(a, b, c, d) {
                return ["M", a + c / 2, b, "L", a + c, b + d, a, b + d, "Z"]
            },
            "triangle-down": function(a, b, c, d) {
                return ["M", a, b, "L", a + c, b, a + c / 2, b + d, "Z"]
            },
            diamond: function(a, b, c, d) {
                return ["M", a + c / 2, b, "L", a + c, b + d / 2, a + c / 2, b + d, a, b + d / 2, "Z"]
            },
            arc: function(a, b, c, d, e) {
                var f = e.start,
                    c = e.r || c || d,
                    g = e.end - 0.001,
                    d = e.innerR,
                    h = e.open,
                    i = W(f),
                    j = aa(f),
                    k = W(g),
                    g = aa(g),
                    e = e.end - f < ma ? 0 : 1;
                return ["M", a + c * i, b + c * j, "A", c, c, 0, e, 1, a + c * k, b + c * g, h ? "M" : "L", a + d * k, b + d * g, "A", d, d, 0, e, 0, a + d * i, b + d * j, h ? "" : "Z"]
            },
            callout: function(a, b, c, d, e) {
                var f = z(e && e.r || 0, c, d),
                    g = f + 6,
                    h = e && e.anchorX,
                    e = e && e.anchorY,
                    i;
                i = ["M", a + f, b, "L", a + c - f, b, "C", a + c, b, a + c, b, a + c, b + f, "L", a + c, b + d - f, "C", a + c, b + d, a + c, b + d, a + c - f, b + d, "L", a + f, b + d, "C", a, b + d, a, b + d, a, b + d - f, "L", a, b + f, "C", a, b, a, b, a + f, b];
                h && h > c && e > b + g && e < b + d - g ? i.splice(13, 3, "L", a + c, e - 6, a + c + 6, e, a + c, e + 6, a + c, b + d - f) : h && h < 0 && e > b + g && e < b + d - g ? i.splice(33, 3, "L", a, e + 6, a - 6, e, a, e - 6, a, b + f) : e && e > d && h > a + g && h < a + c - g ? i.splice(23, 3, "L", h + 6, b + d, h, b + d + 6, h - 6, b + d, a + f, b + d) : e && e < 0 && h > a + g && h < a + c - g && i.splice(3, 3, "L", h - 6, b, h, b - 6, h + 6, b, c - f, b);
                return i
            }
        },
        clipRect: function(a, b, c, d) {
            var e = "highcharts-" + xb++,
                f = this.createElement("clipPath").attr({
                    id: e
                }).add(this.defs),
                a = this.rect(a, b, c, d, 0).add(f);
            a.id = e;
            a.clipPath = f;
            a.count = 0;
            return a
        },
        text: function(a, b, c, d) {
            var e = fa || !ca && this.forExport,
                f = {};
            if (d && (this.allowHTML || !this.forExport)) return this.html(a, b, c);
            f.x = Math.round(b || 0);
            if (c) f.y = Math.round(c);
            if (a || a === 0) f.text = a;
            a = this.createElement("text").attr(f);
            e && a.css({
                position: "absolute"
            });
            if (!d) a.xSetter = function(a, b, c) {
                var d = c.getElementsByTagName("tspan"),
                    e, f = c.getAttribute(b),
                    n;
                for (n = 0; n < d.length; n++) e = d[n], e.getAttribute(b) === f && e.setAttribute(b, a);
                c.setAttribute(b, a)
            };
            return a
        },
        fontMetrics: function(a, b) {
            var c, d, a = a || this.style.fontSize;
            !a && b && L.getComputedStyle && (b = b.element || b, a = (c = L.getComputedStyle(b, "")) && c.fontSize);
            a = /px/.test(a) ? G(a) : /em/.test(a) ? parseFloat(a) * 12 : 12;
            c = a < 24 ? a + 3 : w(a * 1.2);
            d = w(c * 0.8);
            return {
                h: c,
                b: d,
                f: a
            }
        },
        rotCorr: function(a, b, c) {
            var d = a;
            b && c && (d = s(d * W(b * ga), 4));
            return {
                x: -a / 3 * aa(b * ga),
                y: d
            }
        },
        label: function(a, b, c, d, e, f, g, h, i) {
            function j() {
                var a, b;
                a = u.element.style;
                p = (s === void 0 || va === void 0 || l.styles.textAlign) && q(u.textStr) && u.getBBox();
                l.width = (s || p.width || 0) + 2 * v + y;
                l.height = (va || p.height || 0) + 2 * v;
                B = v + n.fontMetrics(a && a.fontSize, u).b;
                if (E) {
                    if (!r) a = w(-A * v) + C, b = (h ? -B : 0) + C, l.box = r = d ? n.symbol(d, a, b, l.width, l.height, H) : n.rect(a, b, l.width, l.height, 0, H[Pb]), r.isImg || r.attr("fill", P), r.add(l);
                    r.isImg || r.attr(t({
                        width: w(l.width),
                        height: w(l.height)
                    }, H));
                    H = null
                }
            }

            function k() {
                var a = l.styles,
                    a = a && a.textAlign,
                    b = y + v * (1 - A),
                    c;
                c = h ? 0 : B;
                if (q(s) && p && (a === "center" || a === "right")) b += {
                    center: 0.5,
                    right: 1
                }[a] * (s - p.width);
                if (b !== u.x || c !== u.y) u.attr("x", b), c !== x && u.attr("y", c);
                u.x = b;
                u.y = c
            }

            function m(a, b) {
                r ? r.attr(a, b) : H[a] = b
            }
            var n = this,
                l = n.g(i),
                u = n.text("", 0, 0, g).attr({
                    zIndex: 1
                }),
                r, p, A = 0,
                v = 3,
                y = 0,
                s, va, zb, z, C = 0,
                H = {},
                B, E;
            l.onAdd = function() {
                u.add(l);
                l.attr({
                    text: a || a === 0 ? a : "",
                    x: b,
                    y: c
                });
                r && q(e) && l.attr({
                    anchorX: e,
                    anchorY: f
                })
            };
            l.widthSetter = function(a) {
                s = a
            };
            l.heightSetter = function(a) {
                va = a
            };
            l.paddingSetter = function(a) {
                if (q(a) && a !== v) v = l.padding = a, k()
            };
            l.paddingLeftSetter = function(a) {
                q(a) && a !== y && (y = a, k())
            };
            l.alignSetter = function(a) {
                A = {
                    left: 0,
                    center: 0.5,
                    right: 1
                }[a]
            };
            l.textSetter = function(a) {
                a !== x && u.textSetter(a);
                j();
                k()
            };
            l["stroke-widthSetter"] = function(a, b) {
                a && (E = !0);
                C = a % 2 / 2;
                m(b, a)
            };
            l.strokeSetter = l.fillSetter = l.rSetter = function(a, b) {
                b === "fill" && a && (E = !0);
                m(b, a)
            };
            l.anchorXSetter = function(a, b) {
                e = a;
                m(b, w(a) -
                    C - zb)
            };
            l.anchorYSetter = function(a, b) {
                f = a;
                m(b, a - z)
            };
            l.xSetter = function(a) {
                l.x = a;
                A && (a -= A * ((s || p.width) + v));
                zb = w(a);
                l.attr("translateX", zb)
            };
            l.ySetter = function(a) {
                z = l.y = w(a);
                l.attr("translateY", z)
            };
            var G = l.css;
            return t(l, {
                css: function(a) {
                    if (a) {
                        var b = {},
                            a = D(a);
                        o(l.textProps, function(c) {
                            a[c] !== x && (b[c] = a[c], delete a[c])
                        });
                        u.css(b)
                    }
                    return G.call(l, a)
                },
                getBBox: function() {
                    return {
                        width: p.width + 2 * v,
                        height: p.height + 2 * v,
                        x: p.x - v,
                        y: p.y - v
                    }
                },
                shadow: function(a) {
                    r && r.shadow(a);
                    return l
                },
                destroy: function() {
                    Y(l.element, "mouseenter");
                    Y(l.element, "mouseleave");
                    u && (u = u.destroy());
                    r && (r = r.destroy());
                    Q.prototype.destroy.call(l);
                    l = n = j = k = m = null
                }
            })
        }
    };
    $a = Aa;
    t(Q.prototype, {
        htmlCss: function(a) {
            var b = this.element;
            if (b = a && b.tagName === "SPAN" && a.width) delete a.width, this.textWidth = b, this.updateTransform();
            if (a && a.textOverflow === "ellipsis") a.whiteSpace = "nowrap", a.overflow = "hidden";
            this.styles = t(this.styles, a);
            M(this.element, a);
            return this
        },
        htmlGetBBox: function() {
            var a = this.element;
            if (a.nodeName === "text") a.style.position = "absolute";
            return {
                x: a.offsetLeft,
                y: a.offsetTop,
                width: a.offsetWidth,
                height: a.offsetHeight
            }
        },
        htmlUpdateTransform: function() {
            if (this.added) {
                var a = this.renderer,
                    b = this.element,
                    c = this.translateX || 0,
                    d = this.translateY || 0,
                    e = this.x || 0,
                    f = this.y || 0,
                    g = this.textAlign || "left",
                    h = {
                        left: 0,
                        center: 0.5,
                        right: 1
                    }[g],
                    i = this.shadows,
                    j = this.styles;
                M(b, {
                    marginLeft: c,
                    marginTop: d
                });
                i && o(i, function(a) {
                    M(a, {
                        marginLeft: c + 1,
                        marginTop: d + 1
                    })
                });
                this.inverted && o(b.childNodes, function(c) {
                    a.invertChild(c, b)
                });
                if (b.tagName === "SPAN") {
                    var k = this.rotation,
                        m, n = G(this.textWidth),
                        l = [k, g, b.innerHTML, this.textWidth, this.textAlign].join(",");
                    if (l !== this.cTT) {
                        m = a.fontMetrics(b.style.fontSize).b;
                        q(k) && this.setSpanRotation(k, h, m);
                        i = p(this.elemWidth, b.offsetWidth);
                        if (i > n && /[ \-]/.test(b.textContent || b.innerText)) M(b, {
                            width: n + "px",
                            display: "block",
                            whiteSpace: j && j.whiteSpace || "normal"
                        }), i = n;
                        this.getSpanCorrection(i, m, h, k, g)
                    }
                    M(b, {
                        left: e + (this.xCorr || 0) + "px",
                        top: f + (this.yCorr || 0) + "px"
                    });
                    if (hb) m = b.offsetHeight;
                    this.cTT = l
                }
            } else this.alignOnAdd = !0
        },
        setSpanRotation: function(a, b, c) {
            var d = {},
                e = sa ? "-ms-transform" : hb ? "-webkit-transform" : Ka ? "MozTransform" : Ib ? "-o-transform" : "";
            d[e] = d.transform = "rotate(" + a + "deg)";
            d[e + (Ka ? "Origin" : "-origin")] = d.transformOrigin = b * 100 + "% " + c + "px";
            M(this.element, d)
        },
        getSpanCorrection: function(a, b, c) {
            this.xCorr = -a * c;
            this.yCorr = -b
        }
    });
    t(Aa.prototype, {
        html: function(a, b, c) {
            var d = this.createElement("span"),
                e = d.element,
                f = d.renderer;
            d.textSetter = function(a) {
                a !== e.innerHTML && delete this.bBox;
                e.innerHTML = this.textStr = a;
                d.htmlUpdateTransform()
            };
            d.xSetter = d.ySetter = d.alignSetter = d.rotationSetter = function(a, b) {
                b === "align" && (b = "textAlign");
                d[b] = a;
                d.htmlUpdateTransform()
            };
            d.attr({
                text: a,
                x: w(b),
                y: w(c)
            }).css({
                position: "absolute",
                fontFamily: this.style.fontFamily,
                fontSize: this.style.fontSize
            });
            e.style.whiteSpace = "nowrap";
            d.css = d.htmlCss;
            if (f.isSVG) d.add = function(a) {
                var b, c = f.box.parentNode,
                    j = [];
                if (this.parentGroup = a) {
                    if (b = a.div, !b) {
                        for (; a;) j.push(a), a = a.parentGroup;
                        o(j.reverse(), function(a) {
                            var d, e = K(a.element, "class");
                            e && (e = {
                                className: e
                            });
                            b = a.div = a.div || $(Ja, e, {
                                position: "absolute",
                                left: (a.translateX || 0) + "px",
                                top: (a.translateY || 0) + "px"
                            }, b || c);
                            d = b.style;
                            t(a, {
                                translateXSetter: function(b, c) {
                                    d.left = b + "px";
                                    a[c] = b;
                                    a.doTransform = !0
                                },
                                translateYSetter: function(b, c) {
                                    d.top = b + "px";
                                    a[c] = b;
                                    a.doTransform = !0
                                }
                            });
                            o(["opacity", "visibility"], function(b) {
                                Ta(a, b + "Setter", function(a, b, c, e) {
                                    a.call(this, b, c, e);
                                    d[c] = b
                                })
                            })
                        })
                    }
                } else b = c;
                b.appendChild(e);
                d.added = !0;
                d.alignOnAdd && d.htmlUpdateTransform();
                return d
            };
            return d
        }
    });
    if (!ca && !fa) {
        E = {
            init: function(a, b) {
                var c = ["<", b, ' filled="f" stroked="f"'],
                    d = ["position: ", "absolute", ";"],
                    e = b === Ja;
                (b === "shape" || e) && d.push("left:0;top:0;width:1px;height:1px;");
                d.push("visibility: ", e ? "hidden" : "visible");
                c.push(' style="', d.join(""), '"/>');
                if (b) c = e || b === "span" || b === "img" ? c.join("") : a.prepVML(c), this.element = $(c);
                this.renderer = a
            },
            add: function(a) {
                var b = this.renderer,
                    c = this.element,
                    d = b.box,
                    d = a ? a.element || a : d;
                a && a.inverted && b.invertChild(c, d);
                d.appendChild(c);
                this.added = !0;
                this.alignOnAdd && !this.deferUpdateTransform && this.updateTransform();
                if (this.onAdd) this.onAdd();
                return this
            },
            updateTransform: Q.prototype.htmlUpdateTransform,
            setSpanRotation: function() {
                var a = this.rotation,
                    b = W(a * ga),
                    c = aa(a * ga);
                M(this.element, {
                    filter: a ? ["progid:DXImageTransform.Microsoft.Matrix(M11=", b, ", M12=", -c, ", M21=", c, ", M22=", b, ", sizingMethod='auto expand')"].join("") : P
                })
            },
            getSpanCorrection: function(a, b, c, d, e) {
                var f = d ? W(d * ga) : 1,
                    g = d ? aa(d * ga) : 0,
                    h = p(this.elemHeight, this.element.offsetHeight),
                    i;
                this.xCorr = f < 0 && -a;
                this.yCorr = g < 0 && -h;
                i = f * g < 0;
                this.xCorr += g * b * (i ? 1 - c : c);
                this.yCorr -= f * b * (d ? i ? c : 1 - c : 1);
                e && e !== "left" && (this.xCorr -= a * c * (f < 0 ? -1 : 1), d && (this.yCorr -= h * c * (g < 0 ? -1 : 1)), M(this.element, {
                    textAlign: e
                }))
            },
            pathToVML: function(a) {
                for (var b = a.length, c = []; b--;)
                    if (qa(a[b])) c[b] = w(a[b] * 10) - 5;
                    else if (a[b] === "Z") c[b] = "x";
                else if (c[b] = a[b], a.isArc && (a[b] === "wa" || a[b] === "at")) c[b + 5] === c[b + 7] && (c[b + 7] += a[b + 7] > a[b + 5] ? 1 : -1), c[b + 6] === c[b + 8] && (c[b + 8] += a[b + 8] > a[b + 6] ? 1 : -1);
                return c.join(" ") || "x"
            },
            clip: function(a) {
                var b = this,
                    c;
                a ? (c = a.members, ja(c, b), c.push(b), b.destroyClip = function() {
                    ja(c, b)
                }, a = a.getCSS(b)) : (b.destroyClip && b.destroyClip(), a = {
                    clip: gb ? "inherit" : "rect(auto)"
                });
                return b.css(a)
            },
            css: Q.prototype.htmlCss,
            safeRemoveChild: function(a) {
                a.parentNode && Qa(a)
            },
            destroy: function() {
                this.destroyClip && this.destroyClip();
                return Q.prototype.destroy.apply(this)
            },
            on: function(a, b) {
                this.element["on" + a] = function() {
                    var a = L.event;
                    a.target = a.srcElement;
                    b(a)
                };
                return this
            },
            cutOffPath: function(a, b) {
                var c, a = a.split(/[ ,]/);
                c = a.length;
                if (c === 9 || c === 11) a[c - 4] = a[c - 2] = G(a[c - 2]) - 10 * b;
                return a.join(" ")
            },
            shadow: function(a, b, c) {
                var d = [],
                    e, f = this.element,
                    g = this.renderer,
                    h, i = f.style,
                    j, k = f.path,
                    m, n, l, u;
                k && typeof k.value !== "string" && (k = "x");
                n = k;
                if (a) {
                    l = p(a.width, 3);
                    u = (a.opacity || 0.15) / l;
                    for (e = 1; e <= 3; e++) {
                        m = l * 2 + 1 - 2 * e;
                        c && (n = this.cutOffPath(k.value, m + 0.5));
                        j = ['<shape isShadow="true" strokeweight="', m, '" filled="false" path="', n, '" coordsize="10 10" style="', f.style.cssText, '" />'];
                        h = $(g.prepVML(j), null, {
                            left: G(i.left) + p(a.offsetX, 1),
                            top: G(i.top) + p(a.offsetY, 1)
                        });
                        if (c) h.cutOff = m + 1;
                        j = ['<stroke color="', a.color || "black", '" opacity="', u * e, '"/>'];
                        $(g.prepVML(j), null, null, h);
                        b ? b.element.appendChild(h) : f.parentNode.insertBefore(h, f);
                        d.push(h)
                    }
                    this.shadows = d
                }
                return this
            },
            updateShadows: ua,
            setAttr: function(a, b) {
                gb ? this.element[a] = b : this.element.setAttribute(a, b)
            },
            classSetter: function(a) {
                this.element.className = a
            },
            dashstyleSetter: function(a, b, c) {
                (c.getElementsByTagName("stroke")[0] || $(this.renderer.prepVML(["<stroke/>"]), null, null, c))[b] = a || "solid";
                this[b] = a
            },
            dSetter: function(a, b, c) {
                var d = this.shadows,
                    a = a || [];
                this.d = a.join && a.join(" ");
                c.path = a = this.pathToVML(a);
                if (d)
                    for (c = d.length; c--;) d[c].path = d[c].cutOff ? this.cutOffPath(a, d[c].cutOff) : a;
                this.setAttr(b, a)
            },
            fillSetter: function(a, b, c) {
                var d = c.nodeName;
                if (d === "SPAN") c.style.color = a;
                else if (d !== "IMG") c.filled = a !== P, this.setAttr("fillcolor", this.renderer.color(a, c, b, this))
            },
            opacitySetter: ua,
            rotationSetter: function(a, b, c) {
                c = c.style;
                this[b] = c[b] = a;
                c.left = -w(aa(a * ga) + 1) + "px";
                c.top = w(W(a * ga)) + "px"
            },
            strokeSetter: function(a, b, c) {
                this.setAttr("strokecolor", this.renderer.color(a, c, b))
            },
            "stroke-widthSetter": function(a, b, c) {
                c.stroked = !!a;
                this[b] = a;
                qa(a) && (a += "px");
                this.setAttr("strokeweight", a)
            },
            titleSetter: function(a, b) {
                this.setAttr(b, a)
            },
            visibilitySetter: function(a, b, c) {
                a === "inherit" && (a = "visible");
                this.shadows && o(this.shadows, function(c) {
                    c.style[b] = a
                });
                c.nodeName === "DIV" && (a = a === "hidden" ? "-999em" : 0, gb || (c.style[b] = a ? "visible" : "hidden"), b = "top");
                c.style[b] = a
            },
            xSetter: function(a, b, c) {
                this[b] = a;
                b === "x" ? b = "left" : b === "y" && (b = "top");
                this.updateClipping ? (this[b] = a, this.updateClipping()) : c.style[b] = a
            },
            zIndexSetter: function(a, b, c) {
                c.style[b] = a
            }
        };
        B.VMLElement = E = ka(Q, E);
        E.prototype.ySetter = E.prototype.widthSetter = E.prototype.heightSetter = E.prototype.xSetter;
        var Ma = {
            Element: E,
            isIE8: za.indexOf("MSIE 8.0") > -1,
            init: function(a, b, c, d) {
                var e;
                this.alignedObjects = [];
                d = this.createElement(Ja).css(t(this.getStyle(d), {
                    position: "relative"
                }));
                e = d.element;
                a.appendChild(d.element);
                this.isVML = !0;
                this.box = e;
                this.boxWrapper = d;
                this.cache = {};
                this.setSize(b, c, !1);
                if (!C.namespaces.hcv) {
                    C.namespaces.add("hcv", "urn:schemas-microsoft-com:vml");
                    try {
                        C.createStyleSheet().cssText = "hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } "
                    } catch (f) {
                        C.styleSheets[0].cssText += "hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } "
                    }
                }
            },
            isHidden: function() {
                return !this.box.offsetWidth
            },
            clipRect: function(a, b, c, d) {
                var e = this.createElement(),
                    f = da(a);
                return t(e, {
                    members: [],
                    count: 0,
                    left: (f ? a.x : a) + 1,
                    top: (f ? a.y : b) + 1,
                    width: (f ? a.width : c) - 1,
                    height: (f ? a.height : d) - 1,
                    getCSS: function(a) {
                        var b = a.element,
                            c = b.nodeName,
                            a = a.inverted,
                            d = this.top - (c === "shape" ? b.offsetTop : 0),
                            e = this.left,
                            b = e + this.width,
                            f = d + this.height,
                            d = {
                                clip: "rect(" + w(a ? e : d) + "px," + w(a ? f : b) + "px," + w(a ? b : f) + "px," + w(a ? d : e) + "px)"
                            };
                        !a && gb && c === "DIV" && t(d, {
                            width: b + "px",
                            height: f + "px"
                        });
                        return d
                    },
                    updateClipping: function() {
                        o(e.members, function(a) {
                            a.element && a.css(e.getCSS(a))
                        })
                    }
                })
            },
            color: function(a, b, c, d) {
                var e = this,
                    f, g = /^rgba/,
                    h, i, j = P;
                a && a.linearGradient ? i = "gradient" : a && a.radialGradient && (i = "pattern");
                if (i) {
                    var k, m, n = a.linearGradient || a.radialGradient,
                        l, u, r, p, A, v = "",
                        a = a.stops,
                        y, q = [],
                        va = function() {
                            h = ['<fill colors="' + q.join(",") + '" opacity="', r, '" o:opacity2="', u, '" type="', i, '" ', v, 'focus="100%" method="any" />'];
                            $(e.prepVML(h), null, null, b)
                        };
                    l = a[0];
                    y = a[a.length - 1];
                    l[0] > 0 && a.unshift([0, l[1]]);
                    y[0] < 1 && a.push([1, y[1]]);
                    o(a, function(a, b) {
                        g.test(a[1]) ? (f = na(a[1]), k = f.get("rgb"), m = f.get("a")) : (k = a[1], m = 1);
                        q.push(a[0] * 100 + "% " + k);
                        b ? (r = m, p = k) : (u = m, A = k)
                    });
                    if (c === "fill")
                        if (i === "gradient") c = n.x1 || n[0] || 0, a = n.y1 || n[1] || 0, l = n.x2 || n[2] || 0, n = n.y2 || n[3] || 0, v = 'angle="' + (90 - V.atan((n - a) / (l - c)) * 180 / ma) + '"', va();
                        else {
                            var j = n.r,
                                s = j * 2,
                                x = j * 2,
                                t = n.cx,
                                w = n.cy,
                                z = b.radialReference,
                                D, j = function() {
                                    z && (D = d.getBBox(), t += (z[0] - D.x) / D.width - 0.5, w += (z[1] - D.y) / D.height - 0.5, s *= z[2] / D.width, x *= z[2] / D.height);
                                    v = 'src="' + S.global.VMLRadialGradientURL + '" size="' + s + "," + x + '" origin="0.5,0.5" position="' + t + "," + w + '" color2="' + A + '" ';
                                    va()
                                };
                            d.added ? j() : d.onAdd = j;
                            j = p
                        }
                    else j = k
                } else if (g.test(a) && b.tagName !== "IMG") f = na(a), h = ["<", c, ' opacity="', f.get("a"), '"/>'], $(this.prepVML(h), null, null, b), j = f.get("rgb");
                else {
                    j = b.getElementsByTagName(c);
                    if (j.length) j[0].opacity = 1, j[0].type = "solid";
                    j = a
                }
                return j
            },
            prepVML: function(a) {
                var b = this.isIE8,
                    a = a.join("");
                b ? (a = a.replace("/>", ' xmlns="urn:schemas-microsoft-com:vml" />'), a = a.indexOf('style="') === -1 ? a.replace("/>", ' style="display:inline-block;behavior:url(#default#VML);" />') : a.replace('style="', 'style="display:inline-block;behavior:url(#default#VML);')) : a = a.replace("<", "<hcv:");
                return a
            },
            text: Aa.prototype.html,
            path: function(a) {
                var b = {
                    coordsize: "10 10"
                };
                Ga(a) ? b.d = a : da(a) && t(b, a);
                return this.createElement("shape").attr(b)
            },
            circle: function(a, b, c) {
                var d = this.symbol("circle");
                if (da(a)) c = a.r, b = a.y, a = a.x;
                d.isCircle = !0;
                d.r = c;
                return d.attr({
                    x: a,
                    y: b
                })
            },
            g: function(a) {
                var b;
                a && (b = {
                    className: "highcharts-" + a,
                    "class": "highcharts-" + a
                });
                return this.createElement(Ja).attr(b)
            },
            image: function(a, b, c, d, e) {
                var f = this.createElement("img").attr({
                    src: a
                });
                arguments.length > 1 && f.attr({
                    x: b,
                    y: c,
                    width: d,
                    height: e
                });
                return f
            },
            createElement: function(a) {
                return a === "rect" ? this.symbol(a) : Aa.prototype.createElement.call(this, a)
            },
            invertChild: function(a, b) {
                var c = this,
                    d = b.style,
                    e = a.tagName === "IMG" && a.style;
                M(a, {
                    flip: "x",
                    left: G(d.width) - (e ? G(e.top) : 1),
                    top: G(d.height) - (e ? G(e.left) : 1),
                    rotation: -90
                });
                o(a.childNodes, function(b) {
                    c.invertChild(b, a)
                })
            },
            symbols: {
                arc: function(a, b, c, d, e) {
                    var f = e.start,
                        g = e.end,
                        h = e.r || c || d,
                        c = e.innerR,
                        d = W(f),
                        i = aa(f),
                        j = W(g),
                        k = aa(g);
                    if (g - f === 0) return ["x"];
                    f = ["wa", a - h, b - h, a + h, b + h, a + h * d, b + h * i, a + h * j, b + h * k];
                    e.open && !c && f.push("e", "M", a, b);
                    f.push("at", a - c, b - c, a + c, b + c, a + c * j, b + c * k, a + c * d, b + c * i, "x", "e");
                    f.isArc = !0;
                    return f
                },
                circle: function(a, b, c, d, e) {
                    e && (c = d = 2 * e.r);
                    e && e.isCircle && (a -= c / 2, b -= d / 2);
                    return ["wa", a, b, a + c, b + d, a + c, b + d / 2, a + c, b + d / 2, "e"]
                },
                rect: function(a, b, c, d, e) {
                    return Aa.prototype.symbols[!q(e) || !e.r ? "square" : "callout"].call(0, a, b, c, d, e)
                }
            }
        };
        B.VMLRenderer = E = function() {
            this.init.apply(this, arguments)
        };
        E.prototype = D(Aa.prototype, Ma);
        $a = E
    }
    Aa.prototype.measureSpanWidth = function(a, b) {
        var c = C.createElement("span"),
            d;
        d = C.createTextNode(a);
        c.appendChild(d);
        M(c, b);
        this.box.appendChild(c);
        d = c.offsetWidth;
        Qa(c);
        return d
    };
    var Lb;
    if (fa) B.CanVGRenderer = E = function() {
        Ea = "http://www.w3.org/1999/xhtml"
    }, E.prototype.symbols = {}, Lb = function() {
        function a() {
            var a = b.length,
                d;
            for (d = 0; d < a; d++) b[d]();
            b = []
        }
        var b = [];
        return {
            push: function(c, d) {
                b.length === 0 && Qb(d, a);
                b.push(c)
            }
        }
    }(), $a = E;
    Sa.prototype = {
        addLabel: function() {
            var a = this.axis,
                b = a.options,
                c = a.chart,
                d = a.categories,
                e = a.names,
                f = this.pos,
                g = b.labels,
                h = a.tickPositions,
                i = f === h[0],
                j = f === h[h.length - 1],
                e = d ? p(d[f], e[f], f) : f,
                d = this.label,
                h = h.info,
                k;
            a.isDatetimeAxis && h && (k = b.dateTimeLabelFormats[h.higherRanks[f] || h.unitName]);
            this.isFirst = i;
            this.isLast = j;
            b = a.labelFormatter.call({
                axis: a,
                chart: c,
                isFirst: i,
                isLast: j,
                dateTimeLabelFormat: k,
                value: a.isLog ? ea(ia(e)) : e
            });
            q(d) ? d && d.attr({
                text: b
            }) : (this.labelLength = (this.label = d = q(b) && g.enabled ? c.renderer.text(b, 0, 0, g.useHTML).css(D(g.style)).add(a.labelGroup) : null) && d.getBBox().width, this.rotation = 0)
        },
        getLabelSize: function() {
            return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0
        },
        handleOverflow: function(a) {
            var b = this.axis,
                c = a.x,
                d = b.chart.chartWidth,
                e = b.chart.spacing,
                f = p(b.labelLeft, z(b.pos, e[3])),
                e = p(b.labelRight, s(b.pos + b.len, d - e[1])),
                g = this.label,
                h = this.rotation,
                i = {
                    left: 0,
                    center: 0.5,
                    right: 1
                }[b.labelAlign],
                j = g.getBBox().width,
                k = b.slotWidth,
                m = 1,
                n, l = {};
            if (h) h < 0 && c - i * j < f ? n = w(c / W(h * ga) - f) : h > 0 && c + i * j > e && (n = w((d - c) / W(h * ga)));
            else if (d = c + (1 - i) * j, c - i * j < f ? k = a.x + k * (1 - i) - f : d > e && (k = e - a.x + k * i, m = -1), k = z(b.slotWidth, k), k < b.slotWidth && b.labelAlign === "center" && (a.x += m * (b.slotWidth - k - i * (b.slotWidth - z(j, k)))), j > k || b.autoRotation && g.styles.width) n = k;
            if (n) {
                l.width = n;
                if (!b.options.labels.style.textOverflow) l.textOverflow = "ellipsis";
                g.css(l)
            }
        },
        getPosition: function(a, b, c, d) {
            var e = this.axis,
                f = e.chart,
                g = d && f.oldChartHeight || f.chartHeight;
            return {
                x: a ? e.translate(b + c, null, null, d) + e.transB : e.left + e.offset + (e.opposite ? (d && f.oldChartWidth || f.chartWidth) - e.right - e.left : 0),
                y: a ? g - e.bottom + e.offset - (e.opposite ? e.height : 0) : g - e.translate(b + c, null, null, d) - e.transB
            }
        },
        getLabelPosition: function(a, b, c, d, e, f, g, h) {
            var i = this.axis,
                j = i.transA,
                k = i.reversed,
                m = i.staggerLines,
                n = i.tickRotCorr || {
                    x: 0,
                    y: 0
                },
                c = p(e.y, n.y + (i.side === 2 ? 8 : -(c.getBBox().height / 2))),
                a = a + e.x + n.x - (f && d ? f * j * (k ? -1 : 1) : 0),
                b = b + c - (f && !d ? f * j * (k ? 1 : -1) : 0);
            m && (b += g / (h || 1) % m * (i.labelOffset / m));
            return {
                x: a,
                y: w(b)
            }
        },
        getMarkPath: function(a, b, c, d, e, f) {
            return f.crispLine(["M", a, b, "L", a + (e ? 0 : -c), b + (e ? c : 0)], d)
        },
        render: function(a, b, c) {
            var d = this.axis,
                e = d.options,
                f = d.chart.renderer,
                g = d.horiz,
                h = this.type,
                i = this.label,
                j = this.pos,
                k = e.labels,
                m = this.gridLine,
                n = h ? h + "Grid" : "grid",
                l = h ? h + "Tick" : "tick",
                u = e[n + "LineWidth"],
                r = e[n + "LineColor"],
                o = e[n + "LineDashStyle"],
                A = e[l + "Length"],
                n = p(e[l + "Width"], !h && d.isXAxis ? 1 : 0),
                v = e[l + "Color"],
                y = e[l + "Position"],
                l = this.mark,
                q = k.step,
                va = !0,
                s = d.tickmarkOffset,
                t = this.getPosition(g, j, s, b),
                w = t.x,
                t = t.y,
                z = g && w === d.pos + d.len || !g && t === d.pos ? -1 : 1,
                c = p(c, 1);
            this.isActive = !0;
            if (u) {
                j = d.getPlotLinePath(j + s, u * z, b, !0);
                if (m === x) {
                    m = {
                        stroke: r,
                        "stroke-width": u
                    };
                    if (o) m.dashstyle = o;
                    if (!h) m.zIndex = 1;
                    if (b) m.opacity = 0;
                    this.gridLine = m = u ? f.path(j).attr(m).add(d.gridGroup) : null
                }
                if (!b && m && j) m[this.isNew ? "attr" : "animate"]({
                    d: j,
                    opacity: c
                })
            }
            if (n && A) y === "inside" && (A = -A), d.opposite && (A = -A), h = this.getMarkPath(w, t, A, n * z, g, f), l ? l.animate({
                d: h,
                opacity: c
            }) : this.mark = f.path(h).attr({
                stroke: v,
                "stroke-width": n,
                opacity: c
            }).add(d.axisGroup);
            if (i && !isNaN(w)) i.xy = t = this.getLabelPosition(w, t, i, g, k, s, a, q), this.isFirst && !this.isLast && !p(e.showFirstLabel, 1) || this.isLast && !this.isFirst && !p(e.showLastLabel, 1) ? va = !1 : g && !d.isRadial && !k.step && !k.rotation && !b && c !== 0 && this.handleOverflow(t), q && a % q && (va = !1), va && !isNaN(t.y) ? (t.opacity = c, i[this.isNew ? "attr" : "animate"](t), this.isNew = !1) : i.attr("y", -9999)
        },
        destroy: function() {
            Pa(this, this.axis)
        }
    };
    B.PlotLineOrBand = function(a, b) {
        this.axis = a;
        if (b) this.options = b, this.id = b.id
    };
    B.PlotLineOrBand.prototype = {
        render: function() {
            var a = this,
                b = a.axis,
                c = b.horiz,
                d = a.options,
                e = d.label,
                f = a.label,
                g = d.width,
                h = d.to,
                i = d.from,
                j = q(i) && q(h),
                k = d.value,
                m = d.dashStyle,
                n = a.svgElem,
                l = [],
                u, r = d.color,
                p = d.zIndex,
                o = d.events,
                v = {},
                y = b.chart.renderer;
            b.isLog && (i = Ca(i), h = Ca(h), k = Ca(k));
            if (g) {
                if (l = b.getPlotLinePath(k, g), v = {
                        stroke: r,
                        "stroke-width": g
                    }, m) v.dashstyle = m
            } else if (j) {
                l = b.getPlotBandPath(i, h, d);
                if (r) v.fill = r;
                if (d.borderWidth) v.stroke = d.borderColor, v["stroke-width"] = d.borderWidth
            } else return;
            if (q(p)) v.zIndex = p;
            if (n)
                if (l) n.animate({
                    d: l
                }, null, n.onGetPath);
                else {
                    if (n.hide(), n.onGetPath = function() {
                            n.show()
                        }, f) a.label = f = f.destroy()
                }
            else if (l && l.length && (a.svgElem = n = y.path(l).attr(v).add(), o))
                for (u in d = function(b) {
                        n.on(b, function(c) {
                            o[b].apply(a, [c])
                        })
                    }, o) d(u);
            if (e && q(e.text) && l && l.length && b.width > 0 && b.height > 0) {
                e = D({
                    align: c && j && "center",
                    x: c ? !j && 4 : 10,
                    verticalAlign: !c && j && "middle",
                    y: c ? j ? 16 : 10 : j ? 6 : -4,
                    rotation: c && !j && 90
                }, e);
                if (!f) {
                    v = {
                        align: e.textAlign || e.align,
                        rotation: e.rotation
                    };
                    if (q(p)) v.zIndex = p;
                    a.label = f = y.text(e.text, 0, 0, e.useHTML).attr(v).css(e.style).add()
                }
                b = [l[1], l[4], j ? l[6] : l[1]];
                j = [l[2], l[5], j ? l[7] : l[2]];
                l = Oa(b);
                c = Oa(j);
                f.align(e, !1, {
                    x: l,
                    y: c,
                    width: Da(b) - l,
                    height: Da(j) - c
                });
                f.show()
            } else f && f.hide();
            return a
        },
        destroy: function() {
            ja(this.axis.plotLinesAndBands, this);
            delete this.axis;
            Pa(this)
        }
    };
    var ha = B.Axis = function() {
        this.init.apply(this, arguments)
    };
    ha.prototype = {
        defaultOptions: {
            dateTimeLabelFormats: {
                millisecond: "%H:%M:%S.%L",
                second: "%H:%M:%S",
                minute: "%H:%M",
                hour: "%H:%M",
                day: "%e. %b",
                week: "%e. %b",
                month: "%b '%y",
                year: "%Y"
            },
            endOnTick: !1,
            gridLineColor: "#D8D8D8",
            labels: {
                enabled: !0,
                style: {
                    color: "#606060",
                    cursor: "default",
                    fontSize: "11px"
                },
                x: 0,
                y: 15
            },
            lineColor: "#C0D0E0",
            lineWidth: 1,
            minPadding: 0.01,
            maxPadding: 0.01,
            minorGridLineColor: "#E0E0E0",
            minorGridLineWidth: 1,
            minorTickColor: "#A0A0A0",
            minorTickLength: 2,
            minorTickPosition: "outside",
            startOfWeek: 1,
            startOnTick: !1,
            tickColor: "#C0D0E0",
            tickLength: 10,
            tickmarkPlacement: "between",
            tickPixelInterval: 100,
            tickPosition: "outside",
            title: {
                align: "middle",
                style: {
                    color: "#707070"
                }
            },
            type: "linear"
        },
        defaultYAxisOptions: {
            endOnTick: !0,
            gridLineWidth: 1,
            tickPixelInterval: 72,
            showLastLabel: !0,
            labels: {
                x: -8,
                y: 3
            },
            lineWidth: 0,
            maxPadding: 0.05,
            minPadding: 0.05,
            startOnTick: !0,
            title: {
                rotation: 270,
                text: "Values"
            },
            stackLabels: {
                enabled: !1,
                formatter: function() {
                    return B.numberFormat(this.total, -1)
                },
                style: D(ba.line.dataLabels.style, {
                    color: "#000000"
                })
            }
        },
        defaultLeftAxisOptions: {
            labels: {
                x: -15,
                y: null
            },
            title: {
                rotation: 270
            }
        },
        defaultRightAxisOptions: {
            labels: {
                x: 15,
                y: null
            },
            title: {
                rotation: 90
            }
        },
        defaultBottomAxisOptions: {
            labels: {
                autoRotation: [-45],
                x: 0,
                y: null
            },
            title: {
                rotation: 0
            }
        },
        defaultTopAxisOptions: {
            labels: {
                autoRotation: [-45],
                x: 0,
                y: -15
            },
            title: {
                rotation: 0
            }
        },
        init: function(a, b) {
            var c = b.isX;
            this.chart = a;
            this.horiz = a.inverted ? !c : c;
            this.coll = (this.isXAxis = c) ? "xAxis" : "yAxis";
            this.opposite = b.opposite;
            this.side = b.side || (this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);
            this.setOptions(b);
            var d = this.options,
                e = d.type;
            this.labelFormatter = d.labels.formatter || this.defaultLabelFormatter;
            this.userOptions = b;
            this.minPixelPadding = 0;
            this.reversed = d.reversed;
            this.visible = d.visible !== !1;
            this.zoomEnabled = d.zoomEnabled !== !1;
            this.categories = d.categories || e === "category";
            this.names = this.names || [];
            this.isLog = e === "logarithmic";
            this.isDatetimeAxis = e === "datetime";
            this.isLinked = q(d.linkedTo);
            this.ticks = {};
            this.labelEdge = [];
            this.minorTicks = {};
            this.plotLinesAndBands = [];
            this.alternateBands = {};
            this.len = 0;
            this.minRange = this.userMinRange = d.minRange || d.maxZoom;
            this.range = d.range;
            this.offset = d.offset || 0;
            this.stacks = {};
            this.oldStacks = {};
            this.stacksTouched = 0;
            this.min = this.max = null;
            this.crosshair = p(d.crosshair, ra(a.options.tooltip.crosshairs)[c ? 0 : 1], !1);
            var f, d = this.options.events;
            La(this, a.axes) === -1 && (c && !this.isColorAxis ? a.axes.splice(a.xAxis.length, 0, this) : a.axes.push(this), a[this.coll].push(this));
            this.series = this.series || [];
            if (a.inverted && c && this.reversed === x) this.reversed = !0;
            this.removePlotLine = this.removePlotBand = this.removePlotBandOrLine;
            for (f in d) I(this, f, d[f]);
            if (this.isLog) this.val2lin = Ca, this.lin2val = ia
        },
        setOptions: function(a) {
            this.options = D(this.defaultOptions, this.isXAxis ? {} : this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], D(S[this.coll], a))
        },
        defaultLabelFormatter: function() {
            var a = this.axis,
                b = this.value,
                c = a.categories,
                d = this.dateTimeLabelFormat,
                e = S.lang.numericSymbols,
                f = e && e.length,
                g, h = a.options.labels.format,
                a = a.isLog ? b : a.tickInterval;
            if (h) g = Ia(h, this);
            else if (c) g = b;
            else if (d) g = Na(d, b);
            else if (f && a >= 1E3)
                for (; f-- && g === x;) c = Math.pow(1E3, f + 1), a >= c && b * 10 % c === 0 && e[f] !== null && (g = B.numberFormat(b / c, -1) + e[f]);
            g === x && (g = O(b) >= 1E4 ? B.numberFormat(b, -1) : B.numberFormat(b, -1, x, ""));
            return g
        },
        getSeriesExtremes: function() {
            var a = this,
                b = a.chart;
            a.hasVisibleSeries = !1;
            a.dataMin = a.dataMax = a.threshold = null;
            a.softThreshold = !a.isXAxis;
            a.buildStacks && a.buildStacks();
            o(a.series, function(c) {
                if (c.visible || !b.options.chart.ignoreHiddenSeries) {
                    var d = c.options,
                        e = d.threshold,
                        f;
                    a.hasVisibleSeries = !0;
                    a.isLog && e <= 0 && (e = null);
                    if (a.isXAxis) {
                        if (d = c.xData, d.length) a.dataMin = z(p(a.dataMin, d[0]), Oa(d)), a.dataMax = s(p(a.dataMax, d[0]), Da(d))
                    } else {
                        c.getExtremes();
                        f = c.dataMax;
                        c = c.dataMin;
                        if (q(c) && q(f)) a.dataMin = z(p(a.dataMin, c), c), a.dataMax = s(p(a.dataMax, f), f);
                        if (q(e)) a.threshold = e;
                        if (!d.softThreshold || a.isLog) a.softThreshold = !1
                    }
                }
            })
        },
        translate: function(a, b, c, d, e, f) {
            var g = this.linkedParent || this,
                h = 1,
                i = 0,
                j = d ? g.oldTransA : g.transA,
                d = d ? g.oldMin : g.min,
                k = g.minPixelPadding,
                e = (g.doPostTranslate || g.isLog && e) && g.lin2val;
            if (!j) j = g.transA;
            if (c) h *= -1, i = g.len;
            g.reversed && (h *= -1, i -= h * (g.sector || g.len));
            b ? (a = a * h + i, a -= k, a = a / j + d, e && (a = g.lin2val(a))) : (e && (a = g.val2lin(a)), f === "between" && (f = 0.5), a = h * (a - d) * j + i + h * k + (qa(f) ? j * f * g.pointRange : 0));
            return a
        },
        toPixels: function(a, b) {
            return this.translate(a, !1, !this.horiz, null, !0) + (b ? 0 : this.pos)
        },
        toValue: function(a, b) {
            return this.translate(a -
                (b ? 0 : this.pos), !0, !this.horiz, null, !0)
        },
        getPlotLinePath: function(a, b, c, d, e) {
            var f = this.chart,
                g = this.left,
                h = this.top,
                i, j, k = c && f.oldChartHeight || f.chartHeight,
                m = c && f.oldChartWidth || f.chartWidth,
                n;
            i = this.transB;
            var l = function(a, b, c) {
                    if (a < b || a > c) d ? a = z(s(b, a), c) : n = !0;
                    return a
                },
                e = p(e, this.translate(a, null, null, c)),
                a = c = w(e + i);
            i = j = w(k - e - i);
            isNaN(e) ? n = !0 : this.horiz ? (i = h, j = k - this.bottom, a = c = l(a, g, g + this.width)) : (a = g, c = m - this.right, i = j = l(i, h, h + this.height));
            return n && !d ? null : f.renderer.crispLine(["M", a, i, "L", c, j], b || 1)
        },
        getLinearTickPositions: function(a, b, c) {
            var d, e = ea(T(b / a) * a),
                f = ea(ta(c / a) * a),
                g = [];
            if (b === c && qa(b)) return [b];
            for (b = e; b <= f;) {
                g.push(b);
                b = ea(b + a);
                if (b === d) break;
                d = b
            }
            return g
        },
        getMinorTickPositions: function() {
            var a = this.options,
                b = this.tickPositions,
                c = this.minorTickInterval,
                d = [],
                e, f = this.pointRangePadding || 0;
            e = this.min - f;
            var f = this.max + f,
                g = f - e;
            if (g && g / c < this.len / 3)
                if (this.isLog) {
                    f = b.length;
                    for (e = 1; e < f; e++) d = d.concat(this.getLogTickPositions(c, b[e - 1], b[e], !0))
                } else if (this.isDatetimeAxis && a.minorTickInterval === "auto") d = d.concat(this.getTimeTicks(this.normalizeTimeTickInterval(c), e, f, a.startOfWeek));
            else
                for (b = e + (b[0] - e) % c; b <= f; b += c) d.push(b);
            d.length !== 0 && this.trimTicks(d, a.startOnTick, a.endOnTick);
            return d
        },
        adjustForMinRange: function() {
            var a = this.options,
                b = this.min,
                c = this.max,
                d, e = this.dataMax - this.dataMin >= this.minRange,
                f, g, h, i, j, k;
            if (this.isXAxis && this.minRange === x && !this.isLog) q(a.min) || q(a.max) ? this.minRange = null : (o(this.series, function(a) {
                i = a.xData;
                for (g = j = a.xIncrement ? 1 : i.length - 1; g > 0; g--)
                    if (h = i[g] -
                        i[g - 1], f === x || h < f) f = h
            }), this.minRange = z(f * 5, this.dataMax - this.dataMin));
            if (c - b < this.minRange) {
                k = this.minRange;
                d = (k - c + b) / 2;
                d = [b - d, p(a.min, b - d)];
                if (e) d[2] = this.dataMin;
                b = Da(d);
                c = [b + k, p(a.max, b + k)];
                if (e) c[2] = this.dataMax;
                c = Oa(c);
                c - b < k && (d[0] = c - k, d[1] = p(a.min, c - k), b = Da(d))
            }
            this.min = b;
            this.max = c
        },
        setAxisTranslation: function(a) {
            var b = this,
                c = b.max - b.min,
                d = b.axisPointRange || 0,
                e, f = 0,
                g = 0,
                h = b.linkedParent,
                i = !!b.categories,
                j = b.transA,
                k = b.isXAxis;
            if (k || i || d)
                if (h ? (f = h.minPointOffset, g = h.pointRangePadding) : o(b.series, function(a) {
                        var c = i ? 1 : k ? a.pointRange : b.axisPointRange || 0,
                            h = a.options.pointPlacement,
                            j = a.closestPointRange;
                        d = s(d, c);
                        b.single || (f = s(f, Ba(h) ? 0 : c / 2), g = s(g, h === "on" ? 0 : c));
                        !a.noSharedTooltip && q(j) && (e = q(e) ? z(e, j) : j)
                    }), h = b.ordinalSlope && e ? b.ordinalSlope / e : 1, b.minPointOffset = f *= h, b.pointRangePadding = g *= h, b.pointRange = z(d, c), k) b.closestPointRange = e;
            if (a) b.oldTransA = j;
            b.translationSlope = b.transA = j = b.len / (c + g || 1);
            b.transB = b.horiz ? b.left : b.bottom;
            b.minPixelPadding = j * f
        },
        minFromRange: function() {
            return this.max -
                this.range
        },
        setTickInterval: function(a) {
            var b = this,
                c = b.chart,
                d = b.options,
                e = b.isLog,
                f = b.isDatetimeAxis,
                g = b.isXAxis,
                h = b.isLinked,
                i = d.maxPadding,
                j = d.minPadding,
                k = d.tickInterval,
                m = d.tickPixelInterval,
                n = b.categories,
                l = b.threshold,
                u = b.softThreshold,
                r, Z, A, v;
            !f && !n && !h && this.getTickAmount();
            A = p(b.userMin, d.min);
            v = p(b.userMax, d.max);
            h ? (b.linkedParent = c[b.coll][d.linkedTo], c = b.linkedParent.getExtremes(), b.min = p(c.min, c.dataMin), b.max = p(c.max, c.dataMax), d.type !== b.linkedParent.options.type && la(11, 1)) : (!u && q(l) && (b.dataMin >= l ? (r = l, j = 0) : b.dataMax <= l && (Z = l, i = 0)), b.min = p(A, r, b.dataMin), b.max = p(v, Z, b.dataMax));
            if (e) !a && z(b.min, p(b.dataMin, b.min)) <= 0 && la(10, 1), b.min = ea(Ca(b.min), 15), b.max = ea(Ca(b.max), 15);
            if (b.range && q(b.max)) b.userMin = b.min = A = s(b.min, b.minFromRange()), b.userMax = v = b.max, b.range = null;
            b.beforePadding && b.beforePadding();
            b.adjustForMinRange();
            if (!n && !b.axisPointRange && !b.usePercentage && !h && q(b.min) && q(b.max) && (c = b.max - b.min)) !q(A) && j && (b.min -= c * j), !q(v) && i && (b.max += c * i);
            if (qa(d.floor)) b.min = s(b.min, d.floor);
            if (qa(d.ceiling)) b.max = z(b.max, d.ceiling);
            if (u && q(b.dataMin))
                if (l = l || 0, !q(A) && b.min < l && b.dataMin >= l) b.min = l;
                else if (!q(v) && b.max > l && b.dataMax <= l) b.max = l;
            b.tickInterval = b.min === b.max || b.min === void 0 || b.max === void 0 ? 1 : h && !k && m === b.linkedParent.options.tickPixelInterval ? k = b.linkedParent.tickInterval : p(k, this.tickAmount ? (b.max - b.min) / s(this.tickAmount - 1, 1) : void 0, n ? 1 : (b.max - b.min) * m / s(b.len, m));
            g && !a && o(b.series, function(a) {
                a.processData(b.min !== b.oldMin || b.max !== b.oldMax)
            });
            b.setAxisTranslation(!0);
            b.beforeSetTickPositions && b.beforeSetTickPositions();
            if (b.postProcessTickInterval) b.tickInterval = b.postProcessTickInterval(b.tickInterval);
            if (b.pointRange) b.tickInterval = s(b.pointRange, b.tickInterval);
            a = p(d.minTickInterval, b.isDatetimeAxis && b.closestPointRange);
            if (!k && b.tickInterval < a) b.tickInterval = a;
            if (!f && !e && !k) b.tickInterval = pb(b.tickInterval, null, ob(b.tickInterval), p(d.allowDecimals, !(b.tickInterval > 0.5 && b.tickInterval < 5 && b.max > 1E3 && b.max < 9999)), !!this.tickAmount);
            if (!this.tickAmount && this.len) b.tickInterval = b.unsquish();
            this.setTickPositions()
        },
        setTickPositions: function() {
            var a = this.options,
                b, c = a.tickPositions,
                d = a.tickPositioner,
                e = a.startOnTick,
                f = a.endOnTick,
                g;
            this.tickmarkOffset = this.categories && a.tickmarkPlacement === "between" && this.tickInterval === 1 ? 0.5 : 0;
            this.minorTickInterval = a.minorTickInterval === "auto" && this.tickInterval ? this.tickInterval / 5 : a.minorTickInterval;
            this.tickPositions = b = c && c.slice();
            if (!b && (b = this.isDatetimeAxis ? this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval, a.units), this.min, this.max, a.startOfWeek, this.ordinalPositions, this.closestPointRange, !0) : this.isLog ? this.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max), b.length > this.len && (b = [b[0], b.pop()]), this.tickPositions = b, d && (d = d.apply(this, [this.min, this.max])))) this.tickPositions = b = d;
            if (!this.isLinked) this.trimTicks(b, e, f), this.min === this.max && q(this.min) && !this.tickAmount && (g = !0, this.min -= 0.5, this.max += 0.5), this.single = g, !c && !d && this.adjustTickAmount()
        },
        trimTicks: function(a, b, c) {
            var d = a[0],
                e = a[a.length - 1],
                f = this.minPointOffset || 0;
            b ? this.min = d : this.min - f > d && a.shift();
            c ? this.max = e : this.max + f < e && a.pop();
            a.length === 0 && q(d) && a.push((e + d) / 2)
        },
        getTickAmount: function() {
            var a = {},
                b, c = this.options,
                d = c.tickAmount,
                e = c.tickPixelInterval;
            !q(c.tickInterval) && this.len < e && !this.isRadial && !this.isLog && c.startOnTick && c.endOnTick && (d = 2);
            !d && this.chart.options.chart.alignTicks !== !1 && c.alignTicks !== !1 && (o(this.chart[this.coll], function(c) {
                var d = c.options,
                    e = c.horiz,
                    d = [e ? d.left : d.top, e ? d.width : d.height, d.pane].join(",");
                c.series.length && (a[d] ? b = !0 : a[d] = 1)
            }), b && (d = ta(this.len / e) + 1));
            if (d < 4) this.finalTickAmt = d, d = 5;
            this.tickAmount = d
        },
        adjustTickAmount: function() {
            var a = this.tickInterval,
                b = this.tickPositions,
                c = this.tickAmount,
                d = this.finalTickAmt,
                e = b && b.length;
            if (e < c) {
                for (; b.length < c;) b.push(ea(b[b.length - 1] + a));
                this.transA *= (e - 1) / (c - 1);
                this.max = b[b.length - 1]
            } else e > c && (this.tickInterval *= 2, this.setTickPositions());
            if (q(d)) {
                for (a = c = b.length; a--;)(d === 3 && a % 2 === 1 || d <= 2 && a > 0 && a < c - 1) && b.splice(a, 1);
                this.finalTickAmt = x
            }
        },
        setScale: function() {
            var a, b;
            this.oldMin = this.min;
            this.oldMax = this.max;
            this.oldAxisLength = this.len;
            this.setAxisSize();
            b = this.len !== this.oldAxisLength;
            o(this.series, function(b) {
                if (b.isDirtyData || b.isDirty || b.xAxis.isDirty) a = !0
            });
            if (b || a || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax) {
                if (this.resetStacks && this.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.oldUserMin = this.userMin, this.oldUserMax = this.userMax, !this.isDirty) this.isDirty = b || this.min !== this.oldMin || this.max !== this.oldMax
            } else this.cleanStacks && this.cleanStacks()
        },
        setExtremes: function(a, b, c, d, e) {
            var f = this,
                g = f.chart,
                c = p(c, !0);
            o(f.series, function(a) {
                delete a.kdTree
            });
            e = t(e, {
                min: a,
                max: b
            });
            J(f, "setExtremes", e, function() {
                f.userMin = a;
                f.userMax = b;
                f.eventArgs = e;
                c && g.redraw(d)
            })
        },
        zoom: function(a, b) {
            var c = this.dataMin,
                d = this.dataMax,
                e = this.options,
                f = z(c, p(e.min, c)),
                e = s(d, p(e.max, d));
            this.allowZoomOutside || (q(c) && a <= f && (a = f), q(d) && b >= e && (b = e));
            this.displayBtn = a !== x || b !== x;
            this.setExtremes(a, b, !1, x, {
                trigger: "zoom"
            });
            return !0
        },
        setAxisSize: function() {
            var a = this.chart,
                b = this.options,
                c = b.offsetLeft || 0,
                d = this.horiz,
                e = p(b.width, a.plotWidth - c + (b.offsetRight || 0)),
                f = p(b.height, a.plotHeight),
                g = p(b.top, a.plotTop),
                b = p(b.left, a.plotLeft + c),
                c = /%$/;
            c.test(f) && (f = parseFloat(f) / 100 * a.plotHeight);
            c.test(g) && (g = parseFloat(g) / 100 * a.plotHeight + a.plotTop);
            this.left = b;
            this.top = g;
            this.width = e;
            this.height = f;
            this.bottom = a.chartHeight -
                f - g;
            this.right = a.chartWidth - e - b;
            this.len = s(d ? e : f, 0);
            this.pos = d ? b : g
        },
        getExtremes: function() {
            var a = this.isLog;
            return {
                min: a ? ea(ia(this.min)) : this.min,
                max: a ? ea(ia(this.max)) : this.max,
                dataMin: this.dataMin,
                dataMax: this.dataMax,
                userMin: this.userMin,
                userMax: this.userMax
            }
        },
        getThreshold: function(a) {
            var b = this.isLog,
                c = b ? ia(this.min) : this.min,
                b = b ? ia(this.max) : this.max;
            a === null ? a = b < 0 ? b : c : c > a ? a = c : b < a && (a = b);
            return this.translate(a, 0, 1, 0, 1)
        },
        autoLabelAlign: function(a) {
            a = (p(a, 0) - this.side * 90 + 720) % 360;
            return a > 15 && a < 165 ? "right" : a > 195 && a < 345 ? "left" : "center"
        },
        unsquish: function() {
            var a = this.ticks,
                b = this.options.labels,
                c = this.horiz,
                d = this.tickInterval,
                e = d,
                f = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / d),
                g, h = b.rotation,
                i = this.chart.renderer.fontMetrics(b.style.fontSize, a[0] && a[0].label),
                j, k = Number.MAX_VALUE,
                m, n = function(a) {
                    a /= f || 1;
                    a = a > 1 ? ta(a) : 1;
                    return a * d
                };
            c ? (m = !b.staggerLines && !b.step && (q(h) ? [h] : f < p(b.autoRotationLimit, 80) && b.autoRotation)) && o(m, function(a) {
                var b;
                if (a === h || a && a >= -90 && a <= 90) j = n(O(i.h / aa(ga * a))), b = j + O(a / 360), b < k && (k = b, g = a, e = j)
            }) : b.step || (e = n(i.h));
            this.autoRotation = m;
            this.labelRotation = p(g, h);
            return e
        },
        renderUnsquish: function() {
            var a = this.chart,
                b = a.renderer,
                c = this.tickPositions,
                d = this.ticks,
                e = this.options.labels,
                f = this.horiz,
                g = a.margin,
                h = this.categories ? c.length : c.length - 1,
                i = this.slotWidth = f && !e.step && !e.rotation && (this.staggerLines || 1) * a.plotWidth / h || !f && (g[3] && g[3] - a.spacing[3] || a.chartWidth * 0.33),
                j = s(1, w(i - 2 * (e.padding || 5))),
                k = {},
                g = b.fontMetrics(e.style.fontSize, d[0] && d[0].label),
                h = e.style.textOverflow,
                m, n = 0;
            if (!Ba(e.rotation)) k.rotation = e.rotation || 0;
            if (this.autoRotation) o(c, function(a) {
                if ((a = d[a]) && a.labelLength > n) n = a.labelLength
            }), n > j && n > g.h ? k.rotation = this.labelRotation : this.labelRotation = 0;
            else if (i && (m = {
                    width: j + "px"
                }, !h)) {
                m.textOverflow = "clip";
                for (i = c.length; !f && i--;)
                    if (j = c[i], j = d[j].label)
                        if (j.styles.textOverflow === "ellipsis" && j.css({
                                textOverflow: "clip"
                            }), j.getBBox().height > this.len / c.length - (g.h - g.f)) j.specCss = {
                            textOverflow: "ellipsis"
                        }
            }
            if (k.rotation && (m = {
                    width: (n > a.chartHeight * 0.5 ? a.chartHeight * 0.33 : a.chartHeight) + "px"
                }, !h)) m.textOverflow = "ellipsis";
            this.labelAlign = k.align = e.align || this.autoLabelAlign(this.labelRotation);
            o(c, function(a) {
                var b = (a = d[a]) && a.label;
                if (b) b.attr(k), m && b.css(D(m, b.specCss)), delete b.specCss, a.rotation = k.rotation
            });
            this.tickRotCorr = b.rotCorr(g.b, this.labelRotation || 0, this.side === 2)
        },
        hasData: function() {
            return this.hasVisibleSeries || q(this.min) && q(this.max) && !!this.tickPositions
        },
        getOffset: function() {
            var a = this,
                b = a.chart,
                c = b.renderer,
                d = a.options,
                e = a.tickPositions,
                f = a.ticks,
                g = a.horiz,
                h = a.side,
                i = b.inverted ? [1, 0, 3, 2][h] : h,
                j, k, m = 0,
                n, l = 0,
                u = d.title,
                r = d.labels,
                Z = 0,
                A = b.axisOffset,
                b = b.clipOffset,
                v = [-1, 1, 1, -1][h],
                y, t = a.axisParent;
            j = a.hasData();
            a.showAxis = k = j || p(d.showEmpty, !0);
            a.staggerLines = a.horiz && r.staggerLines;
            if (!a.axisGroup) a.gridGroup = c.g("grid").attr({
                zIndex: d.gridZIndex || 1
            }).add(t), a.axisGroup = c.g("axis").attr({
                zIndex: d.zIndex || 2
            }).add(t), a.labelGroup = c.g("axis-labels").attr({
                zIndex: r.zIndex || 7
            }).addClass("highcharts-" + a.coll.toLowerCase() + "-labels").add(t);
            if (j || a.isLinked) {
                if (o(e, function(b) {
                        f[b] ? f[b].addLabel() : f[b] = new Sa(a, b)
                    }), a.renderUnsquish(), o(e, function(b) {
                        if (h === 0 || h === 2 || {
                                1: "left",
                                3: "right"
                            }[h] === a.labelAlign) Z = s(f[b].getLabelSize(), Z)
                    }), a.staggerLines) Z *= a.staggerLines, a.labelOffset = Z
            } else
                for (y in f) f[y].destroy(), delete f[y];
            if (u && u.text && u.enabled !== !1) {
                if (!a.axisTitle) a.axisTitle = c.text(u.text, 0, 0, u.useHTML).attr({
                    zIndex: 7,
                    rotation: u.rotation || 0,
                    align: u.textAlign || {
                        low: "left",
                        middle: "center",
                        high: "right"
                    }[u.align]
                }).addClass("highcharts-" +
                    this.coll.toLowerCase() + "-title").css(u.style).add(a.axisGroup), a.axisTitle.isNew = !0;
                if (k) m = a.axisTitle.getBBox()[g ? "height" : "width"], n = u.offset, l = q(n) ? 0 : p(u.margin, g ? 5 : 10);
                a.axisTitle[k ? "show" : "hide"]()
            }
            a.offset = v * p(d.offset, A[h]);
            a.tickRotCorr = a.tickRotCorr || {
                x: 0,
                y: 0
            };
            c = h === 2 ? a.tickRotCorr.y : 0;
            g = Z + l + (Z && v * (g ? p(r.y, a.tickRotCorr.y + 8) : r.x) - c);
            a.axisTitleMargin = p(n, g);
            A[h] = s(A[h], a.axisTitleMargin + m + v * a.offset, g);
            d = d.offset ? 0 : T(d.lineWidth / 2) * 2;
            b[i] = s(b[i], d)
        },
        getLinePath: function(a) {
            var b = this.chart,
                c = this.opposite,
                d = this.offset,
                e = this.horiz,
                f = this.left + (c ? this.width : 0) + d,
                d = b.chartHeight - this.bottom - (c ? this.height : 0) + d;
            c && (a *= -1);
            return b.renderer.crispLine(["M", e ? this.left : f, e ? d : this.top, "L", e ? b.chartWidth - this.right : f, e ? d : b.chartHeight - this.bottom], a)
        },
        getTitlePosition: function() {
            var a = this.horiz,
                b = this.left,
                c = this.top,
                d = this.len,
                e = this.options.title,
                f = a ? b : c,
                g = this.opposite,
                h = this.offset,
                i = e.x || 0,
                j = e.y || 0,
                k = G(e.style.fontSize || 12),
                d = {
                    low: f + (a ? 0 : d),
                    middle: f + d / 2,
                    high: f + (a ? d : 0)
                }[e.align],
                b = (a ? c + this.height : b) + (a ? 1 : -1) * (g ? -1 : 1) * this.axisTitleMargin + (this.side === 2 ? k : 0);
            return {
                x: a ? d + i : b + (g ? this.width : 0) + h + i,
                y: a ? b + j - (g ? this.height : 0) + h : d + j
            }
        },
        render: function() {
            var a = this,
                b = a.chart,
                c = b.renderer,
                d = a.options,
                e = a.isLog,
                f = a.isLinked,
                g = a.tickPositions,
                h = a.axisTitle,
                i = a.ticks,
                j = a.minorTicks,
                k = a.alternateBands,
                m = d.stackLabels,
                n = d.alternateGridColor,
                l = a.tickmarkOffset,
                u = d.lineWidth,
                r, p = b.hasRendered && q(a.oldMin) && !isNaN(a.oldMin),
                A = a.showAxis,
                v = c.globalAnimation,
                y, s;
            a.labelEdge.length = 0;
            a.overlap = !1;
            o([i, j, k], function(a) {
                for (var b in a) a[b].isActive = !1
            });
            if (a.hasData() || f) {
                a.minorTickInterval && !a.categories && o(a.getMinorTickPositions(), function(b) {
                    j[b] || (j[b] = new Sa(a, b, "minor"));
                    p && j[b].isNew && j[b].render(null, !0);
                    j[b].render(null, !1, 1)
                });
                if (g.length && (o(g, function(b, c) {
                        if (!f || b >= a.min && b <= a.max) i[b] || (i[b] = new Sa(a, b)), p && i[b].isNew && i[b].render(c, !0, 0.1), i[b].render(c)
                    }), l && (a.min === 0 || a.single))) i[-1] || (i[-1] = new Sa(a, -1, null, !0)), i[-1].render(-1);
                n && o(g, function(b, c) {
                    s = g[c + 1] !== x ? g[c + 1] +
                        l : a.max - l;
                    if (c % 2 === 0 && b < a.max && s <= a.max - l) k[b] || (k[b] = new B.PlotLineOrBand(a)), y = b + l, k[b].options = {
                        from: e ? ia(y) : y,
                        to: e ? ia(s) : s,
                        color: n
                    }, k[b].render(), k[b].isActive = !0
                });
                if (!a._addedPlotLB) o((d.plotLines || []).concat(d.plotBands || []), function(b) {
                    a.addPlotBandOrLine(b)
                }), a._addedPlotLB = !0
            }
            o([i, j, k], function(a) {
                var c, d, e = [],
                    f = v ? v.duration || 500 : 0,
                    g = function() {
                        for (d = e.length; d--;) a[e[d]] && !a[e[d]].isActive && (a[e[d]].destroy(), delete a[e[d]])
                    };
                for (c in a)
                    if (!a[c].isActive) a[c].render(c, !1, 0), a[c].isActive = !1, e.push(c);
                a === k || !b.hasRendered || !f ? g() : f && setTimeout(g, f)
            });
            if (u) r = a.getLinePath(u), a.axisLine ? a.axisLine.animate({
                d: r
            }) : a.axisLine = c.path(r).attr({
                stroke: d.lineColor,
                "stroke-width": u,
                zIndex: 7
            }).add(a.axisGroup), a.axisLine[A ? "show" : "hide"]();
            if (h && A) h[h.isNew ? "attr" : "animate"](a.getTitlePosition()), h.isNew = !1;
            m && m.enabled && a.renderStackTotals();
            a.isDirty = !1
        },
        redraw: function() {
            this.visible && (this.render(), o(this.plotLinesAndBands, function(a) {
                a.render()
            }));
            o(this.series, function(a) {
                a.isDirty = !0
            })
        },
        destroy: function(a) {
            var b = this,
                c = b.stacks,
                d, e = b.plotLinesAndBands;
            a || Y(b);
            for (d in c) Pa(c[d]), c[d] = null;
            o([b.ticks, b.minorTicks, b.alternateBands], function(a) {
                Pa(a)
            });
            for (a = e.length; a--;) e[a].destroy();
            o("stackTotalGroup,axisLine,axisTitle,axisGroup,cross,gridGroup,labelGroup".split(","), function(a) {
                b[a] && (b[a] = b[a].destroy())
            });
            this.cross && this.cross.destroy()
        },
        drawCrosshair: function(a, b) {
            var c, d = this.crosshair,
                e = d.animation;
            if (!this.crosshair || (q(b) || !p(this.crosshair.snap, !0)) === !1 || b && b.series && b.series[this.coll] !== this) this.hideCrosshair();
            else if (p(d.snap, !0) ? q(b) && (c = this.isXAxis ? b.plotX : this.len - b.plotY) : c = this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos, c = this.isRadial ? this.getPlotLinePath(this.isXAxis ? b.x : p(b.stackY, b.y)) || null : this.getPlotLinePath(null, null, null, null, c) || null, c === null) this.hideCrosshair();
            else if (this.cross) this.cross.attr({
                visibility: "visible"
            })[e ? "animate" : "attr"]({
                d: c
            }, e);
            else {
                e = this.categories && !this.isRadial;
                e = {
                    "stroke-width": d.width || (e ? this.transA : 1),
                    stroke: d.color || (e ? "rgba(155,200,255,0.2)" : "#C0C0C0"),
                    zIndex: d.zIndex || 2
                };
                if (d.dashStyle) e.dashstyle = d.dashStyle;
                this.cross = this.chart.renderer.path(c).attr(e).add()
            }
        },
        hideCrosshair: function() {
            this.cross && this.cross.hide()
        }
    };
    t(ha.prototype, {
        getPlotBandPath: function(a, b) {
            var c = this.getPlotLinePath(b, null, null, !0),
                d = this.getPlotLinePath(a, null, null, !0);
            d && c && d.toString() !== c.toString() ? d.push(c[4], c[5], c[1], c[2]) : d = null;
            return d
        },
        addPlotBand: function(a) {
            return this.addPlotBandOrLine(a, "plotBands")
        },
        addPlotLine: function(a) {
            return this.addPlotBandOrLine(a, "plotLines")
        },
        addPlotBandOrLine: function(a, b) {
            var c = (new B.PlotLineOrBand(this, a)).render(),
                d = this.userOptions;
            c && (b && (d[b] = d[b] || [], d[b].push(a)), this.plotLinesAndBands.push(c));
            return c
        },
        removePlotBandOrLine: function(a) {
            for (var b = this.plotLinesAndBands, c = this.options, d = this.userOptions, e = b.length; e--;) b[e].id === a && b[e].destroy();
            o([c.plotLines || [], d.plotLines || [], c.plotBands || [], d.plotBands || []], function(b) {
                for (e = b.length; e--;) b[e].id === a && ja(b, b[e])
            })
        }
    });
    ha.prototype.getTimeTicks = function(a, b, c, d) {
        var e = [],
            f = {},
            g = S.global.useUTC,
            h, i = new ya(b - Wa(b)),
            j = a.unitRange,
            k = a.count;
        if (q(b)) {
            i[Db](j >= F.second ? 0 : k * T(i.getMilliseconds() / k));
            if (j >= F.second) i[Eb](j >= F.minute ? 0 : k * T(i.getSeconds() / k));
            if (j >= F.minute) i[Fb](j >= F.hour ? 0 : k * T(i[rb]() / k));
            if (j >= F.hour) i[Gb](j >= F.day ? 0 : k * T(i[sb]() / k));
            if (j >= F.day) i[ub](j >= F.month ? 1 : k * T(i[Xa]() / k));
            j >= F.month && (i[vb](j >= F.year ? 0 : k * T(i[Ya]() / k)), h = i[Za]());
            j >= F.year && (h -= h % k, i[wb](h));
            if (j === F.week) i[ub](i[Xa]() -
                i[tb]() + p(d, 1));
            b = 1;
            if (nb || db) i = i.getTime(), i = new ya(i + Wa(i));
            h = i[Za]();
            for (var d = i.getTime(), m = i[Ya](), n = i[Xa](), l = (F.day + (g ? Wa(i) : i.getTimezoneOffset() * 6E4)) % F.day; d < c;) e.push(d), j === F.year ? d = fb(h + b * k, 0) : j === F.month ? d = fb(h, m + b * k) : !g && (j === F.day || j === F.week) ? d = fb(h, m, n + b * k * (j === F.day ? 1 : 7)) : d += j * k, b++;
            e.push(d);
            o(kb(e, function(a) {
                return j <= F.hour && a % F.day === l
            }), function(a) {
                f[a] = "day"
            })
        }
        e.info = t(a, {
            higherRanks: f,
            totalRange: j * k
        });
        return e
    };
    ha.prototype.normalizeTimeTickInterval = function(a, b) {
        var c = b || [
                ["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]],
                ["second", [1, 2, 5, 10, 15, 30]],
                ["minute", [1, 2, 5, 10, 15, 30]],
                ["hour", [1, 2, 3, 4, 6, 8, 12]],
                ["day", [1, 2]],
                ["week", [1, 2]],
                ["month", [1, 2, 3, 4, 6]],
                ["year", null]
            ],
            d = c[c.length - 1],
            e = F[d[0]],
            f = d[1],
            g;
        for (g = 0; g < c.length; g++)
            if (d = c[g], e = F[d[0]], f = d[1], c[g + 1] && a <= (e * f[f.length - 1] + F[c[g + 1][0]]) / 2) break;
        e === F.year && a < 5 * e && (f = [1, 2, 5]);
        c = pb(a / e, f, d[0] === "year" ? s(ob(a / e), 1) : 1);
        return {
            unitRange: e,
            count: c,
            unitName: d[0]
        }
    };
    ha.prototype.getLogTickPositions = function(a, b, c, d) {
        var e = this.options,
            f = this.len,
            g = [];
        if (!d) this._minorAutoInterval = null;
        if (a >= 0.5) a = w(a), g = this.getLinearTickPositions(a, b, c);
        else if (a >= 0.08)
            for (var f = T(b), h, i, j, k, m, e = a > 0.3 ? [1, 2, 4] : a > 0.15 ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; f < c + 1 && !m; f++) {
                i = e.length;
                for (h = 0; h < i && !m; h++) j = Ca(ia(f) * e[h]), j > b && (!d || k <= c) && k !== x && g.push(k), k > c && (m = !0), k = j
            } else if (b = ia(b), c = ia(c), a = e[d ? "minorTickInterval" : "tickInterval"], a = p(a === "auto" ? null : a, this._minorAutoInterval, (c - b) * (e.tickPixelInterval / (d ? 5 : 1)) / ((d ? f / this.tickPositions.length : f) || 1)), a = pb(a, null, ob(a)), g = Ua(this.getLinearTickPositions(a, b, c), Ca), !d) this._minorAutoInterval = a / 5;
        if (!d) this.tickInterval = a;
        return g
    };
    var Mb = B.Tooltip = function() {
        this.init.apply(this, arguments)
    };
    Mb.prototype = {
        init: function(a, b) {
            var c = b.borderWidth,
                d = b.style,
                e = G(d.padding);
            this.chart = a;
            this.options = b;
            this.crosshairs = [];
            this.now = {
                x: 0,
                y: 0
            };
            this.isHidden = !0;
            this.label = a.renderer.label("", 0, 0, b.shape || "callout", null, null, b.useHTML, null, "tooltip").attr({
                padding: e,
                fill: b.backgroundColor,
                "stroke-width": c,
                r: b.borderRadius,
                zIndex: 8
            }).css(d).css({
                padding: 0
            }).add().attr({
                y: -9999
            });
            fa || this.label.shadow(b.shadow);
            this.shared = b.shared
        },
        destroy: function() {
            if (this.label) this.label = this.label.destroy();
            clearTimeout(this.hideTimer);
            clearTimeout(this.tooltipTimeout)
        },
        move: function(a, b, c, d) {
            var e = this,
                f = e.now,
                g = e.options.animation !== !1 && !e.isHidden && (O(a - f.x) > 1 || O(b - f.y) > 1),
                h = e.followPointer || e.len > 1;
            t(f, {
                x: g ? (2 * f.x + a) / 3 : a,
                y: g ? (f.y + b) / 2 : b,
                anchorX: h ? x : g ? (2 * f.anchorX + c) / 3 : c,
                anchorY: h ? x : g ? (f.anchorY + d) / 2 : d
            });
            e.label.attr(f);
            if (g) clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function() {
                e && e.move(a, b, c, d)
            }, 32)
        },
        hide: function(a) {
            var b = this;
            clearTimeout(this.hideTimer);
            if (!this.isHidden) this.hideTimer = setTimeout(function() {
                b.label.fadeOut();
                b.isHidden = !0
            }, p(a, this.options.hideDelay, 500))
        },
        getAnchor: function(a, b) {
            var c, d = this.chart,
                e = d.inverted,
                f = d.plotTop,
                g = d.plotLeft,
                h = 0,
                i = 0,
                j, k, a = ra(a);
            c = a[0].tooltipPos;
            this.followPointer && b && (b.chartX === x && (b = d.pointer.normalize(b)), c = [b.chartX - d.plotLeft, b.chartY -
                f
            ]);
            c || (o(a, function(a) {
                j = a.series.yAxis;
                k = a.series.xAxis;
                h += a.plotX + (!e && k ? k.left - g : 0);
                i += (a.plotLow ? (a.plotLow + a.plotHigh) / 2 : a.plotY) + (!e && j ? j.top - f : 0)
            }), h /= a.length, i /= a.length, c = [e ? d.plotWidth - i : h, this.shared && !e && a.length > 1 && b ? b.chartY - f : e ? d.plotHeight - h : i]);
            return Ua(c, w)
        },
        getPosition: function(a, b, c) {
            var d = this.chart,
                e = this.distance,
                f = {},
                g = c.h || 0,
                h, i = ["y", d.chartHeight, b, c.plotY + d.plotTop, d.plotTop, d.plotTop + d.plotHeight],
                j = ["x", d.chartWidth, a, c.plotX + d.plotLeft, d.plotLeft, d.plotLeft + d.plotWidth],
                k = p(c.ttBelow, d.inverted && !c.negative || !d.inverted && c.negative),
                m = function(a, b, c, d, h, i) {
                    var j = c < d - e,
                        n = d + e + c < b,
                        m = d - e - c;
                    d += e;
                    if (k && n) f[a] = d;
                    else if (!k && j) f[a] = m;
                    else if (j) f[a] = z(i - c, m - g < 0 ? m : m - g);
                    else if (n) f[a] = s(h, d + g + c > b ? d : d + g);
                    else return !1
                },
                n = function(a, b, c, d) {
                    if (d < e || d > b - e) return !1;
                    else f[a] = d < c / 2 ? 1 : d > b - c / 2 ? b - c - 2 : d - c / 2
                },
                l = function(a) {
                    var b = i;
                    i = j;
                    j = b;
                    h = a
                },
                u = function() {
                    m.apply(0, i) !== !1 ? n.apply(0, j) === !1 && !h && (l(!0), u()) : h ? f.x = f.y = 0 : (l(!0), u())
                };
            (d.inverted || this.len > 1) && l();
            u();
            return f
        },
        defaultFormatter: function(a) {
            var b = this.points || ra(this),
                c;
            c = [a.tooltipFooterHeaderFormatter(b[0])];
            c = c.concat(a.bodyFormatter(b));
            c.push(a.tooltipFooterHeaderFormatter(b[0], !0));
            return c.join("")
        },
        refresh: function(a, b) {
            var c = this.chart,
                d = this.label,
                e = this.options,
                f, g, h, i = {},
                j, k = [];
            j = e.formatter || this.defaultFormatter;
            var i = c.hoverPoints,
                m, n = this.shared;
            clearTimeout(this.hideTimer);
            this.followPointer = ra(a)[0].series.tooltipOptions.followPointer;
            h = this.getAnchor(a, b);
            f = h[0];
            g = h[1];
            n && (!a.series || !a.series.noSharedTooltip) ? (c.hoverPoints = a, i && o(i, function(a) {
                a.setState()
            }), o(a, function(a) {
                a.setState("hover");
                k.push(a.getLabelConfig())
            }), i = {
                x: a[0].category,
                y: a[0].y
            }, i.points = k, this.len = k.length, a = a[0]) : i = a.getLabelConfig();
            j = j.call(i, this);
            i = a.series;
            this.distance = p(i.tooltipOptions.distance, 16);
            j === !1 ? this.hide() : (this.isHidden && (cb(d), d.attr("opacity", 1).show()), d.attr({
                text: j
            }), m = e.borderColor || a.color || i.color || "#606060", d.attr({
                stroke: m
            }), this.updatePosition({
                plotX: f,
                plotY: g,
                negative: a.negative,
                ttBelow: a.ttBelow,
                h: h[2] || 0
            }), this.isHidden = !1);
            J(c, "tooltipRefresh", {
                text: j,
                x: f + c.plotLeft,
                y: g + c.plotTop,
                borderColor: m
            })
        },
        updatePosition: function(a) {
            var b = this.chart,
                c = this.label,
                c = (this.options.positioner || this.getPosition).call(this, c.width, c.height, a);
            this.move(w(c.x), w(c.y || 0), a.plotX + b.plotLeft, a.plotY + b.plotTop)
        },
        getXDateFormat: function(a, b, c) {
            var d, b = b.dateTimeLabelFormats,
                e = c && c.closestPointRange,
                f, g = {
                    millisecond: 15,
                    second: 12,
                    minute: 9,
                    hour: 6,
                    day: 3
                },
                h, i = "millisecond";
            if (e) {
                h = Na("%m-%d %H:%M:%S.%L", a.x);
                for (f in F) {
                    if (e === F.week && +Na("%w", a.x) === c.options.startOfWeek && h.substr(6) === "00:00:00.000") {
                        f = "week";
                        break
                    } else if (F[f] > e) {
                        f = i;
                        break
                    } else if (g[f] && h.substr(g[f]) !== "01-01 00:00:00.000".substr(g[f])) break;
                    f !== "week" && (i = f)
                }
                f && (d = b[f])
            } else d = b.day;
            return d || b.year
        },
        tooltipFooterHeaderFormatter: function(a, b) {
            var c = b ? "footer" : "header",
                d = a.series,
                e = d.tooltipOptions,
                f = e.xDateFormat,
                g = d.xAxis,
                h = g && g.options.type === "datetime" && qa(a.key),
                c = e[c + "Format"];
            h && !f && (f = this.getXDateFormat(a, e, g));
            h && f && (c = c.replace("{point.key}", "{point.key:" +
                f + "}"));
            return Ia(c, {
                point: a,
                series: d
            })
        },
        bodyFormatter: function(a) {
            return Ua(a, function(a) {
                var c = a.series.tooltipOptions;
                return (c.pointFormatter || a.point.tooltipFormatter).call(a.point, c.pointFormat)
            })
        }
    };
    var oa;
    ab = C.documentElement.ontouchstart !== x;
    var Va = B.Pointer = function(a, b) {
        this.init(a, b)
    };
    Va.prototype = {
        init: function(a, b) {
            var c = b.chart,
                d = c.events,
                e = fa ? "" : c.zoomType,
                c = a.inverted,
                f;
            this.options = b;
            this.chart = a;
            this.zoomX = f = /x/.test(e);
            this.zoomY = e = /y/.test(e);
            this.zoomHor = f && !c || e && c;
            this.zoomVert = e && !c || f && c;
            this.hasZoom = f || e;
            this.runChartClick = d && !!d.click;
            this.pinchDown = [];
            this.lastValidTouch = {};
            if (B.Tooltip && b.tooltip.enabled) a.tooltip = new Mb(a, b.tooltip), this.followTouchMove = p(b.tooltip.followTouchMove, !0);
            this.setDOMEvents()
        },
        normalize: function(a, b) {
            var c, d, a = a || window.event,
                a = Sb(a);
            if (!a.target) a.target = a.srcElement;
            d = a.touches ? a.touches.length ? a.touches.item(0) : a.changedTouches[0] : a;
            if (!b) this.chartPosition = b = Rb(this.chart.container);
            d.pageX === x ? (c = s(a.x, a.clientX - b.left), d = a.y) : (c = d.pageX - b.left, d = d.pageY - b.top);
            return t(a, {
                chartX: w(c),
                chartY: w(d)
            })
        },
        getCoordinates: function(a) {
            var b = {
                xAxis: [],
                yAxis: []
            };
            o(this.chart.axes, function(c) {
                b[c.isXAxis ? "xAxis" : "yAxis"].push({
                    axis: c,
                    value: c.toValue(a[c.horiz ? "chartX" : "chartY"])
                })
            });
            return b
        },
        runPointActions: function(a) {
            var b = this.chart,
                c = b.series,
                d = b.tooltip,
                e = d ? d.shared : !1,
                f = b.hoverPoint,
                g = b.hoverSeries,
                h, i = Number.MAX_VALUE,
                j, k, m = [],
                n, l;
            if (!e && !g)
                for (h = 0; h < c.length; h++)
                    if (c[h].directTouch || !c[h].options.stickyTracking) c = [];
            g && (e ? g.noSharedTooltip : g.directTouch) && f ? n = f : (o(c, function(b) {
                j = b.noSharedTooltip && e;
                k = !e && b.directTouch;
                b.visible && !j && !k && p(b.options.enableMouseTracking, !0) && (l = b.searchPoint(a, !j && b.kdDimensions === 1)) && m.push(l)
            }), o(m, function(a) {
                if (a && typeof a.dist === "number" && a.dist < i) i = a.dist, n = a
            }));
            if (n && (n !== this.prevKDPoint || d && d.isHidden)) {
                if (e && !n.series.noSharedTooltip) {
                    for (h = m.length; h--;)(m[h].clientX !== n.clientX || m[h].series.noSharedTooltip) && m.splice(h, 1);
                    m.length && d && d.refresh(m, a);
                    o(m, function(b) {
                        b.onMouseOver(a, b !== (g && g.directTouch && f || n))
                    })
                } else if (d && d.refresh(n, a), !g || !g.directTouch) n.onMouseOver(a);
                this.prevKDPoint = n
            } else c = g && g.tooltipOptions.followPointer, d && c && !d.isHidden && (c = d.getAnchor([{}], a), d.updatePosition({
                plotX: c[0],
                plotY: c[1]
            }));
            if (d && !this._onDocumentMouseMove) this._onDocumentMouseMove = function(a) {
                if (X[oa]) X[oa].pointer.onDocumentMouseMove(a)
            }, I(C, "mousemove", this._onDocumentMouseMove);
            o(b.axes, function(b) {
                b.drawCrosshair(a, p(n, f))
            })
        },
        reset: function(a, b) {
            var c = this.chart,
                d = c.hoverSeries,
                e = c.hoverPoint,
                f = c.hoverPoints,
                g = c.tooltip,
                h = g && g.shared ? f : e;
            (a = a && g && h) && ra(h)[0].plotX === x && (a = !1);
            if (a) g.refresh(h), e && (e.setState(e.state, !0), o(c.axes, function(a) {
                p(a.options.crosshair && a.options.crosshair.snap, !0) ? a.drawCrosshair(null, e) : a.hideCrosshair()
            }));
            else {
                if (e) e.onMouseOut();
                f && o(f, function(a) {
                    a.setState()
                });
                if (d) d.onMouseOut();
                g && g.hide(b);
                if (this._onDocumentMouseMove) Y(C, "mousemove", this._onDocumentMouseMove), this._onDocumentMouseMove = null;
                o(c.axes, function(a) {
                    a.hideCrosshair()
                });
                this.hoverX = c.hoverPoints = c.hoverPoint = null
            }
        },
        scaleGroups: function(a, b) {
            var c = this.chart,
                d;
            o(c.series, function(e) {
                d = a || e.getPlotBox();
                e.xAxis && e.xAxis.zoomEnabled && (e.group.attr(d), e.markerGroup && (e.markerGroup.attr(d), e.markerGroup.clip(b ? c.clipRect : null)), e.dataLabelsGroup && e.dataLabelsGroup.attr(d))
            });
            c.clipRect.attr(b || c.clipBox)
        },
        dragStart: function(a) {
            var b = this.chart;
            b.mouseIsDown = a.type;
            b.cancelClick = !1;
            b.mouseDownX = this.mouseDownX = a.chartX;
            b.mouseDownY = this.mouseDownY = a.chartY
        },
        drag: function(a) {
            var b = this.chart,
                c = b.options.chart,
                d = a.chartX,
                e = a.chartY,
                f = this.zoomHor,
                g = this.zoomVert,
                h = b.plotLeft,
                i = b.plotTop,
                j = b.plotWidth,
                k = b.plotHeight,
                m, n = this.selectionMarker,
                l = this.mouseDownX,
                u = this.mouseDownY,
                r = c.panKey && a[c.panKey + "Key"];
            if (!n || !n.touch)
                if (d < h ? d = h : d > h + j && (d = h + j), e < i ? e = i : e > i + k && (e = i + k), this.hasDragged = Math.sqrt(Math.pow(l - d, 2) + Math.pow(u - e, 2)), this.hasDragged > 10) {
                    m = b.isInsidePlot(l - h, u - i);
                    if (b.hasCartesianSeries && (this.zoomX || this.zoomY) && m && !r && !n) this.selectionMarker = n = b.renderer.rect(h, i, f ? 1 : j, g ? 1 : k, 0).attr({
                        fill: c.selectionMarkerFill || "rgba(69,114,167,0.25)",
                        zIndex: 7
                    }).add();
                    n && f && (d -= l, n.attr({
                        width: O(d),
                        x: (d > 0 ? 0 : d) + l
                    }));
                    n && g && (d = e - u, n.attr({
                        height: O(d),
                        y: (d > 0 ? 0 : d) + u
                    }));
                    m && !n && c.panning && b.pan(a, c.panning)
                }
        },
        drop: function(a) {
            var b = this,
                c = this.chart,
                d = this.hasPinched;
            if (this.selectionMarker) {
                var e = {
                        xAxis: [],
                        yAxis: [],
                        originalEvent: a.originalEvent || a
                    },
                    f = this.selectionMarker,
                    g = f.attr ? f.attr("x") : f.x,
                    h = f.attr ? f.attr("y") : f.y,
                    i = f.attr ? f.attr("width") : f.width,
                    j = f.attr ? f.attr("height") : f.height,
                    k;
                if (this.hasDragged || d) o(c.axes, function(c) {
                    if (c.zoomEnabled && q(c.min) && (d || b[{
                            xAxis: "zoomX",
                            yAxis: "zoomY"
                        }[c.coll]])) {
                        var f = c.horiz,
                            l = a.type === "touchend" ? c.minPixelPadding : 0,
                            u = c.toValue((f ? g : h) + l),
                            f = c.toValue((f ? g + i : h + j) - l);
                        e[c.coll].push({
                            axis: c,
                            min: z(u, f),
                            max: s(u, f)
                        });
                        k = !0
                    }
                }), k && J(c, "selection", e, function(a) {
                    c.zoom(t(a, d ? {
                        animation: !1
                    } : null))
                });
                this.selectionMarker = this.selectionMarker.destroy();
                d && this.scaleGroups()
            }
            if (c) M(c.container, {
                cursor: c._cursor
            }), c.cancelClick = this.hasDragged > 10, c.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []
        },
        onContainerMouseDown: function(a) {
            a = this.normalize(a);
            a.preventDefault && a.preventDefault();
            this.dragStart(a)
        },
        onDocumentMouseUp: function(a) {
            X[oa] && X[oa].pointer.drop(a)
        },
        onDocumentMouseMove: function(a) {
            var b = this.chart,
                c = this.chartPosition,
                a = this.normalize(a, c);
            c && !this.inClass(a.target, "highcharts-tracker") && !b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) && this.reset()
        },
        onContainerMouseLeave: function() {
            var a = X[oa];
            if (a) a.pointer.reset(), a.pointer.chartPosition = null
        },
        onContainerMouseMove: function(a) {
            var b = this.chart;
            oa = b.index;
            a = this.normalize(a);
            a.returnValue = !1;
            b.mouseIsDown === "mousedown" && this.drag(a);
            (this.inClass(a.target, "highcharts-tracker") || b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop)) && !b.openMenu && this.runPointActions(a)
        },
        inClass: function(a, b) {
            for (var c; a;) {
                if (c = K(a, "class"))
                    if (c.indexOf(b) !== -1) return !0;
                    else if (c.indexOf("highcharts-container") !== -1) return !1;
                a = a.parentNode
            }
        },
        onTrackerMouseOut: function(a) {
            var b = this.chart.hoverSeries,
                a = a.relatedTarget || a.toElement;
            if (b && !b.options.stickyTracking && !this.inClass(a, "highcharts-tooltip") && !this.inClass(a, "highcharts-series-" + b.index)) b.onMouseOut()
        },
        onContainerClick: function(a) {
            var b = this.chart,
                c = b.hoverPoint,
                d = b.plotLeft,
                e = b.plotTop,
                a = this.normalize(a);
            a.originalEvent = a;
            b.cancelClick || (c && this.inClass(a.target, "highcharts-tracker") ? (J(c.series, "click", t(a, {
                point: c
            })), b.hoverPoint && c.firePointEvent("click", a)) : (t(a, this.getCoordinates(a)), b.isInsidePlot(a.chartX -
                d, a.chartY - e) && J(b, "click", a)))
        },
        setDOMEvents: function() {
            var a = this,
                b = a.chart.container;
            b.onmousedown = function(b) {
                a.onContainerMouseDown(b)
            };
            b.onmousemove = function(b) {
                a.onContainerMouseMove(b)
            };
            b.onclick = function(b) {
                a.onContainerClick(b)
            };
            I(b, "mouseleave", a.onContainerMouseLeave);
            bb === 1 && I(C, "mouseup", a.onDocumentMouseUp);
            if (ab) b.ontouchstart = function(b) {
                a.onContainerTouchStart(b)
            }, b.ontouchmove = function(b) {
                a.onContainerTouchMove(b)
            }, bb === 1 && I(C, "touchend", a.onDocumentTouchEnd)
        },
        destroy: function() {
            var a;
            Y(this.chart.container, "mouseleave", this.onContainerMouseLeave);
            bb || (Y(C, "mouseup", this.onDocumentMouseUp), Y(C, "touchend", this.onDocumentTouchEnd));
            clearInterval(this.tooltipTimeout);
            for (a in this) this[a] = null
        }
    };
    t(B.Pointer.prototype, {
        pinchTranslate: function(a, b, c, d, e, f) {
            (this.zoomHor || this.pinchHor) && this.pinchTranslateDirection(!0, a, b, c, d, e, f);
            (this.zoomVert || this.pinchVert) && this.pinchTranslateDirection(!1, a, b, c, d, e, f)
        },
        pinchTranslateDirection: function(a, b, c, d, e, f, g, h) {
            var i = this.chart,
                j = a ? "x" : "y",
                k = a ? "X" : "Y",
                m = "chart" + k,
                n = a ? "width" : "height",
                l = i["plot" + (a ? "Left" : "Top")],
                u, r, p = h || 1,
                o = i.inverted,
                v = i.bounds[a ? "h" : "v"],
                s = b.length === 1,
                q = b[0][m],
                t = c[0][m],
                x = !s && b[1][m],
                w = !s && c[1][m],
                z, c = function() {
                    !s && O(q - x) > 20 && (p = h || O(t - w) / O(q - x));
                    r = (l - t) / p + q;
                    u = i["plot" + (a ? "Width" : "Height")] / p
                };
            c();
            b = r;
            b < v.min ? (b = v.min, z = !0) : b + u > v.max && (b = v.max - u, z = !0);
            z ? (t -= 0.8 * (t - g[j][0]), s || (w -= 0.8 * (w - g[j][1])), c()) : g[j] = [t, w];
            o || (f[j] = r - l, f[n] = u);
            f = o ? 1 / p : p;
            e[n] = u;
            e[j] = b;
            d[o ? a ? "scaleY" : "scaleX" : "scale" + k] = p;
            d["translate" +
                k] = f * l + (t - f * q)
        },
        pinch: function(a) {
            var b = this,
                c = b.chart,
                d = b.pinchDown,
                e = a.touches,
                f = e.length,
                g = b.lastValidTouch,
                h = b.hasZoom,
                i = b.selectionMarker,
                j = {},
                k = f === 1 && (b.inClass(a.target, "highcharts-tracker") && c.runTrackerClick || b.runChartClick),
                m = {};
            if (f > 1) b.initiated = !0;
            h && b.initiated && !k && a.preventDefault();
            Ua(e, function(a) {
                return b.normalize(a)
            });
            if (a.type === "touchstart") o(e, function(a, b) {
                d[b] = {
                    chartX: a.chartX,
                    chartY: a.chartY
                }
            }), g.x = [d[0].chartX, d[1] && d[1].chartX], g.y = [d[0].chartY, d[1] && d[1].chartY], o(c.axes, function(a) {
                if (a.zoomEnabled) {
                    var b = c.bounds[a.horiz ? "h" : "v"],
                        d = a.minPixelPadding,
                        e = a.toPixels(p(a.options.min, a.dataMin)),
                        f = a.toPixels(p(a.options.max, a.dataMax)),
                        g = z(e, f),
                        e = s(e, f);
                    b.min = z(a.pos, g - d);
                    b.max = s(a.pos + a.len, e + d)
                }
            }), b.res = !0;
            else if (d.length) {
                if (!i) b.selectionMarker = i = t({
                    destroy: ua,
                    touch: !0
                }, c.plotBox);
                b.pinchTranslate(d, e, j, i, m, g);
                b.hasPinched = h;
                b.scaleGroups(j, m);
                if (!h && b.followTouchMove && f === 1) this.runPointActions(b.normalize(a));
                else if (b.res) b.res = !1, this.reset(!1, 0)
            }
        },
        touch: function(a, b) {
            var c = this.chart;
            oa = c.index;
            a.touches.length === 1 ? (a = this.normalize(a), c.isInsidePlot(a.chartX - c.plotLeft, a.chartY - c.plotTop) && !c.openMenu ? (b && this.runPointActions(a), this.pinch(a)) : b && this.reset()) : a.touches.length === 2 && this.pinch(a)
        },
        onContainerTouchStart: function(a) {
            this.touch(a, !0)
        },
        onContainerTouchMove: function(a) {
            this.touch(a)
        },
        onDocumentTouchEnd: function(a) {
            X[oa] && X[oa].pointer.drop(a)
        }
    });
    if (L.PointerEvent || L.MSPointerEvent) {
        var wa = {},
            Ab = !!L.PointerEvent,
            Wb = function() {
                var a, b = [];
                b.item = function(a) {
                    return this[a]
                };
                for (a in wa) wa.hasOwnProperty(a) && b.push({
                    pageX: wa[a].pageX,
                    pageY: wa[a].pageY,
                    target: wa[a].target
                });
                return b
            },
            Bb = function(a, b, c, d) {
                a = a.originalEvent || a;
                if ((a.pointerType === "touch" || a.pointerType === a.MSPOINTER_TYPE_TOUCH) && X[oa]) d(a), d = X[oa].pointer, d[b]({
                    type: c,
                    target: a.currentTarget,
                    preventDefault: ua,
                    touches: Wb()
                })
            };
        t(Va.prototype, {
            onContainerPointerDown: function(a) {
                Bb(a, "onContainerTouchStart", "touchstart", function(a) {
                    wa[a.pointerId] = {
                        pageX: a.pageX,
                        pageY: a.pageY,
                        target: a.currentTarget
                    }
                })
            },
            onContainerPointerMove: function(a) {
                Bb(a, "onContainerTouchMove", "touchmove", function(a) {
                    wa[a.pointerId] = {
                        pageX: a.pageX,
                        pageY: a.pageY
                    };
                    if (!wa[a.pointerId].target) wa[a.pointerId].target = a.currentTarget
                })
            },
            onDocumentPointerUp: function(a) {
                Bb(a, "onDocumentTouchEnd", "touchend", function(a) {
                    delete wa[a.pointerId]
                })
            },
            batchMSEvents: function(a) {
                a(this.chart.container, Ab ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
                a(this.chart.container, Ab ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
                a(C, Ab ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp)
            }
        });
        Ta(Va.prototype, "init", function(a, b, c) {
            a.call(this, b, c);
            this.hasZoom && M(b.container, {
                "-ms-touch-action": P,
                "touch-action": P
            })
        });
        Ta(Va.prototype, "setDOMEvents", function(a) {
            a.apply(this);
            (this.hasZoom || this.followTouchMove) && this.batchMSEvents(I)
        });
        Ta(Va.prototype, "destroy", function(a) {
            this.batchMSEvents(Y);
            a.call(this)
        })
    }
    var mb = B.Legend = function(a, b) {
        this.init(a, b)
    };
    mb.prototype = {
        init: function(a, b) {
            var c = this,
                d = b.itemStyle,
                e = b.itemMarginTop || 0;
            this.options = b;
            if (b.enabled) c.itemStyle = d, c.itemHiddenStyle = D(d, b.itemHiddenStyle), c.itemMarginTop = e, c.padding = d = p(b.padding, 8), c.initialItemX = d, c.initialItemY = d - 5, c.maxItemWidth = 0, c.chart = a, c.itemHeight = 0, c.symbolWidth = p(b.symbolWidth, 16), c.pages = [], c.render(), I(c.chart, "endResize", function() {
                c.positionCheckboxes()
            })
        },
        colorizeItem: function(a, b) {
            var c = this.options,
                d = a.legendItem,
                e = a.legendLine,
                f = a.legendSymbol,
                g = this.itemHiddenStyle.color,
                c = b ? c.itemStyle.color : g,
                h = b ? a.legendColor || a.color || "#CCC" : g,
                g = a.options && a.options.marker,
                i = {
                    fill: h
                },
                j;
            d && d.css({
                fill: c,
                color: c
            });
            e && e.attr({
                stroke: h
            });
            if (f) {
                if (g && f.isMarker)
                    for (j in i.stroke = h, g = a.convertAttribs(g), g) d = g[j], d !== x && (i[j] = d);
                f.attr(i)
            }
        },
        positionItem: function(a) {
            var b = this.options,
                c = b.symbolPadding,
                b = !b.rtl,
                d = a._legendItemPos,
                e = d[0],
                d = d[1],
                f = a.checkbox;
            (a = a.legendGroup) && a.element && a.translate(b ? e : this.legendWidth - e - 2 * c - 4, d);
            if (f) f.x = e, f.y = d
        },
        destroyItem: function(a) {
            var b = a.checkbox;
            o(["legendItem", "legendLine", "legendSymbol", "legendGroup"], function(b) {
                a[b] && (a[b] = a[b].destroy())
            });
            b && Qa(a.checkbox)
        },
        destroy: function() {
            var a = this.group,
                b = this.box;
            if (b) this.box = b.destroy();
            if (a) this.group = a.destroy()
        },
        positionCheckboxes: function(a) {
            var b = this.group.alignAttr,
                c, d = this.clipHeight || this.legendHeight;
            if (b) c = b.translateY, o(this.allItems, function(e) {
                var f = e.checkbox,
                    g;
                f && (g = c + f.y + (a || 0) + 3, M(f, {
                    left: b.translateX + e.checkboxOffset + f.x - 20 + "px",
                    top: g + "px",
                    display: g > c - 6 && g < c + d - 6 ? "" : P
                }))
            })
        },
        renderTitle: function() {
            var a = this.padding,
                b = this.options.title,
                c = 0;
            if (b.text) {
                if (!this.title) this.title = this.chart.renderer.label(b.text, a - 3, a - 4, null, null, null, null, null, "legend-title").attr({
                    zIndex: 1
                }).css(b.style).add(this.group);
                a = this.title.getBBox();
                c = a.height;
                this.offsetWidth = a.width;
                this.contentGroup.attr({
                    translateY: c
                })
            }
            this.titleHeight = c
        },
        setText: function(a) {
            var b = this.options;
            a.legendItem.attr({
                text: b.labelFormat ? Ia(b.labelFormat, a) : b.labelFormatter.call(a)
            })
        },
        renderItem: function(a) {
            var b = this.chart,
                c = b.renderer,
                d = this.options,
                e = d.layout === "horizontal",
                f = this.symbolWidth,
                g = d.symbolPadding,
                h = this.itemStyle,
                i = this.itemHiddenStyle,
                j = this.padding,
                k = e ? p(d.itemDistance, 20) : 0,
                m = !d.rtl,
                n = d.width,
                l = d.itemMarginBottom || 0,
                u = this.itemMarginTop,
                r = this.initialItemX,
                o = a.legendItem,
                A = a.series && a.series.drawLegendSymbol ? a.series : a,
                v = A.options,
                v = this.createCheckboxForItem && v && v.showCheckbox,
                q = d.useHTML;
            if (!o) {
                a.legendGroup = c.g("legend-item").attr({
                    zIndex: 1
                }).add(this.scrollGroup);
                a.legendItem = o = c.text("", m ? f + g : -g, this.baseline || 0, q).css(D(a.visible ? h : i)).attr({
                    align: m ? "left" : "right",
                    zIndex: 2
                }).add(a.legendGroup);
                if (!this.baseline) this.fontMetrics = c.fontMetrics(h.fontSize, o), this.baseline = this.fontMetrics.f + 3 + u, o.attr("y", this.baseline);
                A.drawLegendSymbol(this, a);
                this.setItemEvents && this.setItemEvents(a, o, q, h, i);
                this.colorizeItem(a, a.visible);
                v && this.createCheckboxForItem(a)
            }
            this.setText(a);
            c = o.getBBox();
            f = a.checkboxOffset = d.itemWidth || a.legendItemWidth || f + g + c.width + k + (v ? 20 : 0);
            this.itemHeight = g = w(a.legendItemHeight || c.height);
            if (e && this.itemX - r + f > (n || b.chartWidth - 2 * j - r - d.x)) this.itemX = r, this.itemY += u + this.lastLineHeight + l, this.lastLineHeight = 0;
            this.maxItemWidth = s(this.maxItemWidth, f);
            this.lastItemY = u + this.itemY + l;
            this.lastLineHeight = s(g, this.lastLineHeight);
            a._legendItemPos = [this.itemX, this.itemY];
            e ? this.itemX += f : (this.itemY += u + g + l, this.lastLineHeight = g);
            this.offsetWidth = n || s((e ? this.itemX - r - k : f) + j, this.offsetWidth)
        },
        getAllItems: function() {
            var a = [];
            o(this.chart.series, function(b) {
                var c = b.options;
                if (p(c.showInLegend, !q(c.linkedTo) ? x : !1, !0)) a = a.concat(b.legendItems || (c.legendType === "point" ? b.data : b))
            });
            return a
        },
        adjustMargins: function(a, b) {
            var c = this.chart,
                d = this.options,
                e = d.align.charAt(0) + d.verticalAlign.charAt(0) + d.layout.charAt(0);
            this.display && !d.floating && o([/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/], function(f, g) {
                f.test(e) && !q(a[g]) && (c[ib[g]] = s(c[ib[g]], c.legend[(g + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][g] * d[g % 2 ? "x" : "y"] + p(d.margin, 12) + b[g]))
            })
        },
        render: function() {
            var a = this,
                b = a.chart,
                c = b.renderer,
                d = a.group,
                e, f, g, h, i = a.box,
                j = a.options,
                k = a.padding,
                m = j.borderWidth,
                n = j.backgroundColor;
            a.itemX = a.initialItemX;
            a.itemY = a.initialItemY;
            a.offsetWidth = 0;
            a.lastItemY = 0;
            if (!d) a.group = d = c.g("legend").attr({
                zIndex: 7
            }).add(), a.contentGroup = c.g().attr({
                zIndex: 1
            }).add(d), a.scrollGroup = c.g().add(a.contentGroup);
            a.renderTitle();
            e = a.getAllItems();
            qb(e, function(a, b) {
                return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0)
            });
            j.reversed && e.reverse();
            a.allItems = e;
            a.display = f = !!e.length;
            a.lastLineHeight = 0;
            o(e, function(b) {
                a.renderItem(b)
            });
            g = (j.width || a.offsetWidth) + k;
            h = a.lastItemY + a.lastLineHeight +
                a.titleHeight;
            h = a.handleOverflow(h);
            h += k;
            if (m || n) {
                if (i) {
                    if (g > 0 && h > 0) i[i.isNew ? "attr" : "animate"](i.crisp({
                        width: g,
                        height: h
                    })), i.isNew = !1
                } else a.box = i = c.rect(0, 0, g, h, j.borderRadius, m || 0).attr({
                    stroke: j.borderColor,
                    "stroke-width": m || 0,
                    fill: n || P
                }).add(d).shadow(j.shadow), i.isNew = !0;
                i[f ? "show" : "hide"]()
            }
            a.legendWidth = g;
            a.legendHeight = h;
            o(e, function(b) {
                a.positionItem(b)
            });
            f && d.align(t({
                width: g,
                height: h
            }, j), !0, "spacingBox");
            b.isResizing || this.positionCheckboxes()
        },
        handleOverflow: function(a) {
            var b = this,
                c = this.chart,
                d = c.renderer,
                e = this.options,
                f = e.y,
                f = c.spacingBox.height + (e.verticalAlign === "top" ? -f : f) - this.padding,
                g = e.maxHeight,
                h, i = this.clipRect,
                j = e.navigation,
                k = p(j.animation, !0),
                m = j.arrowSize || 12,
                n = this.nav,
                l = this.pages,
                u = this.padding,
                r, q = this.allItems,
                A = function(a) {
                    i.attr({
                        height: a
                    });
                    if (b.contentGroup.div) b.contentGroup.div.style.clip = "rect(" + u + "px,9999px," + (u + a) + "px,0)"
                };
            e.layout === "horizontal" && (f /= 2);
            g && (f = z(f, g));
            l.length = 0;
            if (a > f) {
                this.clipHeight = h = s(f - 20 - this.titleHeight - u, 0);
                this.currentPage = p(this.currentPage, 1);
                this.fullHeight = a;
                o(q, function(a, b) {
                    var c = a._legendItemPos[1],
                        d = w(a.legendItem.getBBox().height),
                        e = l.length;
                    if (!e || c - l[e - 1] > h && (r || c) !== l[e - 1]) l.push(r || c), e++;
                    b === q.length - 1 && c + d - l[e - 1] > h && l.push(c);
                    c !== r && (r = c)
                });
                if (!i) i = b.clipRect = d.clipRect(0, u, 9999, 0), b.contentGroup.clip(i);
                A(h);
                if (!n) this.nav = n = d.g().attr({
                    zIndex: 1
                }).add(this.group), this.up = d.symbol("triangle", 0, 0, m, m).on("click", function() {
                    b.scroll(-1, k)
                }).add(n), this.pager = d.text("", 15, 10).css(j.style).add(n), this.down = d.symbol("triangle-down", 0, 0, m, m).on("click", function() {
                    b.scroll(1, k)
                }).add(n);
                b.scroll(0);
                a = f
            } else if (n) A(c.chartHeight), n.hide(), this.scrollGroup.attr({
                translateY: 1
            }), this.clipHeight = 0;
            return a
        },
        scroll: function(a, b) {
            var c = this.pages,
                d = c.length,
                e = this.currentPage + a,
                f = this.clipHeight,
                g = this.options.navigation,
                h = g.activeColor,
                g = g.inactiveColor,
                i = this.pager,
                j = this.padding;
            e > d && (e = d);
            if (e > 0) b !== x && Ra(b, this.chart), this.nav.attr({
                translateX: j,
                translateY: f + this.padding + 7 + this.titleHeight,
                visibility: "visible"
            }), this.up.attr({
                fill: e === 1 ? g : h
            }).css({
                cursor: e === 1 ? "default" : "pointer"
            }), i.attr({
                text: e + "/" + d
            }), this.down.attr({
                x: 18 + this.pager.getBBox().width,
                fill: e === d ? g : h
            }).css({
                cursor: e === d ? "default" : "pointer"
            }), c = -c[e - 1] + this.initialItemY, this.scrollGroup.animate({
                translateY: c
            }), this.currentPage = e, this.positionCheckboxes(c)
        }
    };
    Ma = B.LegendSymbolMixin = {
        drawRectangle: function(a, b) {
            var c = a.options.symbolHeight || a.fontMetrics.f;
            b.legendSymbol = this.chart.renderer.rect(0, a.baseline - c + 1, a.symbolWidth, c, a.options.symbolRadius || 0).attr({
                zIndex: 3
            }).add(b.legendGroup)
        },
        drawLineMarker: function(a) {
            var b = this.options,
                c = b.marker,
                d;
            d = a.symbolWidth;
            var e = this.chart.renderer,
                f = this.legendGroup,
                a = a.baseline - w(a.fontMetrics.b * 0.3),
                g;
            if (b.lineWidth) {
                g = {
                    "stroke-width": b.lineWidth
                };
                if (b.dashStyle) g.dashstyle = b.dashStyle;
                this.legendLine = e.path(["M", 0, a, "L", d, a]).attr(g).add(f)
            }
            if (c && c.enabled !== !1) b = c.radius, this.legendSymbol = d = e.symbol(this.symbol, d / 2 - b, a - b, 2 * b, 2 * b).add(f), d.isMarker = !0
        }
    };
    (/Trident\/7\.0/.test(za) || Ka) && Ta(mb.prototype, "positionItem", function(a, b) {
        var c = this,
            d = function() {
                b._legendItemPos && a.call(c, b)
            };
        d();
        setTimeout(d)
    });
    E = B.Chart = function() {
        this.init.apply(this, arguments)
    };
    E.prototype = {
        callbacks: [],
        init: function(a, b) {
            var c, d = a.series;
            a.series = null;
            c = D(S, a);
            c.series = a.series = d;
            this.userOptions = a;
            d = c.chart;
            this.margin = this.splashArray("margin", d);
            this.spacing = this.splashArray("spacing", d);
            var e = d.events;
            this.bounds = {
                h: {},
                v: {}
            };
            this.callback = b;
            this.isResizing = 0;
            this.options = c;
            this.axes = [];
            this.series = [];
            this.hasCartesianSeries = d.showAxes;
            var f = this,
                g;
            f.index = X.length;
            X.push(f);
            bb++;
            d.reflow !== !1 && I(f, "load", function() {
                f.initReflow()
            });
            if (e)
                for (g in e) I(f, g, e[g]);
            f.xAxis = [];
            f.yAxis = [];
            f.animation = fa ? !1 : p(d.animation, !0);
            f.pointCount = f.colorCounter = f.symbolCounter = 0;
            f.firstRender()
        },
        initSeries: function(a) {
            var b = this.options.chart;
            (b = N[a.type || b.type || b.defaultSeriesType]) || la(17, !0);
            b = new b;
            b.init(this, a);
            return b
        },
        isInsidePlot: function(a, b, c) {
            var d = c ? b : a,
                a = c ? a : b;
            return d >= 0 && d <= this.plotWidth && a >= 0 && a <= this.plotHeight
        },
        redraw: function(a) {
            var b = this.axes,
                c = this.series,
                d = this.pointer,
                e = this.legend,
                f = this.isDirtyLegend,
                g, h, i = this.hasCartesianSeries,
                j = this.isDirtyBox,
                k = c.length,
                m = k,
                n = this.renderer,
                l = n.isHidden(),
                p = [];
            Ra(a, this);
            l && this.cloneRenderTo();
            for (this.layOutTitles(); m--;)
                if (a = c[m], a.options.stacking && (g = !0, a.isDirty)) {
                    h = !0;
                    break
                }
            if (h)
                for (m = k; m--;)
                    if (a = c[m], a.options.stacking) a.isDirty = !0;
            o(c, function(a) {
                a.isDirty && a.options.legendType === "point" && (a.updateTotals && a.updateTotals(), f = !0)
            });
            if (f && e.options.enabled) e.render(), this.isDirtyLegend = !1;
            g && this.getStacks();
            if (i && !this.isResizing) this.maxTicks = null, o(b, function(a) {
                a.setScale()
            });
            this.getMargins();
            i && (o(b, function(a) {
                a.isDirty && (j = !0)
            }), o(b, function(a) {
                var b = a.min + "," + a.max;
                if (a.extKey !== b) a.extKey = b, p.push(function() {
                    J(a, "afterSetExtremes", t(a.eventArgs, a.getExtremes()));
                    delete a.eventArgs
                });
                (j || g) && a.redraw()
            }));
            j && this.drawChartBox();
            o(c, function(a) {
                a.isDirty && a.visible && (!a.isCartesian || a.xAxis) && a.redraw()
            });
            d && d.reset(!0);
            n.draw();
            J(this, "redraw");
            l && this.cloneRenderTo(!0);
            o(p, function(a) {
                a.call()
            })
        },
        get: function(a) {
            var b = this.axes,
                c = this.series,
                d, e;
            for (d = 0; d < b.length; d++)
                if (b[d].options.id === a) return b[d];
            for (d = 0; d < c.length; d++)
                if (c[d].options.id === a) return c[d];
            for (d = 0; d < c.length; d++) {
                e = c[d].points || [];
                for (b = 0; b < e.length; b++)
                    if (e[b].id === a) return e[b]
            }
            return null
        },
        getAxes: function() {
            var a = this,
                b = this.options,
                c = b.xAxis = ra(b.xAxis || {}),
                b = b.yAxis = ra(b.yAxis || {});
            o(c, function(a, b) {
                a.index = b;
                a.isX = !0
            });
            o(b, function(a, b) {
                a.index = b
            });
            c = c.concat(b);
            o(c, function(b) {
                new ha(a, b)
            })
        },
        getSelectedPoints: function() {
            var a = [];
            o(this.series, function(b) {
                a = a.concat(kb(b.points || [], function(a) {
                    return a.selected
                }))
            });
            return a
        },
        getSelectedSeries: function() {
            return kb(this.series, function(a) {
                return a.selected
            })
        },
        setTitle: function(a, b, c) {
            var g;
            var d = this,
                e = d.options,
                f;
            f = e.title = D(e.title, a);
            g = e.subtitle = D(e.subtitle, b), e = g;
            o([
                ["title", a, f],
                ["subtitle", b, e]
            ], function(a) {
                var b = a[0],
                    c = d[b],
                    e = a[1],
                    a = a[2];
                c && e && (d[b] = c = c.destroy());
                a && a.text && !c && (d[b] = d.renderer.text(a.text, 0, 0, a.useHTML).attr({
                    align: a.align,
                    "class": "highcharts-" + b,
                    zIndex: a.zIndex || 4
                }).css(a.style).add())
            });
            d.layOutTitles(c)
        },
        layOutTitles: function(a) {
            var b = 0,
                c = this.title,
                d = this.subtitle,
                e = this.options,
                f = e.title,
                e = e.subtitle,
                g = this.renderer,
                h = this.spacingBox.width - 44;
            if (c && (c.css({
                    width: (f.width || h) + "px"
                }).align(t({
                    y: g.fontMetrics(f.style.fontSize, c).b - 3
                }, f), !1, "spacingBox"), !f.floating && !f.verticalAlign)) b = c.getBBox().height;
            d && (d.css({
                width: (e.width || h) + "px"
            }).align(t({
                y: b + (f.margin - 13) + g.fontMetrics(e.style.fontSize, c).b
            }, e), !1, "spacingBox"), !e.floating && !e.verticalAlign && (b = ta(b + d.getBBox().height)));
            c = this.titleOffset !== b;
            this.titleOffset = b;
            if (!this.isDirtyBox && c) this.isDirtyBox = c, this.hasRendered && p(a, !0) && this.isDirtyBox && this.redraw()
        },
        getChartSize: function() {
            var a = this.options.chart,
                b = a.width,
                a = a.height,
                c = this.renderToClone || this.renderTo;
            if (!q(b)) this.containerWidth = jb(c, "width");
            if (!q(a)) this.containerHeight = jb(c, "height");
            this.chartWidth = s(0, b || this.containerWidth || 600);
            this.chartHeight = s(0, p(a, this.containerHeight > 19 ? this.containerHeight : 400))
        },
        cloneRenderTo: function(a) {
            var b = this.renderToClone,
                c = this.container;
            a ? b && (this.renderTo.appendChild(c), Qa(b), delete this.renderToClone) : (c && c.parentNode === this.renderTo && this.renderTo.removeChild(c), this.renderToClone = b = this.renderTo.cloneNode(0), M(b, {
                position: "absolute",
                top: "-9999px",
                display: "block"
            }), b.style.setProperty && b.style.setProperty("display", "block", "important"), C.body.appendChild(b), c && b.appendChild(c))
        },
        getContainer: function() {
            var a, b = this.options,
                c = b.chart,
                d, e, f;
            this.renderTo = a = c.renderTo;
            f = "highcharts-" + xb++;
            if (Ba(a)) this.renderTo = a = C.getElementById(a);
            a || la(13, !0);
            d = G(K(a, "data-highcharts-chart"));
            !isNaN(d) && X[d] && X[d].hasRendered && X[d].destroy();
            K(a, "data-highcharts-chart", this.index);
            a.innerHTML = "";
            !c.skipClone && !a.offsetWidth && this.cloneRenderTo();
            this.getChartSize();
            d = this.chartWidth;
            e = this.chartHeight;
            this.container = a = $(Ja, {
                className: "highcharts-container" + (c.className ? " " + c.className : ""),
                id: f
            }, t({
                position: "relative",
                overflow: "hidden",
                width: d + "px",
                height: e + "px",
                textAlign: "left",
                lineHeight: "normal",
                zIndex: 0,
                "-webkit-tap-highlight-color": "rgba(0,0,0,0)"
            }, c.style), this.renderToClone || a);
            this._cursor = a.style.cursor;
            this.renderer = new(B[c.renderer] || $a)(a, d, e, c.style, c.forExport, b.exporting && b.exporting.allowHTML);
            fa && this.renderer.create(this, a, d, e);
            this.renderer.chartIndex = this.index
        },
        getMargins: function(a) {
            var b = this.spacing,
                c = this.margin,
                d = this.titleOffset;
            this.resetMargins();
            if (d && !q(c[0])) this.plotTop = s(this.plotTop, d + this.options.title.margin + b[0]);
            this.legend.adjustMargins(c, b);
            this.extraBottomMargin && (this.marginBottom += this.extraBottomMargin);
            this.extraTopMargin && (this.plotTop += this.extraTopMargin);
            a || this.getAxisMargins()
        },
        getAxisMargins: function() {
            var a = this,
                b = a.axisOffset = [0, 0, 0, 0],
                c = a.margin;
            a.hasCartesianSeries && o(a.axes, function(a) {
                a.visible && a.getOffset()
            });
            o(ib, function(d, e) {
                q(c[e]) || (a[d] += b[e])
            });
            a.setChartSize()
        },
        reflow: function(a) {
            var b = this,
                c = b.options.chart,
                d = b.renderTo,
                e = c.width || jb(d, "width"),
                f = c.height || jb(d, "height"),
                c = a ? a.target : L,
                d = function() {
                    if (b.container) b.setSize(e, f, !1), b.hasUserSize = null
                };
            if (!b.hasUserSize && !b.isPrinting && e && f && (c === L || c === C)) {
                if (e !== b.containerWidth || f !== b.containerHeight) clearTimeout(b.reflowTimeout), a ? b.reflowTimeout = setTimeout(d, 100) : d();
                b.containerWidth = e;
                b.containerHeight = f
            }
        },
        initReflow: function() {
            var a = this,
                b = function(b) {
                    a.reflow(b)
                };
            I(L, "resize", b);
            I(a, "destroy", function() {
                Y(L, "resize", b)
            })
        },
        setSize: function(a, b, c) {
            var d = this,
                e, f, g, h = d.renderer;
            d.isResizing += 1;
            g = function() {
                d && J(d, "endResize", null, function() {
                    d.isResizing -= 1
                })
            };
            Ra(c, d);
            d.oldChartHeight = d.chartHeight;
            d.oldChartWidth = d.chartWidth;
            if (q(a)) d.chartWidth = e = s(0, w(a)), d.hasUserSize = !!e;
            if (q(b)) d.chartHeight = f = s(0, w(b));
            a = h.globalAnimation;
            (a ? lb : M)(d.container, {
                width: e + "px",
                height: f + "px"
            }, a);
            d.setChartSize(!0);
            h.setSize(e, f, c);
            d.maxTicks = null;
            o(d.axes, function(a) {
                a.isDirty = !0;
                a.setScale()
            });
            o(d.series, function(a) {
                a.isDirty = !0
            });
            d.isDirtyLegend = !0;
            d.isDirtyBox = !0;
            d.layOutTitles();
            d.getMargins();
            d.redraw(c);
            d.oldChartHeight = null;
            J(d, "resize");
            a = h.globalAnimation;
            a === !1 ? g() : setTimeout(g, a && a.duration || 500)
        },
        setChartSize: function(a) {
            var b = this.inverted,
                c = this.renderer,
                d = this.chartWidth,
                e = this.chartHeight,
                f = this.options.chart,
                g = this.spacing,
                h = this.clipOffset,
                i, j, k, m;
            this.plotLeft = i = w(this.plotLeft);
            this.plotTop = j = w(this.plotTop);
            this.plotWidth = k = s(0, w(d - i - this.marginRight));
            this.plotHeight = m = s(0, w(e - j - this.marginBottom));
            this.plotSizeX = b ? m : k;
            this.plotSizeY = b ? k : m;
            this.plotBorderWidth = f.plotBorderWidth || 0;
            this.spacingBox = c.spacingBox = {
                x: g[3],
                y: g[0],
                width: d - g[3] - g[1],
                height: e - g[0] - g[2]
            };
            this.plotBox = c.plotBox = {
                x: i,
                y: j,
                width: k,
                height: m
            };
            d = 2 * T(this.plotBorderWidth / 2);
            b = ta(s(d, h[3]) / 2);
            c = ta(s(d, h[0]) / 2);
            this.clipBox = {
                x: b,
                y: c,
                width: T(this.plotSizeX - s(d, h[1]) / 2 - b),
                height: s(0, T(this.plotSizeY - s(d, h[2]) / 2 - c))
            };
            a || o(this.axes, function(a) {
                a.setAxisSize();
                a.setAxisTranslation()
            })
        },
        resetMargins: function() {
            var a = this;
            o(ib, function(b, c) {
                a[b] = p(a.margin[c], a.spacing[c])
            });
            a.axisOffset = [0, 0, 0, 0];
            a.clipOffset = [0, 0, 0, 0]
        },
        drawChartBox: function() {
            var a = this.options.chart,
                b = this.renderer,
                c = this.chartWidth,
                d = this.chartHeight,
                e = this.chartBackground,
                f = this.plotBackground,
                g = this.plotBorder,
                h = this.plotBGImage,
                i = a.borderWidth || 0,
                j = a.backgroundColor,
                k = a.plotBackgroundColor,
                m = a.plotBackgroundImage,
                n = a.plotBorderWidth || 0,
                l, p = this.plotLeft,
                o = this.plotTop,
                q = this.plotWidth,
                s = this.plotHeight,
                v = this.plotBox,
                t = this.clipRect,
                x = this.clipBox;
            l = i + (a.shadow ? 8 : 0);
            if (i || j)
                if (e) e.animate(e.crisp({
                    width: c - l,
                    height: d - l
                }));
                else {
                    e = {
                        fill: j || P
                    };
                    if (i) e.stroke = a.borderColor, e["stroke-width"] = i;
                    this.chartBackground = b.rect(l / 2, l / 2, c - l, d - l, a.borderRadius, i).attr(e).addClass("highcharts-background").add().shadow(a.shadow)
                }
            if (k) f ? f.animate(v) : this.plotBackground = b.rect(p, o, q, s, 0).attr({
                fill: k
            }).add().shadow(a.plotShadow);
            if (m) h ? h.animate(v) : this.plotBGImage = b.image(m, p, o, q, s).add();
            t ? t.animate({
                width: x.width,
                height: x.height
            }) : this.clipRect = b.clipRect(x);
            if (n) g ? g.animate(g.crisp({
                x: p,
                y: o,
                width: q,
                height: s,
                strokeWidth: -n
            })) : this.plotBorder = b.rect(p, o, q, s, 0, -n).attr({
                stroke: a.plotBorderColor,
                "stroke-width": n,
                fill: P,
                zIndex: 1
            }).add();
            this.isDirtyBox = !1
        },
        propFromSeries: function() {
            var a = this,
                b = a.options.chart,
                c, d = a.options.series,
                e, f;
            o(["inverted", "angular", "polar"], function(g) {
                c = N[b.type || b.defaultSeriesType];
                f = a[g] || b[g] || c && c.prototype[g];
                for (e = d && d.length; !f && e--;)(c = N[d[e].type]) && c.prototype[g] && (f = !0);
                a[g] = f
            })
        },
        linkSeries: function() {
            var a = this,
                b = a.series;
            o(b, function(a) {
                a.linkedSeries.length = 0
            });
            o(b, function(b) {
                var d = b.options.linkedTo;
                if (Ba(d) && (d = d === ":previous" ? a.series[b.index - 1] : a.get(d))) d.linkedSeries.push(b), b.linkedParent = d, b.visible = p(b.options.visible, d.options.visible, b.visible)
            })
        },
        renderSeries: function() {
            o(this.series, function(a) {
                a.translate();
                a.render()
            })
        },
        renderLabels: function() {
            var a = this,
                b = a.options.labels;
            b.items && o(b.items, function(c) {
                var d = t(b.style, c.style),
                    e = G(d.left) + a.plotLeft,
                    f = G(d.top) + a.plotTop + 12;
                delete d.left;
                delete d.top;
                a.renderer.text(c.html, e, f).attr({
                    zIndex: 2
                }).css(d).add()
            })
        },
        render: function() {
            var a = this.axes,
                b = this.renderer,
                c = this.options,
                d, e, f, g;
            this.setTitle();
            this.legend = new mb(this, c.legend);
            this.getStacks && this.getStacks();
            this.getMargins(!0);
            this.setChartSize();
            d = this.plotWidth;
            e = this.plotHeight -= 13;
            o(a, function(a) {
                a.setScale()
            });
            this.getAxisMargins();
            f = d / this.plotWidth > 1.1;
            g = e / this.plotHeight > 1.1;
            if (f || g) this.maxTicks = null, o(a, function(a) {
                (a.horiz && f || !a.horiz && g) && a.setTickInterval(!0)
            }), this.getMargins();
            this.drawChartBox();
            this.hasCartesianSeries && o(a, function(a) {
                a.visible && a.render()
            });
            if (!this.seriesGroup) this.seriesGroup = b.g("series-group").attr({
                zIndex: 3
            }).add();
            this.renderSeries();
            this.renderLabels();
            this.showCredits(c.credits);
            this.hasRendered = !0
        },
        showCredits: function(a) {
            if (a.enabled && !this.credits) this.credits = this.renderer.text(a.text, 0, 0).on("click", function() {
                if (a.href) location.href = a.href
            }).attr({
                align: a.position.align,
                zIndex: 8
            }).css(a.style).add().align(a.position)
        },
        destroy: function() {
            var a = this,
                b = a.axes,
                c = a.series,
                d = a.container,
                e, f = d && d.parentNode;
            J(a, "destroy");
            X[a.index] = x;
            bb--;
            a.renderTo.removeAttribute("data-highcharts-chart");
            Y(a);
            for (e = b.length; e--;) b[e] = b[e].destroy();
            for (e = c.length; e--;) c[e] = c[e].destroy();
            o("title,subtitle,chartBackground,plotBackground,plotBGImage,plotBorder,seriesGroup,clipRect,credits,pointer,scroller,rangeSelector,legend,resetZoomButton,tooltip,renderer".split(","), function(b) {
                var c = a[b];
                c && c.destroy && (a[b] = c.destroy())
            });
            if (d) d.innerHTML = "", Y(d), f && Qa(d);
            for (e in a) delete a[e]
        },
        isReadyToRender: function() {
            var a = this;
            return !ca && L == L.top && C.readyState !== "complete" || fa && !L.canvg ? (fa ? Lb.push(function() {
                a.firstRender()
            }, a.options.global.canvasToolsURL) : C.attachEvent("onreadystatechange", function() {
                C.detachEvent("onreadystatechange", a.firstRender);
                C.readyState === "complete" && a.firstRender()
            }), !1) : !0
        },
        firstRender: function() {
            var a = this,
                b = a.options,
                c = a.callback;
            if (a.isReadyToRender()) {
                a.getContainer();
                J(a, "init");
                a.resetMargins();
                a.setChartSize();
                a.propFromSeries();
                a.getAxes();
                o(b.series || [], function(b) {
                    a.initSeries(b)
                });
                a.linkSeries();
                J(a, "beforeRender");
                if (B.Pointer) a.pointer = new Va(a, b);
                a.render();
                a.renderer.draw();
                c && c.apply(a, [a]);
                o(a.callbacks, function(b) {
                    a.index !== x && b.apply(a, [a])
                });
                J(a, "load");
                a.cloneRenderTo(!0)
            }
        },
        splashArray: function(a, b) {
            var c = b[a],
                c = da(c) ? c : [c, c, c, c];
            return [p(b[a + "Top"], c[0]), p(b[a + "Right"], c[1]), p(b[a + "Bottom"], c[2]), p(b[a + "Left"], c[3])]
        }
    };
    var Xb = B.CenteredSeriesMixin = {
            getCenter: function() {
                var a = this.options,
                    b = this.chart,
                    c = 2 * (a.slicedOffset || 0),
                    d = b.plotWidth - 2 * c,
                    b = b.plotHeight - 2 * c,
                    e = a.center,
                    e = [p(e[0], "50%"), p(e[1], "50%"), a.size || "100%", a.innerSize || 0],
                    f = z(d, b),
                    g, h;
                for (g = 0; g < 4; ++g) h = e[g], a = g < 2 || g === 2 && /%$/.test(h), e[g] = (/%$/.test(h) ? [d, b, f, e[2]][g] * parseFloat(h) / 100 : parseFloat(h)) + (a ? c : 0);
                e[3] > e[2] && (e[3] = e[2]);
                return e
            }
        },
        Fa = function() {};
    Fa.prototype = {
        init: function(a, b, c) {
            this.series = a;
            this.color = a.color;
            this.applyOptions(b, c);
            this.pointAttr = {};
            if (a.options.colorByPoint && (b = a.options.colors || a.chart.options.colors, this.color = this.color || b[a.colorCounter++], a.colorCounter === b.length)) a.colorCounter = 0;
            a.chart.pointCount++;
            return this
        },
        applyOptions: function(a, b) {
            var c = this.series,
                d = c.options.pointValKey || c.pointValKey,
                a = Fa.prototype.optionsToObject.call(this, a);
            t(this, a);
            this.options = this.options ? t(this.options, a) : a;
            if (d) this.y = this[d];
            if (this.x === x && c) this.x = b === x ? c.autoIncrement() : b;
            return this
        },
        optionsToObject: function(a) {
            var b = {},
                c = this.series,
                d = c.options.keys,
                e = d || c.pointArrayMap || ["y"],
                f = e.length,
                g = 0,
                h = 0;
            if (typeof a === "number" || a === null) b[e[0]] = a;
            else if (Ga(a)) {
                if (!d && a.length > f) {
                    c = typeof a[0];
                    if (c === "string") b.name = a[0];
                    else if (c === "number") b.x = a[0];
                    g++
                }
                for (; h < f;) {
                    if (!d || a[g] !== void 0) b[e[h]] = a[g];
                    g++;
                    h++
                }
            } else if (typeof a === "object") {
                b = a;
                if (a.dataLabels) c._hasPointLabels = !0;
                if (a.marker) c._hasPointMarkers = !0
            }
            return b
        },
        destroy: function() {
            var a = this.series.chart,
                b = a.hoverPoints,
                c;
            a.pointCount--;
            if (b && (this.setState(), ja(b, this), !b.length)) a.hoverPoints = null;
            if (this === a.hoverPoint) this.onMouseOut();
            if (this.graphic || this.dataLabel) Y(this), this.destroyElements();
            this.legendItem && a.legend.destroyItem(this);
            for (c in this) this[c] = null
        },
        destroyElements: function() {
            for (var a = ["graphic", "dataLabel", "dataLabelUpper", "connector", "shadowGroup"], b, c = 6; c--;) b = a[c], this[b] && (this[b] = this[b].destroy())
        },
        getLabelConfig: function() {
            return {
                x: this.category,
                y: this.y,
                color: this.color,
                key: this.name || this.category,
                series: this.series,
                point: this,
                percentage: this.percentage,
                total: this.total || this.stackTotal
            }
        },
        tooltipFormatter: function(a) {
            var b = this.series,
                c = b.tooltipOptions,
                d = p(c.valueDecimals, ""),
                e = c.valuePrefix || "",
                f = c.valueSuffix || "";
            o(b.pointArrayMap || ["y"], function(b) {
                b = "{point." + b;
                if (e || f) a = a.replace(b + "}", e + b + "}" + f);
                a = a.replace(b + "}", b + ":,." + d + "f}")
            });
            return Ia(a, {
                point: this,
                series: this.series
            })
        },
        firePointEvent: function(a, b, c) {
            var d = this,
                e = this.series.options;
            (e.point.events[a] || d.options && d.options.events && d.options.events[a]) && this.importEvents();
            a === "click" && e.allowPointSelect && (c = function(a) {
                d.select && d.select(null, a.ctrlKey || a.metaKey || a.shiftKey)
            });
            J(this, a, b, c)
        },
        visible: !0
    };
    var R = B.Series = function() {};
    R.prototype = {
        isCartesian: !0,
        type: "line",
        pointClass: Fa,
        sorted: !0,
        requireSorting: !0,
        pointAttrToOptions: {
            stroke: "lineColor",
            "stroke-width": "lineWidth",
            fill: "fillColor",
            r: "radius"
        },
        directTouch: !1,
        axisTypes: ["xAxis", "yAxis"],
        colorCounter: 0,
        parallelArrays: ["x", "y"],
        init: function(a, b) {
            var c = this,
                d, e, f = a.series,
                g = function(a, b) {
                    return p(a.options.index, a._i) - p(b.options.index, b._i)
                };
            c.chart = a;
            c.options = b = c.setOptions(b);
            c.linkedSeries = [];
            c.bindAxes();
            t(c, {
                name: b.name,
                state: "",
                pointAttr: {},
                visible: b.visible !== !1,
                selected: b.selected === !0
            });
            if (fa) b.animation = !1;
            e = b.events;
            for (d in e) I(c, d, e[d]);
            if (e && e.click || b.point && b.point.events && b.point.events.click || b.allowPointSelect) a.runTrackerClick = !0;
            c.getColor();
            c.getSymbol();
            o(c.parallelArrays, function(a) {
                c[a + "Data"] = []
            });
            c.setData(b.data, !1);
            if (c.isCartesian) a.hasCartesianSeries = !0;
            f.push(c);
            c._i = f.length - 1;
            qb(f, g);
            this.yAxis && qb(this.yAxis.series, g);
            o(f, function(a, b) {
                a.index = b;
                a.name = a.name || "Series " + (b + 1)
            })
        },
        bindAxes: function() {
            var a = this,
                b = a.options,
                c = a.chart,
                d;
            o(a.axisTypes || [], function(e) {
                o(c[e], function(c) {
                    d = c.options;
                    if (b[e] === d.index || b[e] !== x && b[e] === d.id || b[e] === x && d.index === 0) c.series.push(a), a[e] = c, c.isDirty = !0
                });
                !a[e] && a.optionalAxis !== e && la(18, !0)
            })
        },
        updateParallelArrays: function(a, b) {
            var c = a.series,
                d = arguments;
            o(c.parallelArrays, typeof b === "number" ? function(d) {
                var f = d === "y" && c.toYData ? c.toYData(a) : a[d];
                c[d + "Data"][b] = f
            } : function(a) {
                Array.prototype[b].apply(c[a + "Data"], Array.prototype.slice.call(d, 2))
            })
        },
        autoIncrement: function() {
            var a = this.options,
                b = this.xIncrement,
                c, d = a.pointIntervalUnit,
                b = p(b, a.pointStart, 0);
            this.pointInterval = c = p(this.pointInterval, a.pointInterval, 1);
            if (d === "month" || d === "year") a = new ya(b), a = d === "month" ? +a[vb](a[Ya]() + c) : +a[wb](a[Za]() + c), c = a - b;
            this.xIncrement = b + c;
            return b
        },
        getSegments: function() {
            var a = -1,
                b = [],
                c, d = this.points,
                e = d.length;
            if (e)
                if (this.options.connectNulls) {
                    for (c = e; c--;) d[c].y === null && d.splice(c, 1);
                    d.length && (b = [d])
                } else o(d, function(c, g) {
                    c.y === null ? (g > a + 1 && b.push(d.slice(a + 1, g)), a = g) : g === e - 1 && b.push(d.slice(a + 1, g + 1))
                });
            this.segments = b
        },
        setOptions: function(a) {
            var b = this.chart,
                c = b.options.plotOptions,
                b = b.userOptions || {},
                d = b.plotOptions || {},
                e = c[this.type];
            this.userOptions = a;
            c = D(e, c.series, a);
            this.tooltipOptions = D(S.tooltip, S.plotOptions[this.type].tooltip, b.tooltip, d.series && d.series.tooltip, d[this.type] && d[this.type].tooltip, a.tooltip);
            e.marker === null && delete c.marker;
            this.zoneAxis = c.zoneAxis;
            a = this.zones = (c.zones || []).slice();
            if ((c.negativeColor || c.negativeFillColor) && !c.zones) a.push({
                value: c[this.zoneAxis + "Threshold"] || c.threshold || 0,
                color: c.negativeColor,
                fillColor: c.negativeFillColor
            });
            a.length && q(a[a.length - 1].value) && a.push({
                color: this.color,
                fillColor: this.fillColor
            });
            return c
        },
        getCyclic: function(a, b, c) {
            var d = this.userOptions,
                e = "_" + a + "Index",
                f = a + "Counter";
            b || (q(d[e]) ? b = d[e] : (d[e] = b = this.chart[f] % c.length, this.chart[f] += 1), b = c[b]);
            this[a] = b
        },
        getColor: function() {
            this.options.colorByPoint ? this.options.color = null : this.getCyclic("color", this.options.color || ba[this.type].color, this.chart.options.colors)
        },
        getSymbol: function() {
            var a = this.options.marker;
            this.getCyclic("symbol", a.symbol, this.chart.options.symbols);
            if (/^url/.test(this.symbol)) a.radius = 0
        },
        drawLegendSymbol: Ma.drawLineMarker,
        setData: function(a, b, c, d) {
            var e = this,
                f = e.points,
                g = f && f.length || 0,
                h, i = e.options,
                j = e.chart,
                k = null,
                m = e.xAxis,
                n = m && !!m.categories,
                l = i.turboThreshold,
                u = this.xData,
                r = this.yData,
                s = (h = e.pointArrayMap) && h.length,
                a = a || [];
            h = a.length;
            b = p(b, !0);
            if (d !== !1 && h && g === h && !e.cropped && !e.hasGroupedData && e.visible) o(a, function(a, b) {
                f[b].update && f[b].update(a, !1, null, !1)
            });
            else {
                e.xIncrement = null;
                e.pointRange = n ? 1 : i.pointRange;
                e.colorCounter = 0;
                o(this.parallelArrays, function(a) {
                    e[a + "Data"].length = 0
                });
                if (l && h > l) {
                    for (c = 0; k === null && c < h;) k = a[c], c++;
                    if (qa(k)) {
                        n = p(i.pointStart, 0);
                        k = p(i.pointInterval, 1);
                        for (c = 0; c < h; c++) u[c] = n, r[c] = a[c], n += k;
                        e.xIncrement = n
                    } else if (Ga(k))
                        if (s)
                            for (c = 0; c < h; c++) k = a[c], u[c] = k[0], r[c] = k.slice(1, s + 1);
                        else
                            for (c = 0; c < h; c++) k = a[c], u[c] = k[0], r[c] = k[1];
                    else la(12)
                } else
                    for (c = 0; c < h; c++)
                        if (a[c] !== x && (k = {
                                series: e
                            }, e.pointClass.prototype.applyOptions.apply(k, [a[c]]), e.updateParallelArrays(k, c), n && q(k.name))) m.names[k.x] = k.name;
                Ba(r[0]) && la(14, !0);
                e.data = [];
                e.options.data = a;
                for (c = g; c--;) f[c] && f[c].destroy && f[c].destroy();
                if (m) m.minRange = m.userMinRange;
                e.isDirty = e.isDirtyData = j.isDirtyBox = !0;
                c = !1
            }
            i.legendType === "point" && (this.processData(), this.generatePoints());
            b && j.redraw(c)
        },
        processData: function(a) {
            var b = this.xData,
                c = this.yData,
                d = b.length,
                e;
            e = 0;
            var f, g, h = this.xAxis,
                i, j = this.options;
            i = j.cropThreshold;
            var k = this.getExtremesFromAll || j.getExtremesFromAll,
                m = this.isCartesian,
                n, l;
            if (m && !this.isDirty && !h.isDirty && !this.yAxis.isDirty && !a) return !1;
            if (h) a = h.getExtremes(), n = a.min, l = a.max;
            if (m && this.sorted && !k && (!i || d > i || this.forceCrop))
                if (b[d - 1] < n || b[0] > l) b = [], c = [];
                else if (b[0] < n || b[d - 1] > l) e = this.cropData(this.xData, this.yData, n, l), b = e.xData, c = e.yData, e = e.start, f = !0;
            for (i = b.length - 1; i >= 0; i--) d = b[i] - b[i - 1], d > 0 && (g === x || d < g) ? g = d : d < 0 && this.requireSorting && la(15);
            this.cropped = f;
            this.cropStart = e;
            this.processedXData = b;
            this.processedYData = c;
            if (j.pointRange === null) this.pointRange = g || 1;
            this.closestPointRange = g
        },
        cropData: function(a, b, c, d) {
            var e = a.length,
                f = 0,
                g = e,
                h = p(this.cropShoulder, 1),
                i;
            for (i = 0; i < e; i++)
                if (a[i] >= c) {
                    f = s(0, i - h);
                    break
                }
            for (; i < e; i++)
                if (a[i] > d) {
                    g = i + h;
                    break
                }
            return {
                xData: a.slice(f, g),
                yData: b.slice(f, g),
                start: f,
                end: g
            }
        },
        generatePoints: function() {
            var a = this.options.data,
                b = this.data,
                c, d = this.processedXData,
                e = this.processedYData,
                f = this.pointClass,
                g = d.length,
                h = this.cropStart || 0,
                i, j = this.hasGroupedData,
                k, m = [],
                n;
            if (!b && !j) b = [], b.length = a.length, b = this.data = b;
            for (n = 0; n < g; n++) i = h + n, j ? m[n] = (new f).init(this, [d[n]].concat(ra(e[n]))) : (b[i] ? k = b[i] : a[i] !== x && (b[i] = k = (new f).init(this, a[i], d[n])), m[n] = k), m[n].index = i;
            if (b && (g !== (c = b.length) || j))
                for (n = 0; n < c; n++)
                    if (n === h && !j && (n += g), b[n]) b[n].destroyElements(), b[n].plotX = x;
            this.data = b;
            this.points = m
        },
        getExtremes: function(a) {
            var b = this.yAxis,
                c = this.processedXData,
                d, e = [],
                f = 0;
            d = this.xAxis.getExtremes();
            var g = d.min,
                h = d.max,
                i, j, k, m, a = a || this.stackedYData || this.processedYData;
            d = a.length;
            for (m = 0; m < d; m++)
                if (j = c[m], k = a[m], i = k !== null && k !== x && (!b.isLog || k.length || k > 0), j = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || (c[m + 1] || j) >= g && (c[m - 1] || j) <= h, i && j)
                    if (i = k.length)
                        for (; i--;) k[i] !== null && (e[f++] = k[i]);
                    else e[f++] = k;
            this.dataMin = Oa(e);
            this.dataMax = Da(e)
        },
        translate: function() {
            this.processedXData || this.processData();
            this.generatePoints();
            for (var a = this.options, b = a.stacking, c = this.xAxis, d = c.categories, e = this.yAxis, f = this.points, g = f.length, h = !!this.modifyValue, i = a.pointPlacement, j = i === "between" || qa(i), k = a.threshold, m = a.startFromThreshold ? k : 0, n, l, u, o, t = Number.MAX_VALUE, a = 0; a < g; a++) {
                var A = f[a],
                    v = A.x,
                    y = A.y;
                l = A.low;
                var w = b && e.stacks[(this.negStacks && y < (m ? 0 : k) ? "-" : "") + this.stackKey];
                if (e.isLog && y !== null && y <= 0) A.y = y = null, la(10);
                A.plotX = n = z(s(-1E5, c.translate(v, 0, 0, 0, 1, i, this.type === "flags")), 1E5);
                if (b && this.visible && w && w[v]) o = this.getStackIndicator(o, v, this.index), w = w[v], y = w.points[o.key], l = y[0], y = y[1], l === m && (l = p(k, e.min)), e.isLog && l <= 0 && (l = null), A.total = A.stackTotal = w.total, A.percentage = w.total && A.y / w.total * 100, A.stackY = y, w.setOffset(this.pointXOffset || 0, this.barW || 0);
                A.yBottom = q(l) ? e.translate(l, 0, 1, 0, 1) : null;
                h && (y = this.modifyValue(y, A));
                A.plotY = l = typeof y === "number" && y !== Infinity ? z(s(-1E5, e.translate(y, 0, 1, 0, 1)), 1E5) : x;
                A.isInside = l !== x && l >= 0 && l <= e.len && n >= 0 && n <= c.len;
                A.clientX = j ? c.translate(v, 0, 0, 0, 1) : n;
                A.negative = A.y < (k || 0);
                A.category = d && d[A.x] !== x ? d[A.x] : A.x;
                a && (t = z(t, O(n - u)));
                u = n
            }
            this.closestPointRangePx = t;
            this.getSegments()
        },
        setClip: function(a) {
            var b = this.chart,
                c = this.options,
                d = b.renderer,
                e = b.inverted,
                f = this.clipBox,
                g = f || b.clipBox,
                h = this.sharedClipKey || ["_sharedClip", a && a.duration, a && a.easing, g.height, c.xAxis, c.yAxis].join(","),
                i = b[h],
                j = b[h + "m"];
            if (!i) {
                if (a) g.width = 0, b[h + "m"] = j = d.clipRect(-99, e ? -b.plotLeft : -b.plotTop, 99, e ? b.chartWidth : b.chartHeight);
                b[h] = i = d.clipRect(g)
            }
            a && (i.count += 1);
            if (c.clip !== !1) this.group.clip(a || f ? i : b.clipRect), this.markerGroup.clip(j), this.sharedClipKey = h;
            a || (i.count -= 1, i.count <= 0 && h && b[h] && (f || (b[h] = b[h].destroy()), b[h + "m"] && (b[h + "m"] = b[h + "m"].destroy())))
        },
        animate: function(a) {
            var b = this.chart,
                c = this.options.animation,
                d;
            if (c && !da(c)) c = ba[this.type].animation;
            a ? this.setClip(c) : (d = this.sharedClipKey, (a = b[d]) && a.animate({
                width: b.plotSizeX
            }, c), b[d + "m"] && b[d + "m"].animate({
                width: b.plotSizeX + 99
            }, c), this.animate = null)
        },
        afterAnimate: function() {
            this.setClip();
            J(this, "afterAnimate")
        },
        drawPoints: function() {
            var a, b = this.points,
                c = this.chart,
                d, e, f, g, h, i, j, k, m = this.options.marker,
                n = this.pointAttr[""],
                l, o, r, s = this.markerGroup,
                q = p(m.enabled, this.xAxis.isRadial, this.closestPointRangePx > 2 * m.radius);
            if (m.enabled !== !1 || this._hasPointMarkers)
                for (f = b.length; f--;)
                    if (g = b[f], d = T(g.plotX), e = g.plotY, k = g.graphic, l = g.marker || {}, o = !!g.marker, a = q && l.enabled === x || l.enabled, r = g.isInside, a && e !== x && !isNaN(e) && g.y !== null)
                        if (a = g.pointAttr[g.selected ? "select" : ""] || n, h = a.r, i = p(l.symbol, this.symbol), j = i.indexOf("url") === 0, k) k[r ? "show" : "hide"](!0).animate(t({
                            x: d - h,
                            y: e - h
                        }, k.symbolName ? {
                            width: 2 * h,
                            height: 2 * h
                        } : {}));
                        else {
                            if (r && (h > 0 || j)) g.graphic = c.renderer.symbol(i, d - h, e - h, 2 * h, 2 * h, o ? l : m).attr(a).add(s)
                        }
            else if (k) g.graphic = k.destroy()
        },
        convertAttribs: function(a, b, c, d) {
            var e = this.pointAttrToOptions,
                f, g, h = {},
                a = a || {},
                b = b || {},
                c = c || {},
                d = d || {};
            for (f in e) g = e[f], h[f] = p(a[g], b[f], c[f], d[f]);
            return h
        },
        getAttribs: function() {
            var a = this,
                b = a.options,
                c = ba[a.type].marker ? b.marker : b,
                d = c.states,
                e = d.hover,
                f, g = a.color,
                h = a.options.negativeColor;
            f = {
                stroke: g,
                fill: g
            };
            var i = a.points || [],
                j, k, m = [],
                n = a.pointAttrToOptions;
            j = a.hasPointSpecificOptions;
            var l = c.lineColor,
                u = c.fillColor;
            k = b.turboThreshold;
            var r = a.zones,
                s = a.zoneAxis || "y",
                A;
            b.marker ? (e.radius = e.radius || c.radius + e.radiusPlus, e.lineWidth = e.lineWidth || c.lineWidth + e.lineWidthPlus) : (e.color = e.color || na(e.color || g).brighten(e.brightness).get(), e.negativeColor = e.negativeColor || na(e.negativeColor || h).brighten(e.brightness).get());
            m[""] = a.convertAttribs(c, f);
            o(["hover", "select"], function(b) {
                m[b] = a.convertAttribs(d[b], m[""])
            });
            a.pointAttr = m;
            g = i.length;
            if (!k || g < k || j)
                for (; g--;) {
                    k = i[g];
                    if ((c = k.options && k.options.marker || k.options) && c.enabled === !1) c.radius = 0;
                    if (r.length) {
                        j = 0;
                        for (f = r[j]; k[s] >= f.value;) f = r[++j];
                        k.color = k.fillColor = p(f.color, a.color)
                    }
                    j = b.colorByPoint || k.color;
                    if (k.options)
                        for (A in n) q(c[n[A]]) && (j = !0);
                    if (j) {
                        c = c || {};
                        j = [];
                        d = c.states || {};
                        f = d.hover = d.hover || {};
                        if (!b.marker || k.negative && !f.fillColor && !e.fillColor) f[a.pointAttrToOptions.fill] = f.color || !k.options.color && e[k.negative && h ? "negativeColor" : "color"] || na(k.color).brighten(f.brightness || e.brightness).get();
                        f = {
                            color: k.color
                        };
                        if (!u) f.fillColor = k.color;
                        if (!l) f.lineColor = k.color;
                        c.hasOwnProperty("color") && !c.color && delete c.color;
                        j[""] = a.convertAttribs(t(f, c), m[""]);
                        j.hover = a.convertAttribs(d.hover, m.hover, j[""]);
                        j.select = a.convertAttribs(d.select, m.select, j[""])
                    } else j = m;
                    k.pointAttr = j
                }
        },
        destroy: function() {
            var a = this,
                b = a.chart,
                c = /AppleWebKit\/533/.test(za),
                d, e = a.data || [],
                f, g, h;
            J(a, "destroy");
            Y(a);
            o(a.axisTypes || [], function(b) {
                if (h = a[b]) ja(h.series, a), h.isDirty = h.forceRedraw = !0
            });
            a.legendItem && a.chart.legend.destroyItem(a);
            for (d = e.length; d--;)(f = e[d]) && f.destroy && f.destroy();
            a.points = null;
            clearTimeout(a.animationTimeout);
            for (g in a) a[g] instanceof Q && !a[g].survive && (d = c && g === "group" ? "hide" : "destroy", a[g][d]());
            if (b.hoverSeries === a) b.hoverSeries = null;
            ja(b.series, a);
            for (g in a) delete a[g]
        },
        getSegmentPath: function(a) {
            var b = this,
                c = [],
                d = b.options.step;
            o(a, function(e, f) {
                var g = e.plotX,
                    h = e.plotY,
                    i;
                b.getPointSpline ? c.push.apply(c, b.getPointSpline(a, e, f)) : (c.push(f ? "L" : "M"), d && f && (i = a[f - 1], d === "right" ? c.push(i.plotX, h, "L") : d === "center" ? c.push((i.plotX + g) / 2, i.plotY, "L", (i.plotX + g) / 2, h, "L") : c.push(g, i.plotY, "L")), c.push(e.plotX, e.plotY))
            });
            return c
        },
        getGraphPath: function() {
            var a = this,
                b = [],
                c, d = [];
            o(a.segments, function(e) {
                c = a.getSegmentPath(e);
                e.length > 1 ? b = b.concat(c) : d.push(e[0])
            });
            a.singlePoints = d;
            return a.graphPath = b
        },
        drawGraph: function() {
            var a = this,
                b = this.options,
                c = [
                    ["graph", b.lineColor || this.color, b.dashStyle]
                ],
                d = b.lineWidth,
                e = b.linecap !== "square",
                f = this.getGraphPath(),
                g = this.fillGraph && this.color || P;
            o(this.zones, function(d, e) {
                c.push(["zoneGraph" + e, d.color || a.color, d.dashStyle || b.dashStyle])
            });
            o(c, function(c, i) {
                var j = c[0],
                    k = a[j];
                if (k) k.animate({
                    d: f
                });
                else if ((d || g) && f.length) k = {
                    stroke: c[1],
                    "stroke-width": d,
                    fill: g,
                    zIndex: 1
                }, c[2] ? k.dashstyle = c[2] : e && (k["stroke-linecap"] = k["stroke-linejoin"] = "round"), a[j] = a.chart.renderer.path(f).attr(k).add(a.group).shadow(i < 2 && b.shadow)
            })
        },
        applyZones: function() {
            var a = this,
                b = this.chart,
                c = b.renderer,
                d = this.zones,
                e, f, g = this.clips || [],
                h, i = this.graph,
                j = this.area,
                k = s(b.chartWidth, b.chartHeight),
                m = this[(this.zoneAxis || "y") + "Axis"],
                n, l = m.reversed,
                u = b.inverted,
                r = m.horiz,
                q, t, v, y = !1;
            if (d.length && (i || j) && m.min !== x) i && i.hide(), j && j.hide(), n = m.getExtremes(), o(d, function(d, o) {
                e = l ? r ? b.plotWidth : 0 : r ? 0 : m.toPixels(n.min);
                e = z(s(p(f, e), 0), k);
                f = z(s(w(m.toPixels(p(d.value, n.max), !0)), 0), k);
                y && (e = f = m.toPixels(n.max));
                q = Math.abs(e - f);
                t = z(e, f);
                v = s(e, f);
                if (m.isXAxis) {
                    if (h = {
                            x: u ? v : t,
                            y: 0,
                            width: q,
                            height: k
                        }, !r) h.x = b.plotHeight - h.x
                } else if (h = {
                        x: 0,
                        y: u ? v : t,
                        width: k,
                        height: q
                    }, r) h.y = b.plotWidth - h.y;
                b.inverted && c.isVML && (h = m.isXAxis ? {
                    x: 0,
                    y: l ? t : v,
                    height: h.width,
                    width: b.chartWidth
                } : {
                    x: h.y - b.plotLeft - b.spacingBox.x,
                    y: 0,
                    width: h.height,
                    height: b.chartHeight
                });
                g[o] ? g[o].animate(h) : (g[o] = c.clipRect(h), i && a["zoneGraph" + o].clip(g[o]), j && a["zoneArea" +
                    o].clip(g[o]));
                y = d.value > n.max
            }), this.clips = g
        },
        invertGroups: function() {
            function a() {
                var a = {
                    width: b.yAxis.len,
                    height: b.xAxis.len
                };
                o(["group", "markerGroup"], function(c) {
                    b[c] && b[c].attr(a).invert()
                })
            }
            var b = this,
                c = b.chart;
            if (b.xAxis) I(c, "resize", a), I(b, "destroy", function() {
                Y(c, "resize", a)
            }), a(), b.invertGroups = a
        },
        plotGroup: function(a, b, c, d, e) {
            var f = this[a],
                g = !f;
            g && (this[a] = f = this.chart.renderer.g(b).attr({
                visibility: c,
                zIndex: d || 0.1
            }).add(e), f.addClass("highcharts-series-" + this.index));
            f[g ? "attr" : "animate"](this.getPlotBox());
            return f
        },
        getPlotBox: function() {
            var a = this.chart,
                b = this.xAxis,
                c = this.yAxis;
            if (a.inverted) b = c, c = this.xAxis;
            return {
                translateX: b ? b.left : a.plotLeft,
                translateY: c ? c.top : a.plotTop,
                scaleX: 1,
                scaleY: 1
            }
        },
        render: function() {
            var a = this,
                b = a.chart,
                c, d = a.options,
                e = (c = d.animation) && !!a.animate && b.renderer.isSVG && p(c.duration, 500) || 0,
                f = a.visible ? "visible" : "hidden",
                g = d.zIndex,
                h = a.hasRendered,
                i = b.seriesGroup;
            c = a.plotGroup("group", "series", f, g, i);
            a.markerGroup = a.plotGroup("markerGroup", "markers", f, g, i);
            e && a.animate(!0);
            a.getAttribs();
            c.inverted = a.isCartesian ? b.inverted : !1;
            a.drawGraph && (a.drawGraph(), a.applyZones());
            o(a.points, function(a) {
                a.redraw && a.redraw()
            });
            a.drawDataLabels && a.drawDataLabels();
            a.visible && a.drawPoints();
            a.drawTracker && a.options.enableMouseTracking !== !1 && a.drawTracker();
            b.inverted && a.invertGroups();
            d.clip !== !1 && !a.sharedClipKey && !h && c.clip(b.clipRect);
            e && a.animate();
            if (!h) e ? a.animationTimeout = setTimeout(function() {
                a.afterAnimate()
            }, e) : a.afterAnimate();
            a.isDirty = a.isDirtyData = !1;
            a.hasRendered = !0
        },
        redraw: function() {
            var a = this.chart,
                b = this.isDirtyData,
                c = this.isDirty,
                d = this.group,
                e = this.xAxis,
                f = this.yAxis;
            d && (a.inverted && d.attr({
                width: a.plotWidth,
                height: a.plotHeight
            }), d.animate({
                translateX: p(e && e.left, a.plotLeft),
                translateY: p(f && f.top, a.plotTop)
            }));
            this.translate();
            this.render();
            b && J(this, "updatedData");
            (c || b) && delete this.kdTree
        },
        kdDimensions: 1,
        kdAxisArray: ["clientX", "plotY"],
        searchPoint: function(a, b) {
            var c = this.xAxis,
                d = this.yAxis,
                e = this.chart.inverted;
            return this.searchKDTree({
                clientX: e ? c.len -
                    a.chartY + c.pos : a.chartX - c.pos,
                plotY: e ? d.len - a.chartX + d.pos : a.chartY - d.pos
            }, b)
        },
        buildKDTree: function() {
            function a(b, d, g) {
                var h, i;
                if (i = b && b.length) return h = c.kdAxisArray[d % g], b.sort(function(a, b) {
                    return a[h] - b[h]
                }), i = Math.floor(i / 2), {
                    point: b[i],
                    left: a(b.slice(0, i), d + 1, g),
                    right: a(b.slice(i + 1), d + 1, g)
                }
            }

            function b() {
                var b = kb(c.points || [], function(a) {
                    return a.y !== null
                });
                c.kdTree = a(b, d, d)
            }
            var c = this,
                d = c.kdDimensions;
            delete c.kdTree;
            c.options.kdSync ? b() : setTimeout(b)
        },
        searchKDTree: function(a, b) {
            function c(a, b, j, k) {
                var m = b.point,
                    n = d.kdAxisArray[j % k],
                    l, p, o = m;
                p = q(a[e]) && q(m[e]) ? Math.pow(a[e] - m[e], 2) : null;
                l = q(a[f]) && q(m[f]) ? Math.pow(a[f] - m[f], 2) : null;
                l = (p || 0) + (l || 0);
                m.dist = q(l) ? Math.sqrt(l) : Number.MAX_VALUE;
                m.distX = q(p) ? Math.sqrt(p) : Number.MAX_VALUE;
                n = a[n] - m[n];
                l = n < 0 ? "left" : "right";
                p = n < 0 ? "right" : "left";
                b[l] && (l = c(a, b[l], j + 1, k), o = l[g] < o[g] ? l : m);
                b[p] && Math.sqrt(n * n) < o[g] && (a = c(a, b[p], j + 1, k), o = a[g] < o[g] ? a : o);
                return o
            }
            var d = this,
                e = this.kdAxisArray[0],
                f = this.kdAxisArray[1],
                g = b ? "distX" : "dist";
            this.kdTree || this.buildKDTree();
            if (this.kdTree) return c(a, this.kdTree, this.kdDimensions, this.kdDimensions)
        }
    };
    Hb.prototype = {
        destroy: function() {
            Pa(this, this.axis)
        },
        render: function(a) {
            var b = this.options,
                c = b.format,
                c = c ? Ia(c, this) : b.formatter.call(this);
            this.label ? this.label.attr({
                text: c,
                visibility: "hidden"
            }) : this.label = this.axis.chart.renderer.text(c, null, null, b.useHTML).css(b.style).attr({
                align: this.textAlign,
                rotation: b.rotation,
                visibility: "hidden"
            }).add(a)
        },
        setOffset: function(a, b) {
            var c = this.axis,
                d = c.chart,
                e = d.inverted,
                f = c.reversed,
                f = this.isNegative && !f || !this.isNegative && f,
                g = c.translate(c.usePercentage ? 100 : this.total, 0, 0, 0, 1),
                c = c.translate(0),
                c = O(g - c),
                h = d.xAxis[0].translate(this.x) + a,
                i = d.plotHeight,
                f = {
                    x: e ? f ? g : g - c : h,
                    y: e ? i - h - b : f ? i - g - c : i - g,
                    width: e ? c : b,
                    height: e ? b : c
                };
            if (e = this.label) e.align(this.alignOptions, null, f), f = e.alignAttr, e[this.options.crop === !1 || d.isInsidePlot(f.x, f.y) ? "show" : "hide"](!0)
        }
    };
    E.prototype.getStacks = function() {
        var a = this;
        o(a.yAxis, function(a) {
            if (a.stacks && a.hasVisibleSeries) a.oldStacks = a.stacks
        });
        o(a.series, function(b) {
            if (b.options.stacking && (b.visible === !0 || a.options.chart.ignoreHiddenSeries === !1)) b.stackKey = b.type + p(b.options.stack, "")
        })
    };
    ha.prototype.buildStacks = function() {
        var a = this.series,
            b = p(this.options.reversedStacks, !0),
            c = a.length;
        if (!this.isXAxis) {
            for (this.usePercentage = !1; c--;) a[b ? c : a.length - c - 1].setStackedPoints();
            if (this.usePercentage)
                for (c = 0; c < a.length; c++) a[c].setPercentStacks()
        }
    };
    ha.prototype.renderStackTotals = function() {
        var a = this.chart,
            b = a.renderer,
            c = this.stacks,
            d, e, f = this.stackTotalGroup;
        if (!f) this.stackTotalGroup = f = b.g("stack-labels").attr({
            visibility: "visible",
            zIndex: 6
        }).add();
        f.translate(a.plotLeft, a.plotTop);
        for (d in c)
            for (e in a = c[d], a) a[e].render(f)
    };
    ha.prototype.resetStacks = function() {
        var a = this.stacks,
            b, c;
        if (!this.isXAxis)
            for (b in a)
                for (c in a[b]) a[b][c].touched < this.stacksTouched ? (a[b][c].destroy(), delete a[b][c]) : (a[b][c].total = null, a[b][c].cum = 0)
    };
    ha.prototype.cleanStacks = function() {
        var a, b, c;
        if (!this.isXAxis) {
            if (this.oldStacks) a = this.stacks = this.oldStacks;
            for (b in a)
                for (c in a[b]) a[b][c].cum = a[b][c].total
        }
    };
    R.prototype.setStackedPoints = function() {
        if (this.options.stacking && !(this.visible !== !0 && this.chart.options.chart.ignoreHiddenSeries !== !1)) {
            var a = this.processedXData,
                b = this.processedYData,
                c = [],
                d = b.length,
                e = this.options,
                f = e.threshold,
                g = e.startFromThreshold ? f : 0,
                h = e.stack,
                e = e.stacking,
                i = this.stackKey,
                j = "-" + i,
                k = this.negStacks,
                m = this.yAxis,
                n = m.stacks,
                l = m.oldStacks,
                o, r, q, t, v, w, x;
            m.stacksTouched += 1;
            for (v = 0; v < d; v++) {
                w = a[v];
                x = b[v];
                o = this.getStackIndicator(o, w, this.index);
                t = o.key;
                q = (r = k && x < (g ? 0 : f)) ? j : i;
                n[q] || (n[q] = {});
                if (!n[q][w]) l[q] && l[q][w] ? (n[q][w] = l[q][w], n[q][w].total = null) : n[q][w] = new Hb(m, m.options.stackLabels, r, w, h);
                q = n[q][w];
                q.points[t] = [p(q.cum, g)];
                q.touched = m.stacksTouched;
                e === "percent" ? (r = r ? i : j, k && n[r] && n[r][w] ? (r = n[r][w], q.total = r.total = s(r.total, q.total) + O(x) || 0) : q.total = ea(q.total + (O(x) || 0))) : q.total = ea(q.total + (x || 0));
                q.cum = p(q.cum, g) + (x || 0);
                q.points[t].push(q.cum);
                c[v] = q.cum
            }
            if (e === "percent") m.usePercentage = !0;
            this.stackedYData = c;
            m.oldStacks = {}
        }
    };
    R.prototype.setPercentStacks = function() {
        var a = this,
            b = a.stackKey,
            c = a.yAxis.stacks,
            d = a.processedXData,
            e;
        o([b, "-" + b], function(b) {
            var f;
            for (var g = d.length, h, i; g--;)
                if (h = d[g], e = a.getStackIndicator(e, h, a.index), f = (i = c[b] && c[b][h]) && i.points[e.key], h = f) i = i.total ? 100 / i.total : 0, h[0] = ea(h[0] * i), h[1] = ea(h[1] * i), a.stackedYData[g] = h[1]
        })
    };
    R.prototype.getStackIndicator = function(a, b, c) {
        !q(a) || a.x !== b ? a = {
            x: b,
            index: 0
        } : a.index++;
        a.key = [c, b, a.index].join(",");
        return a
    };
    t(E.prototype, {
        addSeries: function(a, b, c) {
            var d, e = this;
            a && (b = p(b, !0), J(e, "addSeries", {
                options: a
            }, function() {
                d = e.initSeries(a);
                e.isDirtyLegend = !0;
                e.linkSeries();
                b && e.redraw(c)
            }));
            return d
        },
        addAxis: function(a, b, c, d) {
            var e = b ? "xAxis" : "yAxis",
                f = this.options;
            new ha(this, D(a, {
                index: this[e].length,
                isX: b
            }));
            f[e] = ra(f[e] || {});
            f[e].push(a);
            p(c, !0) && this.redraw(d)
        },
        showLoading: function(a) {
            var b = this,
                c = b.options,
                d = b.loadingDiv,
                e = c.loading,
                f = function() {
                    d && M(d, {
                        left: b.plotLeft + "px",
                        top: b.plotTop + "px",
                        width: b.plotWidth + "px",
                        height: b.plotHeight + "px"
                    })
                };
            if (!d) b.loadingDiv = d = $(Ja, {
                className: "highcharts-loading"
            }, t(e.style, {
                zIndex: 10,
                display: P
            }), b.container), b.loadingSpan = $("span", null, e.labelStyle, d), I(b, "redraw", f);
            b.loadingSpan.innerHTML = a || c.lang.loading;
            if (!b.loadingShown) M(d, {
                opacity: 0,
                display: ""
            }), lb(d, {
                opacity: e.style.opacity
            }, {
                duration: e.showDuration || 0
            }), b.loadingShown = !0;
            f()
        },
        hideLoading: function() {
            var a = this.options,
                b = this.loadingDiv;
            b && lb(b, {
                opacity: 0
            }, {
                duration: a.loading.hideDuration || 100,
                complete: function() {
                    M(b, {
                        display: P
                    })
                }
            });
            this.loadingShown = !1
        }
    });
    t(Fa.prototype, {
        update: function(a, b, c, d) {
            function e() {
                f.applyOptions(a);
                if (f.y === null && h) f.graphic = h.destroy();
                if (da(a) && !Ga(a)) f.redraw = function() {
                    if (h && h.element && a && a.marker && a.marker.symbol) f.graphic = h.destroy();
                    if (a && a.dataLabels && f.dataLabel) f.dataLabel = f.dataLabel.destroy();
                    f.redraw = null
                };
                i = f.index;
                g.updateParallelArrays(f, i);
                if (m && f.name) m[f.x] = f.name;
                k.data[i] = f.options;
                g.isDirty = g.isDirtyData = !0;
                if (!g.fixedBox && g.hasCartesianSeries) j.isDirtyBox = !0;
                if (k.legendType === "point") j.isDirtyLegend = !0;
                b && j.redraw(c)
            }
            var f = this,
                g = f.series,
                h = f.graphic,
                i, j = g.chart,
                k = g.options,
                m = g.xAxis && g.xAxis.names,
                b = p(b, !0);
            d === !1 ? e() : f.firePointEvent("update", {
                options: a
            }, e)
        },
        remove: function(a, b) {
            this.series.removePoint(La(this, this.series.data), a, b)
        }
    });
    t(R.prototype, {
        addPoint: function(a, b, c, d) {
            var e = this,
                f = e.options,
                g = e.data,
                h = e.graph,
                i = e.area,
                j = e.chart,
                k = e.xAxis && e.xAxis.names,
                m = h && h.shift || 0,
                n = ["graph", "area"],
                h = f.data,
                l, u = e.xData;
            Ra(d, j);
            if (c) {
                for (d = e.zones.length; d--;) n.push("zoneGraph" + d, "zoneArea" + d);
                o(n, function(a) {
                    if (e[a]) e[a].shift = m + (f.step ? 2 : 1)
                })
            }
            if (i) i.isArea = !0;
            b = p(b, !0);
            i = {
                series: e
            };
            e.pointClass.prototype.applyOptions.apply(i, [a]);
            n = i.x;
            d = u.length;
            if (e.requireSorting && n < u[d - 1])
                for (l = !0; d && u[d - 1] > n;) d--;
            e.updateParallelArrays(i, "splice", d, 0, 0);
            e.updateParallelArrays(i, d);
            if (k && i.name) k[n] = i.name;
            h.splice(d, 0, a);
            l && (e.data.splice(d, 0, null), e.processData());
            f.legendType === "point" && e.generatePoints();
            c && (g[0] && g[0].remove ? g[0].remove(!1) : (g.shift(), e.updateParallelArrays(i, "shift"), h.shift()));
            e.isDirty = !0;
            e.isDirtyData = !0;
            b && (e.getAttribs(), j.redraw())
        },
        removePoint: function(a, b, c) {
            var d = this,
                e = d.data,
                f = e[a],
                g = d.points,
                h = d.chart,
                i = function() {
                    e.length === g.length && g.splice(a, 1);
                    e.splice(a, 1);
                    d.options.data.splice(a, 1);
                    d.updateParallelArrays(f || {
                        series: d
                    }, "splice", a, 1);
                    f && f.destroy();
                    d.isDirty = !0;
                    d.isDirtyData = !0;
                    b && h.redraw()
                };
            Ra(c, h);
            b = p(b, !0);
            f ? f.firePointEvent("remove", null, i) : i()
        },
        remove: function(a, b) {
            var c = this,
                d = c.chart,
                a = p(a, !0);
            if (!c.isRemoving) c.isRemoving = !0, J(c, "remove", null, function() {
                c.destroy();
                d.isDirtyLegend = d.isDirtyBox = !0;
                d.linkSeries();
                a && d.redraw(b)
            });
            c.isRemoving = !1
        },
        update: function(a, b) {
            var c = this,
                d = this.chart,
                e = this.userOptions,
                f = this.type,
                g = N[f].prototype,
                h = ["group", "markerGroup", "dataLabelsGroup"],
                i;
            if (a.type && a.type !== f || a.zIndex !== void 0) h.length = 0;
            o(h, function(a) {
                h[a] = c[a];
                delete c[a]
            });
            a = D(e, {
                animation: !1,
                index: this.index,
                pointStart: this.xData[0]
            }, {
                data: this.options.data
            }, a);
            this.remove(!1);
            for (i in g) this[i] = x;
            t(this, N[a.type || f].prototype);
            o(h, function(a) {
                c[a] = h[a]
            });
            this.init(d, a);
            d.linkSeries();
            p(b, !0) && d.redraw(!1)
        }
    });
    t(ha.prototype, {
        update: function(a, b) {
            var c = this.chart,
                a = c.options[this.coll][this.options.index] = D(this.userOptions, a);
            this.destroy(!0);
            this._addedPlotLB = this.chart._labelPanes = x;
            this.init(c, t(a, {
                events: x
            }));
            c.isDirtyBox = !0;
            p(b, !0) && c.redraw()
        },
        remove: function(a) {
            for (var b = this.chart, c = this.coll, d = this.series, e = d.length; e--;) d[e] && d[e].remove(!1);
            ja(b.axes, this);
            ja(b[c], this);
            b.options[c].splice(this.options.index, 1);
            o(b[c], function(a, b) {
                a.options.index = b
            });
            this.destroy();
            b.isDirtyBox = !0;
            p(a, !0) && b.redraw()
        },
        setTitle: function(a, b) {
            this.update({
                title: a
            }, b)
        },
        setCategories: function(a, b) {
            this.update({
                categories: a
            }, b)
        }
    });
    var xa = ka(R);
    N.line = xa;
    ba.area = D(U, {
        softThreshold: !1,
        threshold: 0
    });
    var pa = ka(R, {
        type: "area",
        getSegments: function() {
            var a = this,
                b = [],
                c = [],
                d = [],
                e = this.xAxis,
                f = this.yAxis,
                g = f.stacks[this.stackKey],
                h = {},
                i, j, k = this.points,
                m = this.options.connectNulls,
                n, l, p;
            if (this.options.stacking && !this.cropped) {
                for (l = 0; l < k.length; l++) h[k[l].x] = k[l];
                for (p in g) g[p].total !== null && d.push(+p);
                d.sort(function(a, b) {
                    return a - b
                });
                o(d, function(b) {
                    var d = null,
                        k;
                    if (!m || h[b] && h[b].y !== null)
                        if (h[b]) c.push(h[b]);
                        else {
                            for (l = a.index; l <= f.series.length; l++)
                                if (n = a.getStackIndicator(null, b, l), k = g[b].points[n.key]) {
                                    d = k[1];
                                    break
                                }
                            i = e.translate(b);
                            j = f.getThreshold(d);
                            c.push({
                                y: null,
                                plotX: i,
                                clientX: i,
                                plotY: j,
                                yBottom: j,
                                onMouseOver: ua
                            })
                        }
                });
                c.length && b.push(c)
            } else R.prototype.getSegments.call(this), b = this.segments;
            this.segments = b
        },
        getSegmentPath: function(a) {
            var b = R.prototype.getSegmentPath.call(this, a),
                c = [].concat(b),
                d, e = this.options;
            d = b.length;
            var f = this.yAxis.getThreshold(e.threshold),
                g;
            d === 3 && c.push("L", b[1], b[2]);
            if (e.stacking && !this.closedStacks)
                for (d = a.length - 1; d >= 0; d--) g = p(a[d].yBottom, f), d < a.length - 1 && e.step && c.push(a[d + 1].plotX, g), c.push(a[d].plotX, g);
            else this.closeSegment(c, a, f);
            this.areaPath = this.areaPath.concat(c);
            return b
        },
        closeSegment: function(a, b, c) {
            a.push("L", b[b.length - 1].plotX, c, "L", b[0].plotX, c)
        },
        drawGraph: function() {
            this.areaPath = [];
            R.prototype.drawGraph.apply(this);
            var a = this,
                b = this.areaPath,
                c = this.options,
                d = [
                    ["area", this.color, c.fillColor]
                ];
            o(this.zones, function(b, f) {
                d.push(["zoneArea" + f, b.color || a.color, b.fillColor || c.fillColor])
            });
            o(d, function(d) {
                var f = d[0],
                    g = a[f];
                g ? g.animate({
                    d: b
                }) : a[f] = a.chart.renderer.path(b).attr({
                    fill: p(d[2], na(d[1]).setOpacity(p(c.fillOpacity, 0.75)).get()),
                    zIndex: 0
                }).add(a.group)
            })
        },
        drawLegendSymbol: Ma.drawRectangle
    });
    N.area = pa;
    ba.spline = D(U);
    xa = ka(R, {
        type: "spline",
        getPointSpline: function(a, b, c) {
            var d = b.plotX,
                e = b.plotY,
                f = a[c - 1],
                g = a[c + 1],
                h, i, j, k;
            if (f && g) {
                a = f.plotY;
                j = g.plotX;
                var g = g.plotY,
                    m;
                h = (1.5 * d + f.plotX) / 2.5;
                i = (1.5 * e + a) / 2.5;
                j = (1.5 * d + j) / 2.5;
                k = (1.5 * e + g) / 2.5;
                m = (k - i) * (j - d) / (j - h) + e - k;
                i += m;
                k += m;
                i > a && i > e ? (i = s(a, e), k = 2 * e - i) : i < a && i < e && (i = z(a, e), k = 2 * e - i);
                k > g && k > e ? (k = s(g, e), i = 2 * e - k) : k < g && k < e && (k = z(g, e), i = 2 * e - k);
                b.rightContX = j;
                b.rightContY = k
            }
            c ? (b = ["C", f.rightContX || f.plotX, f.rightContY || f.plotY, h || d, i || e, d, e], f.rightContX = f.rightContY = null) : b = ["M", d, e];
            return b
        }
    });
    N.spline = xa;
    ba.areaspline = D(ba.area);
    pa = pa.prototype;
    xa = ka(xa, {
        type: "areaspline",
        closedStacks: !0,
        getSegmentPath: pa.getSegmentPath,
        closeSegment: pa.closeSegment,
        drawGraph: pa.drawGraph,
        drawLegendSymbol: Ma.drawRectangle
    });
    N.areaspline = xa;
    ba.column = D(U, {
        borderColor: "#FFFFFF",
        borderRadius: 0,
        groupPadding: 0.2,
        marker: null,
        pointPadding: 0.1,
        minPointLength: 0,
        cropThreshold: 50,
        pointRange: null,
        states: {
            hover: {
                brightness: 0.1,
                shadow: !1,
                halo: !1
            },
            select: {
                color: "#C0C0C0",
                borderColor: "#000000",
                shadow: !1
            }
        },
        dataLabels: {
            align: null,
            verticalAlign: null,
            y: null
        },
        softThreshold: !1,
        startFromThreshold: !0,
        stickyTracking: !1,
        tooltip: {
            distance: 6
        },
        threshold: 0
    });
    xa = ka(R, {
        type: "column",
        pointAttrToOptions: {
            stroke: "borderColor",
            fill: "color",
            r: "borderRadius"
        },
        cropShoulder: 0,
        directTouch: !0,
        trackerGroups: ["group", "dataLabelsGroup"],
        negStacks: !0,
        init: function() {
            R.prototype.init.apply(this, arguments);
            var a = this,
                b = a.chart;
            b.hasRendered && o(b.series, function(b) {
                if (b.type === a.type) b.isDirty = !0
            })
        },
        getColumnMetrics: function() {
            var a = this,
                b = a.options,
                c = a.xAxis,
                d = a.yAxis,
                e = c.reversed,
                f, g = {},
                h, i = 0;
            b.grouping === !1 ? i = 1 : o(a.chart.series, function(b) {
                var c = b.options,
                    e = b.yAxis;
                if (b.type === a.type && b.visible && d.len === e.len && d.pos === e.pos) c.stacking ? (f = b.stackKey, g[f] === x && (g[f] = i++), h = g[f]) : c.grouping !== !1 && (h = i++), b.columnIndex = h
            });
            var j = z(O(c.transA) * (c.ordinalSlope || b.pointRange || c.closestPointRange || c.tickInterval || 1), c.len),
                k = j * b.groupPadding,
                m = (j - 2 * k) / i,
                b = z(b.maxPointWidth || c.len, p(b.pointWidth, m * (1 - 2 * b.pointPadding)));
            return a.columnMetrics = {
                width: b,
                offset: (m - b) / 2 + (k + ((e ? i - (a.columnIndex || 0) : a.columnIndex) || 0) * m - j / 2) * (e ? -1 : 1)
            }
        },
        crispCol: function(a, b, c, d) {
            var e = this.chart,
                f = this.borderWidth,
                g = -(f % 2 ? 0.5 : 0),
                f = f % 2 ? 0.5 : 1;
            e.inverted && e.renderer.isVML && (f += 1);
            c = Math.round(a + c) + g;
            a = Math.round(a) + g;
            c -= a;
            g = O(b) <= 0.5;
            d = Math.round(b + d) + f;
            b = Math.round(b) + f;
            d -= b;
            g && (b -= 1, d += 1);
            return {
                x: a,
                y: b,
                width: c,
                height: d
            }
        },
        translate: function() {
            var a = this,
                b = a.chart,
                c = a.options,
                d = a.borderWidth = p(c.borderWidth, a.closestPointRange * a.xAxis.transA < 2 ? 0 : 1),
                e = a.yAxis,
                f = a.translatedThreshold = e.getThreshold(c.threshold),
                g = p(c.minPointLength, 5),
                h = a.getColumnMetrics(),
                i = h.width,
                j = a.barW = s(i, 1 + 2 * d),
                k = a.pointXOffset = h.offset;
            b.inverted && (f -= 0.5);
            c.pointPadding && (j = ta(j));
            R.prototype.translate.apply(a);
            o(a.points, function(c) {
                var d = z(p(c.yBottom, f), 9E4),
                    h = 999 + O(d),
                    h = z(s(-h, c.plotY), e.len + h),
                    o = c.plotX + k,
                    q = j,
                    t = z(h, d),
                    w, v = s(h, d) - t;
                O(v) < g && g && (v = g, w = !e.reversed && !c.negative || e.reversed && c.negative, t = O(t - f) > g ? d - g : f - (w ? g : 0));
                c.barX = o;
                c.pointWidth = i;
                c.tooltipPos = b.inverted ? [e.len + e.pos - b.plotLeft - h, a.xAxis.len - o - q / 2, v] : [o + q / 2, h + e.pos - b.plotTop, v];
                c.shapeType = "rect";
                c.shapeArgs = a.crispCol(o, t, q, v)
            })
        },
        getSymbol: ua,
        drawLegendSymbol: Ma.drawRectangle,
        drawGraph: ua,
        drawPoints: function() {
            var a = this,
                b = this.chart,
                c = a.options,
                d = b.renderer,
                e = c.animationLimit || 250,
                f, g;
            o(a.points, function(h) {
                var i = h.plotY,
                    j = h.graphic;
                if (i !== x && !isNaN(i) && h.y !== null) f = h.shapeArgs, i = q(a.borderWidth) ? {
                    "stroke-width": a.borderWidth
                } : {}, g = h.pointAttr[h.selected ? "select" : ""] || a.pointAttr[""], j ? (cb(j), j.attr(i)[b.pointCount < e ? "animate" : "attr"](D(f))) : h.graphic = d[h.shapeType](f).attr(i).attr(g).add(h.group || a.group).shadow(c.shadow, null, c.stacking && !c.borderRadius);
                else if (j) h.graphic = j.destroy()
            })
        },
        animate: function(a) {
            var b = this.yAxis,
                c = this.options,
                d = this.chart.inverted,
                e = {};
            if (ca) a ? (e.scaleY = 0.001, a = z(b.pos + b.len, s(b.pos, b.toPixels(c.threshold))), d ? e.translateX = a - b.len : e.translateY = a, this.group.attr(e)) : (e.scaleY = 1, e[d ? "translateX" : "translateY"] = b.pos, this.group.animate(e, this.options.animation), this.animate = null)
        },
        remove: function() {
            var a = this,
                b = a.chart;
            b.hasRendered && o(b.series, function(b) {
                if (b.type === a.type) b.isDirty = !0
            });
            R.prototype.remove.apply(a, arguments)
        }
    });
    N.column = xa;
    ba.bar = D(ba.column);
    pa = ka(xa, {
        type: "bar",
        inverted: !0
    });
    N.bar = pa;
    ba.scatter = D(U, {
        lineWidth: 0,
        marker: {
            enabled: !0
        },
        tooltip: {
            headerFormat: '<span style="color:{point.color}">\u25cf</span> <span style="font-size: 10px;"> {series.name}</span><br/>',
            pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
        }
    });
    pa = ka(R, {
        type: "scatter",
        sorted: !1,
        requireSorting: !1,
        noSharedTooltip: !0,
        trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
        takeOrdinalPosition: !1,
        kdDimensions: 2,
        drawGraph: function() {
            this.options.lineWidth && R.prototype.drawGraph.call(this)
        }
    });
    N.scatter = pa;
    ba.pie = D(U, {
        borderColor: "#FFFFFF",
        borderWidth: 1,
        center: [null, null],
        clip: !1,
        colorByPoint: !0,
        dataLabels: {
            distance: 30,
            enabled: !0,
            formatter: function() {
                return this.y === null ? void 0 : this.point.name
            },
            x: 0
        },
        ignoreHiddenPoint: !0,
        legendType: "point",
        marker: null,
        size: null,
        showInLegend: !1,
        slicedOffset: 10,
        states: {
            hover: {
                brightness: 0.1,
                shadow: !1
            }
        },
        stickyTracking: !1,
        tooltip: {
            followPointer: !0
        }
    });
    U = {
        type: "pie",
        isCartesian: !1,
        pointClass: ka(Fa, {
            init: function() {
                Fa.prototype.init.apply(this, arguments);
                var a = this,
                    b;
                a.name = p(a.name, "Slice");
                b = function(b) {
                    a.slice(b.type === "select")
                };
                I(a, "select", b);
                I(a, "unselect", b);
                return a
            },
            setVisible: function(a, b) {
                var c = this,
                    d = c.series,
                    e = d.chart,
                    f = d.options.ignoreHiddenPoint,
                    b = p(b, f);
                if (a !== c.visible) {
                    c.visible = c.options.visible = a = a === x ? !c.visible : a;
                    d.options.data[La(c, d.data)] = c.options;
                    o(["graphic", "dataLabel", "connector", "shadowGroup"], function(b) {
                        if (c[b]) c[b][a ? "show" : "hide"](!0)
                    });
                    c.legendItem && e.legend.colorizeItem(c, a);
                    !a && c.state === "hover" && c.setState("");
                    if (f) d.isDirty = !0;
                    b && e.redraw()
                }
            },
            slice: function(a, b, c) {
                var d = this.series;
                Ra(c, d.chart);
                p(b, !0);
                this.sliced = this.options.sliced = a = q(a) ? a : !this.sliced;
                d.options.data[La(this, d.data)] = this.options;
                a = a ? this.slicedTranslation : {
                    translateX: 0,
                    translateY: 0
                };
                this.graphic.animate(a);
                this.shadowGroup && this.shadowGroup.animate(a)
            },
            haloPath: function(a) {
                var b = this.shapeArgs,
                    c = this.series.chart;
                return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(c.plotLeft + b.x, c.plotTop + b.y, b.r + a, b.r + a, {
                    innerR: this.shapeArgs.r,
                    start: b.start,
                    end: b.end
                })
            }
        }),
        requireSorting: !1,
        directTouch: !0,
        noSharedTooltip: !0,
        trackerGroups: ["group", "dataLabelsGroup"],
        axisTypes: [],
        pointAttrToOptions: {
            stroke: "borderColor",
            "stroke-width": "borderWidth",
            fill: "color"
        },
        animate: function(a) {
            var b = this,
                c = b.points,
                d = b.startAngleRad;
            if (!a) o(c, function(a) {
                var c = a.graphic,
                    g = a.shapeArgs;
                c && (c.attr({
                    r: a.startR || b.center[3] / 2,
                    start: d,
                    end: d
                }), c.animate({
                    r: g.r,
                    start: g.start,
                    end: g.end
                }, b.options.animation))
            }), b.animate = null
        },
        updateTotals: function() {
            var a, b = 0,
                c = this.points,
                d = c.length,
                e, f = this.options.ignoreHiddenPoint;
            for (a = 0; a < d; a++) e = c[a], b += f && !e.visible ? 0 : e.y;
            this.total = b;
            for (a = 0; a < d; a++) e = c[a], e.percentage = b > 0 && (e.visible || !f) ? e.y / b * 100 : 0, e.total = b
        },
        generatePoints: function() {
            R.prototype.generatePoints.call(this);
            this.updateTotals()
        },
        translate: function(a) {
            this.generatePoints();
            var b = 0,
                c = this.options,
                d = c.slicedOffset,
                e = d + c.borderWidth,
                f, g, h, i = c.startAngle || 0,
                j = this.startAngleRad = ma / 180 * (i - 90),
                i = (this.endAngleRad = ma / 180 * (p(c.endAngle, i + 360) - 90)) - j,
                k = this.points,
                m = c.dataLabels.distance,
                c = c.ignoreHiddenPoint,
                n, l = k.length,
                o;
            if (!a) this.center = a = this.getCenter();
            this.getX = function(b, c) {
                h = V.asin(z((b - a[1]) / (a[2] / 2 + m), 1));
                return a[0] + (c ? -1 : 1) * W(h) * (a[2] / 2 + m)
            };
            for (n = 0; n < l; n++) {
                o = k[n];
                f = j + b * i;
                if (!c || o.visible) b += o.percentage / 100;
                g = j + b * i;
                o.shapeType = "arc";
                o.shapeArgs = {
                    x: a[0],
                    y: a[1],
                    r: a[2] / 2,
                    innerR: a[3] / 2,
                    start: w(f * 1E3) / 1E3,
                    end: w(g * 1E3) / 1E3
                };
                h = (g + f) / 2;
                h > 1.5 * ma ? h -= 2 * ma : h < -ma / 2 && (h += 2 * ma);
                o.slicedTranslation = {
                    translateX: w(W(h) * d),
                    translateY: w(aa(h) * d)
                };
                f = W(h) * a[2] / 2;
                g = aa(h) * a[2] / 2;
                o.tooltipPos = [a[0] + f * 0.7, a[1] + g * 0.7];
                o.half = h < -ma / 2 || h > ma / 2 ? 1 : 0;
                o.angle = h;
                e = z(e, m / 2);
                o.labelPos = [a[0] + f + W(h) * m, a[1] + g + aa(h) * m, a[0] + f + W(h) * e, a[1] + g + aa(h) * e, a[0] + f, a[1] + g, m < 0 ? "center" : o.half ? "right" : "left", h]
            }
        },
        drawGraph: null,
        drawPoints: function() {
            var a = this,
                b = a.chart.renderer,
                c, d, e = a.options.shadow,
                f, g, h;
            if (e && !a.shadowGroup) a.shadowGroup = b.g("shadow").add(a.group);
            o(a.points, function(i) {
                if (i.y !== null) {
                    d = i.graphic;
                    g = i.shapeArgs;
                    f = i.shadowGroup;
                    if (e && !f) f = i.shadowGroup = b.g("shadow").add(a.shadowGroup);
                    c = i.sliced ? i.slicedTranslation : {
                        translateX: 0,
                        translateY: 0
                    };
                    f && f.attr(c);
                    if (d) d.setRadialReference(a.center).animate(t(g, c));
                    else {
                        h = {
                            "stroke-linejoin": "round"
                        };
                        if (!i.visible) h.visibility = "hidden";
                        i.graphic = d = b[i.shapeType](g).setRadialReference(a.center).attr(i.pointAttr[i.selected ? "select" : ""]).attr(h).attr(c).add(a.group).shadow(e, f)
                    }
                }
            })
        },
        searchPoint: ua,
        sortByAngle: function(a, b) {
            a.sort(function(a, d) {
                return a.angle !== void 0 && (d.angle - a.angle) * b
            })
        },
        drawLegendSymbol: Ma.drawRectangle,
        getCenter: Xb.getCenter,
        getSymbol: ua
    };
    U = ka(R, U);
    N.pie = U;
    R.prototype.drawDataLabels = function() {
        var a = this,
            b = a.options,
            c = b.cursor,
            d = b.dataLabels,
            e = a.points,
            f, g, h = a.hasRendered || 0,
            i, j, k = a.chart.renderer;
        if (d.enabled || a._hasPointLabels) a.dlProcessOptions && a.dlProcessOptions(d), j = a.plotGroup("dataLabelsGroup", "data-labels", d.defer ? "hidden" : "visible", d.zIndex || 6), p(d.defer, !0) && (j.attr({
            opacity: +h
        }), h || I(a, "afterAnimate", function() {
            a.visible && j.show();
            j[b.animation ? "animate" : "attr"]({
                opacity: 1
            }, {
                duration: 200
            })
        })), g = d, o(e, function(e) {
            var h, l = e.dataLabel,
                o, r, s = e.connector,
                w = !0,
                v, y = {};
            f = e.dlOptions || e.options && e.options.dataLabels;
            h = p(f && f.enabled, g.enabled);
            if (l && !h) e.dataLabel = l.destroy();
            else if (h) {
                d = D(g, f);
                v = d.style;
                h = d.rotation;
                o = e.getLabelConfig();
                i = d.format ? Ia(d.format, o) : d.formatter.call(o, d);
                v.color = p(d.color, v.color, a.color, "black");
                if (l)
                    if (q(i)) l.attr({
                        text: i
                    }), w = !1;
                    else {
                        if (e.dataLabel = l = l.destroy(), s) e.connector = s.destroy()
                    }
                else if (q(i)) {
                    l = {
                        fill: d.backgroundColor,
                        stroke: d.borderColor,
                        "stroke-width": d.borderWidth,
                        r: d.borderRadius || 0,
                        rotation: h,
                        padding: d.padding,
                        zIndex: 1
                    };
                    if (v.color === "contrast") y.color = d.inside || d.distance < 0 || b.stacking ? k.getContrast(e.color || a.color) : "#000000";
                    if (c) y.cursor = c;
                    for (r in l) l[r] === x && delete l[r];
                    l = e.dataLabel = k[h ? "text" : "label"](i, 0, -999, d.shape, null, null, d.useHTML).attr(l).css(t(v, y)).add(j).shadow(d.shadow)
                }
                l && a.alignDataLabel(e, l, d, null, w)
            }
        })
    };
    R.prototype.alignDataLabel = function(a, b, c, d, e) {
        var f = this.chart,
            g = f.inverted,
            h = p(a.plotX, -999),
            i = p(a.plotY, -999),
            j = b.getBBox(),
            k = f.renderer.fontMetrics(c.style.fontSize).b,
            m = this.visible && (a.series.forceDL || f.isInsidePlot(h, w(i), g) || d && f.isInsidePlot(h, g ? d.x + 1 : d.y + d.height - 1, g));
        if (m) d = t({
            x: g ? f.plotWidth - i : h,
            y: w(g ? f.plotHeight - h : i),
            width: 0,
            height: 0
        }, d), t(c, {
            width: j.width,
            height: j.height
        }), c.rotation ? (a = f.renderer.rotCorr(k, c.rotation), b[e ? "attr" : "animate"]({
            x: d.x + c.x + d.width / 2 + a.x,
            y: d.y + c.y + d.height / 2
        }).attr({
            align: c.align
        })) : (b.align(c, null, d), g = b.alignAttr, p(c.overflow, "justify") === "justify" ? this.justifyDataLabel(b, c, g, j, d, e) : p(c.crop, !0) && (m = f.isInsidePlot(g.x, g.y) && f.isInsidePlot(g.x + j.width, g.y + j.height)), c.shape && b.attr({
            anchorX: a.plotX,
            anchorY: a.plotY
        }));
        if (!m) cb(b), b.attr({
            y: -999
        }), b.placed = !1
    };
    R.prototype.justifyDataLabel = function(a, b, c, d, e, f) {
        var g = this.chart,
            h = b.align,
            i = b.verticalAlign,
            j, k, m = a.box ? 0 : a.padding || 0;
        j = c.x + m;
        if (j < 0) h === "right" ? b.align = "left" : b.x = -j, k = !0;
        j = c.x + d.width - m;
        if (j > g.plotWidth) h === "left" ? b.align = "right" : b.x = g.plotWidth - j, k = !0;
        j = c.y + m;
        if (j < 0) i === "bottom" ? b.verticalAlign = "top" : b.y = -j, k = !0;
        j = c.y + d.height - m;
        if (j > g.plotHeight) i === "top" ? b.verticalAlign = "bottom" : b.y = g.plotHeight - j, k = !0;
        if (k) a.placed = !f, a.align(b, null, e)
    };
    if (N.pie) N.pie.prototype.drawDataLabels = function() {
        var a = this,
            b = a.data,
            c, d = a.chart,
            e = a.options.dataLabels,
            f = p(e.connectorPadding, 10),
            g = p(e.connectorWidth, 1),
            h = d.plotWidth,
            i = d.plotHeight,
            j, k, m = p(e.softConnector, !0),
            n = e.distance,
            l = a.center,
            q = l[2] / 2,
            r = l[1],
            t = n > 0,
            x, v, y, D = [
                [],
                []
            ],
            C, B, E, G, H, F = [0, 0, 0, 0],
            M = function(a, b) {
                return b.y - a.y
            };
        if (a.visible && (e.enabled || a._hasPointLabels)) {
            R.prototype.drawDataLabels.apply(a);
            o(b, function(a) {
                a.dataLabel && a.visible && D[a.half].push(a)
            });
            for (G = 2; G--;) {
                var J = [],
                    N = [],
                    I = D[G],
                    L = I.length,
                    K;
                if (L) {
                    a.sortByAngle(I, G - 0.5);
                    for (H = b = 0; !b && I[H];) b = I[H] && I[H].dataLabel && (I[H].dataLabel.getBBox().height || 21), H++;
                    if (n > 0) {
                        v = z(r + q + n, d.plotHeight);
                        for (H = s(0, r - q - n); H <= v; H += b) J.push(H);
                        v = J.length;
                        if (L > v) {
                            c = [].concat(I);
                            c.sort(M);
                            for (H = L; H--;) c[H].rank = H;
                            for (H = L; H--;) I[H].rank >= v && I.splice(H, 1);
                            L = I.length
                        }
                        for (H = 0; H < L; H++) {
                            c = I[H];
                            y = c.labelPos;
                            c = 9999;
                            var Q, P;
                            for (P = 0; P < v; P++) Q = O(J[P] - y[1]), Q < c && (c = Q, K = P);
                            if (K < H && J[H] !== null) K = H;
                            else
                                for (v < L - H + K && J[H] !== null && (K = v - L + H); J[K] === null;) K++;
                            N.push({
                                i: K,
                                y: J[K]
                            });
                            J[K] = null
                        }
                        N.sort(M)
                    }
                    for (H = 0; H < L; H++) {
                        c = I[H];
                        y = c.labelPos;
                        x = c.dataLabel;
                        E = c.visible === !1 ? "hidden" : "inherit";
                        c = y[1];
                        if (n > 0) {
                            if (v = N.pop(), K = v.i, B = v.y, c > B && J[K + 1] !== null || c < B && J[K - 1] !== null) B = z(s(0, c), d.plotHeight)
                        } else B = c;
                        C = e.justify ? l[0] + (G ? -1 : 1) * (q + n) : a.getX(B === r - q - n || B === r + q + n ? c : B, G);
                        x._attr = {
                            visibility: E,
                            align: y[6]
                        };
                        x._pos = {
                            x: C + e.x + ({
                                left: f,
                                right: -f
                            }[y[6]] || 0),
                            y: B + e.y - 10
                        };
                        x.connX = C;
                        x.connY = B;
                        if (this.options.size === null) v = x.width, C - v < f ? F[3] = s(w(v - C + f), F[3]) : C + v > h - f && (F[1] = s(w(C + v - h + f), F[1])), B - b / 2 < 0 ? F[0] = s(w(-B + b / 2), F[0]) : B + b / 2 > i && (F[2] = s(w(B + b / 2 - i), F[2]))
                    }
                }
            }
            if (Da(F) === 0 || this.verifyDataLabelOverflow(F)) this.placeDataLabels(), t && g && o(this.points, function(b) {
                j = b.connector;
                y = b.labelPos;
                if ((x = b.dataLabel) && x._pos && b.visible) E = x._attr.visibility, C = x.connX, B = x.connY, k = m ? ["M", C + (y[6] === "left" ? 5 : -5), B, "C", C, B, 2 * y[2] - y[4], 2 * y[3] - y[5], y[2], y[3], "L", y[4], y[5]] : ["M", C + (y[6] === "left" ? 5 : -5), B, "L", y[2], y[3], "L", y[4], y[5]], j ? (j.animate({
                    d: k
                }), j.attr("visibility", E)) : b.connector = j = a.chart.renderer.path(k).attr({
                    "stroke-width": g,
                    stroke: e.connectorColor || b.color || "#606060",
                    visibility: E
                }).add(a.dataLabelsGroup);
                else if (j) b.connector = j.destroy()
            })
        }
    }, N.pie.prototype.placeDataLabels = function() {
        o(this.points, function(a) {
            var b = a.dataLabel;
            if (b && a.visible)(a = b._pos) ? (b.attr(b._attr), b[b.moved ? "animate" : "attr"](a), b.moved = !0) : b && b.attr({
                y: -999
            })
        })
    }, N.pie.prototype.alignDataLabel = ua, N.pie.prototype.verifyDataLabelOverflow = function(a) {
        var b = this.center,
            c = this.options,
            d = c.center,
            e = c.minSize || 80,
            f = e,
            g;
        d[0] !== null ? f = s(b[2] - s(a[1], a[3]), e) : (f = s(b[2] - a[1] - a[3], e), b[0] += (a[3] - a[1]) / 2);
        d[1] !== null ? f = s(z(f, b[2] - s(a[0], a[2])), e) : (f = s(z(f, b[2] - a[0] - a[2]), e), b[1] += (a[0] - a[2]) / 2);
        f < b[2] ? (b[2] = f, b[3] = Math.min(/%$/.test(c.innerSize || 0) ? f * parseFloat(c.innerSize || 0) / 100 : parseFloat(c.innerSize || 0), f), this.translate(b), o(this.points, function(a) {
            if (a.dataLabel) a.dataLabel._pos = null
        }), this.drawDataLabels && this.drawDataLabels()) : g = !0;
        return g
    };
    if (N.column) N.column.prototype.alignDataLabel = function(a, b, c, d, e) {
        var f = this.chart.inverted,
            g = a.series,
            h = a.dlBox || a.shapeArgs,
            i = p(a.below, a.plotY > p(this.translatedThreshold, g.yAxis.len)),
            j = p(c.inside, !!this.options.stacking);
        if (h && (d = D(h), f && (d = {
                x: g.yAxis.len - d.y - d.height,
                y: g.xAxis.len - d.x - d.width,
                width: d.height,
                height: d.width
            }), !j)) f ? (d.x += i ? 0 : d.width, d.width = 0) : (d.y += i ? d.height : 0, d.height = 0);
        c.align = p(c.align, !f || j ? "center" : i ? "right" : "left");
        c.verticalAlign = p(c.verticalAlign, f || j ? "middle" : i ? "top" : "bottom");
        R.prototype.alignDataLabel.call(this, a, b, c, d, e)
    };
    (function(a) {
        var b = a.Chart,
            c = a.each,
            d = a.pick,
            e = HighchartsAdapter.addEvent;
        b.prototype.callbacks.push(function(a) {
            function b() {
                var e = [];
                c(a.series, function(a) {
                    var b = a.options.dataLabels,
                        f = a.dataLabelCollections || ["dataLabel"];
                    (b.enabled || a._hasPointLabels) && !b.allowOverlap && a.visible && c(f, function(b) {
                        c(a.points, function(a) {
                            if (a[b]) a[b].labelrank = d(a.labelrank, a.shapeArgs && a.shapeArgs.height), e.push(a[b])
                        })
                    })
                });
                a.hideOverlappingLabels(e)
            }
            b();
            e(a, "redraw", b)
        });
        b.prototype.hideOverlappingLabels = function(a) {
            var b = a.length,
                d, e, j, k, m, n, l;
            for (e = 0; e < b; e++)
                if (d = a[e]) d.oldOpacity = d.opacity, d.newOpacity = 1;
            a.sort(function(a, b) {
                return (b.labelrank || 0) - (a.labelrank || 0)
            });
            for (e = 0; e < b; e++) {
                j = a[e];
                for (d = e + 1; d < b; ++d)
                    if (k = a[d], j && k && j.placed && k.placed && j.newOpacity !== 0 && k.newOpacity !== 0 && (m = j.alignAttr, n = k.alignAttr, l = 2 * (j.box ? 0 : j.padding), m = !(n.x > m.x + (j.width - l) || n.x + (k.width - l) < m.x || n.y > m.y + (j.height - l) || n.y + (k.height - l) < m.y)))(j.labelrank < k.labelrank ? j : k).newOpacity = 0
            }
            c(a, function(a) {
                var b, c;
                if (a) {
                    c = a.newOpacity;
                    if (a.oldOpacity !== c && a.placed) c ? a.show(!0) : b = function() {
                        a.hide()
                    }, a.alignAttr.opacity = c, a[a.isOld ? "animate" : "attr"](a.alignAttr, null, b);
                    a.isOld = !0
                }
            })
        }
    })(B);
    U = B.TrackerMixin = {
        drawTrackerPoint: function() {
            var a = this,
                b = a.chart,
                c = b.pointer,
                d = a.options.cursor,
                e = d && {
                    cursor: d
                },
                f = function(a) {
                    for (var c = a.target, d; c && !d;) d = c.point, c = c.parentNode;
                    if (d !== x && d !== b.hoverPoint) d.onMouseOver(a)
                };
            o(a.points, function(a) {
                if (a.graphic) a.graphic.element.point = a;
                if (a.dataLabel) a.dataLabel.element.point = a
            });
            if (!a._hasTracking) o(a.trackerGroups, function(b) {
                if (a[b] && (a[b].addClass("highcharts-tracker").on("mouseover", f).on("mouseout", function(a) {
                        c.onTrackerMouseOut(a)
                    }).css(e), ab)) a[b].on("touchstart", f)
            }), a._hasTracking = !0
        },
        drawTrackerGraph: function() {
            var a = this,
                b = a.options,
                c = b.trackByArea,
                d = [].concat(c ? a.areaPath : a.graphPath),
                e = d.length,
                f = a.chart,
                g = f.pointer,
                h = f.renderer,
                i = f.options.tooltip.snap,
                j = a.tracker,
                k = b.cursor,
                m = k && {
                    cursor: k
                },
                k = a.singlePoints,
                n, l = function() {
                    if (f.hoverSeries !== a) a.onMouseOver()
                },
                p = "rgba(192,192,192," + (ca ? 1.0E-4 : 0.002) + ")";
            if (e && !c)
                for (n = e + 1; n--;) d[n] === "M" && d.splice(n + 1, 0, d[n + 1] - i, d[n + 2], "L"), (n && d[n] === "M" || n === e) && d.splice(n, 0, "L", d[n - 2] + i, d[n - 1]);
            for (n = 0; n < k.length; n++) e = k[n], d.push("M", e.plotX - i, e.plotY, "L", e.plotX + i, e.plotY);
            j ? j.attr({
                d: d
            }) : (a.tracker = h.path(d).attr({
                "stroke-linejoin": "round",
                visibility: a.visible ? "visible" : "hidden",
                stroke: p,
                fill: c ? p : P,
                "stroke-width": b.lineWidth + (c ? 0 : 2 * i),
                zIndex: 2
            }).add(a.group), o([a.tracker, a.markerGroup], function(a) {
                a.addClass("highcharts-tracker").on("mouseover", l).on("mouseout", function(a) {
                    g.onTrackerMouseOut(a)
                }).css(m);
                if (ab) a.on("touchstart", l)
            }))
        }
    };
    if (N.column) xa.prototype.drawTracker = U.drawTrackerPoint;
    if (N.pie) N.pie.prototype.drawTracker = U.drawTrackerPoint;
    if (N.scatter) pa.prototype.drawTracker = U.drawTrackerPoint;
    t(mb.prototype, {
        setItemEvents: function(a, b, c, d, e) {
            var f = this;
            (c ? b : a.legendGroup).on("mouseover", function() {
                a.setState("hover");
                b.css(f.options.itemHoverStyle)
            }).on("mouseout", function() {
                b.css(a.visible ? d : e);
                a.setState()
            }).on("click", function(b) {
                var c = function() {
                        a.setVisible && a.setVisible()
                    },
                    b = {
                        browserEvent: b
                    };
                a.firePointEvent ? a.firePointEvent("legendItemClick", b, c) : J(a, "legendItemClick", b, c)
            })
        },
        createCheckboxForItem: function(a) {
            a.checkbox = $("input", {
                type: "checkbox",
                checked: a.selected,
                defaultChecked: a.selected
            }, this.options.itemCheckboxStyle, this.chart.container);
            I(a.checkbox, "click", function(b) {
                J(a.series || a, "checkboxClick", {
                    checked: b.target.checked,
                    item: a
                }, function() {
                    a.select()
                })
            })
        }
    });
    S.legend.itemStyle.cursor = "pointer";
    t(E.prototype, {
        showResetZoom: function() {
            var a = this,
                b = S.lang,
                c = a.options.chart.resetZoomButton,
                d = c.theme,
                e = d.states,
                f = c.relativeTo === "chart" ? null : "plotBox";
            this.resetZoomButton = a.renderer.button(b.resetZoom, null, null, function() {
                a.zoomOut()
            }, d, e && e.hover).attr({
                align: c.position.align,
                title: b.resetZoomTitle
            }).add().align(c.position, !1, f)
        },
        zoomOut: function() {
            var a = this;
            J(a, "selection", {
                resetSelection: !0
            }, function() {
                a.zoom()
            })
        },
        zoom: function(a) {
            var b, c = this.pointer,
                d = !1,
                e;
            !a || a.resetSelection ? o(this.axes, function(a) {
                b = a.zoom()
            }) : o(a.xAxis.concat(a.yAxis), function(a) {
                var e = a.axis,
                    h = e.isXAxis;
                if (c[h ? "zoomX" : "zoomY"] || c[h ? "pinchX" : "pinchY"]) b = e.zoom(a.min, a.max), e.displayBtn && (d = !0)
            });
            e = this.resetZoomButton;
            if (d && !e) this.showResetZoom();
            else if (!d && da(e)) this.resetZoomButton = e.destroy();
            b && this.redraw(p(this.options.chart.animation, a && a.animation, this.pointCount < 100))
        },
        pan: function(a, b) {
            var c = this,
                d = c.hoverPoints,
                e;
            d && o(d, function(a) {
                a.setState()
            });
            o(b === "xy" ? [1, 0] : [1], function(b) {
                var d = a[b ? "chartX" : "chartY"],
                    h = c[b ? "xAxis" : "yAxis"][0],
                    i = c[b ? "mouseDownX" : "mouseDownY"],
                    j = (h.pointRange || 0) / 2,
                    k = h.getExtremes(),
                    m = h.toValue(i - d, !0) + j,
                    j = h.toValue(i + c[b ? "plotWidth" : "plotHeight"] - d, !0) - j,
                    i = i > d;
                if (h.series.length && (i || m > z(k.dataMin, k.min)) && (!i || j < s(k.dataMax, k.max))) h.setExtremes(m, j, !1, !1, {
                    trigger: "pan"
                }), e = !0;
                c[b ? "mouseDownX" : "mouseDownY"] = d
            });
            e && c.redraw(!1);
            M(c.container, {
                cursor: "move"
            })
        }
    });
    t(Fa.prototype, {
        select: function(a, b) {
            var c = this,
                d = c.series,
                e = d.chart,
                a = p(a, !c.selected);
            c.firePointEvent(a ? "select" : "unselect", {
                accumulate: b
            }, function() {
                c.selected = c.options.selected = a;
                d.options.data[La(c, d.data)] = c.options;
                c.setState(a && "select");
                b || o(e.getSelectedPoints(), function(a) {
                    if (a.selected && a !== c) a.selected = a.options.selected = !1, d.options.data[La(a, d.data)] = a.options, a.setState(""), a.firePointEvent("unselect")
                })
            })
        },
        onMouseOver: function(a, b) {
            var c = this.series,
                d = c.chart,
                e = d.tooltip,
                f = d.hoverPoint;
            if (d.hoverSeries !== c) c.onMouseOver();
            if (f && f !== this) f.onMouseOut();
            if (this.series && (this.firePointEvent("mouseOver"), e && (!e.shared || c.noSharedTooltip) && e.refresh(this, a), this.setState("hover"), !b)) d.hoverPoint = this
        },
        onMouseOut: function() {
            var a = this.series.chart,
                b = a.hoverPoints;
            this.firePointEvent("mouseOut");
            if (!b || La(this, b) === -1) this.setState(), a.hoverPoint = null
        },
        importEvents: function() {
            if (!this.hasImportedEvents) {
                var a = D(this.series.options.point, this.options).events,
                    b;
                this.events = a;
                for (b in a) I(this, b, a[b]);
                this.hasImportedEvents = !0
            }
        },
        setState: function(a, b) {
            var c = T(this.plotX),
                d = this.plotY,
                e = this.series,
                f = e.options.states,
                g = ba[e.type].marker && e.options.marker,
                h = g && !g.enabled,
                i = g && g.states[a],
                j = i && i.enabled === !1,
                k = e.stateMarkerGraphic,
                m = this.marker || {},
                n = e.chart,
                l = e.halo,
                o, a = a || "";
            o = this.pointAttr[a] || e.pointAttr[a];
            if (!(a === this.state && !b || this.selected && a !== "select" || f[a] && f[a].enabled === !1 || a && (j || h && i.enabled === !1) || a && m.states && m.states[a] && m.states[a].enabled === !1)) {
                if (this.graphic) g = g && this.graphic.symbolName && o.r, this.graphic.attr(D(o, g ? {
                    x: c - g,
                    y: d -
                        g,
                    width: 2 * g,
                    height: 2 * g
                } : {})), k && k.hide();
                else {
                    if (a && i)
                        if (g = i.radius, m = m.symbol || e.symbol, k && k.currentSymbol !== m && (k = k.destroy()), k) k[b ? "animate" : "attr"]({
                            x: c - g,
                            y: d - g
                        });
                        else if (m) e.stateMarkerGraphic = k = n.renderer.symbol(m, c - g, d - g, 2 * g, 2 * g).attr(o).add(e.markerGroup), k.currentSymbol = m;
                    if (k) k[a && n.isInsidePlot(c, d, n.inverted) ? "show" : "hide"](), k.element.point = this
                }
                if ((c = f[a] && f[a].halo) && c.size) {
                    if (!l) e.halo = l = n.renderer.path().add(n.seriesGroup);
                    l.attr(t({
                        fill: na(this.color || e.color).setOpacity(c.opacity).get()
                    }, c.attributes))[b ? "animate" : "attr"]({
                        d: this.haloPath(c.size)
                    })
                } else l && l.attr({
                    d: []
                });
                this.state = a
            }
        },
        haloPath: function(a) {
            var b = this.series,
                c = b.chart,
                d = b.getPlotBox(),
                e = c.inverted;
            return c.renderer.symbols.circle(d.translateX + (e ? b.yAxis.len - this.plotY : this.plotX) - a, d.translateY + (e ? b.xAxis.len - this.plotX : this.plotY) - a, a * 2, a * 2)
        }
    });
    t(R.prototype, {
        onMouseOver: function() {
            var a = this.chart,
                b = a.hoverSeries;
            if (b && b !== this) b.onMouseOut();
            this.options.events.mouseOver && J(this, "mouseOver");
            this.setState("hover");
            a.hoverSeries = this
        },
        onMouseOut: function() {
            var a = this.options,
                b = this.chart,
                c = b.tooltip,
                d = b.hoverPoint;
            b.hoverSeries = null;
            if (d) d.onMouseOut();
            this && a.events.mouseOut && J(this, "mouseOut");
            c && !a.stickyTracking && (!c.shared || this.noSharedTooltip) && c.hide();
            this.setState()
        },
        setState: function(a) {
            var b = this.options,
                c = this.graph,
                d = b.states,
                e = b.lineWidth,
                b = 0,
                a = a || "";
            if (this.state !== a && (this.state = a, !(d[a] && d[a].enabled === !1) && (a && (e = d[a].lineWidth || e + (d[a].lineWidthPlus || 0)), c && !c.dashstyle))) {
                a = {
                    "stroke-width": e
                };
                for (c.attr(a); this["zoneGraph" + b];) this["zoneGraph" + b].attr(a), b += 1
            }
        },
        setVisible: function(a, b) {
            var c = this,
                d = c.chart,
                e = c.legendItem,
                f, g = d.options.chart.ignoreHiddenSeries,
                h = c.visible;
            f = (c.visible = a = c.userOptions.visible = a === x ? !h : a) ? "show" : "hide";
            o(["group", "dataLabelsGroup", "markerGroup", "tracker"], function(a) {
                if (c[a]) c[a][f]()
            });
            if (d.hoverSeries === c || (d.hoverPoint && d.hoverPoint.series) === c) c.onMouseOut();
            e && d.legend.colorizeItem(c, a);
            c.isDirty = !0;
            c.options.stacking && o(d.series, function(a) {
                if (a.options.stacking && a.visible) a.isDirty = !0
            });
            o(c.linkedSeries, function(b) {
                b.setVisible(a, !1)
            });
            if (g) d.isDirtyBox = !0;
            b !== !1 && d.redraw();
            J(c, f)
        },
        show: function() {
            this.setVisible(!0)
        },
        hide: function() {
            this.setVisible(!1)
        },
        select: function(a) {
            this.selected = a = a === x ? !this.selected : a;
            if (this.checkbox) this.checkbox.checked = a;
            J(this, a ? "select" : "unselect")
        },
        drawTracker: U.drawTrackerGraph
    });
    t(B, {
        Color: na,
        Point: Fa,
        Tick: Sa,
        Renderer: $a,
        SVGElement: Q,
        SVGRenderer: Aa,
        arrayMin: Oa,
        arrayMax: Da,
        charts: X,
        dateFormat: Na,
        error: la,
        format: Ia,
        pathAnim: yb,
        getOptions: function() {
            return S
        },
        hasBidiBug: Nb,
        isTouchDevice: Jb,
        setOptions: function(a) {
            S = D(!0, S, a);
            Cb();
            return S
        },
        addEvent: I,
        removeEvent: Y,
        createElement: $,
        discardElement: Qa,
        css: M,
        each: o,
        map: Ua,
        merge: D,
        splat: ra,
        extendClass: ka,
        pInt: G,
        svg: ca,
        canvas: fa,
        vml: !ca && !fa,
        product: "Highcharts",
        version: "4.1.9"
    })
})();

Date.CultureInfo = {
    name: "en-US",
    englishName: "English (United States)",
    nativeName: "English (United States)",
    dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    abbreviatedDayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    shortestDayNames: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    firstLetterDayNames: ["S", "M", "T", "W", "T", "F", "S"],
    monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    abbreviatedMonthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    amDesignator: "AM",
    pmDesignator: "PM",
    firstDayOfWeek: 0,
    twoDigitYearMax: 2029,
    dateElementOrder: "mdy",
    formatPatterns: {
        shortDate: "M/d/yyyy",
        longDate: "dddd, MMMM dd, yyyy",
        shortTime: "h:mm tt",
        longTime: "h:mm:ss tt",
        fullDateTime: "dddd, MMMM dd, yyyy h:mm:ss tt",
        sortableDateTime: "yyyy-MM-ddTHH:mm:ss",
        universalSortableDateTime: "yyyy-MM-dd HH:mm:ssZ",
        rfc1123: "ddd, dd MMM yyyy HH:mm:ss GMT",
        monthDay: "MMMM dd",
        yearMonth: "MMMM, yyyy"
    },
    regexPatterns: {
        jan: /^jan(uary)?/i,
        feb: /^feb(ruary)?/i,
        mar: /^mar(ch)?/i,
        apr: /^apr(il)?/i,
        may: /^may/i,
        jun: /^jun(e)?/i,
        jul: /^jul(y)?/i,
        aug: /^aug(ust)?/i,
        sep: /^sep(t(ember)?)?/i,
        oct: /^oct(ober)?/i,
        nov: /^nov(ember)?/i,
        dec: /^dec(ember)?/i,
        sun: /^su(n(day)?)?/i,
        mon: /^mo(n(day)?)?/i,
        tue: /^tu(e(s(day)?)?)?/i,
        wed: /^we(d(nesday)?)?/i,
        thu: /^th(u(r(s(day)?)?)?)?/i,
        fri: /^fr(i(day)?)?/i,
        sat: /^sa(t(urday)?)?/i,
        future: /^next/i,
        past: /^last|past|prev(ious)?/i,
        add: /^(\+|after|from)/i,
        subtract: /^(\-|before|ago)/i,
        yesterday: /^yesterday/i,
        today: /^t(oday)?/i,
        tomorrow: /^tomorrow/i,
        now: /^n(ow)?/i,
        millisecond: /^ms|milli(second)?s?/i,
        second: /^sec(ond)?s?/i,
        minute: /^min(ute)?s?/i,
        hour: /^h(ou)?rs?/i,
        week: /^w(ee)?k/i,
        month: /^m(o(nth)?s?)?/i,
        day: /^d(ays?)?/i,
        year: /^y((ea)?rs?)?/i,
        shortMeridian: /^(a|p)/i,
        longMeridian: /^(a\.?m?\.?|p\.?m?\.?)/i,
        timezone: /^((e(s|d)t|c(s|d)t|m(s|d)t|p(s|d)t)|((gmt)?\s*(\+|\-)\s*\d\d\d\d?)|gmt)/i,
        ordinalSuffix: /^\s*(st|nd|rd|th)/i,
        timeContext: /^\s*(\:|a|p)/i
    },
    abbreviatedTimeZoneStandard: {
        GMT: "-000",
        EST: "-0400",
        CST: "-0500",
        MST: "-0600",
        PST: "-0700"
    },
    abbreviatedTimeZoneDST: {
        GMT: "-000",
        EDT: "-0500",
        CDT: "-0600",
        MDT: "-0700",
        PDT: "-0800"
    }
};
Date.getMonthNumberFromName = function(name) {
    var n = Date.CultureInfo.monthNames,
        m = Date.CultureInfo.abbreviatedMonthNames,
        s = name.toLowerCase();
    for (var i = 0; i < n.length; i++) {
        if (n[i].toLowerCase() == s || m[i].toLowerCase() == s) {
            return i;
        }
    }
    return -1;
};
Date.getDayNumberFromName = function(name) {
    var n = Date.CultureInfo.dayNames,
        m = Date.CultureInfo.abbreviatedDayNames,
        o = Date.CultureInfo.shortestDayNames,
        s = name.toLowerCase();
    for (var i = 0; i < n.length; i++) {
        if (n[i].toLowerCase() == s || m[i].toLowerCase() == s) {
            return i;
        }
    }
    return -1;
};
Date.isLeapYear = function(year) {
    return (((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0));
};
Date.getDaysInMonth = function(year, month) {
    return [31, (Date.isLeapYear(year) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
};
Date.getTimezoneOffset = function(s, dst) {
    return (dst || false) ? Date.CultureInfo.abbreviatedTimeZoneDST[s.toUpperCase()] : Date.CultureInfo.abbreviatedTimeZoneStandard[s.toUpperCase()];
};
Date.getTimezoneAbbreviation = function(offset, dst) {
    var n = (dst || false) ? Date.CultureInfo.abbreviatedTimeZoneDST : Date.CultureInfo.abbreviatedTimeZoneStandard,
        p;
    for (p in n) {
        if (n[p] === offset) {
            return p;
        }
    }
    return null;
};
Date.prototype.clone = function() {
    return new Date(this.getTime());
};
Date.prototype.compareTo = function(date) {
    if (isNaN(this)) {
        throw new Error(this);
    }
    if (date instanceof Date && !isNaN(date)) {
        return (this > date) ? 1 : (this < date) ? -1 : 0;
    } else {
        throw new TypeError(date);
    }
};
Date.prototype.equals = function(date) {
    return (this.compareTo(date) === 0);
};
Date.prototype.between = function(start, end) {
    var t = this.getTime();
    return t >= start.getTime() && t <= end.getTime();
};
Date.prototype.addMilliseconds = function(value) {
    this.setMilliseconds(this.getMilliseconds() + value);
    return this;
};
Date.prototype.addSeconds = function(value) {
    return this.addMilliseconds(value * 1000);
};
Date.prototype.addMinutes = function(value) {
    return this.addMilliseconds(value * 60000);
};
Date.prototype.addHours = function(value) {
    return this.addMilliseconds(value * 3600000);
};
Date.prototype.addDays = function(value) {
    return this.addMilliseconds(value * 86400000);
};
Date.prototype.addWeeks = function(value) {
    return this.addMilliseconds(value * 604800000);
};
Date.prototype.addMonths = function(value) {
    var n = this.getDate();
    this.setDate(1);
    this.setMonth(this.getMonth() + value);
    this.setDate(Math.min(n, this.getDaysInMonth()));
    return this;
};
Date.prototype.addYears = function(value) {
    return this.addMonths(value * 12);
};
Date.prototype.add = function(config) {
    if (typeof config == "number") {
        this._orient = config;
        return this;
    }
    var x = config;
    if (x.millisecond || x.milliseconds) {
        this.addMilliseconds(x.millisecond || x.milliseconds);
    }
    if (x.second || x.seconds) {
        this.addSeconds(x.second || x.seconds);
    }
    if (x.minute || x.minutes) {
        this.addMinutes(x.minute || x.minutes);
    }
    if (x.hour || x.hours) {
        this.addHours(x.hour || x.hours);
    }
    if (x.month || x.months) {
        this.addMonths(x.month || x.months);
    }
    if (x.year || x.years) {
        this.addYears(x.year || x.years);
    }
    if (x.day || x.days) {
        this.addDays(x.day || x.days);
    }
    return this;
};
Date._validate = function(value, min, max, name) {
    if (typeof value != "number") {
        throw new TypeError(value + " is not a Number.");
    } else if (value < min || value > max) {
        throw new RangeError(value + " is not a valid value for " + name + ".");
    }
    return true;
};
Date.validateMillisecond = function(n) {
    return Date._validate(n, 0, 999, "milliseconds");
};
Date.validateSecond = function(n) {
    return Date._validate(n, 0, 59, "seconds");
};
Date.validateMinute = function(n) {
    return Date._validate(n, 0, 59, "minutes");
};
Date.validateHour = function(n) {
    return Date._validate(n, 0, 23, "hours");
};
Date.validateDay = function(n, year, month) {
    return Date._validate(n, 1, Date.getDaysInMonth(year, month), "days");
};
Date.validateMonth = function(n) {
    return Date._validate(n, 0, 11, "months");
};
Date.validateYear = function(n) {
    return Date._validate(n, 1, 9999, "seconds");
};
Date.prototype.set = function(config) {
    var x = config;
    if (!x.millisecond && x.millisecond !== 0) {
        x.millisecond = -1;
    }
    if (!x.second && x.second !== 0) {
        x.second = -1;
    }
    if (!x.minute && x.minute !== 0) {
        x.minute = -1;
    }
    if (!x.hour && x.hour !== 0) {
        x.hour = -1;
    }
    if (!x.day && x.day !== 0) {
        x.day = -1;
    }
    if (!x.month && x.month !== 0) {
        x.month = -1;
    }
    if (!x.year && x.year !== 0) {
        x.year = -1;
    }
    if (x.millisecond != -1 && Date.validateMillisecond(x.millisecond)) {
        this.addMilliseconds(x.millisecond - this.getMilliseconds());
    }
    if (x.second != -1 && Date.validateSecond(x.second)) {
        this.addSeconds(x.second - this.getSeconds());
    }
    if (x.minute != -1 && Date.validateMinute(x.minute)) {
        this.addMinutes(x.minute - this.getMinutes());
    }
    if (x.hour != -1 && Date.validateHour(x.hour)) {
        this.addHours(x.hour - this.getHours());
    }
    if (x.month !== -1 && Date.validateMonth(x.month)) {
        this.addMonths(x.month - this.getMonth());
    }
    if (x.year != -1 && Date.validateYear(x.year)) {
        this.addYears(x.year - this.getFullYear());
    }
    if (x.day != -1 && Date.validateDay(x.day, this.getFullYear(), this.getMonth())) {
        this.addDays(x.day - this.getDate());
    }
    if (x.timezone) {
        this.setTimezone(x.timezone);
    }
    if (x.timezoneOffset) {
        this.setTimezoneOffset(x.timezoneOffset);
    }
    return this;
};
Date.prototype.clearTime = function() {
    this.setHours(0);
    this.setMinutes(0);
    this.setSeconds(0);
    this.setMilliseconds(0);
    return this;
};
Date.prototype.isLeapYear = function() {
    var y = this.getFullYear();
    return (((y % 4 === 0) && (y % 100 !== 0)) || (y % 400 === 0));
};
Date.prototype.isWeekday = function() {
    return !(this.is().sat() || this.is().sun());
};
Date.prototype.getDaysInMonth = function() {
    return Date.getDaysInMonth(this.getFullYear(), this.getMonth());
};
Date.prototype.moveToFirstDayOfMonth = function() {
    return this.set({
        day: 1
    });
};
Date.prototype.moveToLastDayOfMonth = function() {
    return this.set({
        day: this.getDaysInMonth()
    });
};
Date.prototype.moveToDayOfWeek = function(day, orient) {
    var diff = (day - this.getDay() + 7 * (orient || +1)) % 7;
    return this.addDays((diff === 0) ? diff += 7 * (orient || +1) : diff);
};
Date.prototype.moveToMonth = function(month, orient) {
    var diff = (month - this.getMonth() + 12 * (orient || +1)) % 12;
    return this.addMonths((diff === 0) ? diff += 12 * (orient || +1) : diff);
};
Date.prototype.getDayOfYear = function() {
    return Math.floor((this - new Date(this.getFullYear(), 0, 1)) / 86400000);
};
Date.prototype.getWeekOfYear = function(firstDayOfWeek) {
    var y = this.getFullYear(),
        m = this.getMonth(),
        d = this.getDate();
    var dow = firstDayOfWeek || Date.CultureInfo.firstDayOfWeek;
    var offset = 7 + 1 - new Date(y, 0, 1).getDay();
    if (offset == 8) {
        offset = 1;
    }
    var daynum = ((Date.UTC(y, m, d, 0, 0, 0) - Date.UTC(y, 0, 1, 0, 0, 0)) / 86400000) + 1;
    var w = Math.floor((daynum - offset + 7) / 7);
    if (w === dow) {
        y--;
        var prevOffset = 7 + 1 - new Date(y, 0, 1).getDay();
        if (prevOffset == 2 || prevOffset == 8) {
            w = 53;
        } else {
            w = 52;
        }
    }
    return w;
};
Date.prototype.isDST = function() {
    console.log('isDST');
    return this.toString().match(/(E|C|M|P)(S|D)T/)[2] == "D";
};
Date.prototype.getTimezone = function() {
    return Date.getTimezoneAbbreviation(this.getUTCOffset, this.isDST());
};
Date.prototype.setTimezoneOffset = function(s) {
    var here = this.getTimezoneOffset(),
        there = Number(s) * -6 / 10;
    this.addMinutes(there - here);
    return this;
};
Date.prototype.setTimezone = function(s) {
    return this.setTimezoneOffset(Date.getTimezoneOffset(s));
};
Date.prototype.getUTCOffset = function() {
    var n = this.getTimezoneOffset() * -10 / 6,
        r;
    if (n < 0) {
        r = (n - 10000).toString();
        return r[0] + r.substr(2);
    } else {
        r = (n + 10000).toString();
        return "+" + r.substr(1);
    }
};
Date.prototype.getDayName = function(abbrev) {
    return abbrev ? Date.CultureInfo.abbreviatedDayNames[this.getDay()] : Date.CultureInfo.dayNames[this.getDay()];
};
Date.prototype.getMonthName = function(abbrev) {
    return abbrev ? Date.CultureInfo.abbreviatedMonthNames[this.getMonth()] : Date.CultureInfo.monthNames[this.getMonth()];
};
Date.prototype._toString = Date.prototype.toString;
Date.prototype.toString = function(format) {
    var self = this;
    var p = function p(s) {
        return (s.toString().length == 1) ? "0" + s : s;
    };
    return format ? format.replace(/dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|zz?z?/g, function(format) {
        switch (format) {
            case "hh":
                return p(self.getHours() < 13 ? self.getHours() : (self.getHours() - 12));
            case "h":
                return self.getHours() < 13 ? self.getHours() : (self.getHours() - 12);
            case "HH":
                return p(self.getHours());
            case "H":
                return self.getHours();
            case "mm":
                return p(self.getMinutes());
            case "m":
                return self.getMinutes();
            case "ss":
                return p(self.getSeconds());
            case "s":
                return self.getSeconds();
            case "yyyy":
                return self.getFullYear();
            case "yy":
                return self.getFullYear().toString().substring(2, 4);
            case "dddd":
                return self.getDayName();
            case "ddd":
                return self.getDayName(true);
            case "dd":
                return p(self.getDate());
            case "d":
                return self.getDate().toString();
            case "MMMM":
                return self.getMonthName();
            case "MMM":
                return self.getMonthName(true);
            case "MM":
                return p((self.getMonth() + 1));
            case "M":
                return self.getMonth() + 1;
            case "t":
                return self.getHours() < 12 ? Date.CultureInfo.amDesignator.substring(0, 1) : Date.CultureInfo.pmDesignator.substring(0, 1);
            case "tt":
                return self.getHours() < 12 ? Date.CultureInfo.amDesignator : Date.CultureInfo.pmDesignator;
            case "zzz":
            case "zz":
            case "z":
                return "";
        }
    }) : this._toString();
};
Date.now = function() {
    return new Date();
};
Date.today = function() {
    return Date.now().clearTime();
};
Date.prototype._orient = +1;
Date.prototype.next = function() {
    this._orient = +1;
    return this;
};
Date.prototype.last = Date.prototype.prev = Date.prototype.previous = function() {
    this._orient = -1;
    return this;
};
Date.prototype._is = false;
Date.prototype.is = function() {
    this._is = true;
    return this;
};
Number.prototype._dateElement = "day";
Number.prototype.fromNow = function() {
    var c = {};
    c[this._dateElement] = this;
    return Date.now().add(c);
};
Number.prototype.ago = function() {
    var c = {};
    c[this._dateElement] = this * -1;
    return Date.now().add(c);
};
(function() {
    var $D = Date.prototype,
        $N = Number.prototype;
    var dx = ("sunday monday tuesday wednesday thursday friday saturday").split(/\s/),
        mx = ("january february march april may june july august september october november december").split(/\s/),
        px = ("Millisecond Second Minute Hour Day Week Month Year").split(/\s/),
        de;
    var df = function(n) {
        return function() {
            if (this._is) {
                this._is = false;
                return this.getDay() == n;
            }
            return this.moveToDayOfWeek(n, this._orient);
        };
    };
    for (var i = 0; i < dx.length; i++) {
        $D[dx[i]] = $D[dx[i].substring(0, 3)] = df(i);
    }
    var mf = function(n) {
        return function() {
            if (this._is) {
                this._is = false;
                return this.getMonth() === n;
            }
            return this.moveToMonth(n, this._orient);
        };
    };
    for (var j = 0; j < mx.length; j++) {
        $D[mx[j]] = $D[mx[j].substring(0, 3)] = mf(j);
    }
    var ef = function(j) {
        return function() {
            if (j.substring(j.length - 1) != "s") {
                j += "s";
            }
            return this["add" + j](this._orient);
        };
    };
    var nf = function(n) {
        return function() {
            this._dateElement = n;
            return this;
        };
    };
    for (var k = 0; k < px.length; k++) {
        de = px[k].toLowerCase();
        $D[de] = $D[de + "s"] = ef(px[k]);
        $N[de] = $N[de + "s"] = nf(de);
    }
}());
Date.prototype.toJSONString = function() {
    return this.toString("yyyy-MM-ddThh:mm:ssZ");
};
Date.prototype.toShortDateString = function() {
    return this.toString(Date.CultureInfo.formatPatterns.shortDatePattern);
};
Date.prototype.toLongDateString = function() {
    return this.toString(Date.CultureInfo.formatPatterns.longDatePattern);
};
Date.prototype.toShortTimeString = function() {
    return this.toString(Date.CultureInfo.formatPatterns.shortTimePattern);
};
Date.prototype.toLongTimeString = function() {
    return this.toString(Date.CultureInfo.formatPatterns.longTimePattern);
};
Date.prototype.getOrdinal = function() {
    switch (this.getDate()) {
        case 1:
        case 21:
        case 31:
            return "st";
        case 2:
        case 22:
            return "nd";
        case 3:
        case 23:
            return "rd";
        default:
            return "th";
    }
};
(function() {
    Date.Parsing = {
        Exception: function(s) {
            this.message = "Parse error at '" + s.substring(0, 10) + " ...'";
        }
    };
    var $P = Date.Parsing;
    var _ = $P.Operators = {
        rtoken: function(r) {
            return function(s) {
                var mx = s.match(r);
                if (mx) {
                    return ([mx[0], s.substring(mx[0].length)]);
                } else {
                    throw new $P.Exception(s);
                }
            };
        },
        token: function(s) {
            return function(s) {
                return _.rtoken(new RegExp("^\s*" + s + "\s*"))(s);
            };
        },
        stoken: function(s) {
            return _.rtoken(new RegExp("^" + s));
        },
        until: function(p) {
            return function(s) {
                var qx = [],
                    rx = null;
                while (s.length) {
                    try {
                        rx = p.call(this, s);
                    } catch (e) {
                        qx.push(rx[0]);
                        s = rx[1];
                        continue;
                    }
                    break;
                }
                return [qx, s];
            };
        },
        many: function(p) {
            return function(s) {
                var rx = [],
                    r = null;
                while (s.length) {
                    try {
                        r = p.call(this, s);
                    } catch (e) {
                        return [rx, s];
                    }
                    rx.push(r[0]);
                    s = r[1];
                }
                return [rx, s];
            };
        },
        optional: function(p) {
            return function(s) {
                var r = null;
                try {
                    r = p.call(this, s);
                } catch (e) {
                    return [null, s];
                }
                return [r[0], r[1]];
            };
        },
        not: function(p) {
            return function(s) {
                try {
                    p.call(this, s);
                } catch (e) {
                    return [null, s];
                }
                throw new $P.Exception(s);
            };
        },
        ignore: function(p) {
            return p ? function(s) {
                var r = null;
                r = p.call(this, s);
                return [null, r[1]];
            } : null;
        },
        product: function() {
            var px = arguments[0],
                qx = Array.prototype.slice.call(arguments, 1),
                rx = [];
            for (var i = 0; i < px.length; i++) {
                rx.push(_.each(px[i], qx));
            }
            return rx;
        },
        cache: function(rule) {
            var cache = {},
                r = null;
            return function(s) {
                try {
                    r = cache[s] = (cache[s] || rule.call(this, s));
                } catch (e) {
                    r = cache[s] = e;
                }
                if (r instanceof $P.Exception) {
                    throw r;
                } else {
                    return r;
                }
            };
        },
        any: function() {
            var px = arguments;
            return function(s) {
                var r = null;
                for (var i = 0; i < px.length; i++) {
                    if (px[i] == null) {
                        continue;
                    }
                    try {
                        r = (px[i].call(this, s));
                    } catch (e) {
                        r = null;
                    }
                    if (r) {
                        return r;
                    }
                }
                throw new $P.Exception(s);
            };
        },
        each: function() {
            var px = arguments;
            return function(s) {
                var rx = [],
                    r = null;
                for (var i = 0; i < px.length; i++) {
                    if (px[i] == null) {
                        continue;
                    }
                    try {
                        r = (px[i].call(this, s));
                    } catch (e) {
                        throw new $P.Exception(s);
                    }
                    rx.push(r[0]);
                    s = r[1];
                }
                return [rx, s];
            };
        },
        all: function() {
            var px = arguments,
                _ = _;
            return _.each(_.optional(px));
        },
        sequence: function(px, d, c) {
            d = d || _.rtoken(/^\s*/);
            c = c || null;
            if (px.length == 1) {
                return px[0];
            }
            return function(s) {
                var r = null,
                    q = null;
                var rx = [];
                for (var i = 0; i < px.length; i++) {
                    try {
                        r = px[i].call(this, s);
                    } catch (e) {
                        break;
                    }
                    rx.push(r[0]);
                    try {
                        q = d.call(this, r[1]);
                    } catch (ex) {
                        q = null;
                        break;
                    }
                    s = q[1];
                }
                if (!r) {
                    throw new $P.Exception(s);
                }
                if (q) {
                    throw new $P.Exception(q[1]);
                }
                if (c) {
                    try {
                        r = c.call(this, r[1]);
                    } catch (ey) {
                        throw new $P.Exception(r[1]);
                    }
                }
                return [rx, (r ? r[1] : s)];
            };
        },
        between: function(d1, p, d2) {
            d2 = d2 || d1;
            var _fn = _.each(_.ignore(d1), p, _.ignore(d2));
            return function(s) {
                var rx = _fn.call(this, s);
                return [
                    [rx[0][0], r[0][2]], rx[1]
                ];
            };
        },
        list: function(p, d, c) {
            d = d || _.rtoken(/^\s*/);
            c = c || null;
            return (p instanceof Array ? _.each(_.product(p.slice(0, -1), _.ignore(d)), p.slice(-1), _.ignore(c)) : _.each(_.many(_.each(p, _.ignore(d))), px, _.ignore(c)));
        },
        set: function(px, d, c) {
            d = d || _.rtoken(/^\s*/);
            c = c || null;
            return function(s) {
                var r = null,
                    p = null,
                    q = null,
                    rx = null,
                    best = [
                        [], s
                    ],
                    last = false;
                for (var i = 0; i < px.length; i++) {
                    q = null;
                    p = null;
                    r = null;
                    last = (px.length == 1);
                    try {
                        r = px[i].call(this, s);
                    } catch (e) {
                        continue;
                    }
                    rx = [
                        [r[0]], r[1]
                    ];
                    if (r[1].length > 0 && !last) {
                        try {
                            q = d.call(this, r[1]);
                        } catch (ex) {
                            last = true;
                        }
                    } else {
                        last = true;
                    }
                    if (!last && q[1].length === 0) {
                        last = true;
                    }
                    if (!last) {
                        var qx = [];
                        for (var j = 0; j < px.length; j++) {
                            if (i != j) {
                                qx.push(px[j]);
                            }
                        }
                        p = _.set(qx, d).call(this, q[1]);
                        if (p[0].length > 0) {
                            rx[0] = rx[0].concat(p[0]);
                            rx[1] = p[1];
                        }
                    }
                    if (rx[1].length < best[1].length) {
                        best = rx;
                    }
                    if (best[1].length === 0) {
                        break;
                    }
                }
                if (best[0].length === 0) {
                    return best;
                }
                if (c) {
                    try {
                        q = c.call(this, best[1]);
                    } catch (ey) {
                        throw new $P.Exception(best[1]);
                    }
                    best[1] = q[1];
                }
                return best;
            };
        },
        forward: function(gr, fname) {
            return function(s) {
                return gr[fname].call(this, s);
            };
        },
        replace: function(rule, repl) {
            return function(s) {
                var r = rule.call(this, s);
                return [repl, r[1]];
            };
        },
        process: function(rule, fn) {
            return function(s) {
                var r = rule.call(this, s);
                return [fn.call(this, r[0]), r[1]];
            };
        },
        min: function(min, rule) {
            return function(s) {
                var rx = rule.call(this, s);
                if (rx[0].length < min) {
                    throw new $P.Exception(s);
                }
                return rx;
            };
        }
    };
    var _generator = function(op) {
        return function() {
            var args = null,
                rx = [];
            if (arguments.length > 1) {
                args = Array.prototype.slice.call(arguments);
            } else if (arguments[0] instanceof Array) {
                args = arguments[0];
            }
            if (args) {
                for (var i = 0, px = args.shift(); i < px.length; i++) {
                    args.unshift(px[i]);
                    rx.push(op.apply(null, args));
                    args.shift();
                    return rx;
                }
            } else {
                return op.apply(null, arguments);
            }
        };
    };
    var gx = "optional not ignore cache".split(/\s/);
    for (var i = 0; i < gx.length; i++) {
        _[gx[i]] = _generator(_[gx[i]]);
    }
    var _vector = function(op) {
        return function() {
            if (arguments[0] instanceof Array) {
                return op.apply(null, arguments[0]);
            } else {
                return op.apply(null, arguments);
            }
        };
    };
    var vx = "each any all".split(/\s/);
    for (var j = 0; j < vx.length; j++) {
        _[vx[j]] = _vector(_[vx[j]]);
    }
}());
(function() {
    var flattenAndCompact = function(ax) {
        var rx = [];
        for (var i = 0; i < ax.length; i++) {
            if (ax[i] instanceof Array) {
                rx = rx.concat(flattenAndCompact(ax[i]));
            } else {
                if (ax[i]) {
                    rx.push(ax[i]);
                }
            }
        }
        return rx;
    };
    Date.Grammar = {};
    Date.Translator = {
        hour: function(s) {
            return function() {
                this.hour = Number(s);
            };
        },
        minute: function(s) {
            return function() {
                this.minute = Number(s);
            };
        },
        second: function(s) {
            return function() {
                this.second = Number(s);
            };
        },
        meridian: function(s) {
            return function() {
                this.meridian = s.slice(0, 1).toLowerCase();
            };
        },
        timezone: function(s) {
            return function() {
                var n = s.replace(/[^\d\+\-]/g, "");
                if (n.length) {
                    this.timezoneOffset = Number(n);
                } else {
                    this.timezone = s.toLowerCase();
                }
            };
        },
        day: function(x) {
            var s = x[0];
            return function() {
                this.day = Number(s.match(/\d+/)[0]);
            };
        },
        month: function(s) {
            return function() {
                this.month = ((s.length == 3) ? Date.getMonthNumberFromName(s) : (Number(s) - 1));
            };
        },
        year: function(s) {
            return function() {
                var n = Number(s);
                this.year = ((s.length > 2) ? n : (n + (((n + 2000) < Date.CultureInfo.twoDigitYearMax) ? 2000 : 1900)));
            };
        },
        rday: function(s) {
            return function() {
                switch (s) {
                    case "yesterday":
                        this.days = -1;
                        break;
                    case "tomorrow":
                        this.days = 1;
                        break;
                    case "today":
                        this.days = 0;
                        break;
                    case "now":
                        this.days = 0;
                        this.now = true;
                        break;
                }
            };
        },
        finishExact: function(x) {
            x = (x instanceof Array) ? x : [x];
            var now = new Date();
            this.year = now.getFullYear();
            this.month = now.getMonth();
            this.day = 1;
            this.hour = 0;
            this.minute = 0;
            this.second = 0;
            for (var i = 0; i < x.length; i++) {
                if (x[i]) {
                    x[i].call(this);
                }
            }
            this.hour = (this.meridian == "p" && this.hour < 13) ? this.hour + 12 : this.hour;
            if (this.day > Date.getDaysInMonth(this.year, this.month)) {
                throw new RangeError(this.day + " is not a valid value for days.");
            }
            var r = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second);
            if (this.timezone) {
                r.set({
                    timezone: this.timezone
                });
            } else if (this.timezoneOffset) {
                r.set({
                    timezoneOffset: this.timezoneOffset
                });
            }
            return r;
        },
        finish: function(x) {
            x = (x instanceof Array) ? flattenAndCompact(x) : [x];
            if (x.length === 0) {
                return null;
            }
            for (var i = 0; i < x.length; i++) {
                if (typeof x[i] == "function") {
                    x[i].call(this);
                }
            }
            if (this.now) {
                return new Date();
            }
            var today = Date.today();
            var method = null;
            var expression = !!(this.days != null || this.orient || this.operator);
            if (expression) {
                var gap, mod, orient;
                orient = ((this.orient == "past" || this.operator == "subtract") ? -1 : 1);
                if (this.weekday) {
                    this.unit = "day";
                    gap = (Date.getDayNumberFromName(this.weekday) - today.getDay());
                    mod = 7;
                    this.days = gap ? ((gap + (orient * mod)) % mod) : (orient * mod);
                }
                if (this.month) {
                    this.unit = "month";
                    gap = (this.month - today.getMonth());
                    mod = 12;
                    this.months = gap ? ((gap + (orient * mod)) % mod) : (orient * mod);
                    this.month = null;
                }
                if (!this.unit) {
                    this.unit = "day";
                }
                if (this[this.unit + "s"] == null || this.operator != null) {
                    if (!this.value) {
                        this.value = 1;
                    }
                    if (this.unit == "week") {
                        this.unit = "day";
                        this.value = this.value * 7;
                    }
                    this[this.unit + "s"] = this.value * orient;
                }
                return today.add(this);
            } else {
                if (this.meridian && this.hour) {
                    this.hour = (this.hour < 13 && this.meridian == "p") ? this.hour + 12 : this.hour;
                }
                if (this.weekday && !this.day) {
                    this.day = (today.addDays((Date.getDayNumberFromName(this.weekday) - today.getDay()))).getDate();
                }
                if (this.month && !this.day) {
                    this.day = 1;
                }
                return today.set(this);
            }
        }
    };
    var _ = Date.Parsing.Operators,
        g = Date.Grammar,
        t = Date.Translator,
        _fn;
    g.datePartDelimiter = _.rtoken(/^([\s\-\.\,\/\x27]+)/);
    g.timePartDelimiter = _.stoken(":");
    g.whiteSpace = _.rtoken(/^\s*/);
    g.generalDelimiter = _.rtoken(/^(([\s\,]|at|on)+)/);
    var _C = {};
    g.ctoken = function(keys) {
        var fn = _C[keys];
        if (!fn) {
            var c = Date.CultureInfo.regexPatterns;
            var kx = keys.split(/\s+/),
                px = [];
            for (var i = 0; i < kx.length; i++) {
                px.push(_.replace(_.rtoken(c[kx[i]]), kx[i]));
            }
            fn = _C[keys] = _.any.apply(null, px);
        }
        return fn;
    };
    g.ctoken2 = function(key) {
        return _.rtoken(Date.CultureInfo.regexPatterns[key]);
    };
    g.h = _.cache(_.process(_.rtoken(/^(0[0-9]|1[0-2]|[1-9])/), t.hour));
    g.hh = _.cache(_.process(_.rtoken(/^(0[0-9]|1[0-2])/), t.hour));
    g.H = _.cache(_.process(_.rtoken(/^([0-1][0-9]|2[0-3]|[0-9])/), t.hour));
    g.HH = _.cache(_.process(_.rtoken(/^([0-1][0-9]|2[0-3])/), t.hour));
    g.m = _.cache(_.process(_.rtoken(/^([0-5][0-9]|[0-9])/), t.minute));
    g.mm = _.cache(_.process(_.rtoken(/^[0-5][0-9]/), t.minute));
    g.s = _.cache(_.process(_.rtoken(/^([0-5][0-9]|[0-9])/), t.second));
    g.ss = _.cache(_.process(_.rtoken(/^[0-5][0-9]/), t.second));
    g.hms = _.cache(_.sequence([g.H, g.mm, g.ss], g.timePartDelimiter));
    g.t = _.cache(_.process(g.ctoken2("shortMeridian"), t.meridian));
    g.tt = _.cache(_.process(g.ctoken2("longMeridian"), t.meridian));
    g.z = _.cache(_.process(_.rtoken(/^(\+|\-)?\s*\d\d\d\d?/), t.timezone));
    g.zz = _.cache(_.process(_.rtoken(/^(\+|\-)\s*\d\d\d\d/), t.timezone));
    g.zzz = _.cache(_.process(g.ctoken2("timezone"), t.timezone));
    g.timeSuffix = _.each(_.ignore(g.whiteSpace), _.set([g.tt, g.zzz]));
    g.time = _.each(_.optional(_.ignore(_.stoken("T"))), g.hms, g.timeSuffix);
    g.d = _.cache(_.process(_.each(_.rtoken(/^([0-2]\d|3[0-1]|\d)/), _.optional(g.ctoken2("ordinalSuffix"))), t.day));
    g.dd = _.cache(_.process(_.each(_.rtoken(/^([0-2]\d|3[0-1])/), _.optional(g.ctoken2("ordinalSuffix"))), t.day));
    g.ddd = g.dddd = _.cache(_.process(g.ctoken("sun mon tue wed thu fri sat"), function(s) {
        return function() {
            this.weekday = s;
        };
    }));
    g.M = _.cache(_.process(_.rtoken(/^(1[0-2]|0\d|\d)/), t.month));
    g.MM = _.cache(_.process(_.rtoken(/^(1[0-2]|0\d)/), t.month));
    g.MMM = g.MMMM = _.cache(_.process(g.ctoken("jan feb mar apr may jun jul aug sep oct nov dec"), t.month));
    g.y = _.cache(_.process(_.rtoken(/^(\d\d?)/), t.year));
    g.yy = _.cache(_.process(_.rtoken(/^(\d\d)/), t.year));
    g.yyy = _.cache(_.process(_.rtoken(/^(\d\d?\d?\d?)/), t.year));
    g.yyyy = _.cache(_.process(_.rtoken(/^(\d\d\d\d)/), t.year));
    _fn = function() {
        return _.each(_.any.apply(null, arguments), _.not(g.ctoken2("timeContext")));
    };
    g.day = _fn(g.d, g.dd);
    g.month = _fn(g.M, g.MMM);
    g.year = _fn(g.yyyy, g.yy);
    g.orientation = _.process(g.ctoken("past future"), function(s) {
        return function() {
            this.orient = s;
        };
    });
    g.operator = _.process(g.ctoken("add subtract"), function(s) {
        return function() {
            this.operator = s;
        };
    });
    g.rday = _.process(g.ctoken("yesterday tomorrow today now"), t.rday);
    g.unit = _.process(g.ctoken("minute hour day week month year"), function(s) {
        return function() {
            this.unit = s;
        };
    });
    g.value = _.process(_.rtoken(/^\d\d?(st|nd|rd|th)?/), function(s) {
        return function() {
            this.value = s.replace(/\D/g, "");
        };
    });
    g.expression = _.set([g.rday, g.operator, g.value, g.unit, g.orientation, g.ddd, g.MMM]);
    _fn = function() {
        return _.set(arguments, g.datePartDelimiter);
    };
    g.mdy = _fn(g.ddd, g.month, g.day, g.year);
    g.ymd = _fn(g.ddd, g.year, g.month, g.day);
    g.dmy = _fn(g.ddd, g.day, g.month, g.year);
    g.date = function(s) {
        return ((g[Date.CultureInfo.dateElementOrder] || g.mdy).call(this, s));
    };
    g.format = _.process(_.many(_.any(_.process(_.rtoken(/^(dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|zz?z?)/), function(fmt) {
        if (g[fmt]) {
            return g[fmt];
        } else {
            throw Date.Parsing.Exception(fmt);
        }
    }), _.process(_.rtoken(/^[^dMyhHmstz]+/), function(s) {
        return _.ignore(_.stoken(s));
    }))), function(rules) {
        return _.process(_.each.apply(null, rules), t.finishExact);
    });
    var _F = {};
    var _get = function(f) {
        return _F[f] = (_F[f] || g.format(f)[0]);
    };
    g.formats = function(fx) {
        if (fx instanceof Array) {
            var rx = [];
            for (var i = 0; i < fx.length; i++) {
                rx.push(_get(fx[i]));
            }
            return _.any.apply(null, rx);
        } else {
            return _get(fx);
        }
    };
    g._formats = g.formats(["yyyy-MM-ddTHH:mm:ss", "ddd, MMM dd, yyyy H:mm:ss tt", "ddd MMM d yyyy HH:mm:ss zzz", "d"]);
    g._start = _.process(_.set([g.date, g.time, g.expression], g.generalDelimiter, g.whiteSpace), t.finish);
    g.start = function(s) {
        try {
            var r = g._formats.call({}, s);
            if (r[1].length === 0) {
                return r;
            }
        } catch (e) {}
        return g._start.call({}, s);
    };
}());
Date._parse = Date.parse;
Date.parse = function(s) {
    var r = null;
    if (!s) {
        return null;
    }
    try {
        r = Date.Grammar.start.call({}, s);
    } catch (e) {
        return null;
    }
    return ((r[1].length === 0) ? r[0] : null);
};
Date.getParseFunction = function(fx) {
    var fn = Date.Grammar.formats(fx);
    return function(s) {
        var r = null;
        try {
            r = fn.call({}, s);
        } catch (e) {
            return null;
        }
        return ((r[1].length === 0) ? r[0] : null);
    };
};
Date.parseExact = function(s, fx) {
    return Date.getParseFunction(fx)(s);
};
/*!
 * fullPage 2.7.6
 * https://github.com/alvarotrigo/fullPage.js
 * @license MIT licensed
 *
 * Copyright (C) 2015 alvarotrigo.com - A project by Alvaro Trigo
 */
(function(d, h) {
    "function" === typeof define && define.amd ? define(["jquery"], function(m) {
        return h(m, d, d.document, d.Math)
    }) : "undefined" !== typeof exports ? module.exports = h(require("jquery"), d, d.document, d.Math) : h(jQuery, d, d.document, d.Math)
})("undefined" !== typeof window ? window : this, function(d, h, m, n, E) {
    var p = d(h),
        u = d(m),
        ma;
    d.fn.fullpage = function(c) {
        function v() {
            c.css3 && (c.css3 = Na());
            c.anchors.length || (c.anchors = d(c.sectionSelector + "[data-anchor]").map(function() {
                return d(this).data("anchor").toString()
            }).get());
            Oa();
            e.setAllowScrolling(!0);
            r = p.height();
            e.setAutoScrolling(c.autoScrolling, "internal");
            var a = d(".fp-section.active").find(".fp-slide.active");
            a.length && (0 !== d(".fp-section.active").index(".fp-section") || 0 === d(".fp-section.active").index(".fp-section") && 0 !== a.index()) && U(a);
            na();
            oa();
            p.on("load", function() {
                var a = h.location.hash.replace("#", "").split("/"),
                    d = a[0],
                    a = a[1];
                d && (c.animateAnchor ? V(d, a) : e.silentMoveTo(d, a))
            })
        }

        function Oa() {
            k.css({
                height: "100%",
                position: "relative"
            });
            k.addClass("fullpage-wrapper");
            d("html").addClass("fp-enabled");
            k.removeClass("fp-destroyed");
            Pa();
            d(".fp-section").each(function(a) {
                var b = d(this),
                    g = b.find(".fp-slide"),
                    f = g.length;
                a || 0 !== d(".fp-section.active").length || b.addClass("active");
                b.css("height", r + "px");
                c.paddingTop && b.css("padding-top", c.paddingTop);
                c.paddingBottom && b.css("padding-bottom", c.paddingBottom);
                "undefined" !== typeof c.sectionsColor[a] && b.css("background-color", c.sectionsColor[a]);
                "undefined" !== typeof c.anchors[a] && b.attr("data-anchor", c.anchors[a]);
                "undefined" !==
                typeof c.anchors[a] && b.hasClass("active") && W(c.anchors[a], a);
                c.menu && c.css3 && d(c.menu).closest(".fullpage-wrapper").length && d(c.menu).appendTo(q);
                0 < f ? Qa(b, g, f) : c.verticalCentered && pa(b)
            });
            c.fixedElements && c.css3 && d(c.fixedElements).appendTo(q);
            c.navigation && Ra();
            c.scrollOverflow ? ("complete" === m.readyState && qa(), p.on("load", qa)) : ra()
        }

        function Qa(a, b, g) {
            var f = 100 * g,
                e = 100 / g;
            b.wrapAll('<div class="fp-slidesContainer" />');
            b.parent().wrap('<div class="fp-slides" />');
            a.find(".fp-slidesContainer").css("width",
                f + "%");
            1 < g && (c.controlArrows && Sa(a), c.slidesNavigation && Ta(a, g));
            b.each(function(a) {
                d(this).css("width", e + "%");
                c.verticalCentered && pa(d(this))
            });
            a = a.find(".fp-slide.active");
            a.length && (0 !== d(".fp-section.active").index(".fp-section") || 0 === d(".fp-section.active").index(".fp-section") && 0 !== a.index()) ? U(a) : b.eq(0).addClass("active")
        }

        function Pa() {
            d(c.sectionSelector).each(function() {
                d(this).addClass("fp-section")
            });
            d(c.slideSelector).each(function() {
                d(this).addClass("fp-slide")
            })
        }

        function Sa(a) {
            a.find(".fp-slides").after('<div class="fp-controlArrow fp-prev"></div><div class="fp-controlArrow fp-next"></div>');
            "#fff" != c.controlArrowColor && (a.find(".fp-controlArrow.fp-next").css("border-color", "transparent transparent transparent " + c.controlArrowColor), a.find(".fp-controlArrow.fp-prev").css("border-color", "transparent " + c.controlArrowColor + " transparent transparent"));
            c.loopHorizontal || a.find(".fp-controlArrow.fp-prev").hide()
        }

        function Ra() {
            q.append('<div id="fp-nav"><ul></ul></div>');
            var a = d("#fp-nav");
            a.addClass(function() {
                return c.showActiveTooltip ? "fp-show-active " + c.navigationPosition : c.navigationPosition
            });
            for (var b = 0; b < d(".fp-section").length; b++) {
                var g = "";
                c.anchors.length && (g = c.anchors[b]);
                var g = '<li><a href="#' + g + '"><span></span></a>',
                    f = c.navigationTooltips[b];
                "undefined" !== typeof f && "" !== f && (g += '<div class="fp-tooltip ' + c.navigationPosition + '">' + f + "</div>");
                g += "</li>";
                a.find("ul").append(g)
            }
            d("#fp-nav").css("margin-top", "-" + d("#fp-nav").height() / 2 + "px");
            d("#fp-nav").find("li").eq(d(".fp-section.active").index(".fp-section")).find("a").addClass("active")
        }

        function qa() {
            d(".fp-section").each(function() {
                var a =
                    d(this).find(".fp-slide");
                a.length ? a.each(function() {
                    J(d(this))
                }) : J(d(this))
            });
            ra()
        }

        function ra() {
            var a = d(".fp-section.active");
            c.scrollOverflowHandler.afterRender && c.scrollOverflowHandler.afterRender(a);
            K(a);
            X(a);
            d.isFunction(c.afterLoad) && c.afterLoad.call(a, a.data("anchor"), a.index(".fp-section") + 1);
            d.isFunction(c.afterRender) && c.afterRender.call(k)
        }

        function sa() {
            var a;
            if (!c.autoScrolling || c.scrollBar) {
                for (var b = p.scrollTop(), g = 0, f = n.abs(b - m.querySelectorAll(".fp-section")[0].offsetTop), e = m.querySelectorAll(".fp-section"),
                        h = 0; h < e.length; ++h) {
                    var k = n.abs(b - e[h].offsetTop);
                    k < f && (g = h, f = k)
                }
                a = d(e).eq(g);
                if (!a.hasClass("active") && !a.hasClass("fp-auto-height")) {
                    Y = !0;
                    b = d(".fp-section.active");
                    g = b.index(".fp-section") + 1;
                    f = Z(a);
                    e = a.data("anchor");
                    h = a.index(".fp-section") + 1;
                    k = a.find(".fp-slide.active");
                    if (k.length) var l = k.data("anchor"),
                        v = k.index();
                    w && (a.addClass("active").siblings().removeClass("active"), d.isFunction(c.onLeave) && c.onLeave.call(b, g, h, f), d.isFunction(c.afterLoad) && c.afterLoad.call(a, e, h), K(a), W(e, h - 1), c.anchors.length &&
                        (z = e, aa(v, l, e, h)));
                    clearTimeout(ba);
                    ba = setTimeout(function() {
                        Y = !1
                    }, 100)
                }
                c.fitToSection && (clearTimeout(ca), ca = setTimeout(function() {
                    w && c.fitToSection && (d(".fp-section.active").is(a) && requestAnimFrame(function() {
                        t = !0
                    }), A(a), requestAnimFrame(function() {
                        t = !1
                    }))
                }, c.fitToSectionDelay))
            }
        }

        function L(a, b) {
            if (l.m[a]) {
                var d, f;
                "down" == a ? (d = "bottom", f = e.moveSectionDown) : (d = "top", f = e.moveSectionUp);
                if (0 < b.length)
                    if (c.scrollOverflowHandler.isScrolled(d, b)) f();
                    else return !0;
                else f()
            }
        }

        function Ua(a) {
            var b = a.originalEvent;
            if (!ta(a.target) && da(b)) {
                c.autoScrolling && a.preventDefault();
                a = d(".fp-section.active");
                var g = c.scrollOverflowHandler.scrollable(a);
                w && !x && (b = ua(b), F = b.y, M = b.x, a.find(".fp-slides").length && n.abs(N - M) > n.abs(G - F) ? n.abs(N - M) > h.outerWidth / 100 * c.touchSensitivity && (N > M ? l.m.right && e.moveSlideRight() : l.m.left && e.moveSlideLeft()) : c.autoScrolling && n.abs(G - F) > p.height() / 100 * c.touchSensitivity && (G > F ? L("down", g) : F > G && L("up", g)))
            }
        }

        function ta(a, b) {
            b = b || 0;
            var g = d(a).parent();
            return b < c.normalScrollElementTouchThreshold &&
                g.is(c.normalScrollElements) ? !0 : b == c.normalScrollElementTouchThreshold ? !1 : ta(g, ++b)
        }

        function da(a) {
            return "undefined" === typeof a.pointerType || "mouse" != a.pointerType
        }

        function Va(a) {
            a = a.originalEvent;
            c.fitToSection && y.stop();
            da(a) && (a = ua(a), G = a.y, N = a.x)
        }

        function va(a, b) {
            for (var c = 0, d = a.slice(n.max(a.length - b, 1)), e = 0; e < d.length; e++) c += d[e];
            return n.ceil(c / b)
        }

        function B(a) {
            var b = (new Date).getTime();
            if (c.autoScrolling && !O) {
                a = a || h.event;
                var g = a.wheelDelta || -a.deltaY || -a.detail,
                    f = n.max(-1, n.min(1, g)),
                    e =
                    "undefined" !== typeof a.wheelDeltaX || "undefined" !== typeof a.deltaX,
                    e = n.abs(a.wheelDeltaX) < n.abs(a.wheelDelta) || n.abs(a.deltaX) < n.abs(a.deltaY) || !e;
                149 < C.length && C.shift();
                C.push(n.abs(g));
                c.scrollBar && (a.preventDefault ? a.preventDefault() : a.returnValue = !1);
                a = d(".fp-section.active");
                a = c.scrollOverflowHandler.scrollable(a);
                g = b - wa;
                wa = b;
                200 < g && (C = []);
                w && (b = va(C, 10), g = va(C, 70), b >= g && e && (0 > f ? L("down", a) : L("up", a)));
                return !1
            }
            c.fitToSection && y.stop()
        }

        function xa(a, b) {
            var g = ("undefined" === typeof b ? d(".fp-section.active") :
                    b).find(".fp-slides"),
                f = g.find(".fp-slide").length;
            if (!(!g.length || x || 2 > f)) {
                var f = g.find(".fp-slide.active"),
                    e = null,
                    e = "prev" === a ? f.prev(".fp-slide") : f.next(".fp-slide");
                if (!e.length) {
                    if (!c.loopHorizontal) return;
                    e = "prev" === a ? f.siblings(":last") : f.siblings(":first")
                }
                x = !0;
                H(g, e)
            }
        }

        function ya() {
            d(".fp-slide.active").each(function() {
                U(d(this), "internal")
            })
        }

        function A(a, b, g) {
            requestAnimFrame(function() {
                var f = a.position();
                if ("undefined" !== typeof f) {
                    var e = a.hasClass("fp-auto-height") && f.top ? f.top - r + a.height() :
                        f.top,
                        f = {
                            element: a,
                            callback: b,
                            isMovementUp: g,
                            dest: f,
                            dtop: e,
                            yMovement: Z(a),
                            anchorLink: a.data("anchor"),
                            sectionIndex: a.index(".fp-section"),
                            activeSlide: a.find(".fp-slide.active"),
                            activeSection: d(".fp-section.active"),
                            leavingSection: d(".fp-section.active").index(".fp-section") + 1,
                            localIsResizing: t
                        };
                    if (!(f.activeSection.is(a) && !t || c.scrollBar && p.scrollTop() === f.dtop && !a.hasClass("fp-auto-height"))) {
                        if (f.activeSlide.length) var h = f.activeSlide.data("anchor"),
                            k = f.activeSlide.index();
                        c.autoScrolling && c.continuousVertical &&
                            "undefined" !== typeof f.isMovementUp && (!f.isMovementUp && "up" == f.yMovement || f.isMovementUp && "down" == f.yMovement) && (f.isMovementUp ? d(".fp-section.active").before(f.activeSection.nextAll(".fp-section")) : d(".fp-section.active").after(f.activeSection.prevAll(".fp-section").get().reverse()), I(d(".fp-section.active").position().top), ya(), f.wrapAroundElements = f.activeSection, f.dest = f.element.position(), f.dtop = f.dest.top, f.yMovement = Z(f.element));
                        if (!d.isFunction(c.onLeave) || f.localIsResizing || !1 !== c.onLeave.call(f.activeSection,
                                f.leavingSection, f.sectionIndex + 1, f.yMovement)) za(f.activeSection), a.addClass("active").siblings().removeClass("active"), K(a), w = !1, aa(k, h, f.anchorLink, f.sectionIndex), Wa(f), z = f.anchorLink, W(f.anchorLink, f.sectionIndex)
                    }
                }
            })
        }

        function Wa(a) {
            if (c.css3 && c.autoScrolling && !c.scrollBar) Aa("translate3d(0px, -" + a.dtop + "px, 0px)", !0), c.scrollingSpeed ? ea = setTimeout(function() {
                fa(a)
            }, c.scrollingSpeed) : fa(a);
            else {
                var b = Xa(a);
                d(b.element).animate(b.options, c.scrollingSpeed, c.easing).promise().done(function() {
                    fa(a)
                })
            }
        }

        function Xa(a) {
            var b = {};
            c.autoScrolling && !c.scrollBar ? (b.options = {
                top: -a.dtop
            }, b.element = ".fullpage-wrapper") : (b.options = {
                scrollTop: a.dtop
            }, b.element = "html, body");
            return b
        }

        function fa(a) {
            a.wrapAroundElements && a.wrapAroundElements.length && (a.isMovementUp ? d(".fp-section:first").before(a.wrapAroundElements) : d(".fp-section:last").after(a.wrapAroundElements), I(d(".fp-section.active").position().top), ya());
            a.element.find(".fp-scrollable").mouseover();
            d.isFunction(c.afterLoad) && !a.localIsResizing && c.afterLoad.call(a.element,
                a.anchorLink, a.sectionIndex + 1);
            X(a.element);
            w = !0;
            d.isFunction(a.callback) && a.callback.call(this)
        }

        function K(a) {
            a = ga(a);
            a.find("img[data-src], source[data-src], audio[data-src]").each(function() {
                d(this).attr("src", d(this).data("src"));
                d(this).removeAttr("data-src");
                d(this).is("source") && d(this).closest("video").get(0).load()
            })
        }

        function X(a) {
            a = ga(a);
            a.find("video, audio").each(function() {
                var a = d(this).get(0);
                a.hasAttribute("autoplay") && "function" === typeof a.play && a.play()
            })
        }

        function za(a) {
            a = ga(a);
            a.find("video, audio").each(function() {
                var a =
                    d(this).get(0);
                a.hasAttribute("data-ignore") || "function" !== typeof a.pause || a.pause()
            })
        }

        function ga(a) {
            var b = a.find(".fp-slide.active");
            b.length && (a = d(b));
            return a
        }

        function Ba() {
            if (!Y && !c.lockAnchors) {
                var a = h.location.hash.replace("#", "").split("/"),
                    b = a[0],
                    a = a[1],
                    d = "undefined" === typeof z,
                    f = "undefined" === typeof z && "undefined" === typeof a && !x;
                b.length && (b && b !== z && !d || f || !x && ha != a) && V(b, a)
            }
        }

        function Ya(a) {
            w && (a.pageY < P ? e.moveSectionUp() : a.pageY > P && e.moveSectionDown());
            P = a.pageY
        }

        function H(a, b) {
            var g = b.position(),
                f = b.index(),
                e = a.closest(".fp-section"),
                h = e.index(".fp-section"),
                k = e.data("anchor"),
                l = e.find(".fp-slidesNav"),
                m = ia(b),
                v = e.find(".fp-slide.active"),
                p = t;
            if (c.onSlideLeave) {
                var q = v.index(),
                    r;
                r = q == f ? "none" : q > f ? "left" : "right";
                if (!p && "none" !== r && d.isFunction(c.onSlideLeave) && !1 === c.onSlideLeave.call(v, k, h + 1, q, r, f)) {
                    x = !1;
                    return
                }
            }
            za(v);
            b.addClass("active").siblings().removeClass("active");
            p || K(b);
            !c.loopHorizontal && c.controlArrows && (e.find(".fp-controlArrow.fp-prev").toggle(0 !== f), e.find(".fp-controlArrow.fp-next").toggle(!b.is(":last-child")));
            e.hasClass("active") && aa(f, m, k, h);
            var u = function() {
                p || d.isFunction(c.afterSlideLoad) && c.afterSlideLoad.call(b, k, h + 1, m, f);
                X(b);
                x = !1
            };
            c.css3 ? (g = "translate3d(-" + n.round(g.left) + "px, 0px, 0px)", Ca(a.find(".fp-slidesContainer"), 0 < c.scrollingSpeed).css(Da(g)), ja = setTimeout(function() {
                u()
            }, c.scrollingSpeed, c.easing)) : a.animate({
                scrollLeft: n.round(g.left)
            }, c.scrollingSpeed, c.easing, function() {
                u()
            });
            l.find(".active").removeClass("active");
            l.find("li").eq(f).find("a").addClass("active")
        }

        function Ea() {
            na();
            if (Q) {
                var a = d(m.activeElement);
                a.is("textarea") || a.is("input") || a.is("select") || (a = p.height(), n.abs(a - ka) > 20 * n.max(ka, a) / 100 && (e.reBuild(!0), ka = a))
            } else clearTimeout(la), la = setTimeout(function() {
                e.reBuild(!0)
            }, 350)
        }

        function na() {
            var a = c.responsive || c.responsiveWidth,
                b = c.responsiveHeight,
                d = a && h.outerWidth < a,
                f = b && p.height() < b;
            a && b ? e.setResponsive(d || f) : a ? e.setResponsive(d) : b && e.setResponsive(f)
        }

        function Ca(a) {
            var b = "all " + c.scrollingSpeed + "ms " + c.easingcss3;
            a.removeClass("fp-notransition");
            return a.css({
                "-webkit-transition": b,
                transition: b
            })
        }

        function Za(a, b) {
            if (825 > a || 900 > b) {
                var c = n.min(100 * a / 825, 100 * b / 900).toFixed(2);
                q.css("font-size", c + "%")
            } else q.css("font-size", "100%")
        }

        function W(a, b) {
            c.menu && (d(c.menu).find(".active").removeClass("active"), d(c.menu).find('[data-menuanchor="' + a + '"]').addClass("active"));
            c.navigation && (d("#fp-nav").find(".active").removeClass("active"), a ? d("#fp-nav").find('a[href="#' + a + '"]').addClass("active") : d("#fp-nav").find("li").eq(b).find("a").addClass("active"))
        }

        function Z(a) {
            var b = d(".fp-section.active").index(".fp-section");
            a = a.index(".fp-section");
            return b == a ? "none" : b > a ? "up" : "down"
        }

        function J(a) {
            a.css("overflow", "hidden");
            var b = c.scrollOverflowHandler,
                d = b.wrapContent(),
                f = a.closest(".fp-section"),
                e = b.scrollable(a),
                h;
            e.length ? h = b.scrollHeight(a) : (h = a.get(0).scrollHeight, c.verticalCentered && (h = a.find(".fp-tableCell").get(0).scrollHeight));
            f = r - parseInt(f.css("padding-bottom")) - parseInt(f.css("padding-top"));
            h > f ? e.length ? b.update(a, f) : (c.verticalCentered ? a.find(".fp-tableCell").wrapInner(d) : a.wrapInner(d), b.create(a, f)) :
                b.remove(a);
            a.css("overflow", "")
        }

        function pa(a) {
            a.addClass("fp-table").wrapInner('<div class="fp-tableCell" style="height:' + Fa(a) + 'px;" />')
        }

        function Fa(a) {
            var b = r;
            if (c.paddingTop || c.paddingBottom) b = a, b.hasClass("fp-section") || (b = a.closest(".fp-section")), a = parseInt(b.css("padding-top")) + parseInt(b.css("padding-bottom")), b = r - a;
            return b
        }

        function Aa(a, b) {
            b ? Ca(k) : k.addClass("fp-notransition");
            k.css(Da(a));
            setTimeout(function() {
                k.removeClass("fp-notransition")
            }, 10)
        }

        function Ga(a) {
            var b = k.find('.fp-section[data-anchor="' +
                a + '"]');
            b.length || (b = d(".fp-section").eq(a - 1));
            return b
        }

        function V(a, b) {
            var c = Ga(a);
            "undefined" === typeof b && (b = 0);
            a === z || c.hasClass("active") ? Ha(c, b) : A(c, function() {
                Ha(c, b)
            })
        }

        function Ha(a, b) {
            if ("undefined" !== typeof b) {
                var c = a.find(".fp-slides"),
                    d;
                d = a.find(".fp-slides");
                var e = d.find('.fp-slide[data-anchor="' + b + '"]');
                e.length || (e = d.find(".fp-slide").eq(b));
                d = e;
                d.length && H(c, d)
            }
        }

        function Ta(a, b) {
            a.append('<div class="fp-slidesNav"><ul></ul></div>');
            var d = a.find(".fp-slidesNav");
            d.addClass(c.slidesNavPosition);
            for (var f = 0; f < b; f++) d.find("ul").append('<li><a href="#"><span></span></a></li>');
            d.css("margin-left", "-" + d.width() / 2 + "px");
            d.find("li").first().find("a").addClass("active")
        }

        function aa(a, b, d, f) {
            f = "";
            c.anchors.length && !c.lockAnchors && (a ? ("undefined" !== typeof d && (f = d), "undefined" === typeof b && (b = a), ha = b, Ia(f + "/" + b)) : ("undefined" !== typeof a && (ha = b), Ia(d)));
            oa()
        }

        function Ia(a) {
            if (c.recordHistory) location.hash = a;
            else if (Q || R) history.replaceState(E, E, "#" + a);
            else {
                var b = h.location.href.split("#")[0];
                h.location.replace(b +
                    "#" + a)
            }
        }

        function ia(a) {
            var b = a.data("anchor");
            a = a.index();
            "undefined" === typeof b && (b = a);
            return b
        }

        function oa() {
            var a = d(".fp-section.active"),
                b = a.find(".fp-slide.active"),
                c = ia(a),
                f = ia(b);
            a.index(".fp-section");
            a = String(c);
            b.length && (a = a + "-" + f);
            a = a.replace("/", "-").replace("#", "");
            q[0].className = q[0].className.replace(RegExp("\\b\\s?fp-viewing-[^\\s]+\\b", "g"), "");
            q.addClass("fp-viewing-" + a)
        }

        function Na() {
            var a = m.createElement("p"),
                b, c = {
                    webkitTransform: "-webkit-transform",
                    OTransform: "-o-transform",
                    msTransform: "-ms-transform",
                    MozTransform: "-moz-transform",
                    transform: "transform"
                };
            m.body.insertBefore(a, null);
            for (var d in c) a.style[d] !== E && (a.style[d] = "translate3d(1px,1px,1px)", b = h.getComputedStyle(a).getPropertyValue(c[d]));
            m.body.removeChild(a);
            return b !== E && 0 < b.length && "none" !== b
        }

        function $a() {
            if (Q || R) {
                var a = Ja();
                d(".fullpage-wrapper").off("touchstart " + a.down).on("touchstart " + a.down, Va);
                d(".fullpage-wrapper").off("touchmove " + a.move).on("touchmove " + a.move, Ua)
            }
        }

        function ab() {
            if (Q || R) {
                var a =
                    Ja();
                d(".fullpage-wrapper").off("touchstart " + a.down);
                d(".fullpage-wrapper").off("touchmove " + a.move)
            }
        }

        function Ja() {
            return h.PointerEvent ? {
                down: "pointerdown",
                move: "pointermove"
            } : {
                down: "MSPointerDown",
                move: "MSPointerMove"
            }
        }

        function ua(a) {
            var b = [];
            b.y = "undefined" !== typeof a.pageY && (a.pageY || a.pageX) ? a.pageY : a.touches[0].pageY;
            b.x = "undefined" !== typeof a.pageX && (a.pageY || a.pageX) ? a.pageX : a.touches[0].pageX;
            R && da(a) && c.scrollBar && (b.y = a.touches[0].pageY, b.x = a.touches[0].pageX);
            return b
        }

        function U(a, b) {
            e.setScrollingSpeed(0,
                "internal");
            "undefined" !== typeof b && (t = !0);
            H(a.closest(".fp-slides"), a);
            "undefined" !== typeof b && (t = !1);
            e.setScrollingSpeed(D.scrollingSpeed, "internal")
        }

        function I(a) {
            c.scrollBar ? k.scrollTop(a) : c.css3 ? Aa("translate3d(0px, -" + a + "px, 0px)", !1) : k.css("top", -a)
        }

        function Da(a) {
            return {
                "-webkit-transform": a,
                "-moz-transform": a,
                "-ms-transform": a,
                transform: a
            }
        }

        function Ka(a, b, c) {
            switch (b) {
                case "up":
                    l[c].up = a;
                    break;
                case "down":
                    l[c].down = a;
                    break;
                case "left":
                    l[c].left = a;
                    break;
                case "right":
                    l[c].right = a;
                    break;
                case "all":
                    "m" ==
                    c ? e.setAllowScrolling(a) : e.setKeyboardScrolling(a)
            }
        }

        function bb() {
            I(0);
            d("#fp-nav, .fp-slidesNav, .fp-controlArrow").remove();
            d(".fp-section").css({
                height: "",
                "background-color": "",
                padding: ""
            });
            d(".fp-slide").css({
                width: ""
            });
            k.css({
                height: "",
                position: "",
                "-ms-touch-action": "",
                "touch-action": ""
            });
            y.css({
                overflow: "",
                height: ""
            });
            d("html").removeClass("fp-enabled");
            d.each(q.get(0).className.split(/\s+/), function(a, b) {
                0 === b.indexOf("fp-viewing") && q.removeClass(b)
            });
            d(".fp-section, .fp-slide").each(function() {
                c.scrollOverflowHandler.remove(d(this));
                d(this).removeClass("fp-table active")
            });
            k.addClass("fp-notransition");
            k.find(".fp-tableCell, .fp-slidesContainer, .fp-slides").each(function() {
                d(this).replaceWith(this.childNodes)
            });
            y.scrollTop(0);
            d.each(["fp-section", "fp-slide", "fp-slidesContainer"], function(a, b) {
                d("." + b).removeClass(b)
            })
        }

        function S(a, b, d) {
            c[a] = b;
            "internal" !== d && (D[a] = b)
        }

        function T(a, b) {
            console && console[a] && console[a]("fullPage: " + b)
        }
        var y = d("html, body"),
            q = d("body"),
            e = d.fn.fullpage;
        c = d.extend({
            menu: !1,
            anchors: [],
            lockAnchors: !1,
            navigation: !1,
            navigationPosition: "right",
            navigationTooltips: [],
            showActiveTooltip: !1,
            slidesNavigation: !1,
            slidesNavPosition: "bottom",
            scrollBar: !1,
            css3: !0,
            scrollingSpeed: 700,
            autoScrolling: !0,
            fitToSection: !0,
            fitToSectionDelay: 1E3,
            easing: "easeInOutCubic",
            easingcss3: "ease",
            loopBottom: !1,
            loopTop: !1,
            loopHorizontal: !0,
            continuousVertical: !1,
            normalScrollElements: null,
            scrollOverflow: !1,
            scrollOverflowHandler: ma,
            touchSensitivity: 5,
            normalScrollElementTouchThreshold: 5,
            keyboardScrolling: !0,
            animateAnchor: !0,
            recordHistory: !0,
            controlArrows: !0,
            controlArrowColor: "#fff",
            verticalCentered: !0,
            resize: !1,
            sectionsColor: [],
            paddingTop: 0,
            paddingBottom: 0,
            fixedElements: null,
            responsive: 0,
            responsiveWidth: 0,
            responsiveHeight: 0,
            sectionSelector: ".section",
            slideSelector: ".slide",
            afterLoad: null,
            onLeave: null,
            afterRender: null,
            afterResize: null,
            afterReBuild: null,
            afterSlideLoad: null,
            onSlideLeave: null
        }, c);
        (function() {
            c.continuousVertical && (c.loopTop || c.loopBottom) && (c.continuousVertical = !1, T("warn", "Option `loopTop/loopBottom` is mutually exclusive with `continuousVertical`; `continuousVertical` disabled"));
            c.scrollBar && c.scrollOverflow && T("warn", "Option `scrollBar` is mutually exclusive with `scrollOverflow`. Sections with scrollOverflow might not work well in Firefox");
            c.continuousVertical && c.scrollBar && (c.continuousVertical = !1, T("warn", "Option `scrollBar` is mutually exclusive with `continuousVertical`; `continuousVertical` disabled"));
            d.each(c.anchors, function(a, b) {
                (d("#" + b).length || d('[name="' + b + '"]').length) && T("error", "data-anchor tags can not have the same value as any `id` element on the site (or `name` element for IE).")
            })
        })();
        d.extend(d.easing, {
            easeInOutCubic: function(a, b, c, d, e) {
                return 1 > (b /= e / 2) ? d / 2 * b * b * b + c : d / 2 * ((b -= 2) * b * b + 2) + c
            }
        });
        d.extend(d.easing, {
            easeInQuart: function(a, b, c, d, e) {
                return d * (b /= e) * b * b * b + c
            }
        });
        e.setAutoScrolling = function(a, b) {
            S("autoScrolling", a, b);
            var g = d(".fp-section.active");
            c.autoScrolling && !c.scrollBar ? (y.css({
                overflow: "hidden",
                height: "100%"
            }), e.setRecordHistory(D.recordHistory, "internal"), k.css({
                "-ms-touch-action": "none",
                "touch-action": "none"
            }), g.length && I(g.position().top)) : (y.css({
                overflow: "visible",
                height: "initial"
            }), e.setRecordHistory(!1, "internal"), k.css({
                "-ms-touch-action": "",
                "touch-action": ""
            }), I(0), g.length && y.scrollTop(g.position().top))
        };
        e.setRecordHistory = function(a, b) {
            S("recordHistory", a, b)
        };
        e.setScrollingSpeed = function(a, b) {
            S("scrollingSpeed", a, b)
        };
        e.setFitToSection = function(a, b) {
            S("fitToSection", a, b)
        };
        e.setLockAnchors = function(a) {
            c.lockAnchors = a
        };
        e.setMouseWheelScrolling = function(a) {
            if (a) {
                a = "";
                var b;
                h.addEventListener ? b = "addEventListener" : (b = "attachEvent", a = "on");
                var c = "onwheel" in
                    m.createElement("div") ? "wheel" : m.onmousewheel !== E ? "mousewheel" : "DOMMouseScroll";
                if ("DOMMouseScroll" == c) m[b](a + "MozMousePixelScroll", B, !1);
                else m[b](a + c, B, !1)
            } else m.addEventListener ? (m.removeEventListener("mousewheel", B, !1), m.removeEventListener("wheel", B, !1), m.removeEventListener("MozMousePixelScroll", B, !1)) : m.detachEvent("onmousewheel", B)
        };
        e.setAllowScrolling = function(a, b) {
            "undefined" !== typeof b ? (b = b.replace(/ /g, "").split(","), d.each(b, function(b, c) {
                Ka(a, c, "m")
            })) : a ? (e.setMouseWheelScrolling(!0),
                $a()) : (e.setMouseWheelScrolling(!1), ab())
        };
        e.setKeyboardScrolling = function(a, b) {
            "undefined" !== typeof b ? (b = b.replace(/ /g, "").split(","), d.each(b, function(b, c) {
                Ka(a, c, "k")
            })) : c.keyboardScrolling = a
        };
        e.moveSectionUp = function() {
            var a = d(".fp-section.active").prev(".fp-section");
            a.length || !c.loopTop && !c.continuousVertical || (a = d(".fp-section").last());
            a.length && A(a, null, !0)
        };
        e.moveSectionDown = function() {
            var a = d(".fp-section.active").next(".fp-section");
            a.length || !c.loopBottom && !c.continuousVertical || (a =
                d(".fp-section").first());
            a.length && A(a, null, !1)
        };
        e.silentMoveTo = function(a, b) {
            requestAnimFrame(function() {
                e.setScrollingSpeed(0, "internal")
            });
            e.moveTo(a, b);
            requestAnimFrame(function() {
                e.setScrollingSpeed(D.scrollingSpeed, "internal")
            })
        };
        e.moveTo = function(a, b) {
            var c = Ga(a);
            "undefined" !== typeof b ? V(a, b) : 0 < c.length && A(c)
        };
        e.moveSlideRight = function(a) {
            xa("next", a)
        };
        e.moveSlideLeft = function(a) {
            xa("prev", a)
        };
        e.reBuild = function(a) {
            if (!k.hasClass("fp-destroyed")) {
                t = !0;
                requestAnimFrame(function() {
                    t = !0
                });
                var b =
                    h.outerWidth;
                r = p.height();
                c.resize && Za(r, b);
                d(".fp-section").each(function() {
                    var a = d(this).find(".fp-slides"),
                        b = d(this).find(".fp-slide");
                    c.verticalCentered && d(this).find(".fp-tableCell").css("height", Fa(d(this)) + "px");
                    d(this).css("height", r + "px");
                    c.scrollOverflow && (b.length ? b.each(function() {
                        J(d(this))
                    }) : J(d(this)));
                    1 < b.length && H(a, a.find(".fp-slide.active"))
                });
                (b = d(".fp-section.active").index(".fp-section")) && e.silentMoveTo(b + 1);
                t = !1;
                requestAnimFrame(function() {
                    t = !1
                });
                d.isFunction(c.afterResize) &&
                    a && c.afterResize.call(k);
                d.isFunction(c.afterReBuild) && !a && c.afterReBuild.call(k)
            }
        };
        e.setResponsive = function(a) {
            var b = q.hasClass("fp-responsive");
            a ? b || (e.setAutoScrolling(!1, "internal"), e.setFitToSection(!1, "internal"), d("#fp-nav").hide(), q.addClass("fp-responsive")) : b && (e.setAutoScrolling(D.autoScrolling, "internal"), e.setFitToSection(D.autoScrolling, "internal"), d("#fp-nav").show(), q.removeClass("fp-responsive"))
        };
        var x = !1,
            Q = navigator.userAgent.match(/(iPhone|iPod|iPad|Android|playbook|silk|BlackBerry|BB10|Windows Phone|Tizen|Bada|webOS|IEMobile|Opera Mini)/),
            R = "ontouchstart" in h || 0 < navigator.msMaxTouchPoints || navigator.maxTouchPoints,
            k = d(this),
            r = p.height(),
            t = !1,
            La = !0,
            z, ha, w = !0,
            C = [],
            O, l = {
                m: {
                    up: !0,
                    down: !0,
                    left: !0,
                    right: !0
                }
            };
        l.k = d.extend(!0, {}, l.m);
        var D = d.extend(!0, {}, c),
            la, ea, ja, ba, ca, Ma;
        d(this).length && v();
        var Y = !1;
        p.on("scroll", sa);
        var G = 0,
            N = 0,
            F = 0,
            M = 0,
            wa = (new Date).getTime();
        h.requestAnimFrame = function() {
            return h.requestAnimationFrame || h.webkitRequestAnimationFrame || h.mozRequestAnimationFrame || h.oRequestAnimationFrame || h.msRequestAnimationFrame || function(a) {
                a()
            }
        }();
        p.on("hashchange", Ba);
        u.keydown(function(a) {
            clearTimeout(Ma);
            var b = d(":focus");
            b.is("textarea") || b.is("input") || b.is("select") || !c.keyboardScrolling || !c.autoScrolling || (-1 < d.inArray(a.which, [40, 38, 32, 33, 34]) && a.preventDefault(), O = a.ctrlKey, Ma = setTimeout(function() {
                var b = a.shiftKey;
                switch (a.which) {
                    case 38:
                    case 33:
                        l.k.up && e.moveSectionUp();
                        break;
                    case 32:
                        if (b && l.k.up) {
                            e.moveSectionUp();
                            break
                        }
                    case 40:
                    case 34:
                        l.k.down && e.moveSectionDown();
                        break;
                    case 36:
                        l.k.up && e.moveTo(1);
                        break;
                    case 35:
                        l.k.down && e.moveTo(d(".fp-section").length);
                        break;
                    case 37:
                        l.k.left && e.moveSlideLeft();
                        break;
                    case 39:
                        l.k.right && e.moveSlideRight()
                }
            }, 150))
        });
        u.keyup(function(a) {
            La && (O = a.ctrlKey)
        });
        d(h).blur(function() {
            O = La = !1
        });
        k.mousedown(function(a) {
            2 == a.which && (P = a.pageY, k.on("mousemove", Ya))
        });
        k.mouseup(function(a) {
            2 == a.which && k.off("mousemove")
        });
        var P = 0;
        u.on("click touchstart", "#fp-nav a", function(a) {
            a.preventDefault();
            a = d(this).parent().index();
            A(d(".fp-section").eq(a))
        });
        u.on("click touchstart", ".fp-slidesNav a", function(a) {
            a.preventDefault();
            a = d(this).closest(".fp-section").find(".fp-slides");
            var b = a.find(".fp-slide").eq(d(this).closest("li").index());
            H(a, b)
        });
        c.normalScrollElements && (u.on("mouseenter", c.normalScrollElements, function() {
            e.setMouseWheelScrolling(!1)
        }), u.on("mouseleave", c.normalScrollElements, function() {
            e.setMouseWheelScrolling(!0)
        }));
        d(".fp-section").on("click touchstart", ".fp-controlArrow", function() {
            var a = d(this).closest(".fp-section");
            d(this).hasClass("fp-prev") ? l.m.left && e.moveSlideLeft(a) : l.m.right && e.moveSlideRight(a)
        });
        p.resize(Ea);
        var ka = r;
        e.destroy = function(a) {
            e.setAutoScrolling(!1,
                "internal");
            e.setAllowScrolling(!1);
            e.setKeyboardScrolling(!1);
            k.addClass("fp-destroyed");
            clearTimeout(ja);
            clearTimeout(ea);
            clearTimeout(la);
            clearTimeout(ba);
            clearTimeout(ca);
            p.off("scroll", sa).off("hashchange", Ba).off("resize", Ea);
            u.off("click", "#fp-nav a").off("mouseenter", "#fp-nav li").off("mouseleave", "#fp-nav li").off("click", ".fp-slidesNav a").off("mouseover", c.normalScrollElements).off("mouseout", c.normalScrollElements);
            d(".fp-section").off("click", ".fp-controlArrow");
            clearTimeout(ja);
            clearTimeout(ea);
            a && bb()
        }
    };
    ma = {
        afterRender: function(c) {
            var d = c.find("fp-slides");
            c = c.find(".fp-scrollable");
            d.length && (c = d.find(".fp-slide.active"));
            c.mouseover()
        },
        create: function(c, d) {
            c.find(".fp-scrollable").slimScroll({
                allowPageScroll: !0,
                height: d + "px",
                size: "10px",
                alwaysVisible: !0
            })
        },
        isScrolled: function(c, d) {
            if ("top" === c) return !d.scrollTop();
            if ("bottom" === c) return d.scrollTop() + 1 + d.innerHeight() >= d[0].scrollHeight
        },
        scrollable: function(c) {
            return c.find(".fp-slides").length ? c.find(".fp-slide.active").find(".fp-scrollable") :
                c.find(".fp-scrollable")
        },
        scrollHeight: function(c) {
            return c.find(".fp-scrollable").get(0).scrollHeight
        },
        remove: function(c) {
            c.find(".fp-scrollable").children().first().unwrap().unwrap();
            c.find(".slimScrollBar").remove();
            c.find(".slimScrollRail").remove()
        },
        update: function(c, d) {
            c.find(".fp-scrollable").css("height", d + "px").parent().css("height", d + "px")
        },
        wrapContent: function() {
            return '<div class="fp-scrollable"></div>'
        }
    }
});
/* Tooltipster v3.3.0 */
;
(function(e, t, n) {
    function s(t, n) {
        this.bodyOverflowX;
        this.callbacks = {
            hide: [],
            show: []
        };
        this.checkInterval = null;
        this.Content;
        this.$el = e(t);
        this.$elProxy;
        this.elProxyPosition;
        this.enabled = true;
        this.options = e.extend({}, i, n);
        this.mouseIsOverProxy = false;
        this.namespace = "tooltipster-" + Math.round(Math.random() * 1e5);
        this.Status = "hidden";
        this.timerHide = null;
        this.timerShow = null;
        this.$tooltip;
        this.options.iconTheme = this.options.iconTheme.replace(".", "");
        this.options.theme = this.options.theme.replace(".", "");
        this._init()
    }

    function o(t, n) {
        var r = true;
        e.each(t, function(e, i) {
            if (typeof n[e] === "undefined" || t[e] !== n[e]) {
                r = false;
                return false
            }
        });
        return r
    }

    function f() {
        return !a && u
    }

    function l() {
        var e = n.body || n.documentElement,
            t = e.style,
            r = "transition";
        if (typeof t[r] == "string") {
            return true
        }
        v = ["Moz", "Webkit", "Khtml", "O", "ms"], r = r.charAt(0).toUpperCase() + r.substr(1);
        for (var i = 0; i < v.length; i++) {
            if (typeof t[v[i] + r] == "string") {
                return true
            }
        }
        return false
    }
    var r = "tooltipster",
        i = {
            animation: "fade",
            arrow: true,
            arrowColor: "",
            autoClose: true,
            content: null,
            contentAsHTML: false,
            contentCloning: true,
            debug: true,
            delay: 200,
            minWidth: 0,
            maxWidth: null,
            functionInit: function(e, t) {},
            functionBefore: function(e, t) {
                t()
            },
            functionReady: function(e, t) {},
            functionAfter: function(e) {},
            hideOnClick: false,
            icon: "(?)",
            iconCloning: true,
            iconDesktop: false,
            iconTouch: false,
            iconTheme: "tooltipster-icon",
            interactive: false,
            interactiveTolerance: 350,
            multiple: false,
            offsetX: 0,
            offsetY: 0,
            onlyOne: false,
            position: "top",
            positionTracker: false,
            positionTrackerCallback: function(e) {
                if (this.option("trigger") == "hover" && this.option("autoClose")) {
                    this.hide()
                }
            },
            restoration: "current",
            speed: 350,
            timer: 0,
            theme: "tooltipster-default",
            touchDevices: true,
            trigger: "hover",
            updateAnimation: true
        };
    s.prototype = {
        _init: function() {
            var t = this;
            if (n.querySelector) {
                var r = null;
                if (t.$el.data("tooltipster-initialTitle") === undefined) {
                    r = t.$el.attr("title");
                    if (r === undefined) r = null;
                    t.$el.data("tooltipster-initialTitle", r)
                }
                if (t.options.content !== null) {
                    t._content_set(t.options.content)
                } else {
                    t._content_set(r)
                }
                var i = t.options.functionInit.call(t.$el, t.$el, t.Content);
                if (typeof i !== "undefined") t._content_set(i);
                t.$el.removeAttr("title").addClass("tooltipstered");
                if (!u && t.options.iconDesktop || u && t.options.iconTouch) {
                    if (typeof t.options.icon === "string") {
                        t.$elProxy = e('<span class="' + t.options.iconTheme + '"></span>');
                        t.$elProxy.text(t.options.icon)
                    } else {
                        if (t.options.iconCloning) t.$elProxy = t.options.icon.clone(true);
                        else t.$elProxy = t.options.icon
                    }
                    t.$elProxy.insertAfter(t.$el)
                } else {
                    t.$elProxy = t.$el
                }
                if (t.options.trigger == "hover") {
                    t.$elProxy.on("mouseenter." + t.namespace, function() {
                        if (!f() || t.options.touchDevices) {
                            t.mouseIsOverProxy = true;
                            t._show()
                        }
                    }).on("mouseleave." + t.namespace, function() {
                        if (!f() || t.options.touchDevices) {
                            t.mouseIsOverProxy = false
                        }
                    });
                    if (u && t.options.touchDevices) {
                        t.$elProxy.on("touchstart." + t.namespace, function() {
                            t._showNow()
                        })
                    }
                } else if (t.options.trigger == "click") {
                    t.$elProxy.on("click." + t.namespace, function() {
                        if (!f() || t.options.touchDevices) {
                            t._show()
                        }
                    })
                }
            }
        },
        _show: function() {
            var e = this;
            if (e.Status != "shown" && e.Status != "appearing") {
                if (e.options.delay) {
                    e.timerShow = setTimeout(function() {
                        if (e.options.trigger == "click" || e.options.trigger == "hover" && e.mouseIsOverProxy) {
                            e._showNow()
                        }
                    }, e.options.delay)
                } else e._showNow()
            }
        },
        _showNow: function(n) {
            var r = this;
            r.options.functionBefore.call(r.$el, r.$el, function() {
                if (r.enabled && r.Content !== null) {
                    if (n) r.callbacks.show.push(n);
                    r.callbacks.hide = [];
                    clearTimeout(r.timerShow);
                    r.timerShow = null;
                    clearTimeout(r.timerHide);
                    r.timerHide = null;
                    if (r.options.onlyOne) {
                        e(".tooltipstered").not(r.$el).each(function(t, n) {
                            var r = e(n),
                                i = r.data("tooltipster-ns");
                            e.each(i, function(e, t) {
                                var n = r.data(t),
                                    i = n.status(),
                                    s = n.option("autoClose");
                                if (i !== "hidden" && i !== "disappearing" && s) {
                                    n.hide()
                                }
                            })
                        })
                    }
                    var i = function() {
                        r.Status = "shown";
                        e.each(r.callbacks.show, function(e, t) {
                            t.call(r.$el)
                        });
                        r.callbacks.show = []
                    };
                    if (r.Status !== "hidden") {
                        var s = 0;
                        if (r.Status === "disappearing") {
                            r.Status = "appearing";
                            if (l()) {
                                r.$tooltip.clearQueue().removeClass("tooltipster-dying").addClass("tooltipster-" + r.options.animation + "-show");
                                if (r.options.speed > 0) r.$tooltip.delay(r.options.speed);
                                r.$tooltip.queue(i)
                            } else {
                                r.$tooltip.stop().fadeIn(i)
                            }
                        } else if (r.Status === "shown") {
                            i()
                        }
                    } else {
                        r.Status = "appearing";
                        var s = r.options.speed;
                        r.bodyOverflowX = e("body").css("overflow-x");
                        e("body").css("overflow-x", "hidden");
                        var o = "tooltipster-" + r.options.animation,
                            a = "-webkit-transition-duration: " + r.options.speed + "ms; -webkit-animation-duration: " + r.options.speed + "ms; -moz-transition-duration: " + r.options.speed + "ms; -moz-animation-duration: " + r.options.speed + "ms; -o-transition-duration: " + r.options.speed + "ms; -o-animation-duration: " + r.options.speed + "ms; -ms-transition-duration: " + r.options.speed + "ms; -ms-animation-duration: " + r.options.speed + "ms; transition-duration: " + r.options.speed + "ms; animation-duration: " + r.options.speed + "ms;",
                            f = r.options.minWidth ? "min-width:" + Math.round(r.options.minWidth) + "px;" : "",
                            c = r.options.maxWidth ? "max-width:" + Math.round(r.options.maxWidth) + "px;" : "",
                            h = r.options.interactive ? "pointer-events: auto;" : "";
                        r.$tooltip = e('<div class="tooltipster-base ' + r.options.theme + '" style="' + f + " " + c + " " + h + " " + a + '"><div class="tooltipster-content"></div></div>');
                        if (l()) r.$tooltip.addClass(o);
                        r._content_insert();
                        r.$tooltip.appendTo("body");
                        r.reposition();
                        r.options.functionReady.call(r.$el, r.$el, r.$tooltip);
                        if (l()) {
                            r.$tooltip.addClass(o + "-show");
                            if (r.options.speed > 0) r.$tooltip.delay(r.options.speed);
                            r.$tooltip.queue(i)
                        } else {
                            r.$tooltip.css("display", "none").fadeIn(r.options.speed, i)
                        }
                        r._interval_set();
                        e(t).on("scroll." + r.namespace + " resize." + r.namespace, function() {
                            r.reposition()
                        });
                        if (r.options.autoClose) {
                            e("body").off("." + r.namespace);
                            if (r.options.trigger == "hover") {
                                if (u) {
                                    setTimeout(function() {
                                        e("body").on("touchstart." + r.namespace, function() {
                                            r.hide()
                                        })
                                    }, 0)
                                }
                                if (r.options.interactive) {
                                    if (u) {
                                        r.$tooltip.on("touchstart." + r.namespace, function(e) {
                                            e.stopPropagation()
                                        })
                                    }
                                    var p = null;
                                    r.$elProxy.add(r.$tooltip).on("mouseleave." + r.namespace + "-autoClose", function() {
                                        clearTimeout(p);
                                        p = setTimeout(function() {
                                            r.hide()
                                        }, r.options.interactiveTolerance)
                                    }).on("mouseenter." + r.namespace + "-autoClose", function() {
                                        clearTimeout(p)
                                    })
                                } else {
                                    r.$elProxy.on("mouseleave." + r.namespace + "-autoClose", function() {
                                        r.hide()
                                    })
                                }
                                if (r.options.hideOnClick) {
                                    r.$elProxy.on("click." + r.namespace + "-autoClose", function() {
                                        r.hide()
                                    })
                                }
                            } else if (r.options.trigger == "click") {
                                setTimeout(function() {
                                    e("body").on("click." + r.namespace + " touchstart." + r.namespace, function() {
                                        r.hide()
                                    })
                                }, 0);
                                if (r.options.interactive) {
                                    r.$tooltip.on("click." + r.namespace + " touchstart." + r.namespace, function(e) {
                                        e.stopPropagation()
                                    })
                                }
                            }
                        }
                    }
                    if (r.options.timer > 0) {
                        r.timerHide = setTimeout(function() {
                            r.timerHide = null;
                            r.hide()
                        }, r.options.timer + s)
                    }
                }
            })
        },
        _interval_set: function() {
            var t = this;
            t.checkInterval = setInterval(function() {
                if (e("body").find(t.$el).length === 0 || e("body").find(t.$elProxy).length === 0 || t.Status == "hidden" || e("body").find(t.$tooltip).length === 0) {
                    if (t.Status == "shown" || t.Status == "appearing") t.hide();
                    t._interval_cancel()
                } else {
                    if (t.options.positionTracker) {
                        var n = t._repositionInfo(t.$elProxy),
                            r = false;
                        if (o(n.dimension, t.elProxyPosition.dimension)) {
                            if (t.$elProxy.css("position") === "fixed") {
                                if (o(n.position, t.elProxyPosition.position)) r = true
                            } else {
                                if (o(n.offset, t.elProxyPosition.offset)) r = true
                            }
                        }
                        if (!r) {
                            t.reposition();
                            t.options.positionTrackerCallback.call(t, t.$el)
                        }
                    }
                }
            }, 200)
        },
        _interval_cancel: function() {
            clearInterval(this.checkInterval);
            this.checkInterval = null
        },
        _content_set: function(e) {
            if (typeof e === "object" && e !== null && this.options.contentCloning) {
                e = e.clone(true)
            }
            this.Content = e
        },
        _content_insert: function() {
            var e = this,
                t = this.$tooltip.find(".tooltipster-content");
            if (typeof e.Content === "string" && !e.options.contentAsHTML) {
                t.text(e.Content)
            } else {
                t.empty().append(e.Content)
            }
        },
        _update: function(e) {
            var t = this;
            t._content_set(e);
            if (t.Content !== null) {
                if (t.Status !== "hidden") {
                    t._content_insert();
                    t.reposition();
                    if (t.options.updateAnimation) {
                        if (l()) {
                            t.$tooltip.css({
                                width: "",
                                "-webkit-transition": "all " + t.options.speed + "ms, width 0ms, height 0ms, left 0ms, top 0ms",
                                "-moz-transition": "all " + t.options.speed + "ms, width 0ms, height 0ms, left 0ms, top 0ms",
                                "-o-transition": "all " + t.options.speed + "ms, width 0ms, height 0ms, left 0ms, top 0ms",
                                "-ms-transition": "all " + t.options.speed + "ms, width 0ms, height 0ms, left 0ms, top 0ms",
                                transition: "all " + t.options.speed + "ms, width 0ms, height 0ms, left 0ms, top 0ms"
                            }).addClass("tooltipster-content-changing");
                            setTimeout(function() {
                                if (t.Status != "hidden") {
                                    t.$tooltip.removeClass("tooltipster-content-changing");
                                    setTimeout(function() {
                                        if (t.Status !== "hidden") {
                                            t.$tooltip.css({
                                                "-webkit-transition": t.options.speed + "ms",
                                                "-moz-transition": t.options.speed + "ms",
                                                "-o-transition": t.options.speed + "ms",
                                                "-ms-transition": t.options.speed + "ms",
                                                transition: t.options.speed + "ms"
                                            })
                                        }
                                    }, t.options.speed)
                                }
                            }, t.options.speed)
                        } else {
                            t.$tooltip.fadeTo(t.options.speed, .5, function() {
                                if (t.Status != "hidden") {
                                    t.$tooltip.fadeTo(t.options.speed, 1)
                                }
                            })
                        }
                    }
                }
            } else {
                t.hide()
            }
        },
        _repositionInfo: function(e) {
            return {
                dimension: {
                    height: e.outerHeight(false),
                    width: e.outerWidth(false)
                },
                offset: e.offset(),
                position: {
                    left: parseInt(e.css("left")),
                    top: parseInt(e.css("top"))
                }
            }
        },
        hide: function(n) {
            var r = this;
            if (n) r.callbacks.hide.push(n);
            r.callbacks.show = [];
            clearTimeout(r.timerShow);
            r.timerShow = null;
            clearTimeout(r.timerHide);
            r.timerHide = null;
            var i = function() {
                e.each(r.callbacks.hide, function(e, t) {
                    t.call(r.$el)
                });
                r.callbacks.hide = []
            };
            if (r.Status == "shown" || r.Status == "appearing") {
                r.Status = "disappearing";
                var s = function() {
                    r.Status = "hidden";
                    if (typeof r.Content == "object" && r.Content !== null) {
                        r.Content.detach()
                    }
                    r.$tooltip.remove();
                    r.$tooltip = null;
                    e(t).off("." + r.namespace);
                    e("body").off("." + r.namespace).css("overflow-x", r.bodyOverflowX);
                    e("body").off("." + r.namespace);
                    r.$elProxy.off("." + r.namespace + "-autoClose");
                    r.options.functionAfter.call(r.$el, r.$el);
                    i()
                };
                if (l()) {
                    r.$tooltip.clearQueue().removeClass("tooltipster-" + r.options.animation + "-show").addClass("tooltipster-dying");
                    if (r.options.speed > 0) r.$tooltip.delay(r.options.speed);
                    r.$tooltip.queue(s)
                } else {
                    r.$tooltip.stop().fadeOut(r.options.speed, s)
                }
            } else if (r.Status == "hidden") {
                i()
            }
            return r
        },
        show: function(e) {
            this._showNow(e);
            return this
        },
        update: function(e) {
            return this.content(e)
        },
        content: function(e) {
            if (typeof e === "undefined") {
                return this.Content
            } else {
                this._update(e);
                return this
            }
        },
        reposition: function() {
            var n = this;
            if (e("body").find(n.$tooltip).length !== 0) {
                n.$tooltip.css("width", "");
                n.elProxyPosition = n._repositionInfo(n.$elProxy);
                var r = null,
                    i = e(t).width(),
                    s = n.elProxyPosition,
                    o = n.$tooltip.outerWidth(false),
                    u = n.$tooltip.innerWidth() + 1,
                    a = n.$tooltip.outerHeight(false);
                if (n.$elProxy.is("area")) {
                    var f = n.$elProxy.attr("shape"),
                        l = n.$elProxy.parent().attr("name"),
                        c = e('img[usemap="#' + l + '"]'),
                        h = c.offset().left,
                        p = c.offset().top,
                        d = n.$elProxy.attr("coords") !== undefined ? n.$elProxy.attr("coords").split(",") : undefined;
                    if (f == "circle") {
                        var v = parseInt(d[0]),
                            m = parseInt(d[1]),
                            g = parseInt(d[2]);
                        s.dimension.height = g * 2;
                        s.dimension.width = g * 2;
                        s.offset.top = p + m - g;
                        s.offset.left = h + v - g
                    } else if (f == "rect") {
                        var v = parseInt(d[0]),
                            m = parseInt(d[1]),
                            y = parseInt(d[2]),
                            b = parseInt(d[3]);
                        s.dimension.height = b - m;
                        s.dimension.width = y - v;
                        s.offset.top = p + m;
                        s.offset.left = h + v
                    } else if (f == "poly") {
                        var w = [],
                            E = [],
                            S = 0,
                            x = 0,
                            T = 0,
                            N = 0,
                            C = "even";
                        for (var k = 0; k < d.length; k++) {
                            var L = parseInt(d[k]);
                            if (C == "even") {
                                if (L > T) {
                                    T = L;
                                    if (k === 0) {
                                        S = T
                                    }
                                }
                                if (L < S) {
                                    S = L
                                }
                                C = "odd"
                            } else {
                                if (L > N) {
                                    N = L;
                                    if (k == 1) {
                                        x = N
                                    }
                                }
                                if (L < x) {
                                    x = L
                                }
                                C = "even"
                            }
                        }
                        s.dimension.height = N - x;
                        s.dimension.width = T - S;
                        s.offset.top = p + x;
                        s.offset.left = h + S
                    } else {
                        s.dimension.height = c.outerHeight(false);
                        s.dimension.width = c.outerWidth(false);
                        s.offset.top = p;
                        s.offset.left = h
                    }
                }
                var A = 0,
                    O = 0,
                    M = 0,
                    _ = parseInt(n.options.offsetY),
                    D = parseInt(n.options.offsetX),
                    P = n.options.position;

                function H() {
                    var n = e(t).scrollLeft();
                    if (A - n < 0) {
                        r = A - n;
                        A = n
                    }
                    if (A + o - n > i) {
                        r = A - (i + n - o);
                        A = i + n - o
                    }
                }

                function B(n, r) {
                    if (s.offset.top - e(t).scrollTop() - a - _ - 12 < 0 && r.indexOf("top") > -1) {
                        P = n
                    }
                    if (s.offset.top + s.dimension.height + a + 12 + _ > e(t).scrollTop() + e(t).height() && r.indexOf("bottom") > -1) {
                        P = n;
                        M = s.offset.top - a - _ - 12
                    }
                }
                if (P == "top") {
                    var j = s.offset.left + o - (s.offset.left + s.dimension.width);
                    A = s.offset.left + D - j / 2;
                    M = s.offset.top - a - _ - 12;
                    H();
                    B("bottom", "top")
                }
                if (P == "top-left") {
                    A = s.offset.left + D;
                    M = s.offset.top - a - _ - 12;
                    H();
                    B("bottom-left", "top-left")
                }
                if (P == "top-right") {
                    A = s.offset.left + s.dimension.width + D - o;
                    M = s.offset.top - a - _ - 12;
                    H();
                    B("bottom-right", "top-right")
                }
                if (P == "bottom") {
                    var j = s.offset.left + o - (s.offset.left + s.dimension.width);
                    A = s.offset.left - j / 2 + D;
                    M = s.offset.top + s.dimension.height + _ + 12;
                    H();
                    B("top", "bottom")
                }
                if (P == "bottom-left") {
                    A = s.offset.left + D;
                    M = s.offset.top + s.dimension.height + _ + 12;
                    H();
                    B("top-left", "bottom-left")
                }
                if (P == "bottom-right") {
                    A = s.offset.left + s.dimension.width + D - o;
                    M = s.offset.top + s.dimension.height + _ + 12;
                    H();
                    B("top-right", "bottom-right")
                }
                if (P == "left") {
                    A = s.offset.left - D - o - 12;
                    O = s.offset.left + D + s.dimension.width + 12;
                    var F = s.offset.top + a - (s.offset.top + s.dimension.height);
                    M = s.offset.top - F / 2 - _;
                    if (A < 0 && O + o > i) {
                        var I = parseFloat(n.$tooltip.css("border-width")) * 2,
                            q = o + A - I;
                        n.$tooltip.css("width", q + "px");
                        a = n.$tooltip.outerHeight(false);
                        A = s.offset.left - D - q - 12 - I;
                        F = s.offset.top + a - (s.offset.top + s.dimension.height);
                        M = s.offset.top - F / 2 - _
                    } else if (A < 0) {
                        A = s.offset.left + D + s.dimension.width + 12;
                        r = "left"
                    }
                }
                if (P == "right") {
                    A = s.offset.left + D + s.dimension.width + 12;
                    O = s.offset.left - D - o - 12;
                    var F = s.offset.top + a - (s.offset.top + s.dimension.height);
                    M = s.offset.top - F / 2 - _;
                    if (A + o > i && O < 0) {
                        var I = parseFloat(n.$tooltip.css("border-width")) * 2,
                            q = i - A - I;
                        n.$tooltip.css("width", q + "px");
                        a = n.$tooltip.outerHeight(false);
                        F = s.offset.top + a - (s.offset.top + s.dimension.height);
                        M = s.offset.top - F / 2 - _
                    } else if (A + o > i) {
                        A = s.offset.left - D - o - 12;
                        r = "right"
                    }
                }
                if (n.options.arrow) {
                    var R = "tooltipster-arrow-" + P;
                    if (n.options.arrowColor.length < 1) {
                        var U = n.$tooltip.css("background-color")
                    } else {
                        var U = n.options.arrowColor
                    }
                    if (!r) {
                        r = ""
                    } else if (r == "left") {
                        R = "tooltipster-arrow-right";
                        r = ""
                    } else if (r == "right") {
                        R = "tooltipster-arrow-left";
                        r = ""
                    } else {
                        r = "left:" + Math.round(r) + "px;"
                    }
                    if (P == "top" || P == "top-left" || P == "top-right") {
                        var z = parseFloat(n.$tooltip.css("border-bottom-width")),
                            W = n.$tooltip.css("border-bottom-color")
                    } else if (P == "bottom" || P == "bottom-left" || P == "bottom-right") {
                        var z = parseFloat(n.$tooltip.css("border-top-width")),
                            W = n.$tooltip.css("border-top-color")
                    } else if (P == "left") {
                        var z = parseFloat(n.$tooltip.css("border-right-width")),
                            W = n.$tooltip.css("border-right-color")
                    } else if (P == "right") {
                        var z = parseFloat(n.$tooltip.css("border-left-width")),
                            W = n.$tooltip.css("border-left-color")
                    } else {
                        var z = parseFloat(n.$tooltip.css("border-bottom-width")),
                            W = n.$tooltip.css("border-bottom-color")
                    }
                    if (z > 1) {
                        z++
                    }
                    var X = "";
                    if (z !== 0) {
                        var V = "",
                            J = "border-color: " + W + ";";
                        if (R.indexOf("bottom") !== -1) {
                            V = "margin-top: -" + Math.round(z) + "px;"
                        } else if (R.indexOf("top") !== -1) {
                            V = "margin-bottom: -" + Math.round(z) + "px;"
                        } else if (R.indexOf("left") !== -1) {
                            V = "margin-right: -" + Math.round(z) + "px;"
                        } else if (R.indexOf("right") !== -1) {
                            V = "margin-left: -" + Math.round(z) + "px;"
                        }
                        X = '<span class="tooltipster-arrow-border" style="' + V + " " + J + ';"></span>'
                    }
                    n.$tooltip.find(".tooltipster-arrow").remove();
                    var K = '<div class="' + R + ' tooltipster-arrow" style="' + r + '">' + X + '<span style="border-color:' + U + ';"></span></div>';
                    n.$tooltip.append(K)
                }
                n.$tooltip.css({
                    top: Math.round(M) + "px",
                    left: Math.round(A) + "px"
                })
            }
            return n
        },
        enable: function() {
            this.enabled = true;
            return this
        },
        disable: function() {
            this.hide();
            this.enabled = false;
            return this
        },
        destroy: function() {
            var t = this;
            t.hide();
            if (t.$el[0] !== t.$elProxy[0]) {
                t.$elProxy.remove()
            }
            t.$el.removeData(t.namespace).off("." + t.namespace);
            var n = t.$el.data("tooltipster-ns");
            if (n.length === 1) {
                var r = null;
                if (t.options.restoration === "previous") {
                    r = t.$el.data("tooltipster-initialTitle")
                } else if (t.options.restoration === "current") {
                    r = typeof t.Content === "string" ? t.Content : e("<div></div>").append(t.Content).html()
                }
                if (r) {
                    t.$el.attr("title", r)
                }
                t.$el.removeClass("tooltipstered").removeData("tooltipster-ns").removeData("tooltipster-initialTitle")
            } else {
                n = e.grep(n, function(e, n) {
                    return e !== t.namespace
                });
                t.$el.data("tooltipster-ns", n)
            }
            return t
        },
        elementIcon: function() {
            return this.$el[0] !== this.$elProxy[0] ? this.$elProxy[0] : undefined
        },
        elementTooltip: function() {
            return this.$tooltip ? this.$tooltip[0] : undefined
        },
        option: function(e, t) {
            if (typeof t == "undefined") return this.options[e];
            else {
                this.options[e] = t;
                return this
            }
        },
        status: function() {
            return this.Status
        }
    };
    e.fn[r] = function() {
        var t = arguments;
        if (this.length === 0) {
            if (typeof t[0] === "string") {
                var n = true;
                switch (t[0]) {
                    case "setDefaults":
                        e.extend(i, t[1]);
                        break;
                    default:
                        n = false;
                        break
                }
                if (n) return true;
                else return this
            } else {
                return this
            }
        } else {
            if (typeof t[0] === "string") {
                var r = "#*$~&";
                this.each(function() {
                    var n = e(this).data("tooltipster-ns"),
                        i = n ? e(this).data(n[0]) : null;
                    if (i) {
                        if (typeof i[t[0]] === "function") {
                            var s = i[t[0]](t[1], t[2])
                        } else {
                            throw new Error('Unknown method .tooltipster("' + t[0] + '")')
                        }
                        if (s !== i) {
                            r = s;
                            return false
                        }
                    } else {
                        throw new Error("You called Tooltipster's \"" + t[0] + '" method on an uninitialized element')
                    }
                });
                return r !== "#*$~&" ? r : this
            } else {
                var o = [],
                    u = t[0] && typeof t[0].multiple !== "undefined",
                    a = u && t[0].multiple || !u && i.multiple,
                    f = t[0] && typeof t[0].debug !== "undefined",
                    l = f && t[0].debug || !f && i.debug;
                this.each(function() {
                    var n = false,
                        r = e(this).data("tooltipster-ns"),
                        i = null;
                    if (!r) {
                        n = true
                    } else if (a) {
                        n = true
                    } else if (l) {
                        console.log('Tooltipster: one or more tooltips are already attached to this element: ignoring. Use the "multiple" option to attach more tooltips.')
                    }
                    if (n) {
                        i = new s(this, t[0]);
                        if (!r) r = [];
                        r.push(i.namespace);
                        e(this).data("tooltipster-ns", r);
                        e(this).data(i.namespace, i)
                    }
                    o.push(i)
                });
                if (a) return o;
                else return this
            }
        }
    };
    var u = !!("ontouchstart" in t);
    var a = false;
    e("body").one("mousemove", function() {
        a = true
    })
})(jQuery, window, document);
/*! Copyright (c) 2011 Piotr Rochala (http://rocha.la)
 * Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
 * and GPL (http://www.opensource.org/licenses/gpl-license.php) licenses.
 *
 * Version: 1.3.8
 *
 */
(function(e) {
    e.fn.extend({
        slimScroll: function(f) {
            var a = e.extend({
                width: "auto",
                height: "250px",
                size: "7px",
                color: "#000",
                position: "right",
                distance: "1px",
                start: "top",
                opacity: .4,
                alwaysVisible: !1,
                disableFadeOut: !1,
                railVisible: !1,
                railColor: "#333",
                railOpacity: .2,
                railDraggable: !0,
                railClass: "slimScrollRail",
                barClass: "slimScrollBar",
                wrapperClass: "slimScrollDiv",
                allowPageScroll: !1,
                wheelStep: 20,
                touchScrollStep: 200,
                borderRadius: "7px",
                railBorderRadius: "7px"
            }, f);
            this.each(function() {
                function v(d) {
                    if (r) {
                        d = d || window.event;
                        var c = 0;
                        d.wheelDelta && (c = -d.wheelDelta / 120);
                        d.detail && (c = d.detail / 3);
                        e(d.target || d.srcTarget || d.srcElement).closest("." + a.wrapperClass).is(b.parent()) && n(c, !0);
                        d.preventDefault && !k && d.preventDefault();
                        k || (d.returnValue = !1)
                    }
                }

                function n(d, e, f) {
                    k = !1;
                    var g = d,
                        h = b.outerHeight() - c.outerHeight();
                    e && (g = parseInt(c.css("top")) + d * parseInt(a.wheelStep) / 100 * c.outerHeight(), g = Math.min(Math.max(g, 0), h), g = 0 < d ? Math.ceil(g) : Math.floor(g), c.css({
                        top: g + "px"
                    }));
                    l = parseInt(c.css("top")) / (b.outerHeight() - c.outerHeight());
                    g = l * (b[0].scrollHeight - b.outerHeight());
                    f && (g = d, d = g / b[0].scrollHeight * b.outerHeight(), d = Math.min(Math.max(d, 0), h), c.css({
                        top: d + "px"
                    }));
                    b.scrollTop(g);
                    b.trigger("slimscrolling", ~~g);
                    w();
                    q()
                }

                function x() {
                    u = Math.max(b.outerHeight() / b[0].scrollHeight * b.outerHeight(), 30);
                    c.css({
                        height: u + "px"
                    });
                    var a = u == b.outerHeight() ? "none" : "block";
                    c.css({
                        display: a
                    })
                }

                function w() {
                    x();
                    clearTimeout(B);
                    l == ~~l ? (k = a.allowPageScroll, C != l && b.trigger("slimscroll", 0 == ~~l ? "top" : "bottom")) : k = !1;
                    C = l;
                    u >= b.outerHeight() ? k = !0 : (c.stop(!0, !0).fadeIn("fast"), a.railVisible && m.stop(!0, !0).fadeIn("fast"))
                }

                function q() {
                    a.alwaysVisible || (B = setTimeout(function() {
                        a.disableFadeOut && r || y || z || (c.fadeOut("slow"), m.fadeOut("slow"))
                    }, 1E3))
                }
                var r, y, z, B, A, u, l, C, k = !1,
                    b = e(this);
                if (b.parent().hasClass(a.wrapperClass)) {
                    var p = b.scrollTop(),
                        c = b.siblings("." + a.barClass),
                        m = b.siblings("." + a.railClass);
                    x();
                    if (e.isPlainObject(f)) {
                        if ("height" in f && "auto" == f.height) {
                            b.parent().css("height", "auto");
                            b.css("height", "auto");
                            var h = b.parent().parent().height();
                            b.parent().css("height",
                                h);
                            b.css("height", h)
                        } else "height" in f && (h = f.height, b.parent().css("height", h), b.css("height", h));
                        if ("scrollTo" in f) p = parseInt(a.scrollTo);
                        else if ("scrollBy" in f) p += parseInt(a.scrollBy);
                        else if ("destroy" in f) {
                            c.remove();
                            m.remove();
                            b.unwrap();
                            return
                        }
                        n(p, !1, !0)
                    }
                } else if (!(e.isPlainObject(f) && "destroy" in f)) {
                    a.height = "auto" == a.height ? b.parent().height() : a.height;
                    p = e("<div></div>").addClass(a.wrapperClass).css({
                        position: "relative",
                        overflow: "hidden",
                        width: a.width,
                        height: a.height
                    });
                    b.css({
                        overflow: "hidden",
                        width: a.width,
                        height: a.height
                    });
                    var m = e("<div></div>").addClass(a.railClass).css({
                            width: a.size,
                            height: "100%",
                            position: "absolute",
                            top: 0,
                            display: a.alwaysVisible && a.railVisible ? "block" : "none",
                            "border-radius": a.railBorderRadius,
                            background: a.railColor,
                            opacity: a.railOpacity,
                            zIndex: 90
                        }),
                        c = e("<div></div>").addClass(a.barClass).css({
                            background: a.color,
                            width: a.size,
                            position: "absolute",
                            top: 0,
                            opacity: a.opacity,
                            display: a.alwaysVisible ? "block" : "none",
                            "border-radius": a.borderRadius,
                            BorderRadius: a.borderRadius,
                            MozBorderRadius: a.borderRadius,
                            WebkitBorderRadius: a.borderRadius,
                            zIndex: 99
                        }),
                        h = "right" == a.position ? {
                            right: a.distance
                        } : {
                            left: a.distance
                        };
                    m.css(h);
                    c.css(h);
                    b.wrap(p);
                    b.parent().append(c);
                    b.parent().append(m);
                    a.railDraggable && c.bind("mousedown", function(a) {
                        var b = e(document);
                        z = !0;
                        t = parseFloat(c.css("top"));
                        pageY = a.pageY;
                        b.bind("mousemove.slimscroll", function(a) {
                            currTop = t + a.pageY - pageY;
                            c.css("top", currTop);
                            n(0, c.position().top, !1)
                        });
                        b.bind("mouseup.slimscroll", function(a) {
                            z = !1;
                            q();
                            b.unbind(".slimscroll")
                        });
                        return !1
                    }).bind("selectstart.slimscroll",
                        function(a) {
                            a.stopPropagation();
                            a.preventDefault();
                            return !1
                        });
                    m.hover(function() {
                        w()
                    }, function() {
                        q()
                    });
                    c.hover(function() {
                        y = !0
                    }, function() {
                        y = !1
                    });
                    b.hover(function() {
                        r = !0;
                        w();
                        q()
                    }, function() {
                        r = !1;
                        q()
                    });
                    b.bind("touchstart", function(a, b) {
                        a.originalEvent.touches.length && (A = a.originalEvent.touches[0].pageY)
                    });
                    b.bind("touchmove", function(b) {
                        k || b.originalEvent.preventDefault();
                        b.originalEvent.touches.length && (n((A - b.originalEvent.touches[0].pageY) / a.touchScrollStep, !0), A = b.originalEvent.touches[0].pageY)
                    });
                    x();
                    "bottom" === a.start ? (c.css({
                        top: b.outerHeight() - c.outerHeight()
                    }), n(0, !0)) : "top" !== a.start && (n(e(a.start).position().top, null, !0), a.alwaysVisible || c.hide());
                    window.addEventListener ? (this.addEventListener("DOMMouseScroll", v, !1), this.addEventListener("mousewheel", v, !1)) : document.attachEvent("onmousewheel", v)
                }
            });
            return this
        }
    });
    e.fn.extend({
        slimscroll: e.fn.slimScroll
    })
})(jQuery);
/*!
 * jqPagination, a jQuery pagination plugin (obviously)
 * Version: 1.4 (26th July 2013)
 *
 * Copyright (C) 2013 Ben Everard
 *
 * http://beneverard.github.com/jqPagination
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *     
 */
(function(e) {
    "use strict";
    e.jqPagination = function(t, n) {
        var r = this;
        r.$el = e(t);
        r.el = t;
        r.$input = r.$el.find("input");
        r.$el.data("jqPagination", r);
        r.init = function() {
            r.options = e.extend({}, e.jqPagination.defaultOptions, n);
            r.options.max_page === null && (r.$input.data("max-page") !== undefined ? r.options.max_page = r.$input.data("max-page") : r.options.max_page = 1);
            r.$input.data("current-page") !== undefined && r.isNumber(r.$input.data("current-page")) && (r.options.current_page = r.$input.data("current-page"));
            r.$input.removeAttr("readonly");
            r.updateInput(!0);
            r.$input.on("focus.jqPagination mouseup.jqPagination", function(t) {
                if (t.type === "focus") {
                    var n = parseInt(r.options.current_page, 10);
                    e(this).val(n).select()
                }
                if (t.type === "mouseup") return !1
            });
            r.$input.on("blur.jqPagination keydown.jqPagination", function(t) {
                var n = e(this),
                    i = parseInt(r.options.current_page, 10);
                if (t.keyCode === 27) {
                    n.val(i);
                    n.blur()
                }
                t.keyCode === 13 && n.blur();
                t.type === "blur" && r.setPage(n.val())
            });
            r.$el.on("click.jqPagination", "a", function(t) {
                var n = e(this);
                if (n.hasClass("disabled")) return !1;
                if (!t.metaKey && !t.ctrlKey) {
                    t.preventDefault();
                    r.setPage(n.data("action"))
                }
            })
        };
        r.setPage = function(e, t) {
            if (e === undefined) return r.options.current_page;
            var n = parseInt(r.options.current_page, 10),
                i = parseInt(r.options.max_page, 10);
            if (isNaN(parseInt(e, 10))) switch (e) {
                case "first":
                    e = 1;
                    break;
                case "prev":
                case "previous":
                    e = n - 1;
                    break;
                case "next":
                    e = n + 1;
                    break;
                case "last":
                    e = i
            }
            e = parseInt(e, 10);
            if (isNaN(e) || e < 1 || e > i) {
                r.setInputValue(n);
                return !1
            }
            r.options.current_page = e;
            r.$input.data("current-page", e);
            r.updateInput(t)
        };
        r.setMaxPage = function(e, t) {
            if (e === undefined) return r.options.max_page;
            if (!r.isNumber(e)) {
                console.error("jqPagination: max_page is not a number");
                return !1
            }
            if (e < r.options.current_page) {
                console.error("jqPagination: max_page lower than current_page");
                return !1
            }
            r.options.max_page = e;
            r.$input.data("max-page", e);
            r.updateInput(t)
        };
        r.updateInput = function(e) {
            var t = parseInt(r.options.current_page, 10);
            r.setInputValue(t);
            r.setLinks(t);
            e !== !0 && r.options.paged(t)
        };
        r.setInputValue = function(e) {
            var t = r.options.page_string,
                n = r.options.max_page;
            t = t.replace("{current_page}", e).replace("{max_page}", n);
            r.$input.val(t)
        };
        r.isNumber = function(e) {
            return !isNaN(parseFloat(e)) && isFinite(e)
        };
        r.setLinks = function(e) {
            var t = r.options.link_string,
                n = parseInt(r.options.current_page, 10),
                i = parseInt(r.options.max_page, 10);
            if (t !== "") {
                var s = n - 1;
                s < 1 && (s = 1);
                var o = n + 1;
                o > i && (o = i);
                r.$el.find("a.first").attr("href", t.replace("{page_number}", "1"));
                r.$el.find("a.prev, a.previous").attr("href", t.replace("{page_number}", s));
                r.$el.find("a.next").attr("href", t.replace("{page_number}", o));
                r.$el.find("a.last").attr("href", t.replace("{page_number}", i))
            }
            r.$el.find("a").removeClass("disabled");
            n === i && r.$el.find(".next, .last").addClass("disabled");
            n === 1 && r.$el.find(".previous, .first").addClass("disabled")
        };
        r.callMethod = function(t, n, i) {
            switch (t.toLowerCase()) {
                case "option":
                    if (i === undefined && typeof n != "object") return r.options[n];
                    var s = {
                            trigger: !0
                        },
                        o = !1;
                    e.isPlainObject(n) && !i ? e.extend(s, n) : s[n] = i;
                    var u = s.trigger === !1;
                    s.current_page !== undefined && (o = r.setPage(s.current_page, u));
                    s.max_page !== undefined && (o = r.setMaxPage(s.max_page, u));
                    o === !1 && console.error("jqPagination: cannot get / set option " + n);
                    return o;
                case "destroy":
                    r.$el.off(".jqPagination").find("*").off(".jqPagination");
                    break;
                default:
                    console.error('jqPagination: method "' + t + '" does not exist');
                    return !1
            }
        };
        r.init()
    };
    e.jqPagination.defaultOptions = {
        current_page: 1,
        link_string: "",
        max_page: null,
        page_string: "Page {current_page} of {max_page}",
        paged: function() {}
    };
    e.fn.jqPagination = function() {
        var t = this,
            n = e(t),
            r = Array.prototype.slice.call(arguments),
            i = !1;
        if (typeof r[0] == "string") {
            r[2] === undefined ? i = n.first().data("jqPagination").callMethod(r[0], r[1]) : n.each(function() {
                i = e(this).data("jqPagination").callMethod(r[0], r[1], r[2])
            });
            return i
        }
        t.each(function() {
            new e.jqPagination(this, r[0])
        })
    }
})(jQuery);
if (!console) {
    var console = {},
        func = function() {
            return !1
        };
    console.log = func;
    console.info = func;
    console.warn = func;
    console.error = func
};
/*!
 * numeral.js
 * version : 1.5.3
 * author : Adam Draper
 * license : MIT
 * http://adamwdraper.github.com/Numeral-js/
 */
(function() {
    function a(a) {
        this._value = a
    }

    function b(a, b, c, d) {
        var e, f, g = Math.pow(10, b);
        return f = (c(a * g) / g).toFixed(b), d && (e = new RegExp("0{1," + d + "}$"), f = f.replace(e, "")), f
    }

    function c(a, b, c) {
        var d;
        return d = b.indexOf("$") > -1 ? e(a, b, c) : b.indexOf("%") > -1 ? f(a, b, c) : b.indexOf(":") > -1 ? g(a, b) : i(a._value, b, c)
    }

    function d(a, b) {
        var c, d, e, f, g, i = b,
            j = ["KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"],
            k = !1;
        if (b.indexOf(":") > -1) a._value = h(b);
        else if (b === q) a._value = 0;
        else {
            for ("." !== o[p].delimiters.decimal && (b = b.replace(/\./g, "").replace(o[p].delimiters.decimal, ".")), c = new RegExp("[^a-zA-Z]" + o[p].abbreviations.thousand + "(?:\\)|(\\" + o[p].currency.symbol + ")?(?:\\))?)?$"), d = new RegExp("[^a-zA-Z]" + o[p].abbreviations.million + "(?:\\)|(\\" + o[p].currency.symbol + ")?(?:\\))?)?$"), e = new RegExp("[^a-zA-Z]" + o[p].abbreviations.billion + "(?:\\)|(\\" + o[p].currency.symbol + ")?(?:\\))?)?$"), f = new RegExp("[^a-zA-Z]" + o[p].abbreviations.trillion + "(?:\\)|(\\" + o[p].currency.symbol + ")?(?:\\))?)?$"), g = 0; g <= j.length && !(k = b.indexOf(j[g]) > -1 ? Math.pow(1024, g + 1) : !1); g++);
            a._value = (k ? k : 1) * (i.match(c) ? Math.pow(10, 3) : 1) * (i.match(d) ? Math.pow(10, 6) : 1) * (i.match(e) ? Math.pow(10, 9) : 1) * (i.match(f) ? Math.pow(10, 12) : 1) * (b.indexOf("%") > -1 ? .01 : 1) * ((b.split("-").length + Math.min(b.split("(").length - 1, b.split(")").length - 1)) % 2 ? 1 : -1) * Number(b.replace(/[^0-9\.]+/g, "")), a._value = k ? Math.ceil(a._value) : a._value
        }
        return a._value
    }

    function e(a, b, c) {
        var d, e, f = b.indexOf("$"),
            g = b.indexOf("("),
            h = b.indexOf("-"),
            j = "";
        return b.indexOf(" $") > -1 ? (j = " ", b = b.replace(" $", "")) : b.indexOf("$ ") > -1 ? (j = " ", b = b.replace("$ ", "")) : b = b.replace("$", ""), e = i(a._value, b, c), 1 >= f ? e.indexOf("(") > -1 || e.indexOf("-") > -1 ? (e = e.split(""), d = 1, (g > f || h > f) && (d = 0), e.splice(d, 0, o[p].currency.symbol + j), e = e.join("")) : e = o[p].currency.symbol + j + e : e.indexOf(")") > -1 ? (e = e.split(""), e.splice(-1, 0, j + o[p].currency.symbol), e = e.join("")) : e = e + j + o[p].currency.symbol, e
    }

    function f(a, b, c) {
        var d, e = "",
            f = 100 * a._value;
        return b.indexOf(" %") > -1 ? (e = " ", b = b.replace(" %", "")) : b = b.replace("%", ""), d = i(f, b, c), d.indexOf(")") > -1 ? (d = d.split(""), d.splice(-1, 0, e + "%"), d = d.join("")) : d = d + e + "%", d
    }

    function g(a) {
        var b = Math.floor(a._value / 60 / 60),
            c = Math.floor((a._value - 60 * b * 60) / 60),
            d = Math.round(a._value - 60 * b * 60 - 60 * c);
        return b + ":" + (10 > c ? "0" + c : c) + ":" + (10 > d ? "0" + d : d)
    }

    function h(a) {
        var b = a.split(":"),
            c = 0;
        return 3 === b.length ? (c += 60 * Number(b[0]) * 60, c += 60 * Number(b[1]), c += Number(b[2])) : 2 === b.length && (c += 60 * Number(b[0]), c += Number(b[1])), Number(c)
    }

    function i(a, c, d) {
        var e, f, g, h, i, j, k = !1,
            l = !1,
            m = !1,
            n = "",
            r = !1,
            s = !1,
            t = !1,
            u = !1,
            v = !1,
            w = "",
            x = "",
            y = Math.abs(a),
            z = ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"],
            A = "",
            B = !1;
        if (0 === a && null !== q) return q;
        if (c.indexOf("(") > -1 ? (k = !0, c = c.slice(1, -1)) : c.indexOf("+") > -1 && (l = !0, c = c.replace(/\+/g, "")), c.indexOf("a") > -1 && (r = c.indexOf("aK") >= 0, s = c.indexOf("aM") >= 0, t = c.indexOf("aB") >= 0, u = c.indexOf("aT") >= 0, v = r || s || t || u, c.indexOf(" a") > -1 ? (n = " ", c = c.replace(" a", "")) : c = c.replace("a", ""), y >= Math.pow(10, 12) && !v || u ? (n += o[p].abbreviations.trillion, a /= Math.pow(10, 12)) : y < Math.pow(10, 12) && y >= Math.pow(10, 9) && !v || t ? (n += o[p].abbreviations.billion, a /= Math.pow(10, 9)) : y < Math.pow(10, 9) && y >= Math.pow(10, 6) && !v || s ? (n += o[p].abbreviations.million, a /= Math.pow(10, 6)) : (y < Math.pow(10, 6) && y >= Math.pow(10, 3) && !v || r) && (n += o[p].abbreviations.thousand, a /= Math.pow(10, 3))), c.indexOf("b") > -1)
            for (c.indexOf(" b") > -1 ? (w = " ", c = c.replace(" b", "")) : c = c.replace("b", ""), g = 0; g <= z.length; g++)
                if (e = Math.pow(1024, g), f = Math.pow(1024, g + 1), a >= e && f > a) {
                    w += z[g], e > 0 && (a /= e);
                    break
                }
        return c.indexOf("o") > -1 && (c.indexOf(" o") > -1 ? (x = " ", c = c.replace(" o", "")) : c = c.replace("o", ""), x += o[p].ordinal(a)), c.indexOf("[.]") > -1 && (m = !0, c = c.replace("[.]", ".")), h = a.toString().split(".")[0], i = c.split(".")[1], j = c.indexOf(","), i ? (i.indexOf("[") > -1 ? (i = i.replace("]", ""), i = i.split("["), A = b(a, i[0].length + i[1].length, d, i[1].length)) : A = b(a, i.length, d), h = A.split(".")[0], A = A.split(".")[1].length ? o[p].delimiters.decimal + A.split(".")[1] : "", m && 0 === Number(A.slice(1)) && (A = "")) : h = b(a, null, d), h.indexOf("-") > -1 && (h = h.slice(1), B = !0), j > -1 && (h = h.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1" + o[p].delimiters.thousands)), 0 === c.indexOf(".") && (h = ""), (k && B ? "(" : "") + (!k && B ? "-" : "") + (!B && l ? "+" : "") + h + A + (x ? x : "") + (n ? n : "") + (w ? w : "") + (k && B ? ")" : "")
    }

    function j(a, b) {
        o[a] = b
    }

    function k(a) {
        var b = a.toString().split(".");
        return b.length < 2 ? 1 : Math.pow(10, b[1].length)
    }

    function l() {
        var a = Array.prototype.slice.call(arguments);
        return a.reduce(function(a, b) {
            var c = k(a),
                d = k(b);
            return c > d ? c : d
        }, -1 / 0)
    }
    var m, n = "1.5.3",
        o = {},
        p = "en",
        q = null,
        r = "0,0",
        s = "undefined" != typeof module && module.exports;
    m = function(b) {
        return m.isNumeral(b) ? b = b.value() : 0 === b || "undefined" == typeof b ? b = 0 : Number(b) || (b = m.fn.unformat(b)), new a(Number(b))
    }, m.version = n, m.isNumeral = function(b) {
        return b instanceof a
    }, m.language = function(a, b) {
        if (!a) return p;
        if (a && !b) {
            if (!o[a]) throw new Error("Unknown language : " + a);
            p = a
        }
        return (b || !o[a]) && j(a, b), m
    }, m.languageData = function(a) {
        if (!a) return o[p];
        if (!o[a]) throw new Error("Unknown language : " + a);
        return o[a]
    }, m.language("en", {
        delimiters: {
            thousands: ",",
            decimal: "."
        },
        abbreviations: {
            thousand: "k",
            million: "m",
            billion: "b",
            trillion: "t"
        },
        ordinal: function(a) {
            var b = a % 10;
            return 1 === ~~(a % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th"
        },
        currency: {
            symbol: "$"
        }
    }), m.zeroFormat = function(a) {
        q = "string" == typeof a ? a : null
    }, m.defaultFormat = function(a) {
        r = "string" == typeof a ? a : "0.0"
    }, "function" != typeof Array.prototype.reduce && (Array.prototype.reduce = function(a, b) {
        "use strict";
        if (null === this || "undefined" == typeof this) throw new TypeError("Array.prototype.reduce called on null or undefined");
        if ("function" != typeof a) throw new TypeError(a + " is not a function");
        var c, d, e = this.length >>> 0,
            f = !1;
        for (1 < arguments.length && (d = b, f = !0), c = 0; e > c; ++c) this.hasOwnProperty(c) && (f ? d = a(d, this[c], c, this) : (d = this[c], f = !0));
        if (!f) throw new TypeError("Reduce of empty array with no initial value");
        return d
    }), m.fn = a.prototype = {
        clone: function() {
            return m(this)
        },
        format: function(a, b) {
            return c(this, a ? a : r, void 0 !== b ? b : Math.round)
        },
        unformat: function(a) {
            return "[object Number]" === Object.prototype.toString.call(a) ? a : d(this, a ? a : r)
        },
        value: function() {
            return this._value
        },
        valueOf: function() {
            return this._value
        },
        set: function(a) {
            return this._value = Number(a), this
        },
        add: function(a) {
            function b(a, b) {
                return a + c * b
            }
            var c = l.call(null, this._value, a);
            return this._value = [this._value, a].reduce(b, 0) / c, this
        },
        subtract: function(a) {
            function b(a, b) {
                return a - c * b
            }
            var c = l.call(null, this._value, a);
            return this._value = [a].reduce(b, this._value * c) / c, this
        },
        multiply: function(a) {
            function b(a, b) {
                var c = l(a, b);
                return a * c * b * c / (c * c)
            }
            return this._value = [this._value, a].reduce(b, 1), this
        },
        divide: function(a) {
            function b(a, b) {
                var c = l(a, b);
                return a * c / (b * c)
            }
            return this._value = [this._value, a].reduce(b), this
        },
        difference: function(a) {
            return Math.abs(m(this._value).subtract(a).value())
        }
    }, s && (module.exports = m), "undefined" == typeof ender && (this.numeral = m), "function" == typeof define && define.amd && define([], function() {
        return m
    })
}).call(this);
/*! VelocityJS.org (1.2.3). (C) 2014 Julian Shapiro. MIT @license: en.wikipedia.org/wiki/MIT_License */
/*! VelocityJS.org jQuery Shim (1.0.1). (C) 2014 The jQuery Foundation. MIT @license: en.wikipedia.org/wiki/MIT_License. */
! function(a) {
    function b(a) {
        var b = a.length,
            d = c.type(a);
        return "function" === d || c.isWindow(a) ? !1 : 1 === a.nodeType && b ? !0 : "array" === d || 0 === b || "number" == typeof b && b > 0 && b - 1 in a
    }
    if (!a.jQuery) {
        var c = function(a, b) {
            return new c.fn.init(a, b)
        };
        c.isWindow = function(a) {
            return null != a && a == a.window
        }, c.type = function(a) {
            return null == a ? a + "" : "object" == typeof a || "function" == typeof a ? e[g.call(a)] || "object" : typeof a
        }, c.isArray = Array.isArray || function(a) {
            return "array" === c.type(a)
        }, c.isPlainObject = function(a) {
            var b;
            if (!a || "object" !== c.type(a) || a.nodeType || c.isWindow(a)) return !1;
            try {
                if (a.constructor && !f.call(a, "constructor") && !f.call(a.constructor.prototype, "isPrototypeOf")) return !1
            } catch (d) {
                return !1
            }
            for (b in a);
            return void 0 === b || f.call(a, b)
        }, c.each = function(a, c, d) {
            var e, f = 0,
                g = a.length,
                h = b(a);
            if (d) {
                if (h)
                    for (; g > f && (e = c.apply(a[f], d), e !== !1); f++);
                else
                    for (f in a)
                        if (e = c.apply(a[f], d), e === !1) break
            } else if (h)
                for (; g > f && (e = c.call(a[f], f, a[f]), e !== !1); f++);
            else
                for (f in a)
                    if (e = c.call(a[f], f, a[f]), e === !1) break;
            return a
        }, c.data = function(a, b, e) {
            if (void 0 === e) {
                var f = a[c.expando],
                    g = f && d[f];
                if (void 0 === b) return g;
                if (g && b in g) return g[b]
            } else if (void 0 !== b) {
                var f = a[c.expando] || (a[c.expando] = ++c.uuid);
                return d[f] = d[f] || {}, d[f][b] = e, e
            }
        }, c.removeData = function(a, b) {
            var e = a[c.expando],
                f = e && d[e];
            f && c.each(b, function(a, b) {
                delete f[b]
            })
        }, c.extend = function() {
            var a, b, d, e, f, g, h = arguments[0] || {},
                i = 1,
                j = arguments.length,
                k = !1;
            for ("boolean" == typeof h && (k = h, h = arguments[i] || {}, i++), "object" != typeof h && "function" !== c.type(h) && (h = {}), i === j && (h = this, i--); j > i; i++)
                if (null != (f = arguments[i]))
                    for (e in f) a = h[e], d = f[e], h !== d && (k && d && (c.isPlainObject(d) || (b = c.isArray(d))) ? (b ? (b = !1, g = a && c.isArray(a) ? a : []) : g = a && c.isPlainObject(a) ? a : {}, h[e] = c.extend(k, g, d)) : void 0 !== d && (h[e] = d));
            return h
        }, c.queue = function(a, d, e) {
            function f(a, c) {
                var d = c || [];
                return null != a && (b(Object(a)) ? ! function(a, b) {
                    for (var c = +b.length, d = 0, e = a.length; c > d;) a[e++] = b[d++];
                    if (c !== c)
                        for (; void 0 !== b[d];) a[e++] = b[d++];
                    return a.length = e, a
                }(d, "string" == typeof a ? [a] : a) : [].push.call(d, a)), d
            }
            if (a) {
                d = (d || "fx") + "queue";
                var g = c.data(a, d);
                return e ? (!g || c.isArray(e) ? g = c.data(a, d, f(e)) : g.push(e), g) : g || []
            }
        }, c.dequeue = function(a, b) {
            c.each(a.nodeType ? [a] : a, function(a, d) {
                b = b || "fx";
                var e = c.queue(d, b),
                    f = e.shift();
                "inprogress" === f && (f = e.shift()), f && ("fx" === b && e.unshift("inprogress"), f.call(d, function() {
                    c.dequeue(d, b)
                }))
            })
        }, c.fn = c.prototype = {
            init: function(a) {
                if (a.nodeType) return this[0] = a, this;
                throw new Error("Not a DOM node.")
            },
            offset: function() {
                var b = this[0].getBoundingClientRect ? this[0].getBoundingClientRect() : {
                    top: 0,
                    left: 0
                };
                return {
                    top: b.top + (a.pageYOffset || document.scrollTop || 0) - (document.clientTop || 0),
                    left: b.left + (a.pageXOffset || document.scrollLeft || 0) - (document.clientLeft || 0)
                }
            },
            position: function() {
                function a() {
                    for (var a = this.offsetParent || document; a && "html" === !a.nodeType.toLowerCase && "static" === a.style.position;) a = a.offsetParent;
                    return a || document
                }
                var b = this[0],
                    a = a.apply(b),
                    d = this.offset(),
                    e = /^(?:body|html)$/i.test(a.nodeName) ? {
                        top: 0,
                        left: 0
                    } : c(a).offset();
                return d.top -= parseFloat(b.style.marginTop) || 0, d.left -= parseFloat(b.style.marginLeft) || 0, a.style && (e.top += parseFloat(a.style.borderTopWidth) || 0, e.left += parseFloat(a.style.borderLeftWidth) || 0), {
                    top: d.top - e.top,
                    left: d.left - e.left
                }
            }
        };
        var d = {};
        c.expando = "velocity" + (new Date).getTime(), c.uuid = 0;
        for (var e = {}, f = e.hasOwnProperty, g = e.toString, h = "Boolean Number String Function Array Date RegExp Object Error".split(" "), i = 0; i < h.length; i++) e["[object " + h[i] + "]"] = h[i].toLowerCase();
        c.fn.init.prototype = c.fn, a.Velocity = {
            Utilities: c
        }
    }
}(window),
function(a) {
    "object" == typeof module && "object" == typeof module.exports ? module.exports = a() : "function" == typeof define && define.amd ? define(a) : a()
}(function() {
    return function(a, b, c, d) {
        function e(a) {
            for (var b = -1, c = a ? a.length : 0, d = []; ++b < c;) {
                var e = a[b];
                e && d.push(e)
            }
            return d
        }

        function f(a) {
            return p.isWrapped(a) ? a = [].slice.call(a) : p.isNode(a) && (a = [a]), a
        }

        function g(a) {
            var b = m.data(a, "velocity");
            return null === b ? d : b
        }

        function h(a) {
            return function(b) {
                return Math.round(b * a) * (1 / a)
            }
        }

        function i(a, c, d, e) {
            function f(a, b) {
                return 1 - 3 * b + 3 * a
            }

            function g(a, b) {
                return 3 * b - 6 * a
            }

            function h(a) {
                return 3 * a
            }

            function i(a, b, c) {
                return ((f(b, c) * a + g(b, c)) * a + h(b)) * a
            }

            function j(a, b, c) {
                return 3 * f(b, c) * a * a + 2 * g(b, c) * a + h(b)
            }

            function k(b, c) {
                for (var e = 0; p > e; ++e) {
                    var f = j(c, a, d);
                    if (0 === f) return c;
                    var g = i(c, a, d) - b;
                    c -= g / f
                }
                return c
            }

            function l() {
                for (var b = 0; t > b; ++b) x[b] = i(b * u, a, d)
            }

            function m(b, c, e) {
                var f, g, h = 0;
                do g = c + (e - c) / 2, f = i(g, a, d) - b, f > 0 ? e = g : c = g; while (Math.abs(f) > r && ++h < s);
                return g
            }

            function n(b) {
                for (var c = 0, e = 1, f = t - 1; e != f && x[e] <= b; ++e) c += u;
                --e;
                var g = (b - x[e]) / (x[e + 1] - x[e]),
                    h = c + g * u,
                    i = j(h, a, d);
                return i >= q ? k(b, h) : 0 == i ? h : m(b, c, c + u)
            }

            function o() {
                y = !0, (a != c || d != e) && l()
            }
            var p = 4,
                q = .001,
                r = 1e-7,
                s = 10,
                t = 11,
                u = 1 / (t - 1),
                v = "Float32Array" in b;
            if (4 !== arguments.length) return !1;
            for (var w = 0; 4 > w; ++w)
                if ("number" != typeof arguments[w] || isNaN(arguments[w]) || !isFinite(arguments[w])) return !1;
            a = Math.min(a, 1), d = Math.min(d, 1), a = Math.max(a, 0), d = Math.max(d, 0);
            var x = v ? new Float32Array(t) : new Array(t),
                y = !1,
                z = function(b) {
                    return y || o(), a === c && d === e ? b : 0 === b ? 0 : 1 === b ? 1 : i(n(b), c, e)
                };
            z.getControlPoints = function() {
                return [{
                    x: a,
                    y: c
                }, {
                    x: d,
                    y: e
                }]
            };
            var A = "generateBezier(" + [a, c, d, e] + ")";
            return z.toString = function() {
                return A
            }, z
        }

        function j(a, b) {
            var c = a;
            return p.isString(a) ? t.Easings[a] || (c = !1) : c = p.isArray(a) && 1 === a.length ? h.apply(null, a) : p.isArray(a) && 2 === a.length ? u.apply(null, a.concat([b])) : p.isArray(a) && 4 === a.length ? i.apply(null, a) : !1, c === !1 && (c = t.Easings[t.defaults.easing] ? t.defaults.easing : s), c
        }

        function k(a) {
            if (a) {
                var b = (new Date).getTime(),
                    c = t.State.calls.length;
                c > 1e4 && (t.State.calls = e(t.State.calls));
                for (var f = 0; c > f; f++)
                    if (t.State.calls[f]) {
                        var h = t.State.calls[f],
                            i = h[0],
                            j = h[2],
                            n = h[3],
                            o = !!n,
                            q = null;
                        n || (n = t.State.calls[f][3] = b - 16);
                        for (var r = Math.min((b - n) / j.duration, 1), s = 0, u = i.length; u > s; s++) {
                            var w = i[s],
                                y = w.element;
                            if (g(y)) {
                                var z = !1;
                                if (j.display !== d && null !== j.display && "none" !== j.display) {
                                    if ("flex" === j.display) {
                                        var A = ["-webkit-box", "-moz-box", "-ms-flexbox", "-webkit-flex"];
                                        m.each(A, function(a, b) {
                                            v.setPropertyValue(y, "display", b)
                                        })
                                    }
                                    v.setPropertyValue(y, "display", j.display)
                                }
                                j.visibility !== d && "hidden" !== j.visibility && v.setPropertyValue(y, "visibility", j.visibility);
                                for (var B in w)
                                    if ("element" !== B) {
                                        var C, D = w[B],
                                            E = p.isString(D.easing) ? t.Easings[D.easing] : D.easing;
                                        if (1 === r) C = D.endValue;
                                        else {
                                            var F = D.endValue - D.startValue;
                                            if (C = D.startValue + F * E(r, j, F), !o && C === D.currentValue) continue
                                        }
                                        if (D.currentValue = C, "tween" === B) q = C;
                                        else {
                                            if (v.Hooks.registered[B]) {
                                                var G = v.Hooks.getRoot(B),
                                                    H = g(y).rootPropertyValueCache[G];
                                                H && (D.rootPropertyValue = H)
                                            }
                                            var I = v.setPropertyValue(y, B, D.currentValue + (0 === parseFloat(C) ? "" : D.unitType), D.rootPropertyValue, D.scrollData);
                                            v.Hooks.registered[B] && (g(y).rootPropertyValueCache[G] = v.Normalizations.registered[G] ? v.Normalizations.registered[G]("extract", null, I[1]) : I[1]), "transform" === I[0] && (z = !0)
                                        }
                                    }
                                j.mobileHA && g(y).transformCache.translate3d === d && (g(y).transformCache.translate3d = "(0px, 0px, 0px)", z = !0), z && v.flushTransformCache(y)
                            }
                        }
                        j.display !== d && "none" !== j.display && (t.State.calls[f][2].display = !1), j.visibility !== d && "hidden" !== j.visibility && (t.State.calls[f][2].visibility = !1), j.progress && j.progress.call(h[1], h[1], r, Math.max(0, n + j.duration - b), n, q), 1 === r && l(f)
                    }
            }
            t.State.isTicking && x(k)
        }

        function l(a, b) {
            if (!t.State.calls[a]) return !1;
            for (var c = t.State.calls[a][0], e = t.State.calls[a][1], f = t.State.calls[a][2], h = t.State.calls[a][4], i = !1, j = 0, k = c.length; k > j; j++) {
                var l = c[j].element;
                if (b || f.loop || ("none" === f.display && v.setPropertyValue(l, "display", f.display), "hidden" === f.visibility && v.setPropertyValue(l, "visibility", f.visibility)), f.loop !== !0 && (m.queue(l)[1] === d || !/\.velocityQueueEntryFlag/i.test(m.queue(l)[1])) && g(l)) {
                    g(l).isAnimating = !1, g(l).rootPropertyValueCache = {};
                    var n = !1;
                    m.each(v.Lists.transforms3D, function(a, b) {
                        var c = /^scale/.test(b) ? 1 : 0,
                            e = g(l).transformCache[b];
                        g(l).transformCache[b] !== d && new RegExp("^\\(" + c + "[^.]").test(e) && (n = !0, delete g(l).transformCache[b])
                    }), f.mobileHA && (n = !0, delete g(l).transformCache.translate3d), n && v.flushTransformCache(l), v.Values.removeClass(l, "velocity-animating")
                }
                if (!b && f.complete && !f.loop && j === k - 1) try {
                    f.complete.call(e, e)
                } catch (o) {
                    setTimeout(function() {
                        throw o
                    }, 1)
                }
                h && f.loop !== !0 && h(e), g(l) && f.loop === !0 && !b && (m.each(g(l).tweensContainer, function(a, b) {
                    /^rotate/.test(a) && 360 === parseFloat(b.endValue) && (b.endValue = 0, b.startValue = 360), /^backgroundPosition/.test(a) && 100 === parseFloat(b.endValue) && "%" === b.unitType && (b.endValue = 0, b.startValue = 100)
                }), t(l, "reverse", {
                    loop: !0,
                    delay: f.delay
                })), f.queue !== !1 && m.dequeue(l, f.queue)
            }
            t.State.calls[a] = !1;
            for (var p = 0, q = t.State.calls.length; q > p; p++)
                if (t.State.calls[p] !== !1) {
                    i = !0;
                    break
                }
            i === !1 && (t.State.isTicking = !1, delete t.State.calls, t.State.calls = [])
        }
        var m, n = function() {
                if (c.documentMode) return c.documentMode;
                for (var a = 7; a > 4; a--) {
                    var b = c.createElement("div");
                    if (b.innerHTML = "<!--[if IE " + a + "]><span></span><![endif]-->", b.getElementsByTagName("span").length) return b = null, a
                }
                return d
            }(),
            o = function() {
                var a = 0;
                return b.webkitRequestAnimationFrame || b.mozRequestAnimationFrame || function(b) {
                    var c, d = (new Date).getTime();
                    return c = Math.max(0, 16 - (d - a)), a = d + c, setTimeout(function() {
                        b(d + c)
                    }, c)
                }
            }(),
            p = {
                isString: function(a) {
                    return "string" == typeof a
                },
                isArray: Array.isArray || function(a) {
                    return "[object Array]" === Object.prototype.toString.call(a)
                },
                isFunction: function(a) {
                    return "[object Function]" === Object.prototype.toString.call(a)
                },
                isNode: function(a) {
                    return a && a.nodeType
                },
                isNodeList: function(a) {
                    return "object" == typeof a && /^\[object (HTMLCollection|NodeList|Object)\]$/.test(Object.prototype.toString.call(a)) && a.length !== d && (0 === a.length || "object" == typeof a[0] && a[0].nodeType > 0)
                },
                isWrapped: function(a) {
                    return a && (a.jquery || b.Zepto && b.Zepto.zepto.isZ(a))
                },
                isSVG: function(a) {
                    return b.SVGElement && a instanceof b.SVGElement
                },
                isEmptyObject: function(a) {
                    for (var b in a) return !1;
                    return !0
                }
            },
            q = !1;
        if (a.fn && a.fn.jquery ? (m = a, q = !0) : m = b.Velocity.Utilities, 8 >= n && !q) throw new Error("Velocity: IE8 and below require jQuery to be loaded before Velocity.");
        if (7 >= n) return void(jQuery.fn.velocity = jQuery.fn.animate);
        var r = 400,
            s = "swing",
            t = {
                State: {
                    isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
                    isAndroid: /Android/i.test(navigator.userAgent),
                    isGingerbread: /Android 2\.3\.[3-7]/i.test(navigator.userAgent),
                    isChrome: b.chrome,
                    isFirefox: /Firefox/i.test(navigator.userAgent),
                    prefixElement: c.createElement("div"),
                    prefixMatches: {},
                    scrollAnchor: null,
                    scrollPropertyLeft: null,
                    scrollPropertyTop: null,
                    isTicking: !1,
                    calls: []
                },
                CSS: {},
                Utilities: m,
                Redirects: {},
                Easings: {},
                Promise: b.Promise,
                defaults: {
                    queue: "",
                    duration: r,
                    easing: s,
                    begin: d,
                    complete: d,
                    progress: d,
                    display: d,
                    visibility: d,
                    loop: !1,
                    delay: !1,
                    mobileHA: !0,
                    _cacheValues: !0
                },
                init: function(a) {
                    m.data(a, "velocity", {
                        isSVG: p.isSVG(a),
                        isAnimating: !1,
                        computedStyle: null,
                        tweensContainer: null,
                        rootPropertyValueCache: {},
                        transformCache: {}
                    })
                },
                hook: null,
                mock: !1,
                version: {
                    major: 1,
                    minor: 2,
                    patch: 2
                },
                debug: !1
            };
        b.pageYOffset !== d ? (t.State.scrollAnchor = b, t.State.scrollPropertyLeft = "pageXOffset", t.State.scrollPropertyTop = "pageYOffset") : (t.State.scrollAnchor = c.documentElement || c.body.parentNode || c.body, t.State.scrollPropertyLeft = "scrollLeft", t.State.scrollPropertyTop = "scrollTop");
        var u = function() {
            function a(a) {
                return -a.tension * a.x - a.friction * a.v
            }

            function b(b, c, d) {
                var e = {
                    x: b.x + d.dx * c,
                    v: b.v + d.dv * c,
                    tension: b.tension,
                    friction: b.friction
                };
                return {
                    dx: e.v,
                    dv: a(e)
                }
            }

            function c(c, d) {
                var e = {
                        dx: c.v,
                        dv: a(c)
                    },
                    f = b(c, .5 * d, e),
                    g = b(c, .5 * d, f),
                    h = b(c, d, g),
                    i = 1 / 6 * (e.dx + 2 * (f.dx + g.dx) + h.dx),
                    j = 1 / 6 * (e.dv + 2 * (f.dv + g.dv) + h.dv);
                return c.x = c.x + i * d, c.v = c.v + j * d, c
            }
            return function d(a, b, e) {
                var f, g, h, i = {
                        x: -1,
                        v: 0,
                        tension: null,
                        friction: null
                    },
                    j = [0],
                    k = 0,
                    l = 1e-4,
                    m = .016;
                for (a = parseFloat(a) || 500, b = parseFloat(b) || 20, e = e || null, i.tension = a, i.friction = b, f = null !== e, f ? (k = d(a, b), g = k / e * m) : g = m;;)
                    if (h = c(h || i, g), j.push(1 + h.x), k += 16, !(Math.abs(h.x) > l && Math.abs(h.v) > l)) break;
                return f ? function(a) {
                    return j[a * (j.length - 1) | 0]
                } : k
            }
        }();
        t.Easings = {
            linear: function(a) {
                return a
            },
            swing: function(a) {
                return .5 - Math.cos(a * Math.PI) / 2
            },
            spring: function(a) {
                return 1 - Math.cos(4.5 * a * Math.PI) * Math.exp(6 * -a)
            }
        }, m.each([
            ["ease", [.25, .1, .25, 1]],
            ["ease-in", [.42, 0, 1, 1]],
            ["ease-out", [0, 0, .58, 1]],
            ["ease-in-out", [.42, 0, .58, 1]],
            ["easeInSine", [.47, 0, .745, .715]],
            ["easeOutSine", [.39, .575, .565, 1]],
            ["easeInOutSine", [.445, .05, .55, .95]],
            ["easeInQuad", [.55, .085, .68, .53]],
            ["easeOutQuad", [.25, .46, .45, .94]],
            ["easeInOutQuad", [.455, .03, .515, .955]],
            ["easeInCubic", [.55, .055, .675, .19]],
            ["easeOutCubic", [.215, .61, .355, 1]],
            ["easeInOutCubic", [.645, .045, .355, 1]],
            ["easeInQuart", [.895, .03, .685, .22]],
            ["easeOutQuart", [.165, .84, .44, 1]],
            ["easeInOutQuart", [.77, 0, .175, 1]],
            ["easeInQuint", [.755, .05, .855, .06]],
            ["easeOutQuint", [.23, 1, .32, 1]],
            ["easeInOutQuint", [.86, 0, .07, 1]],
            ["easeInExpo", [.95, .05, .795, .035]],
            ["easeOutExpo", [.19, 1, .22, 1]],
            ["easeInOutExpo", [1, 0, 0, 1]],
            ["easeInCirc", [.6, .04, .98, .335]],
            ["easeOutCirc", [.075, .82, .165, 1]],
            ["easeInOutCirc", [.785, .135, .15, .86]]
        ], function(a, b) {
            t.Easings[b[0]] = i.apply(null, b[1])
        });
        var v = t.CSS = {
            RegEx: {
                isHex: /^#([A-f\d]{3}){1,2}$/i,
                valueUnwrap: /^[A-z]+\((.*)\)$/i,
                wrappedValueAlreadyExtracted: /[0-9.]+ [0-9.]+ [0-9.]+( [0-9.]+)?/,
                valueSplit: /([A-z]+\(.+\))|(([A-z0-9#-.]+?)(?=\s|$))/gi
            },
            Lists: {
                colors: ["fill", "stroke", "stopColor", "color", "backgroundColor", "borderColor", "borderTopColor", "borderRightColor", "borderBottomColor", "borderLeftColor", "outlineColor"],
                transformsBase: ["translateX", "translateY", "scale", "scaleX", "scaleY", "skewX", "skewY", "rotateZ"],
                transforms3D: ["transformPerspective", "translateZ", "scaleZ", "rotateX", "rotateY"]
            },
            Hooks: {
                templates: {
                    textShadow: ["Color X Y Blur", "black 0px 0px 0px"],
                    boxShadow: ["Color X Y Blur Spread", "black 0px 0px 0px 0px"],
                    clip: ["Top Right Bottom Left", "0px 0px 0px 0px"],
                    backgroundPosition: ["X Y", "0% 0%"],
                    transformOrigin: ["X Y Z", "50% 50% 0px"],
                    perspectiveOrigin: ["X Y", "50% 50%"]
                },
                registered: {},
                register: function() {
                    for (var a = 0; a < v.Lists.colors.length; a++) {
                        var b = "color" === v.Lists.colors[a] ? "0 0 0 1" : "255 255 255 1";
                        v.Hooks.templates[v.Lists.colors[a]] = ["Red Green Blue Alpha", b]
                    }
                    var c, d, e;
                    if (n)
                        for (c in v.Hooks.templates) {
                            d = v.Hooks.templates[c], e = d[0].split(" ");
                            var f = d[1].match(v.RegEx.valueSplit);
                            "Color" === e[0] && (e.push(e.shift()), f.push(f.shift()), v.Hooks.templates[c] = [e.join(" "), f.join(" ")])
                        }
                    for (c in v.Hooks.templates) {
                        d = v.Hooks.templates[c], e = d[0].split(" ");
                        for (var a in e) {
                            var g = c + e[a],
                                h = a;
                            v.Hooks.registered[g] = [c, h]
                        }
                    }
                },
                getRoot: function(a) {
                    var b = v.Hooks.registered[a];
                    return b ? b[0] : a
                },
                cleanRootPropertyValue: function(a, b) {
                    return v.RegEx.valueUnwrap.test(b) && (b = b.match(v.RegEx.valueUnwrap)[1]), v.Values.isCSSNullValue(b) && (b = v.Hooks.templates[a][1]), b
                },
                extractValue: function(a, b) {
                    var c = v.Hooks.registered[a];
                    if (c) {
                        var d = c[0],
                            e = c[1];
                        return b = v.Hooks.cleanRootPropertyValue(d, b), b.toString().match(v.RegEx.valueSplit)[e]
                    }
                    return b
                },
                injectValue: function(a, b, c) {
                    var d = v.Hooks.registered[a];
                    if (d) {
                        var e, f, g = d[0],
                            h = d[1];
                        return c = v.Hooks.cleanRootPropertyValue(g, c), e = c.toString().match(v.RegEx.valueSplit), e[h] = b, f = e.join(" ")
                    }
                    return c
                }
            },
            Normalizations: {
                registered: {
                    clip: function(a, b, c) {
                        switch (a) {
                            case "name":
                                return "clip";
                            case "extract":
                                var d;
                                return v.RegEx.wrappedValueAlreadyExtracted.test(c) ? d = c : (d = c.toString().match(v.RegEx.valueUnwrap), d = d ? d[1].replace(/,(\s+)?/g, " ") : c), d;
                            case "inject":
                                return "rect(" + c + ")"
                        }
                    },
                    blur: function(a, b, c) {
                        switch (a) {
                            case "name":
                                return t.State.isFirefox ? "filter" : "-webkit-filter";
                            case "extract":
                                var d = parseFloat(c);
                                if (!d && 0 !== d) {
                                    var e = c.toString().match(/blur\(([0-9]+[A-z]+)\)/i);
                                    d = e ? e[1] : 0
                                }
                                return d;
                            case "inject":
                                return parseFloat(c) ? "blur(" + c + ")" : "none"
                        }
                    },
                    opacity: function(a, b, c) {
                        if (8 >= n) switch (a) {
                            case "name":
                                return "filter";
                            case "extract":
                                var d = c.toString().match(/alpha\(opacity=(.*)\)/i);
                                return c = d ? d[1] / 100 : 1;
                            case "inject":
                                return b.style.zoom = 1, parseFloat(c) >= 1 ? "" : "alpha(opacity=" + parseInt(100 * parseFloat(c), 10) + ")"
                        } else switch (a) {
                            case "name":
                                return "opacity";
                            case "extract":
                                return c;
                            case "inject":
                                return c
                        }
                    }
                },
                register: function() {
                    9 >= n || t.State.isGingerbread || (v.Lists.transformsBase = v.Lists.transformsBase.concat(v.Lists.transforms3D));
                    for (var a = 0; a < v.Lists.transformsBase.length; a++) ! function() {
                        var b = v.Lists.transformsBase[a];
                        v.Normalizations.registered[b] = function(a, c, e) {
                            switch (a) {
                                case "name":
                                    return "transform";
                                case "extract":
                                    return g(c) === d || g(c).transformCache[b] === d ? /^scale/i.test(b) ? 1 : 0 : g(c).transformCache[b].replace(/[()]/g, "");
                                case "inject":
                                    var f = !1;
                                    switch (b.substr(0, b.length - 1)) {
                                        case "translate":
                                            f = !/(%|px|em|rem|vw|vh|\d)$/i.test(e);
                                            break;
                                        case "scal":
                                        case "scale":
                                            t.State.isAndroid && g(c).transformCache[b] === d && 1 > e && (e = 1), f = !/(\d)$/i.test(e);
                                            break;
                                        case "skew":
                                            f = !/(deg|\d)$/i.test(e);
                                            break;
                                        case "rotate":
                                            f = !/(deg|\d)$/i.test(e)
                                    }
                                    return f || (g(c).transformCache[b] = "(" + e + ")"), g(c).transformCache[b]
                            }
                        }
                    }();
                    for (var a = 0; a < v.Lists.colors.length; a++) ! function() {
                        var b = v.Lists.colors[a];
                        v.Normalizations.registered[b] = function(a, c, e) {
                            switch (a) {
                                case "name":
                                    return b;
                                case "extract":
                                    var f;
                                    if (v.RegEx.wrappedValueAlreadyExtracted.test(e)) f = e;
                                    else {
                                        var g, h = {
                                            black: "rgb(0, 0, 0)",
                                            blue: "rgb(0, 0, 255)",
                                            gray: "rgb(128, 128, 128)",
                                            green: "rgb(0, 128, 0)",
                                            red: "rgb(255, 0, 0)",
                                            white: "rgb(255, 255, 255)"
                                        };
                                        /^[A-z]+$/i.test(e) ? g = h[e] !== d ? h[e] : h.black : v.RegEx.isHex.test(e) ? g = "rgb(" + v.Values.hexToRgb(e).join(" ") + ")" : /^rgba?\(/i.test(e) || (g = h.black), f = (g || e).toString().match(v.RegEx.valueUnwrap)[1].replace(/,(\s+)?/g, " ")
                                    }
                                    return 8 >= n || 3 !== f.split(" ").length || (f += " 1"), f;
                                case "inject":
                                    return 8 >= n ? 4 === e.split(" ").length && (e = e.split(/\s+/).slice(0, 3).join(" ")) : 3 === e.split(" ").length && (e += " 1"), (8 >= n ? "rgb" : "rgba") + "(" + e.replace(/\s+/g, ",").replace(/\.(\d)+(?=,)/g, "") + ")"
                            }
                        }
                    }()
                }
            },
            Names: {
                camelCase: function(a) {
                    return a.replace(/-(\w)/g, function(a, b) {
                        return b.toUpperCase()
                    })
                },
                SVGAttribute: function(a) {
                    var b = "width|height|x|y|cx|cy|r|rx|ry|x1|x2|y1|y2";
                    return (n || t.State.isAndroid && !t.State.isChrome) && (b += "|transform"), new RegExp("^(" + b + ")$", "i").test(a)
                },
                prefixCheck: function(a) {
                    if (t.State.prefixMatches[a]) return [t.State.prefixMatches[a], !0];
                    for (var b = ["", "Webkit", "Moz", "ms", "O"], c = 0, d = b.length; d > c; c++) {
                        var e;
                        if (e = 0 === c ? a : b[c] + a.replace(/^\w/, function(a) {
                                return a.toUpperCase()
                            }), p.isString(t.State.prefixElement.style[e])) return t.State.prefixMatches[a] = e, [e, !0]
                    }
                    return [a, !1]
                }
            },
            Values: {
                hexToRgb: function(a) {
                    var b, c = /^#?([a-f\d])([a-f\d])([a-f\d])$/i,
                        d = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
                    return a = a.replace(c, function(a, b, c, d) {
                        return b + b + c + c + d + d
                    }), b = d.exec(a), b ? [parseInt(b[1], 16), parseInt(b[2], 16), parseInt(b[3], 16)] : [0, 0, 0]
                },
                isCSSNullValue: function(a) {
                    return 0 == a || /^(none|auto|transparent|(rgba\(0, ?0, ?0, ?0\)))$/i.test(a)
                },
                getUnitType: function(a) {
                    return /^(rotate|skew)/i.test(a) ? "deg" : /(^(scale|scaleX|scaleY|scaleZ|alpha|flexGrow|flexHeight|zIndex|fontWeight)$)|((opacity|red|green|blue|alpha)$)/i.test(a) ? "" : "px"
                },
                getDisplayType: function(a) {
                    var b = a && a.tagName.toString().toLowerCase();
                    return /^(b|big|i|small|tt|abbr|acronym|cite|code|dfn|em|kbd|strong|samp|var|a|bdo|br|img|map|object|q|script|span|sub|sup|button|input|label|select|textarea)$/i.test(b) ? "inline" : /^(li)$/i.test(b) ? "list-item" : /^(tr)$/i.test(b) ? "table-row" : /^(table)$/i.test(b) ? "table" : /^(tbody)$/i.test(b) ? "table-row-group" : "block"
                },
                addClass: function(a, b) {
                    a.classList ? a.classList.add(b) : a.className += (a.className.length ? " " : "") + b
                },
                removeClass: function(a, b) {
                    a.classList ? a.classList.remove(b) : a.className = a.className.toString().replace(new RegExp("(^|\\s)" + b.split(" ").join("|") + "(\\s|$)", "gi"), " ")
                }
            },
            getPropertyValue: function(a, c, e, f) {
                function h(a, c) {
                    function e() {
                        j && v.setPropertyValue(a, "display", "none")
                    }
                    var i = 0;
                    if (8 >= n) i = m.css(a, c);
                    else {
                        var j = !1;
                        if (/^(width|height)$/.test(c) && 0 === v.getPropertyValue(a, "display") && (j = !0, v.setPropertyValue(a, "display", v.Values.getDisplayType(a))), !f) {
                            if ("height" === c && "border-box" !== v.getPropertyValue(a, "boxSizing").toString().toLowerCase()) {
                                var k = a.offsetHeight - (parseFloat(v.getPropertyValue(a, "borderTopWidth")) || 0) - (parseFloat(v.getPropertyValue(a, "borderBottomWidth")) || 0) - (parseFloat(v.getPropertyValue(a, "paddingTop")) || 0) - (parseFloat(v.getPropertyValue(a, "paddingBottom")) || 0);
                                return e(), k
                            }
                            if ("width" === c && "border-box" !== v.getPropertyValue(a, "boxSizing").toString().toLowerCase()) {
                                var l = a.offsetWidth - (parseFloat(v.getPropertyValue(a, "borderLeftWidth")) || 0) - (parseFloat(v.getPropertyValue(a, "borderRightWidth")) || 0) - (parseFloat(v.getPropertyValue(a, "paddingLeft")) || 0) - (parseFloat(v.getPropertyValue(a, "paddingRight")) || 0);
                                return e(), l
                            }
                        }
                        var o;
                        o = g(a) === d ? b.getComputedStyle(a, null) : g(a).computedStyle ? g(a).computedStyle : g(a).computedStyle = b.getComputedStyle(a, null), "borderColor" === c && (c = "borderTopColor"), i = 9 === n && "filter" === c ? o.getPropertyValue(c) : o[c], ("" === i || null === i) && (i = a.style[c]), e()
                    }
                    if ("auto" === i && /^(top|right|bottom|left)$/i.test(c)) {
                        var p = h(a, "position");
                        ("fixed" === p || "absolute" === p && /top|left/i.test(c)) && (i = m(a).position()[c] + "px")
                    }
                    return i
                }
                var i;
                if (v.Hooks.registered[c]) {
                    var j = c,
                        k = v.Hooks.getRoot(j);
                    e === d && (e = v.getPropertyValue(a, v.Names.prefixCheck(k)[0])), v.Normalizations.registered[k] && (e = v.Normalizations.registered[k]("extract", a, e)), i = v.Hooks.extractValue(j, e)
                } else if (v.Normalizations.registered[c]) {
                    var l, o;
                    l = v.Normalizations.registered[c]("name", a), "transform" !== l && (o = h(a, v.Names.prefixCheck(l)[0]), v.Values.isCSSNullValue(o) && v.Hooks.templates[c] && (o = v.Hooks.templates[c][1])), i = v.Normalizations.registered[c]("extract", a, o)
                }
                if (!/^[\d-]/.test(i))
                    if (g(a) && g(a).isSVG && v.Names.SVGAttribute(c))
                        if (/^(height|width)$/i.test(c)) try {
                            i = a.getBBox()[c]
                        } catch (p) {
                            i = 0
                        } else i = a.getAttribute(c);
                        else i = h(a, v.Names.prefixCheck(c)[0]);
                return v.Values.isCSSNullValue(i) && (i = 0), t.debug >= 2 && console.log("Get " + c + ": " + i), i
            },
            setPropertyValue: function(a, c, d, e, f) {
                var h = c;
                if ("scroll" === c) f.container ? f.container["scroll" + f.direction] = d : "Left" === f.direction ? b.scrollTo(d, f.alternateValue) : b.scrollTo(f.alternateValue, d);
                else if (v.Normalizations.registered[c] && "transform" === v.Normalizations.registered[c]("name", a)) v.Normalizations.registered[c]("inject", a, d), h = "transform", d = g(a).transformCache[c];
                else {
                    if (v.Hooks.registered[c]) {
                        var i = c,
                            j = v.Hooks.getRoot(c);
                        e = e || v.getPropertyValue(a, j), d = v.Hooks.injectValue(i, d, e), c = j
                    }
                    if (v.Normalizations.registered[c] && (d = v.Normalizations.registered[c]("inject", a, d), c = v.Normalizations.registered[c]("name", a)), h = v.Names.prefixCheck(c)[0], 8 >= n) try {
                        a.style[h] = d
                    } catch (k) {
                        t.debug && console.log("Browser does not support [" + d + "] for [" + h + "]")
                    } else g(a) && g(a).isSVG && v.Names.SVGAttribute(c) ? a.setAttribute(c, d) : a.style[h] = d;
                    t.debug >= 2 && console.log("Set " + c + " (" + h + "): " + d)
                }
                return [h, d]
            },
            flushTransformCache: function(a) {
                function b(b) {
                    return parseFloat(v.getPropertyValue(a, b))
                }
                var c = "";
                if ((n || t.State.isAndroid && !t.State.isChrome) && g(a).isSVG) {
                    var d = {
                        translate: [b("translateX"), b("translateY")],
                        skewX: [b("skewX")],
                        skewY: [b("skewY")],
                        scale: 1 !== b("scale") ? [b("scale"), b("scale")] : [b("scaleX"), b("scaleY")],
                        rotate: [b("rotateZ"), 0, 0]
                    };
                    m.each(g(a).transformCache, function(a) {
                        /^translate/i.test(a) ? a = "translate" : /^scale/i.test(a) ? a = "scale" : /^rotate/i.test(a) && (a = "rotate"), d[a] && (c += a + "(" + d[a].join(" ") + ") ", delete d[a])
                    })
                } else {
                    var e, f;
                    m.each(g(a).transformCache, function(b) {
                        return e = g(a).transformCache[b], "transformPerspective" === b ? (f = e, !0) : (9 === n && "rotateZ" === b && (b = "rotate"), void(c += b + e + " "))
                    }), f && (c = "perspective" + f + " " + c)
                }
                v.setPropertyValue(a, "transform", c)
            }
        };
        v.Hooks.register(), v.Normalizations.register(), t.hook = function(a, b, c) {
            var e = d;
            return a = f(a), m.each(a, function(a, f) {
                if (g(f) === d && t.init(f), c === d) e === d && (e = t.CSS.getPropertyValue(f, b));
                else {
                    var h = t.CSS.setPropertyValue(f, b, c);
                    "transform" === h[0] && t.CSS.flushTransformCache(f), e = h
                }
            }), e
        };
        var w = function() {
            function a() {
                return h ? B.promise || null : i
            }

            function e() {
                function a() {
                    function a(a, b) {
                        var c = d,
                            e = d,
                            g = d;
                        return p.isArray(a) ? (c = a[0], !p.isArray(a[1]) && /^[\d-]/.test(a[1]) || p.isFunction(a[1]) || v.RegEx.isHex.test(a[1]) ? g = a[1] : (p.isString(a[1]) && !v.RegEx.isHex.test(a[1]) || p.isArray(a[1])) && (e = b ? a[1] : j(a[1], h.duration), a[2] !== d && (g = a[2]))) : c = a, b || (e = e || h.easing), p.isFunction(c) && (c = c.call(f, y, x)), p.isFunction(g) && (g = g.call(f, y, x)), [c || 0, e, g]
                    }

                    function l(a, b) {
                        var c, d;
                        return d = (b || "0").toString().toLowerCase().replace(/[%A-z]+$/, function(a) {
                            return c = a, ""
                        }), c || (c = v.Values.getUnitType(a)), [d, c]
                    }

                    function n() {
                        var a = {
                                myParent: f.parentNode || c.body,
                                position: v.getPropertyValue(f, "position"),
                                fontSize: v.getPropertyValue(f, "fontSize")
                            },
                            d = a.position === I.lastPosition && a.myParent === I.lastParent,
                            e = a.fontSize === I.lastFontSize;
                        I.lastParent = a.myParent, I.lastPosition = a.position, I.lastFontSize = a.fontSize;
                        var h = 100,
                            i = {};
                        if (e && d) i.emToPx = I.lastEmToPx, i.percentToPxWidth = I.lastPercentToPxWidth, i.percentToPxHeight = I.lastPercentToPxHeight;
                        else {
                            var j = g(f).isSVG ? c.createElementNS("http://www.w3.org/2000/svg", "rect") : c.createElement("div");
                            t.init(j), a.myParent.appendChild(j), m.each(["overflow", "overflowX", "overflowY"], function(a, b) {
                                t.CSS.setPropertyValue(j, b, "hidden")
                            }), t.CSS.setPropertyValue(j, "position", a.position), t.CSS.setPropertyValue(j, "fontSize", a.fontSize), t.CSS.setPropertyValue(j, "boxSizing", "content-box"), m.each(["minWidth", "maxWidth", "width", "minHeight", "maxHeight", "height"], function(a, b) {
                                t.CSS.setPropertyValue(j, b, h + "%")
                            }), t.CSS.setPropertyValue(j, "paddingLeft", h + "em"), i.percentToPxWidth = I.lastPercentToPxWidth = (parseFloat(v.getPropertyValue(j, "width", null, !0)) || 1) / h, i.percentToPxHeight = I.lastPercentToPxHeight = (parseFloat(v.getPropertyValue(j, "height", null, !0)) || 1) / h, i.emToPx = I.lastEmToPx = (parseFloat(v.getPropertyValue(j, "paddingLeft")) || 1) / h, a.myParent.removeChild(j)
                        }
                        return null === I.remToPx && (I.remToPx = parseFloat(v.getPropertyValue(c.body, "fontSize")) || 16), null === I.vwToPx && (I.vwToPx = parseFloat(b.innerWidth) / 100, I.vhToPx = parseFloat(b.innerHeight) / 100), i.remToPx = I.remToPx, i.vwToPx = I.vwToPx, i.vhToPx = I.vhToPx, t.debug >= 1 && console.log("Unit ratios: " + JSON.stringify(i), f), i
                    }
                    if (h.begin && 0 === y) try {
                        h.begin.call(o, o)
                    } catch (r) {
                        setTimeout(function() {
                            throw r
                        }, 1)
                    }
                    if ("scroll" === C) {
                        var u, w, z, A = /^x$/i.test(h.axis) ? "Left" : "Top",
                            D = parseFloat(h.offset) || 0;
                        h.container ? p.isWrapped(h.container) || p.isNode(h.container) ? (h.container = h.container[0] || h.container, u = h.container["scroll" + A], z = u + m(f).position()[A.toLowerCase()] + D) : h.container = null : (u = t.State.scrollAnchor[t.State["scrollProperty" + A]], w = t.State.scrollAnchor[t.State["scrollProperty" + ("Left" === A ? "Top" : "Left")]], z = m(f).offset()[A.toLowerCase()] + D), i = {
                            scroll: {
                                rootPropertyValue: !1,
                                startValue: u,
                                currentValue: u,
                                endValue: z,
                                unitType: "",
                                easing: h.easing,
                                scrollData: {
                                    container: h.container,
                                    direction: A,
                                    alternateValue: w
                                }
                            },
                            element: f
                        }, t.debug && console.log("tweensContainer (scroll): ", i.scroll, f)
                    } else if ("reverse" === C) {
                        if (!g(f).tweensContainer) return void m.dequeue(f, h.queue);
                        "none" === g(f).opts.display && (g(f).opts.display = "auto"), "hidden" === g(f).opts.visibility && (g(f).opts.visibility = "visible"), g(f).opts.loop = !1, g(f).opts.begin = null, g(f).opts.complete = null, s.easing || delete h.easing, s.duration || delete h.duration, h = m.extend({}, g(f).opts, h);
                        var E = m.extend(!0, {}, g(f).tweensContainer);
                        for (var F in E)
                            if ("element" !== F) {
                                var G = E[F].startValue;
                                E[F].startValue = E[F].currentValue = E[F].endValue, E[F].endValue = G, p.isEmptyObject(s) || (E[F].easing = h.easing), t.debug && console.log("reverse tweensContainer (" + F + "): " + JSON.stringify(E[F]), f)
                            }
                        i = E
                    } else if ("start" === C) {
                        var E;
                        g(f).tweensContainer && g(f).isAnimating === !0 && (E = g(f).tweensContainer), m.each(q, function(b, c) {
                            if (RegExp("^" + v.Lists.colors.join("$|^") + "$").test(b)) {
                                var e = a(c, !0),
                                    f = e[0],
                                    g = e[1],
                                    h = e[2];
                                if (v.RegEx.isHex.test(f)) {
                                    for (var i = ["Red", "Green", "Blue"], j = v.Values.hexToRgb(f), k = h ? v.Values.hexToRgb(h) : d, l = 0; l < i.length; l++) {
                                        var m = [j[l]];
                                        g && m.push(g), k !== d && m.push(k[l]), q[b + i[l]] = m
                                    }
                                    delete q[b]
                                }
                            }
                        });
                        for (var H in q) {
                            var K = a(q[H]),
                                L = K[0],
                                M = K[1],
                                N = K[2];
                            H = v.Names.camelCase(H);
                            var O = v.Hooks.getRoot(H),
                                P = !1;
                            if (g(f).isSVG || "tween" === O || v.Names.prefixCheck(O)[1] !== !1 || v.Normalizations.registered[O] !== d) {
                                (h.display !== d && null !== h.display && "none" !== h.display || h.visibility !== d && "hidden" !== h.visibility) && /opacity|filter/.test(H) && !N && 0 !== L && (N = 0), h._cacheValues && E && E[H] ? (N === d && (N = E[H].endValue + E[H].unitType), P = g(f).rootPropertyValueCache[O]) : v.Hooks.registered[H] ? N === d ? (P = v.getPropertyValue(f, O), N = v.getPropertyValue(f, H, P)) : P = v.Hooks.templates[O][1] : N === d && (N = v.getPropertyValue(f, H));
                                var Q, R, S, T = !1;
                                if (Q = l(H, N), N = Q[0], S = Q[1], Q = l(H, L), L = Q[0].replace(/^([+-\/*])=/, function(a, b) {
                                        return T = b, ""
                                    }), R = Q[1], N = parseFloat(N) || 0, L = parseFloat(L) || 0, "%" === R && (/^(fontSize|lineHeight)$/.test(H) ? (L /= 100, R = "em") : /^scale/.test(H) ? (L /= 100, R = "") : /(Red|Green|Blue)$/i.test(H) && (L = L / 100 * 255, R = "")), /[\/*]/.test(T)) R = S;
                                else if (S !== R && 0 !== N)
                                    if (0 === L) R = S;
                                    else {
                                        e = e || n();
                                        var U = /margin|padding|left|right|width|text|word|letter/i.test(H) || /X$/.test(H) || "x" === H ? "x" : "y";
                                        switch (S) {
                                            case "%":
                                                N *= "x" === U ? e.percentToPxWidth : e.percentToPxHeight;
                                                break;
                                            case "px":
                                                break;
                                            default:
                                                N *= e[S + "ToPx"]
                                        }
                                        switch (R) {
                                            case "%":
                                                N *= 1 / ("x" === U ? e.percentToPxWidth : e.percentToPxHeight);
                                                break;
                                            case "px":
                                                break;
                                            default:
                                                N *= 1 / e[R + "ToPx"]
                                        }
                                    }
                                switch (T) {
                                    case "+":
                                        L = N + L;
                                        break;
                                    case "-":
                                        L = N - L;
                                        break;
                                    case "*":
                                        L = N * L;
                                        break;
                                    case "/":
                                        L = N / L
                                }
                                i[H] = {
                                    rootPropertyValue: P,
                                    startValue: N,
                                    currentValue: N,
                                    endValue: L,
                                    unitType: R,
                                    easing: M
                                }, t.debug && console.log("tweensContainer (" + H + "): " + JSON.stringify(i[H]), f)
                            } else t.debug && console.log("Skipping [" + O + "] due to a lack of browser support.")
                        }
                        i.element = f
                    }
                    i.element && (v.Values.addClass(f, "velocity-animating"), J.push(i), "" === h.queue && (g(f).tweensContainer = i, g(f).opts = h), g(f).isAnimating = !0, y === x - 1 ? (t.State.calls.push([J, o, h, null, B.resolver]), t.State.isTicking === !1 && (t.State.isTicking = !0, k())) : y++)
                }
                var e, f = this,
                    h = m.extend({}, t.defaults, s),
                    i = {};
                switch (g(f) === d && t.init(f), parseFloat(h.delay) && h.queue !== !1 && m.queue(f, h.queue, function(a) {
                    t.velocityQueueEntryFlag = !0, g(f).delayTimer = {
                        setTimeout: setTimeout(a, parseFloat(h.delay)),
                        next: a
                    }
                }), h.duration.toString().toLowerCase()) {
                    case "fast":
                        h.duration = 200;
                        break;
                    case "normal":
                        h.duration = r;
                        break;
                    case "slow":
                        h.duration = 600;
                        break;
                    default:
                        h.duration = parseFloat(h.duration) || 1
                }
                t.mock !== !1 && (t.mock === !0 ? h.duration = h.delay = 1 : (h.duration *= parseFloat(t.mock) || 1, h.delay *= parseFloat(t.mock) || 1)), h.easing = j(h.easing, h.duration), h.begin && !p.isFunction(h.begin) && (h.begin = null), h.progress && !p.isFunction(h.progress) && (h.progress = null), h.complete && !p.isFunction(h.complete) && (h.complete = null), h.display !== d && null !== h.display && (h.display = h.display.toString().toLowerCase(), "auto" === h.display && (h.display = t.CSS.Values.getDisplayType(f))), h.visibility !== d && null !== h.visibility && (h.visibility = h.visibility.toString().toLowerCase()), h.mobileHA = h.mobileHA && t.State.isMobile && !t.State.isGingerbread, h.queue === !1 ? h.delay ? setTimeout(a, h.delay) : a() : m.queue(f, h.queue, function(b, c) {
                    return c === !0 ? (B.promise && B.resolver(o), !0) : (t.velocityQueueEntryFlag = !0, void a(b))
                }), "" !== h.queue && "fx" !== h.queue || "inprogress" === m.queue(f)[0] || m.dequeue(f)
            }
            var h, i, n, o, q, s, u = arguments[0] && (arguments[0].p || m.isPlainObject(arguments[0].properties) && !arguments[0].properties.names || p.isString(arguments[0].properties));
            if (p.isWrapped(this) ? (h = !1, n = 0, o = this, i = this) : (h = !0, n = 1, o = u ? arguments[0].elements || arguments[0].e : arguments[0]), o = f(o)) {
                u ? (q = arguments[0].properties || arguments[0].p, s = arguments[0].options || arguments[0].o) : (q = arguments[n], s = arguments[n + 1]);
                var x = o.length,
                    y = 0;
                if (!/^(stop|finish|finishAll)$/i.test(q) && !m.isPlainObject(s)) {
                    var z = n + 1;
                    s = {};
                    for (var A = z; A < arguments.length; A++) p.isArray(arguments[A]) || !/^(fast|normal|slow)$/i.test(arguments[A]) && !/^\d/.test(arguments[A]) ? p.isString(arguments[A]) || p.isArray(arguments[A]) ? s.easing = arguments[A] : p.isFunction(arguments[A]) && (s.complete = arguments[A]) : s.duration = arguments[A]
                }
                var B = {
                    promise: null,
                    resolver: null,
                    rejecter: null
                };
                h && t.Promise && (B.promise = new t.Promise(function(a, b) {
                    B.resolver = a, B.rejecter = b
                }));
                var C;
                switch (q) {
                    case "scroll":
                        C = "scroll";
                        break;
                    case "reverse":
                        C = "reverse";
                        break;
                    case "finish":
                    case "finishAll":
                    case "stop":
                        m.each(o, function(a, b) {
                            g(b) && g(b).delayTimer && (clearTimeout(g(b).delayTimer.setTimeout), g(b).delayTimer.next && g(b).delayTimer.next(), delete g(b).delayTimer), "finishAll" !== q || s !== !0 && !p.isString(s) || (m.each(m.queue(b, p.isString(s) ? s : ""), function(a, b) {
                                p.isFunction(b) && b()
                            }), m.queue(b, p.isString(s) ? s : "", []))
                        });
                        var D = [];
                        return m.each(t.State.calls, function(a, b) {
                            b && m.each(b[1], function(c, e) {
                                var f = s === d ? "" : s;
                                return f === !0 || b[2].queue === f || s === d && b[2].queue === !1 ? void m.each(o, function(c, d) {
                                    d === e && ((s === !0 || p.isString(s)) && (m.each(m.queue(d, p.isString(s) ? s : ""), function(a, b) {
                                        p.isFunction(b) && b(null, !0)
                                    }), m.queue(d, p.isString(s) ? s : "", [])), "stop" === q ? (g(d) && g(d).tweensContainer && f !== !1 && m.each(g(d).tweensContainer, function(a, b) {
                                        b.endValue = b.currentValue
                                    }), D.push(a)) : ("finish" === q || "finishAll" === q) && (b[2].duration = 1))
                                }) : !0
                            })
                        }), "stop" === q && (m.each(D, function(a, b) {
                            l(b, !0)
                        }), B.promise && B.resolver(o)), a();
                    default:
                        if (!m.isPlainObject(q) || p.isEmptyObject(q)) {
                            if (p.isString(q) && t.Redirects[q]) {
                                var E = m.extend({}, s),
                                    F = E.duration,
                                    G = E.delay || 0;
                                return E.backwards === !0 && (o = m.extend(!0, [], o).reverse()), m.each(o, function(a, b) {
                                    parseFloat(E.stagger) ? E.delay = G + parseFloat(E.stagger) * a : p.isFunction(E.stagger) && (E.delay = G + E.stagger.call(b, a, x)), E.drag && (E.duration = parseFloat(F) || (/^(callout|transition)/.test(q) ? 1e3 : r), E.duration = Math.max(E.duration * (E.backwards ? 1 - a / x : (a + 1) / x), .75 * E.duration, 200)), t.Redirects[q].call(b, b, E || {}, a, x, o, B.promise ? B : d)
                                }), a()
                            }
                            var H = "Velocity: First argument (" + q + ") was not a property map, a known action, or a registered redirect. Aborting.";
                            return B.promise ? B.rejecter(new Error(H)) : console.log(H), a()
                        }
                        C = "start"
                }
                var I = {
                        lastParent: null,
                        lastPosition: null,
                        lastFontSize: null,
                        lastPercentToPxWidth: null,
                        lastPercentToPxHeight: null,
                        lastEmToPx: null,
                        remToPx: null,
                        vwToPx: null,
                        vhToPx: null
                    },
                    J = [];
                m.each(o, function(a, b) {
                    p.isNode(b) && e.call(b)
                });
                var K, E = m.extend({}, t.defaults, s);
                if (E.loop = parseInt(E.loop), K = 2 * E.loop - 1, E.loop)
                    for (var L = 0; K > L; L++) {
                        var M = {
                            delay: E.delay,
                            progress: E.progress
                        };
                        L === K - 1 && (M.display = E.display, M.visibility = E.visibility, M.complete = E.complete), w(o, "reverse", M)
                    }
                return a()
            }
        };
        t = m.extend(w, t), t.animate = w;
        var x = b.requestAnimationFrame || o;
        return t.State.isMobile || c.hidden === d || c.addEventListener("visibilitychange", function() {
            c.hidden ? (x = function(a) {
                return setTimeout(function() {
                    a(!0)
                }, 16)
            }, k()) : x = b.requestAnimationFrame || o
        }), a.Velocity = t, a !== b && (a.fn.velocity = w, a.fn.velocity.defaults = t.defaults), m.each(["Down", "Up"], function(a, b) {
            t.Redirects["slide" + b] = function(a, c, e, f, g, h) {
                var i = m.extend({}, c),
                    j = i.begin,
                    k = i.complete,
                    l = {
                        height: "",
                        marginTop: "",
                        marginBottom: "",
                        paddingTop: "",
                        paddingBottom: ""
                    },
                    n = {};
                i.display === d && (i.display = "Down" === b ? "inline" === t.CSS.Values.getDisplayType(a) ? "inline-block" : "block" : "none"), i.begin = function() {
                    j && j.call(g, g);
                    for (var c in l) {
                        n[c] = a.style[c];
                        var d = t.CSS.getPropertyValue(a, c);
                        l[c] = "Down" === b ? [d, 0] : [0, d]
                    }
                    n.overflow = a.style.overflow, a.style.overflow = "hidden"
                }, i.complete = function() {
                    for (var b in n) a.style[b] = n[b];
                    k && k.call(g, g), h && h.resolver(g)
                }, t(a, l, i)
            }
        }), m.each(["In", "Out"], function(a, b) {
            t.Redirects["fade" + b] = function(a, c, e, f, g, h) {
                var i = m.extend({}, c),
                    j = {
                        opacity: "In" === b ? 1 : 0
                    },
                    k = i.complete;
                i.complete = e !== f - 1 ? i.begin = null : function() {
                    k && k.call(g, g), h && h.resolver(g)
                }, i.display === d && (i.display = "In" === b ? "auto" : "none"), t(this, j, i)
            }
        }), t
    }(window.jQuery || window.Zepto || window, window, document)
});

! function(t, e, i) {
    var n = t.L,
        o = {};
    o.version = "0.7.7", "object" == typeof module && "object" == typeof module.exports ? module.exports = o : "function" == typeof define && define.amd && define(o), o.noConflict = function() {
            return t.L = n, this
        }, t.L = o, o.Util = {
            extend: function(t) {
                var e, i, n, o, s = Array.prototype.slice.call(arguments, 1);
                for (i = 0, n = s.length; n > i; i++) {
                    o = s[i] || {};
                    for (e in o) o.hasOwnProperty(e) && (t[e] = o[e])
                }
                return t
            },
            bind: function(t, e) {
                var i = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;
                return function() {
                    return t.apply(e, i || arguments)
                }
            },
            stamp: function() {
                var t = 0,
                    e = "_leaflet_id";
                return function(i) {
                    return i[e] = i[e] || ++t, i[e]
                }
            }(),
            invokeEach: function(t, e, i) {
                var n, o;
                if ("object" == typeof t) {
                    o = Array.prototype.slice.call(arguments, 3);
                    for (n in t) e.apply(i, [n, t[n]].concat(o));
                    return !0
                }
                return !1
            },
            limitExecByInterval: function(t, e, i) {
                var n, o;
                return function s() {
                    var a = arguments;
                    return n ? void(o = !0) : (n = !0, setTimeout(function() {
                        n = !1, o && (s.apply(i, a), o = !1)
                    }, e), void t.apply(i, a))
                }
            },
            falseFn: function() {
                return !1
            },
            formatNum: function(t, e) {
                var i = Math.pow(10, e || 5);
                return Math.round(t * i) / i
            },
            trim: function(t) {
                return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "")
            },
            splitWords: function(t) {
                return o.Util.trim(t).split(/\s+/)
            },
            setOptions: function(t, e) {
                return t.options = o.extend({}, t.options, e), t.options
            },
            getParamString: function(t, e, i) {
                var n = [];
                for (var o in t) n.push(encodeURIComponent(i ? o.toUpperCase() : o) + "=" + encodeURIComponent(t[o]));
                return (e && -1 !== e.indexOf("?") ? "&" : "?") + n.join("&")
            },
            template: function(t, e) {
                return t.replace(/\{ *([\w_]+) *\}/g, function(t, n) {
                    var o = e[n];
                    if (o === i) throw new Error("No value provided for variable " + t);
                    return "function" == typeof o && (o = o(e)), o
                })
            },
            isArray: Array.isArray || function(t) {
                return "[object Array]" === Object.prototype.toString.call(t)
            },
            emptyImageUrl: "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs="
        },
        function() {
            function e(e) {
                var i, n, o = ["webkit", "moz", "o", "ms"];
                for (i = 0; i < o.length && !n; i++) n = t[o[i] + e];
                return n
            }

            function i(e) {
                var i = +new Date,
                    o = Math.max(0, 16 - (i - n));
                return n = i + o, t.setTimeout(e, o)
            }
            var n = 0,
                s = t.requestAnimationFrame || e("RequestAnimationFrame") || i,
                a = t.cancelAnimationFrame || e("CancelAnimationFrame") || e("CancelRequestAnimationFrame") || function(e) {
                    t.clearTimeout(e)
                };
            o.Util.requestAnimFrame = function(e, n, a, r) {
                return e = o.bind(e, n), a && s === i ? void e() : s.call(t, e, r)
            }, o.Util.cancelAnimFrame = function(e) {
                e && a.call(t, e)
            }
        }(), o.extend = o.Util.extend, o.bind = o.Util.bind, o.stamp = o.Util.stamp, o.setOptions = o.Util.setOptions, o.Class = function() {}, o.Class.extend = function(t) {
            var e = function() {
                    this.initialize && this.initialize.apply(this, arguments), this._initHooks && this.callInitHooks()
                },
                i = function() {};
            i.prototype = this.prototype;
            var n = new i;
            n.constructor = e, e.prototype = n;
            for (var s in this) this.hasOwnProperty(s) && "prototype" !== s && (e[s] = this[s]);
            t.statics && (o.extend(e, t.statics), delete t.statics), t.includes && (o.Util.extend.apply(null, [n].concat(t.includes)), delete t.includes), t.options && n.options && (t.options = o.extend({}, n.options, t.options)), o.extend(n, t), n._initHooks = [];
            var a = this;
            return e.__super__ = a.prototype, n.callInitHooks = function() {
                if (!this._initHooksCalled) {
                    a.prototype.callInitHooks && a.prototype.callInitHooks.call(this), this._initHooksCalled = !0;
                    for (var t = 0, e = n._initHooks.length; e > t; t++) n._initHooks[t].call(this)
                }
            }, e
        }, o.Class.include = function(t) {
            o.extend(this.prototype, t)
        }, o.Class.mergeOptions = function(t) {
            o.extend(this.prototype.options, t)
        }, o.Class.addInitHook = function(t) {
            var e = Array.prototype.slice.call(arguments, 1),
                i = "function" == typeof t ? t : function() {
                    this[t].apply(this, e)
                };
            this.prototype._initHooks = this.prototype._initHooks || [], this.prototype._initHooks.push(i)
        };
    var s = "_leaflet_events";
    o.Mixin = {}, o.Mixin.Events = {
            addEventListener: function(t, e, i) {
                if (o.Util.invokeEach(t, this.addEventListener, this, e, i)) return this;
                var n, a, r, h, l, u, c, d = this[s] = this[s] || {},
                    p = i && i !== this && o.stamp(i);
                for (t = o.Util.splitWords(t), n = 0, a = t.length; a > n; n++) r = {
                    action: e,
                    context: i || this
                }, h = t[n], p ? (l = h + "_idx", u = l + "_len", c = d[l] = d[l] || {}, c[p] || (c[p] = [], d[u] = (d[u] || 0) + 1), c[p].push(r)) : (d[h] = d[h] || [], d[h].push(r));
                return this
            },
            hasEventListeners: function(t) {
                var e = this[s];
                return !!e && (t in e && e[t].length > 0 || t + "_idx" in e && e[t + "_idx_len"] > 0)
            },
            removeEventListener: function(t, e, i) {
                if (!this[s]) return this;
                if (!t) return this.clearAllEventListeners();
                if (o.Util.invokeEach(t, this.removeEventListener, this, e, i)) return this;
                var n, a, r, h, l, u, c, d, p, _ = this[s],
                    m = i && i !== this && o.stamp(i);
                for (t = o.Util.splitWords(t), n = 0, a = t.length; a > n; n++)
                    if (r = t[n], u = r + "_idx", c = u + "_len", d = _[u], e) {
                        if (h = m && d ? d[m] : _[r]) {
                            for (l = h.length - 1; l >= 0; l--) h[l].action !== e || i && h[l].context !== i || (p = h.splice(l, 1), p[0].action = o.Util.falseFn);
                            i && d && 0 === h.length && (delete d[m], _[c]--)
                        }
                    } else delete _[r], delete _[u], delete _[c];
                return this
            },
            clearAllEventListeners: function() {
                return delete this[s], this
            },
            fireEvent: function(t, e) {
                if (!this.hasEventListeners(t)) return this;
                var i, n, a, r, h, l = o.Util.extend({}, e, {
                        type: t,
                        target: this
                    }),
                    u = this[s];
                if (u[t])
                    for (i = u[t].slice(), n = 0, a = i.length; a > n; n++) i[n].action.call(i[n].context, l);
                r = u[t + "_idx"];
                for (h in r)
                    if (i = r[h].slice())
                        for (n = 0, a = i.length; a > n; n++) i[n].action.call(i[n].context, l);
                return this
            },
            addOneTimeEventListener: function(t, e, i) {
                if (o.Util.invokeEach(t, this.addOneTimeEventListener, this, e, i)) return this;
                var n = o.bind(function() {
                    this.removeEventListener(t, e, i).removeEventListener(t, n, i)
                }, this);
                return this.addEventListener(t, e, i).addEventListener(t, n, i)
            }
        }, o.Mixin.Events.on = o.Mixin.Events.addEventListener, o.Mixin.Events.off = o.Mixin.Events.removeEventListener, o.Mixin.Events.once = o.Mixin.Events.addOneTimeEventListener, o.Mixin.Events.fire = o.Mixin.Events.fireEvent,
        function() {
            var n = "ActiveXObject" in t,
                s = n && !e.addEventListener,
                a = navigator.userAgent.toLowerCase(),
                r = -1 !== a.indexOf("webkit"),
                h = -1 !== a.indexOf("chrome"),
                l = -1 !== a.indexOf("phantom"),
                u = -1 !== a.indexOf("android"),
                c = -1 !== a.search("android [23]"),
                d = -1 !== a.indexOf("gecko"),
                p = typeof orientation != i + "",
                _ = !t.PointerEvent && t.MSPointerEvent,
                m = t.PointerEvent && t.navigator.pointerEnabled || _,
                f = "devicePixelRatio" in t && t.devicePixelRatio > 1 || "matchMedia" in t && t.matchMedia("(min-resolution:144dpi)") && t.matchMedia("(min-resolution:144dpi)").matches,
                g = e.documentElement,
                v = n && "transition" in g.style,
                y = "WebKitCSSMatrix" in t && "m11" in new t.WebKitCSSMatrix && !c,
                P = "MozPerspective" in g.style,
                L = "OTransition" in g.style,
                x = !t.L_DISABLE_3D && (v || y || P || L) && !l,
                w = !t.L_NO_TOUCH && !l && (m || "ontouchstart" in t || t.DocumentTouch && e instanceof t.DocumentTouch);
            o.Browser = {
                ie: n,
                ielt9: s,
                webkit: r,
                gecko: d && !r && !t.opera && !n,
                android: u,
                android23: c,
                chrome: h,
                ie3d: v,
                webkit3d: y,
                gecko3d: P,
                opera3d: L,
                any3d: x,
                mobile: p,
                mobileWebkit: p && r,
                mobileWebkit3d: p && y,
                mobileOpera: p && t.opera,
                touch: w,
                msPointer: _,
                pointer: m,
                retina: f
            }
        }(), o.Point = function(t, e, i) {
            this.x = i ? Math.round(t) : t, this.y = i ? Math.round(e) : e
        }, o.Point.prototype = {
            clone: function() {
                return new o.Point(this.x, this.y)
            },
            add: function(t) {
                return this.clone()._add(o.point(t))
            },
            _add: function(t) {
                return this.x += t.x, this.y += t.y, this
            },
            subtract: function(t) {
                return this.clone()._subtract(o.point(t))
            },
            _subtract: function(t) {
                return this.x -= t.x, this.y -= t.y, this
            },
            divideBy: function(t) {
                return this.clone()._divideBy(t)
            },
            _divideBy: function(t) {
                return this.x /= t, this.y /= t, this
            },
            multiplyBy: function(t) {
                return this.clone()._multiplyBy(t)
            },
            _multiplyBy: function(t) {
                return this.x *= t, this.y *= t, this
            },
            round: function() {
                return this.clone()._round()
            },
            _round: function() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this
            },
            floor: function() {
                return this.clone()._floor()
            },
            _floor: function() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
            },
            distanceTo: function(t) {
                t = o.point(t);
                var e = t.x - this.x,
                    i = t.y - this.y;
                return Math.sqrt(e * e + i * i)
            },
            equals: function(t) {
                return t = o.point(t), t.x === this.x && t.y === this.y
            },
            contains: function(t) {
                return t = o.point(t), Math.abs(t.x) <= Math.abs(this.x) && Math.abs(t.y) <= Math.abs(this.y)
            },
            toString: function() {
                return "Point(" + o.Util.formatNum(this.x) + ", " + o.Util.formatNum(this.y) + ")"
            }
        }, o.point = function(t, e, n) {
            return t instanceof o.Point ? t : o.Util.isArray(t) ? new o.Point(t[0], t[1]) : t === i || null === t ? t : new o.Point(t, e, n)
        }, o.Bounds = function(t, e) {
            if (t)
                for (var i = e ? [t, e] : t, n = 0, o = i.length; o > n; n++) this.extend(i[n])
        }, o.Bounds.prototype = {
            extend: function(t) {
                return t = o.point(t), this.min || this.max ? (this.min.x = Math.min(t.x, this.min.x), this.max.x = Math.max(t.x, this.max.x), this.min.y = Math.min(t.y, this.min.y), this.max.y = Math.max(t.y, this.max.y)) : (this.min = t.clone(), this.max = t.clone()), this
            },
            getCenter: function(t) {
                return new o.Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, t)
            },
            getBottomLeft: function() {
                return new o.Point(this.min.x, this.max.y)
            },
            getTopRight: function() {
                return new o.Point(this.max.x, this.min.y)
            },
            getSize: function() {
                return this.max.subtract(this.min)
            },
            contains: function(t) {
                var e, i;
                return t = "number" == typeof t[0] || t instanceof o.Point ? o.point(t) : o.bounds(t), t instanceof o.Bounds ? (e = t.min, i = t.max) : e = i = t, e.x >= this.min.x && i.x <= this.max.x && e.y >= this.min.y && i.y <= this.max.y
            },
            intersects: function(t) {
                t = o.bounds(t);
                var e = this.min,
                    i = this.max,
                    n = t.min,
                    s = t.max,
                    a = s.x >= e.x && n.x <= i.x,
                    r = s.y >= e.y && n.y <= i.y;
                return a && r
            },
            isValid: function() {
                return !(!this.min || !this.max)
            }
        }, o.bounds = function(t, e) {
            return !t || t instanceof o.Bounds ? t : new o.Bounds(t, e)
        }, o.Transformation = function(t, e, i, n) {
            this._a = t, this._b = e, this._c = i, this._d = n
        }, o.Transformation.prototype = {
            transform: function(t, e) {
                return this._transform(t.clone(), e)
            },
            _transform: function(t, e) {
                return e = e || 1, t.x = e * (this._a * t.x + this._b), t.y = e * (this._c * t.y + this._d), t
            },
            untransform: function(t, e) {
                return e = e || 1, new o.Point((t.x / e - this._b) / this._a, (t.y / e - this._d) / this._c)
            }
        }, o.DomUtil = {
            get: function(t) {
                return "string" == typeof t ? e.getElementById(t) : t
            },
            getStyle: function(t, i) {
                var n = t.style[i];
                if (!n && t.currentStyle && (n = t.currentStyle[i]), (!n || "auto" === n) && e.defaultView) {
                    var o = e.defaultView.getComputedStyle(t, null);
                    n = o ? o[i] : null
                }
                return "auto" === n ? null : n
            },
            getViewportOffset: function(t) {
                var i, n = 0,
                    s = 0,
                    a = t,
                    r = e.body,
                    h = e.documentElement;
                do {
                    if (n += a.offsetTop || 0, s += a.offsetLeft || 0, n += parseInt(o.DomUtil.getStyle(a, "borderTopWidth"), 10) || 0, s += parseInt(o.DomUtil.getStyle(a, "borderLeftWidth"), 10) || 0, i = o.DomUtil.getStyle(a, "position"), a.offsetParent === r && "absolute" === i) break;
                    if ("fixed" === i) {
                        n += r.scrollTop || h.scrollTop || 0, s += r.scrollLeft || h.scrollLeft || 0;
                        break
                    }
                    if ("relative" === i && !a.offsetLeft) {
                        var l = o.DomUtil.getStyle(a, "width"),
                            u = o.DomUtil.getStyle(a, "max-width"),
                            c = a.getBoundingClientRect();
                        ("none" !== l || "none" !== u) && (s += c.left + a.clientLeft), n += c.top + (r.scrollTop || h.scrollTop || 0);
                        break
                    }
                    a = a.offsetParent
                } while (a);
                a = t;
                do {
                    if (a === r) break;
                    n -= a.scrollTop || 0, s -= a.scrollLeft || 0, a = a.parentNode
                } while (a);
                return new o.Point(s, n)
            },
            documentIsLtr: function() {
                return o.DomUtil._docIsLtrCached || (o.DomUtil._docIsLtrCached = !0, o.DomUtil._docIsLtr = "ltr" === o.DomUtil.getStyle(e.body, "direction")), o.DomUtil._docIsLtr
            },
            create: function(t, i, n) {
                var o = e.createElement(t);
                return o.className = i, n && n.appendChild(o), o
            },
            hasClass: function(t, e) {
                if (t.classList !== i) return t.classList.contains(e);
                var n = o.DomUtil._getClass(t);
                return n.length > 0 && new RegExp("(^|\\s)" + e + "(\\s|$)").test(n)
            },
            addClass: function(t, e) {
                if (t.classList !== i)
                    for (var n = o.Util.splitWords(e), s = 0, a = n.length; a > s; s++) t.classList.add(n[s]);
                else if (!o.DomUtil.hasClass(t, e)) {
                    var r = o.DomUtil._getClass(t);
                    o.DomUtil._setClass(t, (r ? r + " " : "") + e)
                }
            },
            removeClass: function(t, e) {
                t.classList !== i ? t.classList.remove(e) : o.DomUtil._setClass(t, o.Util.trim((" " + o.DomUtil._getClass(t) + " ").replace(" " + e + " ", " ")))
            },
            _setClass: function(t, e) {
                t.className.baseVal === i ? t.className = e : t.className.baseVal = e
            },
            _getClass: function(t) {
                return t.className.baseVal === i ? t.className : t.className.baseVal
            },
            setOpacity: function(t, e) {
                if ("opacity" in t.style) t.style.opacity = e;
                else if ("filter" in t.style) {
                    var i = !1,
                        n = "DXImageTransform.Microsoft.Alpha";
                    try {
                        i = t.filters.item(n)
                    } catch (o) {
                        if (1 === e) return
                    }
                    e = Math.round(100 * e), i ? (i.Enabled = 100 !== e, i.Opacity = e) : t.style.filter += " progid:" + n + "(opacity=" + e + ")"
                }
            },
            testProp: function(t) {
                for (var i = e.documentElement.style, n = 0; n < t.length; n++)
                    if (t[n] in i) return t[n];
                return !1
            },
            getTranslateString: function(t) {
                var e = o.Browser.webkit3d,
                    i = "translate" + (e ? "3d" : "") + "(",
                    n = (e ? ",0" : "") + ")";
                return i + t.x + "px," + t.y + "px" + n
            },
            getScaleString: function(t, e) {
                var i = o.DomUtil.getTranslateString(e.add(e.multiplyBy(-1 * t))),
                    n = " scale(" + t + ") ";
                return i + n
            },
            setPosition: function(t, e, i) {
                t._leaflet_pos = e, !i && o.Browser.any3d ? t.style[o.DomUtil.TRANSFORM] = o.DomUtil.getTranslateString(e) : (t.style.left = e.x + "px", t.style.top = e.y + "px")
            },
            getPosition: function(t) {
                return t._leaflet_pos
            }
        }, o.DomUtil.TRANSFORM = o.DomUtil.testProp(["transform", "WebkitTransform", "OTransform", "MozTransform", "msTransform"]), o.DomUtil.TRANSITION = o.DomUtil.testProp(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]), o.DomUtil.TRANSITION_END = "webkitTransition" === o.DomUtil.TRANSITION || "OTransition" === o.DomUtil.TRANSITION ? o.DomUtil.TRANSITION + "End" : "transitionend",
        function() {
            if ("onselectstart" in e) o.extend(o.DomUtil, {
                disableTextSelection: function() {
                    o.DomEvent.on(t, "selectstart", o.DomEvent.preventDefault)
                },
                enableTextSelection: function() {
                    o.DomEvent.off(t, "selectstart", o.DomEvent.preventDefault)
                }
            });
            else {
                var i = o.DomUtil.testProp(["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]);
                o.extend(o.DomUtil, {
                    disableTextSelection: function() {
                        if (i) {
                            var t = e.documentElement.style;
                            this._userSelect = t[i], t[i] = "none"
                        }
                    },
                    enableTextSelection: function() {
                        i && (e.documentElement.style[i] = this._userSelect, delete this._userSelect)
                    }
                })
            }
            o.extend(o.DomUtil, {
                disableImageDrag: function() {
                    o.DomEvent.on(t, "dragstart", o.DomEvent.preventDefault)
                },
                enableImageDrag: function() {
                    o.DomEvent.off(t, "dragstart", o.DomEvent.preventDefault)
                }
            })
        }(), o.LatLng = function(t, e, n) {
            if (t = parseFloat(t), e = parseFloat(e), isNaN(t) || isNaN(e)) throw new Error("Invalid LatLng object: (" + t + ", " + e + ")");
            this.lat = t, this.lng = e, n !== i && (this.alt = parseFloat(n))
        }, o.extend(o.LatLng, {
            DEG_TO_RAD: Math.PI / 180,
            RAD_TO_DEG: 180 / Math.PI,
            MAX_MARGIN: 1e-9
        }), o.LatLng.prototype = {
            equals: function(t) {
                if (!t) return !1;
                t = o.latLng(t);
                var e = Math.max(Math.abs(this.lat - t.lat), Math.abs(this.lng - t.lng));
                return e <= o.LatLng.MAX_MARGIN
            },
            toString: function(t) {
                return "LatLng(" + o.Util.formatNum(this.lat, t) + ", " + o.Util.formatNum(this.lng, t) + ")"
            },
            distanceTo: function(t) {
                t = o.latLng(t);
                var e = 6378137,
                    i = o.LatLng.DEG_TO_RAD,
                    n = (t.lat - this.lat) * i,
                    s = (t.lng - this.lng) * i,
                    a = this.lat * i,
                    r = t.lat * i,
                    h = Math.sin(n / 2),
                    l = Math.sin(s / 2),
                    u = h * h + l * l * Math.cos(a) * Math.cos(r);
                return 2 * e * Math.atan2(Math.sqrt(u), Math.sqrt(1 - u))
            },
            wrap: function(t, e) {
                var i = this.lng;
                return t = t || -180, e = e || 180, i = (i + e) % (e - t) + (t > i || i === e ? e : t), new o.LatLng(this.lat, i)
            }
        }, o.latLng = function(t, e) {
            return t instanceof o.LatLng ? t : o.Util.isArray(t) ? "number" == typeof t[0] || "string" == typeof t[0] ? new o.LatLng(t[0], t[1], t[2]) : null : t === i || null === t ? t : "object" == typeof t && "lat" in t ? new o.LatLng(t.lat, "lng" in t ? t.lng : t.lon) : e === i ? null : new o.LatLng(t, e)
        }, o.LatLngBounds = function(t, e) {
            if (t)
                for (var i = e ? [t, e] : t, n = 0, o = i.length; o > n; n++) this.extend(i[n])
        }, o.LatLngBounds.prototype = {
            extend: function(t) {
                if (!t) return this;
                var e = o.latLng(t);
                return t = null !== e ? e : o.latLngBounds(t), t instanceof o.LatLng ? this._southWest || this._northEast ? (this._southWest.lat = Math.min(t.lat, this._southWest.lat), this._southWest.lng = Math.min(t.lng, this._southWest.lng), this._northEast.lat = Math.max(t.lat, this._northEast.lat), this._northEast.lng = Math.max(t.lng, this._northEast.lng)) : (this._southWest = new o.LatLng(t.lat, t.lng), this._northEast = new o.LatLng(t.lat, t.lng)) : t instanceof o.LatLngBounds && (this.extend(t._southWest), this.extend(t._northEast)), this
            },
            pad: function(t) {
                var e = this._southWest,
                    i = this._northEast,
                    n = Math.abs(e.lat - i.lat) * t,
                    s = Math.abs(e.lng - i.lng) * t;
                return new o.LatLngBounds(new o.LatLng(e.lat - n, e.lng - s), new o.LatLng(i.lat + n, i.lng + s))
            },
            getCenter: function() {
                return new o.LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2)
            },
            getSouthWest: function() {
                return this._southWest
            },
            getNorthEast: function() {
                return this._northEast
            },
            getNorthWest: function() {
                return new o.LatLng(this.getNorth(), this.getWest())
            },
            getSouthEast: function() {
                return new o.LatLng(this.getSouth(), this.getEast())
            },
            getWest: function() {
                return this._southWest.lng
            },
            getSouth: function() {
                return this._southWest.lat
            },
            getEast: function() {
                return this._northEast.lng
            },
            getNorth: function() {
                return this._northEast.lat
            },
            contains: function(t) {
                t = "number" == typeof t[0] || t instanceof o.LatLng ? o.latLng(t) : o.latLngBounds(t);
                var e, i, n = this._southWest,
                    s = this._northEast;
                return t instanceof o.LatLngBounds ? (e = t.getSouthWest(), i = t.getNorthEast()) : e = i = t, e.lat >= n.lat && i.lat <= s.lat && e.lng >= n.lng && i.lng <= s.lng
            },
            intersects: function(t) {
                t = o.latLngBounds(t);
                var e = this._southWest,
                    i = this._northEast,
                    n = t.getSouthWest(),
                    s = t.getNorthEast(),
                    a = s.lat >= e.lat && n.lat <= i.lat,
                    r = s.lng >= e.lng && n.lng <= i.lng;
                return a && r
            },
            toBBoxString: function() {
                return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",")
            },
            equals: function(t) {
                return t ? (t = o.latLngBounds(t), this._southWest.equals(t.getSouthWest()) && this._northEast.equals(t.getNorthEast())) : !1
            },
            isValid: function() {
                return !(!this._southWest || !this._northEast)
            }
        }, o.latLngBounds = function(t, e) {
            return !t || t instanceof o.LatLngBounds ? t : new o.LatLngBounds(t, e)
        }, o.Projection = {}, o.Projection.SphericalMercator = {
            MAX_LATITUDE: 85.0511287798,
            project: function(t) {
                var e = o.LatLng.DEG_TO_RAD,
                    i = this.MAX_LATITUDE,
                    n = Math.max(Math.min(i, t.lat), -i),
                    s = t.lng * e,
                    a = n * e;
                return a = Math.log(Math.tan(Math.PI / 4 + a / 2)), new o.Point(s, a)
            },
            unproject: function(t) {
                var e = o.LatLng.RAD_TO_DEG,
                    i = t.x * e,
                    n = (2 * Math.atan(Math.exp(t.y)) - Math.PI / 2) * e;
                return new o.LatLng(n, i)
            }
        }, o.Projection.LonLat = {
            project: function(t) {
                return new o.Point(t.lng, t.lat)
            },
            unproject: function(t) {
                return new o.LatLng(t.y, t.x)
            }
        }, o.CRS = {
            latLngToPoint: function(t, e) {
                var i = this.projection.project(t),
                    n = this.scale(e);
                return this.transformation._transform(i, n)
            },
            pointToLatLng: function(t, e) {
                var i = this.scale(e),
                    n = this.transformation.untransform(t, i);
                return this.projection.unproject(n)
            },
            project: function(t) {
                return this.projection.project(t)
            },
            scale: function(t) {
                return 256 * Math.pow(2, t)
            },
            getSize: function(t) {
                var e = this.scale(t);
                return o.point(e, e)
            }
        }, o.CRS.Simple = o.extend({}, o.CRS, {
            projection: o.Projection.LonLat,
            transformation: new o.Transformation(1, 0, -1, 0),
            scale: function(t) {
                return Math.pow(2, t)
            }
        }), o.CRS.EPSG3857 = o.extend({}, o.CRS, {
            code: "EPSG:3857",
            projection: o.Projection.SphericalMercator,
            transformation: new o.Transformation(.5 / Math.PI, .5, -.5 / Math.PI, .5),
            project: function(t) {
                var e = this.projection.project(t),
                    i = 6378137;
                return e.multiplyBy(i)
            }
        }), o.CRS.EPSG900913 = o.extend({}, o.CRS.EPSG3857, {
            code: "EPSG:900913"
        }), o.CRS.EPSG4326 = o.extend({}, o.CRS, {
            code: "EPSG:4326",
            projection: o.Projection.LonLat,
            transformation: new o.Transformation(1 / 360, .5, -1 / 360, .5)
        }), o.Map = o.Class.extend({
            includes: o.Mixin.Events,
            options: {
                crs: o.CRS.EPSG3857,
                fadeAnimation: o.DomUtil.TRANSITION && !o.Browser.android23,
                trackResize: !0,
                markerZoomAnimation: o.DomUtil.TRANSITION && o.Browser.any3d
            },
            initialize: function(t, e) {
                e = o.setOptions(this, e), this._initContainer(t), this._initLayout(), this._onResize = o.bind(this._onResize, this), this._initEvents(), e.maxBounds && this.setMaxBounds(e.maxBounds), e.center && e.zoom !== i && this.setView(o.latLng(e.center), e.zoom, {
                    reset: !0
                }), this._handlers = [], this._layers = {}, this._zoomBoundLayers = {}, this._tileLayersNum = 0, this.callInitHooks(), this._addLayers(e.layers)
            },
            setView: function(t, e) {
                return e = e === i ? this.getZoom() : e, this._resetView(o.latLng(t), this._limitZoom(e)), this
            },
            setZoom: function(t, e) {
                return this._loaded ? this.setView(this.getCenter(), t, {
                    zoom: e
                }) : (this._zoom = this._limitZoom(t), this)
            },
            zoomIn: function(t, e) {
                return this.setZoom(this._zoom + (t || 1), e)
            },
            zoomOut: function(t, e) {
                return this.setZoom(this._zoom - (t || 1), e)
            },
            setZoomAround: function(t, e, i) {
                var n = this.getZoomScale(e),
                    s = this.getSize().divideBy(2),
                    a = t instanceof o.Point ? t : this.latLngToContainerPoint(t),
                    r = a.subtract(s).multiplyBy(1 - 1 / n),
                    h = this.containerPointToLatLng(s.add(r));
                return this.setView(h, e, {
                    zoom: i
                })
            },
            fitBounds: function(t, e) {
                e = e || {}, t = t.getBounds ? t.getBounds() : o.latLngBounds(t);
                var i = o.point(e.paddingTopLeft || e.padding || [0, 0]),
                    n = o.point(e.paddingBottomRight || e.padding || [0, 0]),
                    s = this.getBoundsZoom(t, !1, i.add(n));
                s = e.maxZoom ? Math.min(e.maxZoom, s) : s;
                var a = n.subtract(i).divideBy(2),
                    r = this.project(t.getSouthWest(), s),
                    h = this.project(t.getNorthEast(), s),
                    l = this.unproject(r.add(h).divideBy(2).add(a), s);
                return this.setView(l, s, e)
            },
            fitWorld: function(t) {
                return this.fitBounds([
                    [-90, -180],
                    [90, 180]
                ], t)
            },
            panTo: function(t, e) {
                return this.setView(t, this._zoom, {
                    pan: e
                })
            },
            panBy: function(t) {
                return this.fire("movestart"), this._rawPanBy(o.point(t)), this.fire("move"), this.fire("moveend")
            },
            setMaxBounds: function(t) {
                return t = o.latLngBounds(t), this.options.maxBounds = t, t ? (this._loaded && this._panInsideMaxBounds(), this.on("moveend", this._panInsideMaxBounds, this)) : this.off("moveend", this._panInsideMaxBounds, this)
            },
            panInsideBounds: function(t, e) {
                var i = this.getCenter(),
                    n = this._limitCenter(i, this._zoom, t);
                return i.equals(n) ? this : this.panTo(n, e)
            },
            addLayer: function(t) {
                var e = o.stamp(t);
                return this._layers[e] ? this : (this._layers[e] = t, !t.options || isNaN(t.options.maxZoom) && isNaN(t.options.minZoom) || (this._zoomBoundLayers[e] = t, this._updateZoomLevels()), this.options.zoomAnimation && o.TileLayer && t instanceof o.TileLayer && (this._tileLayersNum++, this._tileLayersToLoad++, t.on("load", this._onTileLayerLoad, this)), this._loaded && this._layerAdd(t), this)
            },
            removeLayer: function(t) {
                var e = o.stamp(t);
                return this._layers[e] ? (this._loaded && t.onRemove(this), delete this._layers[e], this._loaded && this.fire("layerremove", {
                    layer: t
                }), this._zoomBoundLayers[e] && (delete this._zoomBoundLayers[e], this._updateZoomLevels()), this.options.zoomAnimation && o.TileLayer && t instanceof o.TileLayer && (this._tileLayersNum--, this._tileLayersToLoad--, t.off("load", this._onTileLayerLoad, this)), this) : this
            },
            hasLayer: function(t) {
                return t ? o.stamp(t) in this._layers : !1
            },
            eachLayer: function(t, e) {
                for (var i in this._layers) t.call(e, this._layers[i]);
                return this
            },
            invalidateSize: function(t) {
                if (!this._loaded) return this;
                t = o.extend({
                    animate: !1,
                    pan: !0
                }, t === !0 ? {
                    animate: !0
                } : t);
                var e = this.getSize();
                this._sizeChanged = !0, this._initialCenter = null;
                var i = this.getSize(),
                    n = e.divideBy(2).round(),
                    s = i.divideBy(2).round(),
                    a = n.subtract(s);
                return a.x || a.y ? (t.animate && t.pan ? this.panBy(a) : (t.pan && this._rawPanBy(a), this.fire("move"), t.debounceMoveend ? (clearTimeout(this._sizeTimer), this._sizeTimer = setTimeout(o.bind(this.fire, this, "moveend"), 200)) : this.fire("moveend")), this.fire("resize", {
                    oldSize: e,
                    newSize: i
                })) : this
            },
            addHandler: function(t, e) {
                if (!e) return this;
                var i = this[t] = new e(this);
                return this._handlers.push(i), this.options[t] && i.enable(), this
            },
            remove: function() {
                this._loaded && this.fire("unload"), this._initEvents("off");
                try {
                    delete this._container._leaflet
                } catch (t) {
                    this._container._leaflet = i
                }
                return this._clearPanes(), this._clearControlPos && this._clearControlPos(), this._clearHandlers(), this
            },
            getCenter: function() {
                return this._checkIfLoaded(), this._initialCenter && !this._moved() ? this._initialCenter : this.layerPointToLatLng(this._getCenterLayerPoint())
            },
            getZoom: function() {
                return this._zoom
            },
            getBounds: function() {
                var t = this.getPixelBounds(),
                    e = this.unproject(t.getBottomLeft()),
                    i = this.unproject(t.getTopRight());
                return new o.LatLngBounds(e, i)
            },
            getMinZoom: function() {
                return this.options.minZoom === i ? this._layersMinZoom === i ? 0 : this._layersMinZoom : this.options.minZoom
            },
            getMaxZoom: function() {
                return this.options.maxZoom === i ? this._layersMaxZoom === i ? 1 / 0 : this._layersMaxZoom : this.options.maxZoom
            },
            getBoundsZoom: function(t, e, i) {
                t = o.latLngBounds(t);
                var n, s = this.getMinZoom() - (e ? 1 : 0),
                    a = this.getMaxZoom(),
                    r = this.getSize(),
                    h = t.getNorthWest(),
                    l = t.getSouthEast(),
                    u = !0;
                i = o.point(i || [0, 0]);
                do s++, n = this.project(l, s).subtract(this.project(h, s)).add(i), u = e ? n.x < r.x || n.y < r.y : r.contains(n); while (u && a >= s);
                return u && e ? null : e ? s : s - 1
            },
            getSize: function() {
                return (!this._size || this._sizeChanged) && (this._size = new o.Point(this._container.clientWidth, this._container.clientHeight), this._sizeChanged = !1), this._size.clone()
            },
            getPixelBounds: function() {
                var t = this._getTopLeftPoint();
                return new o.Bounds(t, t.add(this.getSize()))
            },
            getPixelOrigin: function() {
                return this._checkIfLoaded(), this._initialTopLeftPoint
            },
            getPanes: function() {
                return this._panes
            },
            getContainer: function() {
                return this._container
            },
            getZoomScale: function(t) {
                var e = this.options.crs;
                return e.scale(t) / e.scale(this._zoom)
            },
            getScaleZoom: function(t) {
                return this._zoom + Math.log(t) / Math.LN2
            },
            project: function(t, e) {
                return e = e === i ? this._zoom : e, this.options.crs.latLngToPoint(o.latLng(t), e)
            },
            unproject: function(t, e) {
                return e = e === i ? this._zoom : e, this.options.crs.pointToLatLng(o.point(t), e)
            },
            layerPointToLatLng: function(t) {
                var e = o.point(t).add(this.getPixelOrigin());
                return this.unproject(e)
            },
            latLngToLayerPoint: function(t) {
                var e = this.project(o.latLng(t))._round();
                return e._subtract(this.getPixelOrigin())
            },
            containerPointToLayerPoint: function(t) {
                return o.point(t).subtract(this._getMapPanePos())
            },
            layerPointToContainerPoint: function(t) {
                return o.point(t).add(this._getMapPanePos())
            },
            containerPointToLatLng: function(t) {
                var e = this.containerPointToLayerPoint(o.point(t));
                return this.layerPointToLatLng(e)
            },
            latLngToContainerPoint: function(t) {
                return this.layerPointToContainerPoint(this.latLngToLayerPoint(o.latLng(t)))
            },
            mouseEventToContainerPoint: function(t) {
                return o.DomEvent.getMousePosition(t, this._container)
            },
            mouseEventToLayerPoint: function(t) {
                return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t))
            },
            mouseEventToLatLng: function(t) {
                return this.layerPointToLatLng(this.mouseEventToLayerPoint(t))
            },
            _initContainer: function(t) {
                var e = this._container = o.DomUtil.get(t);
                if (!e) throw new Error("Map container not found.");
                if (e._leaflet) throw new Error("Map container is already initialized.");
                e._leaflet = !0
            },
            _initLayout: function() {
                var t = this._container;
                o.DomUtil.addClass(t, "leaflet-container" + (o.Browser.touch ? " leaflet-touch" : "") + (o.Browser.retina ? " leaflet-retina" : "") + (o.Browser.ielt9 ? " leaflet-oldie" : "") + (this.options.fadeAnimation ? " leaflet-fade-anim" : ""));
                var e = o.DomUtil.getStyle(t, "position");
                "absolute" !== e && "relative" !== e && "fixed" !== e && (t.style.position = "relative"), this._initPanes(), this._initControlPos && this._initControlPos()
            },
            _initPanes: function() {
                var t = this._panes = {};
                this._mapPane = t.mapPane = this._createPane("leaflet-map-pane", this._container), this._tilePane = t.tilePane = this._createPane("leaflet-tile-pane", this._mapPane), t.objectsPane = this._createPane("leaflet-objects-pane", this._mapPane), t.shadowPane = this._createPane("leaflet-shadow-pane"), t.overlayPane = this._createPane("leaflet-overlay-pane"), t.markerPane = this._createPane("leaflet-marker-pane"), t.popupPane = this._createPane("leaflet-popup-pane");
                var e = " leaflet-zoom-hide";
                this.options.markerZoomAnimation || (o.DomUtil.addClass(t.markerPane, e), o.DomUtil.addClass(t.shadowPane, e), o.DomUtil.addClass(t.popupPane, e))
            },
            _createPane: function(t, e) {
                return o.DomUtil.create("div", t, e || this._panes.objectsPane)
            },
            _clearPanes: function() {
                this._container.removeChild(this._mapPane)
            },
            _addLayers: function(t) {
                t = t ? o.Util.isArray(t) ? t : [t] : [];
                for (var e = 0, i = t.length; i > e; e++) this.addLayer(t[e])
            },
            _resetView: function(t, e, i, n) {
                var s = this._zoom !== e;
                n || (this.fire("movestart"), s && this.fire("zoomstart")), this._zoom = e, this._initialCenter = t, this._initialTopLeftPoint = this._getNewTopLeftPoint(t), i ? this._initialTopLeftPoint._add(this._getMapPanePos()) : o.DomUtil.setPosition(this._mapPane, new o.Point(0, 0)), this._tileLayersToLoad = this._tileLayersNum;
                var a = !this._loaded;
                this._loaded = !0, this.fire("viewreset", {
                    hard: !i
                }), a && (this.fire("load"), this.eachLayer(this._layerAdd, this)), this.fire("move"), (s || n) && this.fire("zoomend"), this.fire("moveend", {
                    hard: !i
                })
            },
            _rawPanBy: function(t) {
                o.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(t))
            },
            _getZoomSpan: function() {
                return this.getMaxZoom() - this.getMinZoom()
            },
            _updateZoomLevels: function() {
                var t, e = 1 / 0,
                    n = -(1 / 0),
                    o = this._getZoomSpan();
                for (t in this._zoomBoundLayers) {
                    var s = this._zoomBoundLayers[t];
                    isNaN(s.options.minZoom) || (e = Math.min(e, s.options.minZoom)), isNaN(s.options.maxZoom) || (n = Math.max(n, s.options.maxZoom))
                }
                t === i ? this._layersMaxZoom = this._layersMinZoom = i : (this._layersMaxZoom = n, this._layersMinZoom = e), o !== this._getZoomSpan() && this.fire("zoomlevelschange")
            },
            _panInsideMaxBounds: function() {
                this.panInsideBounds(this.options.maxBounds)
            },
            _checkIfLoaded: function() {
                if (!this._loaded) throw new Error("Set map center and zoom first.")
            },
            _initEvents: function(e) {
                if (o.DomEvent) {
                    e = e || "on", o.DomEvent[e](this._container, "click", this._onMouseClick, this);
                    var i, n, s = ["dblclick", "mousedown", "mouseup", "mouseenter", "mouseleave", "mousemove", "contextmenu"];
                    for (i = 0, n = s.length; n > i; i++) o.DomEvent[e](this._container, s[i], this._fireMouseEvent, this);
                    this.options.trackResize && o.DomEvent[e](t, "resize", this._onResize, this)
                }
            },
            _onResize: function() {
                o.Util.cancelAnimFrame(this._resizeRequest), this._resizeRequest = o.Util.requestAnimFrame(function() {
                    this.invalidateSize({
                        debounceMoveend: !0
                    })
                }, this, !1, this._container)
            },
            _onMouseClick: function(t) {
                !this._loaded || !t._simulated && (this.dragging && this.dragging.moved() || this.boxZoom && this.boxZoom.moved()) || o.DomEvent._skipped(t) || (this.fire("preclick"), this._fireMouseEvent(t))
            },
            _fireMouseEvent: function(t) {
                if (this._loaded && !o.DomEvent._skipped(t)) {
                    var e = t.type;
                    if (e = "mouseenter" === e ? "mouseover" : "mouseleave" === e ? "mouseout" : e, this.hasEventListeners(e)) {
                        "contextmenu" === e && o.DomEvent.preventDefault(t);
                        var i = this.mouseEventToContainerPoint(t),
                            n = this.containerPointToLayerPoint(i),
                            s = this.layerPointToLatLng(n);
                        this.fire(e, {
                            latlng: s,
                            layerPoint: n,
                            containerPoint: i,
                            originalEvent: t
                        })
                    }
                }
            },
            _onTileLayerLoad: function() {
                this._tileLayersToLoad--, this._tileLayersNum && !this._tileLayersToLoad && this.fire("tilelayersload")
            },
            _clearHandlers: function() {
                for (var t = 0, e = this._handlers.length; e > t; t++) this._handlers[t].disable()
            },
            whenReady: function(t, e) {
                return this._loaded ? t.call(e || this, this) : this.on("load", t, e), this
            },
            _layerAdd: function(t) {
                t.onAdd(this), this.fire("layeradd", {
                    layer: t
                })
            },
            _getMapPanePos: function() {
                return o.DomUtil.getPosition(this._mapPane)
            },
            _moved: function() {
                var t = this._getMapPanePos();
                return t && !t.equals([0, 0])
            },
            _getTopLeftPoint: function() {
                return this.getPixelOrigin().subtract(this._getMapPanePos())
            },
            _getNewTopLeftPoint: function(t, e) {
                var i = this.getSize()._divideBy(2);
                return this.project(t, e)._subtract(i)._round()
            },
            _latLngToNewLayerPoint: function(t, e, i) {
                var n = this._getNewTopLeftPoint(i, e).add(this._getMapPanePos());
                return this.project(t, e)._subtract(n)
            },
            _getCenterLayerPoint: function() {
                return this.containerPointToLayerPoint(this.getSize()._divideBy(2))
            },
            _getCenterOffset: function(t) {
                return this.latLngToLayerPoint(t).subtract(this._getCenterLayerPoint())
            },
            _limitCenter: function(t, e, i) {
                if (!i) return t;
                var n = this.project(t, e),
                    s = this.getSize().divideBy(2),
                    a = new o.Bounds(n.subtract(s), n.add(s)),
                    r = this._getBoundsOffset(a, i, e);
                return this.unproject(n.add(r), e)
            },
            _limitOffset: function(t, e) {
                if (!e) return t;
                var i = this.getPixelBounds(),
                    n = new o.Bounds(i.min.add(t), i.max.add(t));
                return t.add(this._getBoundsOffset(n, e))
            },
            _getBoundsOffset: function(t, e, i) {
                var n = this.project(e.getNorthWest(), i).subtract(t.min),
                    s = this.project(e.getSouthEast(), i).subtract(t.max),
                    a = this._rebound(n.x, -s.x),
                    r = this._rebound(n.y, -s.y);
                return new o.Point(a, r)
            },
            _rebound: function(t, e) {
                return t + e > 0 ? Math.round(t - e) / 2 : Math.max(0, Math.ceil(t)) - Math.max(0, Math.floor(e))
            },
            _limitZoom: function(t) {
                var e = this.getMinZoom(),
                    i = this.getMaxZoom();
                return Math.max(e, Math.min(i, t))
            }
        }), o.map = function(t, e) {
            return new o.Map(t, e)
        }, o.Projection.Mercator = {
            MAX_LATITUDE: 85.0840591556,
            R_MINOR: 6356752.314245179,
            R_MAJOR: 6378137,
            project: function(t) {
                var e = o.LatLng.DEG_TO_RAD,
                    i = this.MAX_LATITUDE,
                    n = Math.max(Math.min(i, t.lat), -i),
                    s = this.R_MAJOR,
                    a = this.R_MINOR,
                    r = t.lng * e * s,
                    h = n * e,
                    l = a / s,
                    u = Math.sqrt(1 - l * l),
                    c = u * Math.sin(h);
                c = Math.pow((1 - c) / (1 + c), .5 * u);
                var d = Math.tan(.5 * (.5 * Math.PI - h)) / c;
                return h = -s * Math.log(d), new o.Point(r, h)
            },
            unproject: function(t) {
                for (var e, i = o.LatLng.RAD_TO_DEG, n = this.R_MAJOR, s = this.R_MINOR, a = t.x * i / n, r = s / n, h = Math.sqrt(1 - r * r), l = Math.exp(-t.y / n), u = Math.PI / 2 - 2 * Math.atan(l), c = 15, d = 1e-7, p = c, _ = .1; Math.abs(_) > d && --p > 0;) e = h * Math.sin(u), _ = Math.PI / 2 - 2 * Math.atan(l * Math.pow((1 - e) / (1 + e), .5 * h)) - u, u += _;
                return new o.LatLng(u * i, a)
            }
        }, o.CRS.EPSG3395 = o.extend({}, o.CRS, {
            code: "EPSG:3395",
            projection: o.Projection.Mercator,
            transformation: function() {
                var t = o.Projection.Mercator,
                    e = t.R_MAJOR,
                    i = .5 / (Math.PI * e);
                return new o.Transformation(i, .5, -i, .5)
            }()
        }), o.TileLayer = o.Class.extend({
            includes: o.Mixin.Events,
            options: {
                minZoom: 0,
                maxZoom: 18,
                tileSize: 256,
                subdomains: "abc",
                errorTileUrl: "",
                attribution: "",
                zoomOffset: 0,
                opacity: 1,
                unloadInvisibleTiles: o.Browser.mobile,
                updateWhenIdle: o.Browser.mobile
            },
            initialize: function(t, e) {
                e = o.setOptions(this, e), e.detectRetina && o.Browser.retina && e.maxZoom > 0 && (e.tileSize = Math.floor(e.tileSize / 2), e.zoomOffset++, e.minZoom > 0 && e.minZoom--, this.options.maxZoom--), e.bounds && (e.bounds = o.latLngBounds(e.bounds)), this._url = t;
                var i = this.options.subdomains;
                "string" == typeof i && (this.options.subdomains = i.split(""))
            },
            onAdd: function(t) {
                this._map = t, this._animated = t._zoomAnimated, this._initContainer(), t.on({
                    viewreset: this._reset,
                    moveend: this._update
                }, this), this._animated && t.on({
                    zoomanim: this._animateZoom,
                    zoomend: this._endZoomAnim
                }, this), this.options.updateWhenIdle || (this._limitedUpdate = o.Util.limitExecByInterval(this._update, 150, this), t.on("move", this._limitedUpdate, this)), this._reset(), this._update()
            },
            addTo: function(t) {
                return t.addLayer(this), this
            },
            onRemove: function(t) {
                this._container.parentNode.removeChild(this._container), t.off({
                    viewreset: this._reset,
                    moveend: this._update
                }, this), this._animated && t.off({
                    zoomanim: this._animateZoom,
                    zoomend: this._endZoomAnim
                }, this), this.options.updateWhenIdle || t.off("move", this._limitedUpdate, this), this._container = null, this._map = null
            },
            bringToFront: function() {
                var t = this._map._panes.tilePane;
                return this._container && (t.appendChild(this._container), this._setAutoZIndex(t, Math.max)), this
            },
            bringToBack: function() {
                var t = this._map._panes.tilePane;
                return this._container && (t.insertBefore(this._container, t.firstChild), this._setAutoZIndex(t, Math.min)), this
            },
            getAttribution: function() {
                return this.options.attribution
            },
            getContainer: function() {
                return this._container
            },
            setOpacity: function(t) {
                return this.options.opacity = t, this._map && this._updateOpacity(), this
            },
            setZIndex: function(t) {
                return this.options.zIndex = t, this._updateZIndex(), this
            },
            setUrl: function(t, e) {
                return this._url = t, e || this.redraw(), this
            },
            redraw: function() {
                return this._map && (this._reset({
                    hard: !0
                }), this._update()), this
            },
            _updateZIndex: function() {
                this._container && this.options.zIndex !== i && (this._container.style.zIndex = this.options.zIndex)
            },
            _setAutoZIndex: function(t, e) {
                var i, n, o, s = t.children,
                    a = -e(1 / 0, -(1 / 0));
                for (n = 0, o = s.length; o > n; n++) s[n] !== this._container && (i = parseInt(s[n].style.zIndex, 10), isNaN(i) || (a = e(a, i)));
                this.options.zIndex = this._container.style.zIndex = (isFinite(a) ? a : 0) + e(1, -1)
            },
            _updateOpacity: function() {
                var t, e = this._tiles;
                if (o.Browser.ielt9)
                    for (t in e) o.DomUtil.setOpacity(e[t], this.options.opacity);
                else o.DomUtil.setOpacity(this._container, this.options.opacity)
            },
            _initContainer: function() {
                var t = this._map._panes.tilePane;
                if (!this._container) {
                    if (this._container = o.DomUtil.create("div", "leaflet-layer"), this._updateZIndex(), this._animated) {
                        var e = "leaflet-tile-container";
                        this._bgBuffer = o.DomUtil.create("div", e, this._container), this._tileContainer = o.DomUtil.create("div", e, this._container)
                    } else this._tileContainer = this._container;
                    t.appendChild(this._container), this.options.opacity < 1 && this._updateOpacity()
                }
            },
            _reset: function(t) {
                for (var e in this._tiles) this.fire("tileunload", {
                    tile: this._tiles[e]
                });
                this._tiles = {}, this._tilesToLoad = 0, this.options.reuseTiles && (this._unusedTiles = []), this._tileContainer.innerHTML = "", this._animated && t && t.hard && this._clearBgBuffer(), this._initContainer()
            },
            _getTileSize: function() {
                var t = this._map,
                    e = t.getZoom() + this.options.zoomOffset,
                    i = this.options.maxNativeZoom,
                    n = this.options.tileSize;
                return i && e > i && (n = Math.round(t.getZoomScale(e) / t.getZoomScale(i) * n)), n
            },
            _update: function() {
                if (this._map) {
                    var t = this._map,
                        e = t.getPixelBounds(),
                        i = t.getZoom(),
                        n = this._getTileSize();
                    if (!(i > this.options.maxZoom || i < this.options.minZoom)) {
                        var s = o.bounds(e.min.divideBy(n)._floor(), e.max.divideBy(n)._floor());
                        this._addTilesFromCenterOut(s), (this.options.unloadInvisibleTiles || this.options.reuseTiles) && this._removeOtherTiles(s)
                    }
                }
            },
            _addTilesFromCenterOut: function(t) {
                var i, n, s, a = [],
                    r = t.getCenter();
                for (i = t.min.y; i <= t.max.y; i++)
                    for (n = t.min.x; n <= t.max.x; n++) s = new o.Point(n, i), this._tileShouldBeLoaded(s) && a.push(s);
                var h = a.length;
                if (0 !== h) {
                    a.sort(function(t, e) {
                        return t.distanceTo(r) - e.distanceTo(r)
                    });
                    var l = e.createDocumentFragment();
                    for (this._tilesToLoad || this.fire("loading"), this._tilesToLoad += h, n = 0; h > n; n++) this._addTile(a[n], l);
                    this._tileContainer.appendChild(l)
                }
            },
            _tileShouldBeLoaded: function(t) {
                if (t.x + ":" + t.y in this._tiles) return !1;
                var e = this.options;
                if (!e.continuousWorld) {
                    var i = this._getWrapTileNum();
                    if (e.noWrap && (t.x < 0 || t.x >= i.x) || t.y < 0 || t.y >= i.y) return !1
                }
                if (e.bounds) {
                    var n = this._getTileSize(),
                        o = t.multiplyBy(n),
                        s = o.add([n, n]),
                        a = this._map.unproject(o),
                        r = this._map.unproject(s);
                    if (e.continuousWorld || e.noWrap || (a = a.wrap(), r = r.wrap()), !e.bounds.intersects([a, r])) return !1
                }
                return !0
            },
            _removeOtherTiles: function(t) {
                var e, i, n, o;
                for (o in this._tiles) e = o.split(":"), i = parseInt(e[0], 10), n = parseInt(e[1], 10), (i < t.min.x || i > t.max.x || n < t.min.y || n > t.max.y) && this._removeTile(o)
            },
            _removeTile: function(t) {
                var e = this._tiles[t];
                this.fire("tileunload", {
                    tile: e,
                    url: e.src
                }), this.options.reuseTiles ? (o.DomUtil.removeClass(e, "leaflet-tile-loaded"), this._unusedTiles.push(e)) : e.parentNode === this._tileContainer && this._tileContainer.removeChild(e), o.Browser.android || (e.onload = null, e.src = o.Util.emptyImageUrl), delete this._tiles[t]
            },
            _addTile: function(t, e) {
                var i = this._getTilePos(t),
                    n = this._getTile();
                o.DomUtil.setPosition(n, i, o.Browser.chrome), this._tiles[t.x + ":" + t.y] = n, this._loadTile(n, t), n.parentNode !== this._tileContainer && e.appendChild(n)
            },
            _getZoomForUrl: function() {
                var t = this.options,
                    e = this._map.getZoom();
                return t.zoomReverse && (e = t.maxZoom - e), e += t.zoomOffset, t.maxNativeZoom ? Math.min(e, t.maxNativeZoom) : e
            },
            _getTilePos: function(t) {
                var e = this._map.getPixelOrigin(),
                    i = this._getTileSize();
                return t.multiplyBy(i).subtract(e)
            },
            getTileUrl: function(t) {
                return o.Util.template(this._url, o.extend({
                    s: this._getSubdomain(t),
                    z: t.z,
                    x: t.x,
                    y: t.y
                }, this.options))
            },
            _getWrapTileNum: function() {
                var t = this._map.options.crs,
                    e = t.getSize(this._map.getZoom());
                return e.divideBy(this._getTileSize())._floor()
            },
            _adjustTilePoint: function(t) {
                var e = this._getWrapTileNum();
                this.options.continuousWorld || this.options.noWrap || (t.x = (t.x % e.x + e.x) % e.x), this.options.tms && (t.y = e.y - t.y - 1), t.z = this._getZoomForUrl()
            },
            _getSubdomain: function(t) {
                var e = Math.abs(t.x + t.y) % this.options.subdomains.length;
                return this.options.subdomains[e]
            },
            _getTile: function() {
                if (this.options.reuseTiles && this._unusedTiles.length > 0) {
                    var t = this._unusedTiles.pop();
                    return this._resetTile(t), t
                }
                return this._createTile()
            },
            _resetTile: function() {},
            _createTile: function() {
                var t = o.DomUtil.create("img", "leaflet-tile");
                return t.style.width = t.style.height = this._getTileSize() + "px", t.galleryimg = "no", t.onselectstart = t.onmousemove = o.Util.falseFn, o.Browser.ielt9 && this.options.opacity !== i && o.DomUtil.setOpacity(t, this.options.opacity), o.Browser.mobileWebkit3d && (t.style.WebkitBackfaceVisibility = "hidden"), t
            },
            _loadTile: function(t, e) {
                t._layer = this, t.onload = this._tileOnLoad, t.onerror = this._tileOnError, this._adjustTilePoint(e), t.src = this.getTileUrl(e), this.fire("tileloadstart", {
                    tile: t,
                    url: t.src
                })
            },
            _tileLoaded: function() {
                this._tilesToLoad--, this._animated && o.DomUtil.addClass(this._tileContainer, "leaflet-zoom-animated"), this._tilesToLoad || (this.fire("load"), this._animated && (clearTimeout(this._clearBgBufferTimer), this._clearBgBufferTimer = setTimeout(o.bind(this._clearBgBuffer, this), 500)))
            },
            _tileOnLoad: function() {
                var t = this._layer;
                this.src !== o.Util.emptyImageUrl && (o.DomUtil.addClass(this, "leaflet-tile-loaded"), t.fire("tileload", {
                    tile: this,
                    url: this.src
                })), t._tileLoaded()
            },
            _tileOnError: function() {
                var t = this._layer;
                t.fire("tileerror", {
                    tile: this,
                    url: this.src
                });
                var e = t.options.errorTileUrl;
                e && (this.src = e), t._tileLoaded()
            }
        }), o.tileLayer = function(t, e) {
            return new o.TileLayer(t, e)
        }, o.TileLayer.WMS = o.TileLayer.extend({
            defaultWmsParams: {
                service: "WMS",
                request: "GetMap",
                version: "1.1.1",
                layers: "",
                styles: "",
                format: "image/jpeg",
                transparent: !1
            },
            initialize: function(t, e) {
                this._url = t;
                var i = o.extend({}, this.defaultWmsParams),
                    n = e.tileSize || this.options.tileSize;
                e.detectRetina && o.Browser.retina ? i.width = i.height = 2 * n : i.width = i.height = n;
                for (var s in e) this.options.hasOwnProperty(s) || "crs" === s || (i[s] = e[s]);
                this.wmsParams = i, o.setOptions(this, e)
            },
            onAdd: function(t) {
                this._crs = this.options.crs || t.options.crs, this._wmsVersion = parseFloat(this.wmsParams.version);
                var e = this._wmsVersion >= 1.3 ? "crs" : "srs";
                this.wmsParams[e] = this._crs.code, o.TileLayer.prototype.onAdd.call(this, t)
            },
            getTileUrl: function(t) {
                var e = this._map,
                    i = this.options.tileSize,
                    n = t.multiplyBy(i),
                    s = n.add([i, i]),
                    a = this._crs.project(e.unproject(n, t.z)),
                    r = this._crs.project(e.unproject(s, t.z)),
                    h = this._wmsVersion >= 1.3 && this._crs === o.CRS.EPSG4326 ? [r.y, a.x, a.y, r.x].join(",") : [a.x, r.y, r.x, a.y].join(","),
                    l = o.Util.template(this._url, {
                        s: this._getSubdomain(t)
                    });
                return l + o.Util.getParamString(this.wmsParams, l, !0) + "&BBOX=" + h
            },
            setParams: function(t, e) {
                return o.extend(this.wmsParams, t), e || this.redraw(), this
            }
        }), o.tileLayer.wms = function(t, e) {
            return new o.TileLayer.WMS(t, e)
        }, o.TileLayer.Canvas = o.TileLayer.extend({
            options: {
                async: !1
            },
            initialize: function(t) {
                o.setOptions(this, t)
            },
            redraw: function() {
                this._map && (this._reset({
                    hard: !0
                }), this._update());
                for (var t in this._tiles) this._redrawTile(this._tiles[t]);
                return this
            },
            _redrawTile: function(t) {
                this.drawTile(t, t._tilePoint, this._map._zoom)
            },
            _createTile: function() {
                var t = o.DomUtil.create("canvas", "leaflet-tile");
                return t.width = t.height = this.options.tileSize, t.onselectstart = t.onmousemove = o.Util.falseFn, t
            },
            _loadTile: function(t, e) {
                t._layer = this, t._tilePoint = e, this._redrawTile(t), this.options.async || this.tileDrawn(t)
            },
            drawTile: function() {},
            tileDrawn: function(t) {
                this._tileOnLoad.call(t)
            }
        }), o.tileLayer.canvas = function(t) {
            return new o.TileLayer.Canvas(t)
        }, o.ImageOverlay = o.Class.extend({
            includes: o.Mixin.Events,
            options: {
                opacity: 1
            },
            initialize: function(t, e, i) {
                this._url = t, this._bounds = o.latLngBounds(e), o.setOptions(this, i)
            },
            onAdd: function(t) {
                this._map = t, this._image || this._initImage(), t._panes.overlayPane.appendChild(this._image), t.on("viewreset", this._reset, this), t.options.zoomAnimation && o.Browser.any3d && t.on("zoomanim", this._animateZoom, this), this._reset()
            },
            onRemove: function(t) {
                t.getPanes().overlayPane.removeChild(this._image), t.off("viewreset", this._reset, this), t.options.zoomAnimation && t.off("zoomanim", this._animateZoom, this)
            },
            addTo: function(t) {
                return t.addLayer(this), this
            },
            setOpacity: function(t) {
                return this.options.opacity = t, this._updateOpacity(), this
            },
            bringToFront: function() {
                return this._image && this._map._panes.overlayPane.appendChild(this._image), this
            },
            bringToBack: function() {
                var t = this._map._panes.overlayPane;
                return this._image && t.insertBefore(this._image, t.firstChild), this
            },
            setUrl: function(t) {
                this._url = t, this._image.src = this._url
            },
            getAttribution: function() {
                return this.options.attribution
            },
            _initImage: function() {
                this._image = o.DomUtil.create("img", "leaflet-image-layer"), this._map.options.zoomAnimation && o.Browser.any3d ? o.DomUtil.addClass(this._image, "leaflet-zoom-animated") : o.DomUtil.addClass(this._image, "leaflet-zoom-hide"), this._updateOpacity(), o.extend(this._image, {
                    galleryimg: "no",
                    onselectstart: o.Util.falseFn,
                    onmousemove: o.Util.falseFn,
                    onload: o.bind(this._onImageLoad, this),
                    src: this._url
                })
            },
            _animateZoom: function(t) {
                var e = this._map,
                    i = this._image,
                    n = e.getZoomScale(t.zoom),
                    s = this._bounds.getNorthWest(),
                    a = this._bounds.getSouthEast(),
                    r = e._latLngToNewLayerPoint(s, t.zoom, t.center),
                    h = e._latLngToNewLayerPoint(a, t.zoom, t.center)._subtract(r),
                    l = r._add(h._multiplyBy(.5 * (1 - 1 / n)));
                i.style[o.DomUtil.TRANSFORM] = o.DomUtil.getTranslateString(l) + " scale(" + n + ") "
            },
            _reset: function() {
                var t = this._image,
                    e = this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
                    i = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(e);
                o.DomUtil.setPosition(t, e), t.style.width = i.x + "px", t.style.height = i.y + "px"
            },
            _onImageLoad: function() {
                this.fire("load")
            },
            _updateOpacity: function() {
                o.DomUtil.setOpacity(this._image, this.options.opacity)
            }
        }), o.imageOverlay = function(t, e, i) {
            return new o.ImageOverlay(t, e, i)
        }, o.Icon = o.Class.extend({
            options: {
                className: ""
            },
            initialize: function(t) {
                o.setOptions(this, t)
            },
            createIcon: function(t) {
                return this._createIcon("icon", t)
            },
            createShadow: function(t) {
                return this._createIcon("shadow", t)
            },
            _createIcon: function(t, e) {
                var i = this._getIconUrl(t);
                if (!i) {
                    if ("icon" === t) throw new Error("iconUrl not set in Icon options (see the docs).");
                    return null
                }
                var n;
                return n = e && "IMG" === e.tagName ? this._createImg(i, e) : this._createImg(i), this._setIconStyles(n, t), n
            },
            _setIconStyles: function(t, e) {
                var i, n = this.options,
                    s = o.point(n[e + "Size"]);
                i = "shadow" === e ? o.point(n.shadowAnchor || n.iconAnchor) : o.point(n.iconAnchor), !i && s && (i = s.divideBy(2, !0)), t.className = "leaflet-marker-" + e + " " + n.className, i && (t.style.marginLeft = -i.x + "px", t.style.marginTop = -i.y + "px"), s && (t.style.width = s.x + "px", t.style.height = s.y + "px")
            },
            _createImg: function(t, i) {
                return i = i || e.createElement("img"), i.src = t, i
            },
            _getIconUrl: function(t) {
                return o.Browser.retina && this.options[t + "RetinaUrl"] ? this.options[t + "RetinaUrl"] : this.options[t + "Url"]
            }
        }), o.icon = function(t) {
            return new o.Icon(t)
        }, o.Icon.Default = o.Icon.extend({
            options: {
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
            },
            _getIconUrl: function(t) {
                var e = t + "Url";
                if (this.options[e]) return this.options[e];
                o.Browser.retina && "icon" === t && (t += "-2x");
                var i = o.Icon.Default.imagePath;
                if (!i) throw new Error("Couldn't autodetect L.Icon.Default.imagePath, set it manually.");
                return i + "/marker-" + t + ".png"
            }
        }), o.Icon.Default.imagePath = function() {
            var t, i, n, o, s, a = e.getElementsByTagName("script"),
                r = /[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;
            for (t = 0, i = a.length; i > t; t++)
                if (n = a[t].src, o = n.match(r)) return s = n.split(r)[0], (s ? s + "/" : "") + "images"
        }(), o.Marker = o.Class.extend({
            includes: o.Mixin.Events,
            options: {
                icon: new o.Icon.Default,
                title: "",
                alt: "",
                clickable: !0,
                draggable: !1,
                keyboard: !0,
                zIndexOffset: 0,
                opacity: 1,
                riseOnHover: !1,
                riseOffset: 250
            },
            initialize: function(t, e) {
                o.setOptions(this, e), this._latlng = o.latLng(t)
            },
            onAdd: function(t) {
                this._map = t, t.on("viewreset", this.update, this), this._initIcon(), this.update(), this.fire("add"), t.options.zoomAnimation && t.options.markerZoomAnimation && t.on("zoomanim", this._animateZoom, this)
            },
            addTo: function(t) {
                return t.addLayer(this), this
            },
            onRemove: function(t) {
                this.dragging && this.dragging.disable(), this._removeIcon(), this._removeShadow(), this.fire("remove"), t.off({
                    viewreset: this.update,
                    zoomanim: this._animateZoom
                }, this), this._map = null
            },
            getLatLng: function() {
                return this._latlng
            },
            setLatLng: function(t) {
                return this._latlng = o.latLng(t), this.update(), this.fire("move", {
                    latlng: this._latlng
                })
            },
            setZIndexOffset: function(t) {
                return this.options.zIndexOffset = t, this.update(), this
            },
            setIcon: function(t) {
                return this.options.icon = t, this._map && (this._initIcon(), this.update()), this._popup && this.bindPopup(this._popup), this
            },
            update: function() {
                return this._icon && this._setPos(this._map.latLngToLayerPoint(this._latlng).round()), this
            },
            _initIcon: function() {
                var t = this.options,
                    e = this._map,
                    i = e.options.zoomAnimation && e.options.markerZoomAnimation,
                    n = i ? "leaflet-zoom-animated" : "leaflet-zoom-hide",
                    s = t.icon.createIcon(this._icon),
                    a = !1;
                s !== this._icon && (this._icon && this._removeIcon(), a = !0, t.title && (s.title = t.title), t.alt && (s.alt = t.alt)), o.DomUtil.addClass(s, n), t.keyboard && (s.tabIndex = "0"), this._icon = s, this._initInteraction(), t.riseOnHover && o.DomEvent.on(s, "mouseover", this._bringToFront, this).on(s, "mouseout", this._resetZIndex, this);
                var r = t.icon.createShadow(this._shadow),
                    h = !1;
                r !== this._shadow && (this._removeShadow(), h = !0), r && o.DomUtil.addClass(r, n), this._shadow = r, t.opacity < 1 && this._updateOpacity();
                var l = this._map._panes;
                a && l.markerPane.appendChild(this._icon), r && h && l.shadowPane.appendChild(this._shadow)
            },
            _removeIcon: function() {
                this.options.riseOnHover && o.DomEvent.off(this._icon, "mouseover", this._bringToFront).off(this._icon, "mouseout", this._resetZIndex), this._map._panes.markerPane.removeChild(this._icon), this._icon = null
            },
            _removeShadow: function() {
                this._shadow && this._map._panes.shadowPane.removeChild(this._shadow), this._shadow = null
            },
            _setPos: function(t) {
                o.DomUtil.setPosition(this._icon, t), this._shadow && o.DomUtil.setPosition(this._shadow, t), this._zIndex = t.y + this.options.zIndexOffset, this._resetZIndex()
            },
            _updateZIndex: function(t) {
                this._icon.style.zIndex = this._zIndex + t
            },
            _animateZoom: function(t) {
                var e = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center).round();
                this._setPos(e)
            },
            _initInteraction: function() {
                if (this.options.clickable) {
                    var t = this._icon,
                        e = ["dblclick", "mousedown", "mouseover", "mouseout", "contextmenu"];
                    o.DomUtil.addClass(t, "leaflet-clickable"), o.DomEvent.on(t, "click", this._onMouseClick, this), o.DomEvent.on(t, "keypress", this._onKeyPress, this);
                    for (var i = 0; i < e.length; i++) o.DomEvent.on(t, e[i], this._fireMouseEvent, this);
                    o.Handler.MarkerDrag && (this.dragging = new o.Handler.MarkerDrag(this), this.options.draggable && this.dragging.enable())
                }
            },
            _onMouseClick: function(t) {
                var e = this.dragging && this.dragging.moved();
                (this.hasEventListeners(t.type) || e) && o.DomEvent.stopPropagation(t), e || (this.dragging && this.dragging._enabled || !this._map.dragging || !this._map.dragging.moved()) && this.fire(t.type, {
                    originalEvent: t,
                    latlng: this._latlng
                })
            },
            _onKeyPress: function(t) {
                13 === t.keyCode && this.fire("click", {
                    originalEvent: t,
                    latlng: this._latlng
                })
            },
            _fireMouseEvent: function(t) {
                this.fire(t.type, {
                    originalEvent: t,
                    latlng: this._latlng
                }), "contextmenu" === t.type && this.hasEventListeners(t.type) && o.DomEvent.preventDefault(t), "mousedown" !== t.type ? o.DomEvent.stopPropagation(t) : o.DomEvent.preventDefault(t)
            },
            setOpacity: function(t) {
                return this.options.opacity = t, this._map && this._updateOpacity(), this
            },
            _updateOpacity: function() {
                o.DomUtil.setOpacity(this._icon, this.options.opacity), this._shadow && o.DomUtil.setOpacity(this._shadow, this.options.opacity)
            },
            _bringToFront: function() {
                this._updateZIndex(this.options.riseOffset)
            },
            _resetZIndex: function() {
                this._updateZIndex(0)
            }
        }), o.marker = function(t, e) {
            return new o.Marker(t, e)
        }, o.DivIcon = o.Icon.extend({
            options: {
                iconSize: [12, 12],
                className: "leaflet-div-icon",
                html: !1
            },
            createIcon: function(t) {
                var i = t && "DIV" === t.tagName ? t : e.createElement("div"),
                    n = this.options;
                return n.html !== !1 ? i.innerHTML = n.html : i.innerHTML = "", n.bgPos && (i.style.backgroundPosition = -n.bgPos.x + "px " + -n.bgPos.y + "px"), this._setIconStyles(i, "icon"), i
            },
            createShadow: function() {
                return null
            }
        }), o.divIcon = function(t) {
            return new o.DivIcon(t)
        }, o.Map.mergeOptions({
            closePopupOnClick: !0
        }), o.Popup = o.Class.extend({
            includes: o.Mixin.Events,
            options: {
                minWidth: 50,
                maxWidth: 300,
                autoPan: !0,
                closeButton: !0,
                offset: [0, 7],
                autoPanPadding: [5, 5],
                keepInView: !1,
                className: "",
                zoomAnimation: !0
            },
            initialize: function(t, e) {
                o.setOptions(this, t), this._source = e, this._animated = o.Browser.any3d && this.options.zoomAnimation, this._isOpen = !1
            },
            onAdd: function(t) {
                this._map = t, this._container || this._initLayout();
                var e = t.options.fadeAnimation;
                e && o.DomUtil.setOpacity(this._container, 0), t._panes.popupPane.appendChild(this._container), t.on(this._getEvents(), this), this.update(), e && o.DomUtil.setOpacity(this._container, 1), this.fire("open"), t.fire("popupopen", {
                    popup: this
                }), this._source && this._source.fire("popupopen", {
                    popup: this
                })
            },
            addTo: function(t) {
                return t.addLayer(this), this
            },
            openOn: function(t) {
                return t.openPopup(this), this
            },
            onRemove: function(t) {
                t._panes.popupPane.removeChild(this._container), o.Util.falseFn(this._container.offsetWidth), t.off(this._getEvents(), this), t.options.fadeAnimation && o.DomUtil.setOpacity(this._container, 0), this._map = null, this.fire("close"), t.fire("popupclose", {
                    popup: this
                }), this._source && this._source.fire("popupclose", {
                    popup: this
                })
            },
            getLatLng: function() {
                return this._latlng
            },
            setLatLng: function(t) {
                return this._latlng = o.latLng(t), this._map && (this._updatePosition(), this._adjustPan()), this
            },
            getContent: function() {
                return this._content
            },
            setContent: function(t) {
                return this._content = t, this.update(), this
            },
            update: function() {
                this._map && (this._container.style.visibility = "hidden", this._updateContent(), this._updateLayout(), this._updatePosition(), this._container.style.visibility = "", this._adjustPan())
            },
            _getEvents: function() {
                var t = {
                    viewreset: this._updatePosition
                };
                return this._animated && (t.zoomanim = this._zoomAnimation), ("closeOnClick" in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) && (t.preclick = this._close), this.options.keepInView && (t.moveend = this._adjustPan), t
            },
            _close: function() {
                this._map && this._map.closePopup(this)
            },
            _initLayout: function() {
                var t, e = "leaflet-popup",
                    i = e + " " + this.options.className + " leaflet-zoom-" + (this._animated ? "animated" : "hide"),
                    n = this._container = o.DomUtil.create("div", i);
                this.options.closeButton && (t = this._closeButton = o.DomUtil.create("a", e + "-close-button", n), t.href = "#close", t.innerHTML = "&#215;", o.DomEvent.disableClickPropagation(t), o.DomEvent.on(t, "click", this._onCloseButtonClick, this));
                var s = this._wrapper = o.DomUtil.create("div", e + "-content-wrapper", n);
                o.DomEvent.disableClickPropagation(s), this._contentNode = o.DomUtil.create("div", e + "-content", s), o.DomEvent.disableScrollPropagation(this._contentNode), o.DomEvent.on(s, "contextmenu", o.DomEvent.stopPropagation), this._tipContainer = o.DomUtil.create("div", e + "-tip-container", n), this._tip = o.DomUtil.create("div", e + "-tip", this._tipContainer)
            },
            _updateContent: function() {
                if (this._content) {
                    if ("string" == typeof this._content) this._contentNode.innerHTML = this._content;
                    else {
                        for (; this._contentNode.hasChildNodes();) this._contentNode.removeChild(this._contentNode.firstChild);
                        this._contentNode.appendChild(this._content)
                    }
                    this.fire("contentupdate")
                }
            },
            _updateLayout: function() {
                var t = this._contentNode,
                    e = t.style;
                e.width = "", e.whiteSpace = "nowrap";
                var i = t.offsetWidth;
                i = Math.min(i, this.options.maxWidth), i = Math.max(i, this.options.minWidth), e.width = i + 1 + "px", e.whiteSpace = "", e.height = "";
                var n = t.offsetHeight,
                    s = this.options.maxHeight,
                    a = "leaflet-popup-scrolled";
                s && n > s ? (e.height = s + "px", o.DomUtil.addClass(t, a)) : o.DomUtil.removeClass(t, a), this._containerWidth = this._container.offsetWidth
            },
            _updatePosition: function() {
                if (this._map) {
                    var t = this._map.latLngToLayerPoint(this._latlng),
                        e = this._animated,
                        i = o.point(this.options.offset);
                    e && o.DomUtil.setPosition(this._container, t), this._containerBottom = -i.y - (e ? 0 : t.y), this._containerLeft = -Math.round(this._containerWidth / 2) + i.x + (e ? 0 : t.x), this._container.style.bottom = this._containerBottom + "px", this._container.style.left = this._containerLeft + "px"
                }
            },
            _zoomAnimation: function(t) {
                var e = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center);
                o.DomUtil.setPosition(this._container, e)
            },
            _adjustPan: function() {
                if (this.options.autoPan) {
                    var t = this._map,
                        e = this._container.offsetHeight,
                        i = this._containerWidth,
                        n = new o.Point(this._containerLeft, -e - this._containerBottom);
                    this._animated && n._add(o.DomUtil.getPosition(this._container));
                    var s = t.layerPointToContainerPoint(n),
                        a = o.point(this.options.autoPanPadding),
                        r = o.point(this.options.autoPanPaddingTopLeft || a),
                        h = o.point(this.options.autoPanPaddingBottomRight || a),
                        l = t.getSize(),
                        u = 0,
                        c = 0;
                    s.x + i + h.x > l.x && (u = s.x + i - l.x + h.x), s.x - u - r.x < 0 && (u = s.x - r.x), s.y + e + h.y > l.y && (c = s.y + e - l.y + h.y), s.y - c - r.y < 0 && (c = s.y - r.y), (u || c) && t.fire("autopanstart").panBy([u, c])
                }
            },
            _onCloseButtonClick: function(t) {
                this._close(), o.DomEvent.stop(t)
            }
        }), o.popup = function(t, e) {
            return new o.Popup(t, e)
        }, o.Map.include({
            openPopup: function(t, e, i) {
                if (this.closePopup(), !(t instanceof o.Popup)) {
                    var n = t;
                    t = new o.Popup(i).setLatLng(e).setContent(n)
                }
                return t._isOpen = !0, this._popup = t, this.addLayer(t)
            },
            closePopup: function(t) {
                return t && t !== this._popup || (t = this._popup, this._popup = null), t && (this.removeLayer(t), t._isOpen = !1), this
            }
        }), o.Marker.include({
            openPopup: function() {
                return this._popup && this._map && !this._map.hasLayer(this._popup) && (this._popup.setLatLng(this._latlng), this._map.openPopup(this._popup)), this
            },
            closePopup: function() {
                return this._popup && this._popup._close(), this
            },
            togglePopup: function() {
                return this._popup && (this._popup._isOpen ? this.closePopup() : this.openPopup()), this
            },
            bindPopup: function(t, e) {
                var i = o.point(this.options.icon.options.popupAnchor || [0, 0]);
                return i = i.add(o.Popup.prototype.options.offset), e && e.offset && (i = i.add(e.offset)), e = o.extend({
                    offset: i
                }, e), this._popupHandlersAdded || (this.on("click", this.togglePopup, this).on("remove", this.closePopup, this).on("move", this._movePopup, this), this._popupHandlersAdded = !0), t instanceof o.Popup ? (o.setOptions(t, e), this._popup = t, t._source = this) : this._popup = new o.Popup(e, this).setContent(t), this
            },
            setPopupContent: function(t) {
                return this._popup && this._popup.setContent(t), this
            },
            unbindPopup: function() {
                return this._popup && (this._popup = null, this.off("click", this.togglePopup, this).off("remove", this.closePopup, this).off("move", this._movePopup, this), this._popupHandlersAdded = !1), this
            },
            getPopup: function() {
                return this._popup
            },
            _movePopup: function(t) {
                this._popup.setLatLng(t.latlng)
            }
        }), o.LayerGroup = o.Class.extend({
            initialize: function(t) {
                this._layers = {};
                var e, i;
                if (t)
                    for (e = 0, i = t.length; i > e; e++) this.addLayer(t[e])
            },
            addLayer: function(t) {
                var e = this.getLayerId(t);
                return this._layers[e] = t, this._map && this._map.addLayer(t), this
            },
            removeLayer: function(t) {
                var e = t in this._layers ? t : this.getLayerId(t);
                return this._map && this._layers[e] && this._map.removeLayer(this._layers[e]), delete this._layers[e], this
            },
            hasLayer: function(t) {
                return t ? t in this._layers || this.getLayerId(t) in this._layers : !1
            },
            clearLayers: function() {
                return this.eachLayer(this.removeLayer, this), this
            },
            invoke: function(t) {
                var e, i, n = Array.prototype.slice.call(arguments, 1);
                for (e in this._layers) i = this._layers[e], i[t] && i[t].apply(i, n);
                return this
            },
            onAdd: function(t) {
                this._map = t, this.eachLayer(t.addLayer, t)
            },
            onRemove: function(t) {
                this.eachLayer(t.removeLayer, t), this._map = null
            },
            addTo: function(t) {
                return t.addLayer(this), this
            },
            eachLayer: function(t, e) {
                for (var i in this._layers) t.call(e, this._layers[i]);
                return this
            },
            getLayer: function(t) {
                return this._layers[t]
            },
            getLayers: function() {
                var t = [];
                for (var e in this._layers) t.push(this._layers[e]);
                return t
            },
            setZIndex: function(t) {
                return this.invoke("setZIndex", t)
            },
            getLayerId: function(t) {
                return o.stamp(t)
            }
        }), o.layerGroup = function(t) {
            return new o.LayerGroup(t)
        }, o.FeatureGroup = o.LayerGroup.extend({
            includes: o.Mixin.Events,
            statics: {
                EVENTS: "click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose"
            },
            addLayer: function(t) {
                return this.hasLayer(t) ? this : ("on" in t && t.on(o.FeatureGroup.EVENTS, this._propagateEvent, this), o.LayerGroup.prototype.addLayer.call(this, t), this._popupContent && t.bindPopup && t.bindPopup(this._popupContent, this._popupOptions), this.fire("layeradd", {
                    layer: t
                }))
            },
            removeLayer: function(t) {
                return this.hasLayer(t) ? (t in this._layers && (t = this._layers[t]), "off" in t && t.off(o.FeatureGroup.EVENTS, this._propagateEvent, this), o.LayerGroup.prototype.removeLayer.call(this, t), this._popupContent && this.invoke("unbindPopup"), this.fire("layerremove", {
                    layer: t
                })) : this
            },
            bindPopup: function(t, e) {
                return this._popupContent = t, this._popupOptions = e, this.invoke("bindPopup", t, e)
            },
            openPopup: function(t) {
                for (var e in this._layers) {
                    this._layers[e].openPopup(t);
                    break
                }
                return this
            },
            setStyle: function(t) {
                return this.invoke("setStyle", t)
            },
            bringToFront: function() {
                return this.invoke("bringToFront")
            },
            bringToBack: function() {
                return this.invoke("bringToBack")
            },
            getBounds: function() {
                var t = new o.LatLngBounds;
                return this.eachLayer(function(e) {
                    t.extend(e instanceof o.Marker ? e.getLatLng() : e.getBounds())
                }), t
            },
            _propagateEvent: function(t) {
                t = o.extend({
                    layer: t.target,
                    target: this
                }, t), this.fire(t.type, t)
            }
        }), o.featureGroup = function(t) {
            return new o.FeatureGroup(t)
        }, o.Path = o.Class.extend({
            includes: [o.Mixin.Events],
            statics: {
                CLIP_PADDING: function() {
                    var e = o.Browser.mobile ? 1280 : 2e3,
                        i = (e / Math.max(t.outerWidth, t.outerHeight) - 1) / 2;
                    return Math.max(0, Math.min(.5, i))
                }()
            },
            options: {
                stroke: !0,
                color: "#0033ff",
                dashArray: null,
                lineCap: null,
                lineJoin: null,
                weight: 5,
                opacity: .5,
                fill: !1,
                fillColor: null,
                fillOpacity: .2,
                clickable: !0
            },
            initialize: function(t) {
                o.setOptions(this, t)
            },
            onAdd: function(t) {
                this._map = t, this._container || (this._initElements(), this._initEvents()), this.projectLatlngs(), this._updatePath(), this._container && this._map._pathRoot.appendChild(this._container), this.fire("add"), t.on({
                    viewreset: this.projectLatlngs,
                    moveend: this._updatePath
                }, this)
            },
            addTo: function(t) {
                return t.addLayer(this), this
            },
            onRemove: function(t) {
                t._pathRoot.removeChild(this._container), this.fire("remove"), this._map = null, o.Browser.vml && (this._container = null, this._stroke = null, this._fill = null), t.off({
                    viewreset: this.projectLatlngs,
                    moveend: this._updatePath
                }, this)
            },
            projectLatlngs: function() {},
            setStyle: function(t) {
                return o.setOptions(this, t), this._container && this._updateStyle(), this
            },
            redraw: function() {
                return this._map && (this.projectLatlngs(), this._updatePath()), this
            }
        }), o.Map.include({
            _updatePathViewport: function() {
                var t = o.Path.CLIP_PADDING,
                    e = this.getSize(),
                    i = o.DomUtil.getPosition(this._mapPane),
                    n = i.multiplyBy(-1)._subtract(e.multiplyBy(t)._round()),
                    s = n.add(e.multiplyBy(1 + 2 * t)._round());
                this._pathViewport = new o.Bounds(n, s)
            }
        }), o.Path.SVG_NS = "http://www.w3.org/2000/svg", o.Browser.svg = !(!e.createElementNS || !e.createElementNS(o.Path.SVG_NS, "svg").createSVGRect), o.Path = o.Path.extend({
            statics: {
                SVG: o.Browser.svg
            },
            bringToFront: function() {
                var t = this._map._pathRoot,
                    e = this._container;
                return e && t.lastChild !== e && t.appendChild(e), this
            },
            bringToBack: function() {
                var t = this._map._pathRoot,
                    e = this._container,
                    i = t.firstChild;
                return e && i !== e && t.insertBefore(e, i), this
            },
            getPathString: function() {},
            _createElement: function(t) {
                return e.createElementNS(o.Path.SVG_NS, t)
            },
            _initElements: function() {
                this._map._initPathRoot(), this._initPath(), this._initStyle()
            },
            _initPath: function() {
                this._container = this._createElement("g"), this._path = this._createElement("path"), this.options.className && o.DomUtil.addClass(this._path, this.options.className), this._container.appendChild(this._path)
            },
            _initStyle: function() {
                this.options.stroke && (this._path.setAttribute("stroke-linejoin", "round"), this._path.setAttribute("stroke-linecap", "round")), this.options.fill && this._path.setAttribute("fill-rule", "evenodd"), this.options.pointerEvents && this._path.setAttribute("pointer-events", this.options.pointerEvents), this.options.clickable || this.options.pointerEvents || this._path.setAttribute("pointer-events", "none"), this._updateStyle()
            },
            _updateStyle: function() {
                this.options.stroke ? (this._path.setAttribute("stroke", this.options.color), this._path.setAttribute("stroke-opacity", this.options.opacity), this._path.setAttribute("stroke-width", this.options.weight), this.options.dashArray ? this._path.setAttribute("stroke-dasharray", this.options.dashArray) : this._path.removeAttribute("stroke-dasharray"), this.options.lineCap && this._path.setAttribute("stroke-linecap", this.options.lineCap), this.options.lineJoin && this._path.setAttribute("stroke-linejoin", this.options.lineJoin)) : this._path.setAttribute("stroke", "none"), this.options.fill ? (this._path.setAttribute("fill", this.options.fillColor || this.options.color), this._path.setAttribute("fill-opacity", this.options.fillOpacity)) : this._path.setAttribute("fill", "none")
            },
            _updatePath: function() {
                var t = this.getPathString();
                t || (t = "M0 0"), this._path.setAttribute("d", t)
            },
            _initEvents: function() {
                if (this.options.clickable) {
                    (o.Browser.svg || !o.Browser.vml) && o.DomUtil.addClass(this._path, "leaflet-clickable"), o.DomEvent.on(this._container, "click", this._onMouseClick, this);
                    for (var t = ["dblclick", "mousedown", "mouseover", "mouseout", "mousemove", "contextmenu"], e = 0; e < t.length; e++) o.DomEvent.on(this._container, t[e], this._fireMouseEvent, this)
                }
            },
            _onMouseClick: function(t) {
                this._map.dragging && this._map.dragging.moved() || this._fireMouseEvent(t)
            },
            _fireMouseEvent: function(t) {
                if (this._map && this.hasEventListeners(t.type)) {
                    var e = this._map,
                        i = e.mouseEventToContainerPoint(t),
                        n = e.containerPointToLayerPoint(i),
                        s = e.layerPointToLatLng(n);
                    this.fire(t.type, {
                        latlng: s,
                        layerPoint: n,
                        containerPoint: i,
                        originalEvent: t
                    }), "contextmenu" === t.type && o.DomEvent.preventDefault(t), "mousemove" !== t.type && o.DomEvent.stopPropagation(t)
                }
            }
        }), o.Map.include({
            _initPathRoot: function() {
                this._pathRoot || (this._pathRoot = o.Path.prototype._createElement("svg"), this._panes.overlayPane.appendChild(this._pathRoot), this.options.zoomAnimation && o.Browser.any3d ? (o.DomUtil.addClass(this._pathRoot, "leaflet-zoom-animated"), this.on({
                    zoomanim: this._animatePathZoom,
                    zoomend: this._endPathZoom
                })) : o.DomUtil.addClass(this._pathRoot, "leaflet-zoom-hide"), this.on("moveend", this._updateSvgViewport), this._updateSvgViewport())
            },
            _animatePathZoom: function(t) {
                var e = this.getZoomScale(t.zoom),
                    i = this._getCenterOffset(t.center)._multiplyBy(-e)._add(this._pathViewport.min);
                this._pathRoot.style[o.DomUtil.TRANSFORM] = o.DomUtil.getTranslateString(i) + " scale(" + e + ") ", this._pathZooming = !0
            },
            _endPathZoom: function() {
                this._pathZooming = !1
            },
            _updateSvgViewport: function() {
                if (!this._pathZooming) {
                    this._updatePathViewport();
                    var t = this._pathViewport,
                        e = t.min,
                        i = t.max,
                        n = i.x - e.x,
                        s = i.y - e.y,
                        a = this._pathRoot,
                        r = this._panes.overlayPane;
                    o.Browser.mobileWebkit && r.removeChild(a), o.DomUtil.setPosition(a, e), a.setAttribute("width", n), a.setAttribute("height", s), a.setAttribute("viewBox", [e.x, e.y, n, s].join(" ")), o.Browser.mobileWebkit && r.appendChild(a)
                }
            }
        }), o.Path.include({
            bindPopup: function(t, e) {
                return t instanceof o.Popup ? this._popup = t : ((!this._popup || e) && (this._popup = new o.Popup(e, this)), this._popup.setContent(t)), this._popupHandlersAdded || (this.on("click", this._openPopup, this).on("remove", this.closePopup, this), this._popupHandlersAdded = !0), this
            },
            unbindPopup: function() {
                return this._popup && (this._popup = null, this.off("click", this._openPopup).off("remove", this.closePopup), this._popupHandlersAdded = !1), this
            },
            openPopup: function(t) {
                return this._popup && (t = t || this._latlng || this._latlngs[Math.floor(this._latlngs.length / 2)], this._openPopup({
                    latlng: t
                })), this
            },
            closePopup: function() {
                return this._popup && this._popup._close(), this
            },
            _openPopup: function(t) {
                this._popup.setLatLng(t.latlng), this._map.openPopup(this._popup)
            }
        }), o.Browser.vml = !o.Browser.svg && function() {
            try {
                var t = e.createElement("div");
                t.innerHTML = '<v:shape adj="1"/>';
                var i = t.firstChild;
                return i.style.behavior = "url(#default#VML)", i && "object" == typeof i.adj
            } catch (n) {
                return !1
            }
        }(), o.Path = o.Browser.svg || !o.Browser.vml ? o.Path : o.Path.extend({
            statics: {
                VML: !0,
                CLIP_PADDING: .02
            },
            _createElement: function() {
                try {
                    return e.namespaces.add("lvml", "urn:schemas-microsoft-com:vml"),
                        function(t) {
                            return e.createElement("<lvml:" + t + ' class="lvml">')
                        }
                } catch (t) {
                    return function(t) {
                        return e.createElement("<" + t + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">')
                    }
                }
            }(),
            _initPath: function() {
                var t = this._container = this._createElement("shape");
                o.DomUtil.addClass(t, "leaflet-vml-shape" + (this.options.className ? " " + this.options.className : "")), this.options.clickable && o.DomUtil.addClass(t, "leaflet-clickable"), t.coordsize = "1 1", this._path = this._createElement("path"), t.appendChild(this._path), this._map._pathRoot.appendChild(t)
            },
            _initStyle: function() {
                this._updateStyle()
            },
            _updateStyle: function() {
                var t = this._stroke,
                    e = this._fill,
                    i = this.options,
                    n = this._container;
                n.stroked = i.stroke, n.filled = i.fill, i.stroke ? (t || (t = this._stroke = this._createElement("stroke"), t.endcap = "round", n.appendChild(t)), t.weight = i.weight + "px", t.color = i.color, t.opacity = i.opacity, i.dashArray ? t.dashStyle = o.Util.isArray(i.dashArray) ? i.dashArray.join(" ") : i.dashArray.replace(/( *, *)/g, " ") : t.dashStyle = "", i.lineCap && (t.endcap = i.lineCap.replace("butt", "flat")), i.lineJoin && (t.joinstyle = i.lineJoin)) : t && (n.removeChild(t), this._stroke = null), i.fill ? (e || (e = this._fill = this._createElement("fill"), n.appendChild(e)), e.color = i.fillColor || i.color, e.opacity = i.fillOpacity) : e && (n.removeChild(e), this._fill = null)
            },
            _updatePath: function() {
                var t = this._container.style;
                t.display = "none", this._path.v = this.getPathString() + " ", t.display = ""
            }
        }), o.Map.include(o.Browser.svg || !o.Browser.vml ? {} : {
            _initPathRoot: function() {
                if (!this._pathRoot) {
                    var t = this._pathRoot = e.createElement("div");
                    t.className = "leaflet-vml-container", this._panes.overlayPane.appendChild(t), this.on("moveend", this._updatePathViewport), this._updatePathViewport()
                }
            }
        }), o.Browser.canvas = function() {
            return !!e.createElement("canvas").getContext
        }(), o.Path = o.Path.SVG && !t.L_PREFER_CANVAS || !o.Browser.canvas ? o.Path : o.Path.extend({
            statics: {
                CANVAS: !0,
                SVG: !1
            },
            redraw: function() {
                return this._map && (this.projectLatlngs(), this._requestUpdate()), this
            },
            setStyle: function(t) {
                return o.setOptions(this, t), this._map && (this._updateStyle(), this._requestUpdate()), this
            },
            onRemove: function(t) {
                t.off("viewreset", this.projectLatlngs, this).off("moveend", this._updatePath, this), this.options.clickable && (this._map.off("click", this._onClick, this), this._map.off("mousemove", this._onMouseMove, this)), this._requestUpdate(), this.fire("remove"), this._map = null
            },
            _requestUpdate: function() {
                this._map && !o.Path._updateRequest && (o.Path._updateRequest = o.Util.requestAnimFrame(this._fireMapMoveEnd, this._map))
            },
            _fireMapMoveEnd: function() {
                o.Path._updateRequest = null, this.fire("moveend")
            },
            _initElements: function() {
                this._map._initPathRoot(), this._ctx = this._map._canvasCtx
            },
            _updateStyle: function() {
                var t = this.options;
                t.stroke && (this._ctx.lineWidth = t.weight, this._ctx.strokeStyle = t.color), t.fill && (this._ctx.fillStyle = t.fillColor || t.color), t.lineCap && (this._ctx.lineCap = t.lineCap), t.lineJoin && (this._ctx.lineJoin = t.lineJoin)
            },
            _drawPath: function() {
                var t, e, i, n, s, a;
                for (this._ctx.beginPath(), t = 0, i = this._parts.length; i > t; t++) {
                    for (e = 0, n = this._parts[t].length; n > e; e++) s = this._parts[t][e], a = (0 === e ? "move" : "line") + "To", this._ctx[a](s.x, s.y);
                    this instanceof o.Polygon && this._ctx.closePath()
                }
            },
            _checkIfEmpty: function() {
                return !this._parts.length
            },
            _updatePath: function() {
                if (!this._checkIfEmpty()) {
                    var t = this._ctx,
                        e = this.options;
                    this._drawPath(), t.save(), this._updateStyle(), e.fill && (t.globalAlpha = e.fillOpacity, t.fill(e.fillRule || "evenodd")), e.stroke && (t.globalAlpha = e.opacity, t.stroke()), t.restore()
                }
            },
            _initEvents: function() {
                this.options.clickable && (this._map.on("mousemove", this._onMouseMove, this), this._map.on("click dblclick contextmenu", this._fireMouseEvent, this))
            },
            _fireMouseEvent: function(t) {
                this._containsPoint(t.layerPoint) && this.fire(t.type, t)
            },
            _onMouseMove: function(t) {
                this._map && !this._map._animatingZoom && (this._containsPoint(t.layerPoint) ? (this._ctx.canvas.style.cursor = "pointer", this._mouseInside = !0, this.fire("mouseover", t)) : this._mouseInside && (this._ctx.canvas.style.cursor = "", this._mouseInside = !1, this.fire("mouseout", t)))
            }
        }), o.Map.include(o.Path.SVG && !t.L_PREFER_CANVAS || !o.Browser.canvas ? {} : {
            _initPathRoot: function() {
                var t, i = this._pathRoot;
                i || (i = this._pathRoot = e.createElement("canvas"), i.style.position = "absolute", t = this._canvasCtx = i.getContext("2d"), t.lineCap = "round", t.lineJoin = "round", this._panes.overlayPane.appendChild(i), this.options.zoomAnimation && (this._pathRoot.className = "leaflet-zoom-animated", this.on("zoomanim", this._animatePathZoom), this.on("zoomend", this._endPathZoom)), this.on("moveend", this._updateCanvasViewport), this._updateCanvasViewport())
            },
            _updateCanvasViewport: function() {
                if (!this._pathZooming) {
                    this._updatePathViewport();
                    var t = this._pathViewport,
                        e = t.min,
                        i = t.max.subtract(e),
                        n = this._pathRoot;
                    o.DomUtil.setPosition(n, e), n.width = i.x, n.height = i.y, n.getContext("2d").translate(-e.x, -e.y)
                }
            }
        }), o.LineUtil = {
            simplify: function(t, e) {
                if (!e || !t.length) return t.slice();
                var i = e * e;
                return t = this._reducePoints(t, i), t = this._simplifyDP(t, i)
            },
            pointToSegmentDistance: function(t, e, i) {
                return Math.sqrt(this._sqClosestPointOnSegment(t, e, i, !0))
            },
            closestPointOnSegment: function(t, e, i) {
                return this._sqClosestPointOnSegment(t, e, i)
            },
            _simplifyDP: function(t, e) {
                var n = t.length,
                    o = typeof Uint8Array != i + "" ? Uint8Array : Array,
                    s = new o(n);
                s[0] = s[n - 1] = 1, this._simplifyDPStep(t, s, e, 0, n - 1);
                var a, r = [];
                for (a = 0; n > a; a++) s[a] && r.push(t[a]);
                return r
            },
            _simplifyDPStep: function(t, e, i, n, o) {
                var s, a, r, h = 0;
                for (a = n + 1; o - 1 >= a; a++) r = this._sqClosestPointOnSegment(t[a], t[n], t[o], !0), r > h && (s = a, h = r);
                h > i && (e[s] = 1, this._simplifyDPStep(t, e, i, n, s), this._simplifyDPStep(t, e, i, s, o))
            },
            _reducePoints: function(t, e) {
                for (var i = [t[0]], n = 1, o = 0, s = t.length; s > n; n++) this._sqDist(t[n], t[o]) > e && (i.push(t[n]), o = n);
                return s - 1 > o && i.push(t[s - 1]), i
            },
            clipSegment: function(t, e, i, n) {
                var o, s, a, r = n ? this._lastCode : this._getBitCode(t, i),
                    h = this._getBitCode(e, i);
                for (this._lastCode = h;;) {
                    if (!(r | h)) return [t, e];
                    if (r & h) return !1;
                    o = r || h, s = this._getEdgeIntersection(t, e, o, i), a = this._getBitCode(s, i), o === r ? (t = s, r = a) : (e = s, h = a)
                }
            },
            _getEdgeIntersection: function(t, e, i, n) {
                var s = e.x - t.x,
                    a = e.y - t.y,
                    r = n.min,
                    h = n.max;
                return 8 & i ? new o.Point(t.x + s * (h.y - t.y) / a, h.y) : 4 & i ? new o.Point(t.x + s * (r.y - t.y) / a, r.y) : 2 & i ? new o.Point(h.x, t.y + a * (h.x - t.x) / s) : 1 & i ? new o.Point(r.x, t.y + a * (r.x - t.x) / s) : void 0
            },
            _getBitCode: function(t, e) {
                var i = 0;
                return t.x < e.min.x ? i |= 1 : t.x > e.max.x && (i |= 2), t.y < e.min.y ? i |= 4 : t.y > e.max.y && (i |= 8), i
            },
            _sqDist: function(t, e) {
                var i = e.x - t.x,
                    n = e.y - t.y;
                return i * i + n * n
            },
            _sqClosestPointOnSegment: function(t, e, i, n) {
                var s, a = e.x,
                    r = e.y,
                    h = i.x - a,
                    l = i.y - r,
                    u = h * h + l * l;
                return u > 0 && (s = ((t.x - a) * h + (t.y - r) * l) / u, s > 1 ? (a = i.x, r = i.y) : s > 0 && (a += h * s, r += l * s)), h = t.x - a, l = t.y - r, n ? h * h + l * l : new o.Point(a, r)
            }
        }, o.Polyline = o.Path.extend({
            initialize: function(t, e) {
                o.Path.prototype.initialize.call(this, e), this._latlngs = this._convertLatLngs(t)
            },
            options: {
                smoothFactor: 1,
                noClip: !1
            },
            projectLatlngs: function() {
                this._originalPoints = [];
                for (var t = 0, e = this._latlngs.length; e > t; t++) this._originalPoints[t] = this._map.latLngToLayerPoint(this._latlngs[t])
            },
            getPathString: function() {
                for (var t = 0, e = this._parts.length, i = ""; e > t; t++) i += this._getPathPartStr(this._parts[t]);
                return i
            },
            getLatLngs: function() {
                return this._latlngs
            },
            setLatLngs: function(t) {
                return this._latlngs = this._convertLatLngs(t), this.redraw()
            },
            addLatLng: function(t) {
                return this._latlngs.push(o.latLng(t)), this.redraw()
            },
            spliceLatLngs: function() {
                var t = [].splice.apply(this._latlngs, arguments);
                return this._convertLatLngs(this._latlngs, !0), this.redraw(), t
            },
            closestLayerPoint: function(t) {
                for (var e, i, n = 1 / 0, s = this._parts, a = null, r = 0, h = s.length; h > r; r++)
                    for (var l = s[r], u = 1, c = l.length; c > u; u++) {
                        e = l[u - 1], i = l[u];
                        var d = o.LineUtil._sqClosestPointOnSegment(t, e, i, !0);
                        n > d && (n = d, a = o.LineUtil._sqClosestPointOnSegment(t, e, i))
                    }
                return a && (a.distance = Math.sqrt(n)), a
            },
            getBounds: function() {
                return new o.LatLngBounds(this.getLatLngs())
            },
            _convertLatLngs: function(t, e) {
                var i, n, s = e ? t : [];
                for (i = 0, n = t.length; n > i; i++) {
                    if (o.Util.isArray(t[i]) && "number" != typeof t[i][0]) return;
                    s[i] = o.latLng(t[i])
                }
                return s
            },
            _initEvents: function() {
                o.Path.prototype._initEvents.call(this)
            },
            _getPathPartStr: function(t) {
                for (var e, i = o.Path.VML, n = 0, s = t.length, a = ""; s > n; n++) e = t[n], i && e._round(), a += (n ? "L" : "M") + e.x + " " + e.y;
                return a
            },
            _clipPoints: function() {
                var t, e, i, n = this._originalPoints,
                    s = n.length;
                if (this.options.noClip) return void(this._parts = [n]);
                this._parts = [];
                var a = this._parts,
                    r = this._map._pathViewport,
                    h = o.LineUtil;
                for (t = 0, e = 0; s - 1 > t; t++) i = h.clipSegment(n[t], n[t + 1], r, t), i && (a[e] = a[e] || [], a[e].push(i[0]), (i[1] !== n[t + 1] || t === s - 2) && (a[e].push(i[1]), e++))
            },
            _simplifyPoints: function() {
                for (var t = this._parts, e = o.LineUtil, i = 0, n = t.length; n > i; i++) t[i] = e.simplify(t[i], this.options.smoothFactor)
            },
            _updatePath: function() {
                this._map && (this._clipPoints(), this._simplifyPoints(), o.Path.prototype._updatePath.call(this))
            }
        }), o.polyline = function(t, e) {
            return new o.Polyline(t, e)
        }, o.PolyUtil = {}, o.PolyUtil.clipPolygon = function(t, e) {
            var i, n, s, a, r, h, l, u, c, d = [1, 4, 2, 8],
                p = o.LineUtil;
            for (n = 0, l = t.length; l > n; n++) t[n]._code = p._getBitCode(t[n], e);
            for (a = 0; 4 > a; a++) {
                for (u = d[a], i = [], n = 0, l = t.length, s = l - 1; l > n; s = n++) r = t[n], h = t[s], r._code & u ? h._code & u || (c = p._getEdgeIntersection(h, r, u, e), c._code = p._getBitCode(c, e), i.push(c)) : (h._code & u && (c = p._getEdgeIntersection(h, r, u, e), c._code = p._getBitCode(c, e), i.push(c)), i.push(r));
                t = i
            }
            return t
        }, o.Polygon = o.Polyline.extend({
            options: {
                fill: !0
            },
            initialize: function(t, e) {
                o.Polyline.prototype.initialize.call(this, t, e), this._initWithHoles(t)
            },
            _initWithHoles: function(t) {
                var e, i, n;
                if (t && o.Util.isArray(t[0]) && "number" != typeof t[0][0])
                    for (this._latlngs = this._convertLatLngs(t[0]), this._holes = t.slice(1), e = 0, i = this._holes.length; i > e; e++) n = this._holes[e] = this._convertLatLngs(this._holes[e]), n[0].equals(n[n.length - 1]) && n.pop();
                t = this._latlngs, t.length >= 2 && t[0].equals(t[t.length - 1]) && t.pop()
            },
            projectLatlngs: function() {
                if (o.Polyline.prototype.projectLatlngs.call(this), this._holePoints = [], this._holes) {
                    var t, e, i, n;
                    for (t = 0, i = this._holes.length; i > t; t++)
                        for (this._holePoints[t] = [], e = 0, n = this._holes[t].length; n > e; e++) this._holePoints[t][e] = this._map.latLngToLayerPoint(this._holes[t][e])
                }
            },
            setLatLngs: function(t) {
                return t && o.Util.isArray(t[0]) && "number" != typeof t[0][0] ? (this._initWithHoles(t), this.redraw()) : o.Polyline.prototype.setLatLngs.call(this, t)
            },
            _clipPoints: function() {
                var t = this._originalPoints,
                    e = [];
                if (this._parts = [t].concat(this._holePoints), !this.options.noClip) {
                    for (var i = 0, n = this._parts.length; n > i; i++) {
                        var s = o.PolyUtil.clipPolygon(this._parts[i], this._map._pathViewport);
                        s.length && e.push(s)
                    }
                    this._parts = e
                }
            },
            _getPathPartStr: function(t) {
                var e = o.Polyline.prototype._getPathPartStr.call(this, t);
                return e + (o.Browser.svg ? "z" : "x")
            }
        }), o.polygon = function(t, e) {
            return new o.Polygon(t, e)
        },
        function() {
            function t(t) {
                return o.FeatureGroup.extend({
                    initialize: function(t, e) {
                        this._layers = {}, this._options = e, this.setLatLngs(t)
                    },
                    setLatLngs: function(e) {
                        var i = 0,
                            n = e.length;
                        for (this.eachLayer(function(t) {
                                n > i ? t.setLatLngs(e[i++]) : this.removeLayer(t)
                            }, this); n > i;) this.addLayer(new t(e[i++], this._options));
                        return this
                    },
                    getLatLngs: function() {
                        var t = [];
                        return this.eachLayer(function(e) {
                            t.push(e.getLatLngs())
                        }), t
                    }
                })
            }
            o.MultiPolyline = t(o.Polyline), o.MultiPolygon = t(o.Polygon), o.multiPolyline = function(t, e) {
                return new o.MultiPolyline(t, e)
            }, o.multiPolygon = function(t, e) {
                return new o.MultiPolygon(t, e)
            }
        }(), o.Rectangle = o.Polygon.extend({
            initialize: function(t, e) {
                o.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(t), e)
            },
            setBounds: function(t) {
                this.setLatLngs(this._boundsToLatLngs(t))
            },
            _boundsToLatLngs: function(t) {
                return t = o.latLngBounds(t), [t.getSouthWest(), t.getNorthWest(), t.getNorthEast(), t.getSouthEast()]
            }
        }), o.rectangle = function(t, e) {
            return new o.Rectangle(t, e)
        }, o.Circle = o.Path.extend({
            initialize: function(t, e, i) {
                o.Path.prototype.initialize.call(this, i), this._latlng = o.latLng(t), this._mRadius = e
            },
            options: {
                fill: !0
            },
            setLatLng: function(t) {
                return this._latlng = o.latLng(t), this.redraw()
            },
            setRadius: function(t) {
                return this._mRadius = t, this.redraw()
            },
            projectLatlngs: function() {
                var t = this._getLngRadius(),
                    e = this._latlng,
                    i = this._map.latLngToLayerPoint([e.lat, e.lng - t]);
                this._point = this._map.latLngToLayerPoint(e), this._radius = Math.max(this._point.x - i.x, 1)
            },
            getBounds: function() {
                var t = this._getLngRadius(),
                    e = this._mRadius / 40075017 * 360,
                    i = this._latlng;
                return new o.LatLngBounds([i.lat - e, i.lng - t], [i.lat + e, i.lng + t])
            },
            getLatLng: function() {
                return this._latlng
            },
            getPathString: function() {
                var t = this._point,
                    e = this._radius;
                return this._checkIfEmpty() ? "" : o.Browser.svg ? "M" + t.x + "," + (t.y - e) + "A" + e + "," + e + ",0,1,1," + (t.x - .1) + "," + (t.y - e) + " z" : (t._round(), e = Math.round(e), "AL " + t.x + "," + t.y + " " + e + "," + e + " 0,23592600")
            },
            getRadius: function() {
                return this._mRadius
            },
            _getLatRadius: function() {
                return this._mRadius / 40075017 * 360
            },
            _getLngRadius: function() {
                return this._getLatRadius() / Math.cos(o.LatLng.DEG_TO_RAD * this._latlng.lat)
            },
            _checkIfEmpty: function() {
                if (!this._map) return !1;
                var t = this._map._pathViewport,
                    e = this._radius,
                    i = this._point;
                return i.x - e > t.max.x || i.y - e > t.max.y || i.x + e < t.min.x || i.y + e < t.min.y
            }
        }), o.circle = function(t, e, i) {
            return new o.Circle(t, e, i)
        }, o.CircleMarker = o.Circle.extend({
            options: {
                radius: 10,
                weight: 2
            },
            initialize: function(t, e) {
                o.Circle.prototype.initialize.call(this, t, null, e), this._radius = this.options.radius
            },
            projectLatlngs: function() {
                this._point = this._map.latLngToLayerPoint(this._latlng)
            },
            _updateStyle: function() {
                o.Circle.prototype._updateStyle.call(this), this.setRadius(this.options.radius)
            },
            setLatLng: function(t) {
                return o.Circle.prototype.setLatLng.call(this, t), this._popup && this._popup._isOpen && this._popup.setLatLng(t), this
            },
            setRadius: function(t) {
                return this.options.radius = this._radius = t, this.redraw()
            },
            getRadius: function() {
                return this._radius
            }
        }), o.circleMarker = function(t, e) {
            return new o.CircleMarker(t, e)
        }, o.Polyline.include(o.Path.CANVAS ? {
            _containsPoint: function(t, e) {
                var i, n, s, a, r, h, l, u = this.options.weight / 2;
                for (o.Browser.touch && (u += 10), i = 0, a = this._parts.length; a > i; i++)
                    for (l = this._parts[i], n = 0, r = l.length, s = r - 1; r > n; s = n++)
                        if ((e || 0 !== n) && (h = o.LineUtil.pointToSegmentDistance(t, l[s], l[n]), u >= h)) return !0;
                return !1
            }
        } : {}), o.Polygon.include(o.Path.CANVAS ? {
            _containsPoint: function(t) {
                var e, i, n, s, a, r, h, l, u = !1;
                if (o.Polyline.prototype._containsPoint.call(this, t, !0)) return !0;
                for (s = 0, h = this._parts.length; h > s; s++)
                    for (e = this._parts[s], a = 0, l = e.length, r = l - 1; l > a; r = a++) i = e[a], n = e[r], i.y > t.y != n.y > t.y && t.x < (n.x - i.x) * (t.y - i.y) / (n.y - i.y) + i.x && (u = !u);
                return u
            }
        } : {}), o.Circle.include(o.Path.CANVAS ? {
            _drawPath: function() {
                var t = this._point;
                this._ctx.beginPath(), this._ctx.arc(t.x, t.y, this._radius, 0, 2 * Math.PI, !1)
            },
            _containsPoint: function(t) {
                var e = this._point,
                    i = this.options.stroke ? this.options.weight / 2 : 0;
                return t.distanceTo(e) <= this._radius + i
            }
        } : {}), o.CircleMarker.include(o.Path.CANVAS ? {
            _updateStyle: function() {
                o.Path.prototype._updateStyle.call(this)
            }
        } : {}), o.GeoJSON = o.FeatureGroup.extend({
            initialize: function(t, e) {
                o.setOptions(this, e), this._layers = {}, t && this.addData(t)
            },
            addData: function(t) {
                var e, i, n, s = o.Util.isArray(t) ? t : t.features;
                if (s) {
                    for (e = 0, i = s.length; i > e; e++) n = s[e], (n.geometries || n.geometry || n.features || n.coordinates) && this.addData(s[e]);
                    return this
                }
                var a = this.options;
                if (!a.filter || a.filter(t)) {
                    var r = o.GeoJSON.geometryToLayer(t, a.pointToLayer, a.coordsToLatLng, a);
                    return r.feature = o.GeoJSON.asFeature(t), r.defaultOptions = r.options, this.resetStyle(r), a.onEachFeature && a.onEachFeature(t, r), this.addLayer(r)
                }
            },
            resetStyle: function(t) {
                var e = this.options.style;
                e && (o.Util.extend(t.options, t.defaultOptions), this._setLayerStyle(t, e))
            },
            setStyle: function(t) {
                this.eachLayer(function(e) {
                    this._setLayerStyle(e, t)
                }, this)
            },
            _setLayerStyle: function(t, e) {
                "function" == typeof e && (e = e(t.feature)), t.setStyle && t.setStyle(e)
            }
        }), o.extend(o.GeoJSON, {
            geometryToLayer: function(t, e, i, n) {
                var s, a, r, h, l = "Feature" === t.type ? t.geometry : t,
                    u = l.coordinates,
                    c = [];
                switch (i = i || this.coordsToLatLng, l.type) {
                    case "Point":
                        return s = i(u), e ? e(t, s) : new o.Marker(s);
                    case "MultiPoint":
                        for (r = 0, h = u.length; h > r; r++) s = i(u[r]), c.push(e ? e(t, s) : new o.Marker(s));
                        return new o.FeatureGroup(c);
                    case "LineString":
                        return a = this.coordsToLatLngs(u, 0, i), new o.Polyline(a, n);
                    case "Polygon":
                        if (2 === u.length && !u[1].length) throw new Error("Invalid GeoJSON object.");
                        return a = this.coordsToLatLngs(u, 1, i), new o.Polygon(a, n);
                    case "MultiLineString":
                        return a = this.coordsToLatLngs(u, 1, i), new o.MultiPolyline(a, n);
                    case "MultiPolygon":
                        return a = this.coordsToLatLngs(u, 2, i), new o.MultiPolygon(a, n);
                    case "GeometryCollection":
                        for (r = 0, h = l.geometries.length; h > r; r++) c.push(this.geometryToLayer({
                            geometry: l.geometries[r],
                            type: "Feature",
                            properties: t.properties
                        }, e, i, n));
                        return new o.FeatureGroup(c);
                    default:
                        throw new Error("Invalid GeoJSON object.")
                }
            },
            coordsToLatLng: function(t) {
                return new o.LatLng(t[1], t[0], t[2])
            },
            coordsToLatLngs: function(t, e, i) {
                var n, o, s, a = [];
                for (o = 0, s = t.length; s > o; o++) n = e ? this.coordsToLatLngs(t[o], e - 1, i) : (i || this.coordsToLatLng)(t[o]), a.push(n);
                return a
            },
            latLngToCoords: function(t) {
                var e = [t.lng, t.lat];
                return t.alt !== i && e.push(t.alt), e
            },
            latLngsToCoords: function(t) {
                for (var e = [], i = 0, n = t.length; n > i; i++) e.push(o.GeoJSON.latLngToCoords(t[i]));
                return e
            },
            getFeature: function(t, e) {
                return t.feature ? o.extend({}, t.feature, {
                    geometry: e
                }) : o.GeoJSON.asFeature(e)
            },
            asFeature: function(t) {
                return "Feature" === t.type ? t : {
                    type: "Feature",
                    properties: {},
                    geometry: t
                }
            }
        });
    var a = {
        toGeoJSON: function() {
            return o.GeoJSON.getFeature(this, {
                type: "Point",
                coordinates: o.GeoJSON.latLngToCoords(this.getLatLng())
            })
        }
    };
    o.Marker.include(a), o.Circle.include(a), o.CircleMarker.include(a), o.Polyline.include({
            toGeoJSON: function() {
                return o.GeoJSON.getFeature(this, {
                    type: "LineString",
                    coordinates: o.GeoJSON.latLngsToCoords(this.getLatLngs())
                })
            }
        }), o.Polygon.include({
            toGeoJSON: function() {
                var t, e, i, n = [o.GeoJSON.latLngsToCoords(this.getLatLngs())];
                if (n[0].push(n[0][0]), this._holes)
                    for (t = 0, e = this._holes.length; e > t; t++) i = o.GeoJSON.latLngsToCoords(this._holes[t]), i.push(i[0]), n.push(i);
                return o.GeoJSON.getFeature(this, {
                    type: "Polygon",
                    coordinates: n
                })
            }
        }),
        function() {
            function t(t) {
                return function() {
                    var e = [];
                    return this.eachLayer(function(t) {
                        e.push(t.toGeoJSON().geometry.coordinates)
                    }), o.GeoJSON.getFeature(this, {
                        type: t,
                        coordinates: e
                    })
                }
            }
            o.MultiPolyline.include({
                toGeoJSON: t("MultiLineString")
            }), o.MultiPolygon.include({
                toGeoJSON: t("MultiPolygon")
            }), o.LayerGroup.include({
                toGeoJSON: function() {
                    var e, i = this.feature && this.feature.geometry,
                        n = [];
                    if (i && "MultiPoint" === i.type) return t("MultiPoint").call(this);
                    var s = i && "GeometryCollection" === i.type;
                    return this.eachLayer(function(t) {
                        t.toGeoJSON && (e = t.toGeoJSON(), n.push(s ? e.geometry : o.GeoJSON.asFeature(e)))
                    }), s ? o.GeoJSON.getFeature(this, {
                        geometries: n,
                        type: "GeometryCollection"
                    }) : {
                        type: "FeatureCollection",
                        features: n
                    }
                }
            })
        }(), o.geoJson = function(t, e) {
            return new o.GeoJSON(t, e)
        }, o.DomEvent = {
            addListener: function(t, e, i, n) {
                var s, a, r, h = o.stamp(i),
                    l = "_leaflet_" + e + h;
                return t[l] ? this : (s = function(e) {
                    return i.call(n || t, e || o.DomEvent._getEvent())
                }, o.Browser.pointer && 0 === e.indexOf("touch") ? this.addPointerListener(t, e, s, h) : (o.Browser.touch && "dblclick" === e && this.addDoubleTapListener && this.addDoubleTapListener(t, s, h), "addEventListener" in t ? "mousewheel" === e ? (t.addEventListener("DOMMouseScroll", s, !1), t.addEventListener(e, s, !1)) : "mouseenter" === e || "mouseleave" === e ? (a = s, r = "mouseenter" === e ? "mouseover" : "mouseout", s = function(e) {
                    return o.DomEvent._checkMouse(t, e) ? a(e) : void 0
                }, t.addEventListener(r, s, !1)) : "click" === e && o.Browser.android ? (a = s, s = function(t) {
                    return o.DomEvent._filterClick(t, a)
                }, t.addEventListener(e, s, !1)) : t.addEventListener(e, s, !1) : "attachEvent" in t && t.attachEvent("on" + e, s), t[l] = s, this))
            },
            removeListener: function(t, e, i) {
                var n = o.stamp(i),
                    s = "_leaflet_" + e + n,
                    a = t[s];
                return a ? (o.Browser.pointer && 0 === e.indexOf("touch") ? this.removePointerListener(t, e, n) : o.Browser.touch && "dblclick" === e && this.removeDoubleTapListener ? this.removeDoubleTapListener(t, n) : "removeEventListener" in t ? "mousewheel" === e ? (t.removeEventListener("DOMMouseScroll", a, !1), t.removeEventListener(e, a, !1)) : "mouseenter" === e || "mouseleave" === e ? t.removeEventListener("mouseenter" === e ? "mouseover" : "mouseout", a, !1) : t.removeEventListener(e, a, !1) : "detachEvent" in t && t.detachEvent("on" + e, a), t[s] = null, this) : this
            },
            stopPropagation: function(t) {
                return t.stopPropagation ? t.stopPropagation() : t.cancelBubble = !0, o.DomEvent._skipped(t), this
            },
            disableScrollPropagation: function(t) {
                var e = o.DomEvent.stopPropagation;
                return o.DomEvent.on(t, "mousewheel", e).on(t, "MozMousePixelScroll", e)
            },
            disableClickPropagation: function(t) {
                for (var e = o.DomEvent.stopPropagation, i = o.Draggable.START.length - 1; i >= 0; i--) o.DomEvent.on(t, o.Draggable.START[i], e);
                return o.DomEvent.on(t, "click", o.DomEvent._fakeStop).on(t, "dblclick", e)
            },
            preventDefault: function(t) {
                return t.preventDefault ? t.preventDefault() : t.returnValue = !1, this
            },
            stop: function(t) {
                return o.DomEvent.preventDefault(t).stopPropagation(t)
            },
            getMousePosition: function(t, e) {
                if (!e) return new o.Point(t.clientX, t.clientY);
                var i = e.getBoundingClientRect();
                return new o.Point(t.clientX - i.left - e.clientLeft, t.clientY - i.top - e.clientTop)
            },
            getWheelDelta: function(t) {
                var e = 0;
                return t.wheelDelta && (e = t.wheelDelta / 120), t.detail && (e = -t.detail / 3), e
            },
            _skipEvents: {},
            _fakeStop: function(t) {
                o.DomEvent._skipEvents[t.type] = !0
            },
            _skipped: function(t) {
                var e = this._skipEvents[t.type];
                return this._skipEvents[t.type] = !1, e
            },
            _checkMouse: function(t, e) {
                var i = e.relatedTarget;
                if (!i) return !0;
                try {
                    for (; i && i !== t;) i = i.parentNode
                } catch (n) {
                    return !1
                }
                return i !== t
            },
            _getEvent: function() {
                var e = t.event;
                if (!e)
                    for (var i = arguments.callee.caller; i && (e = i.arguments[0], !e || t.Event !== e.constructor);) i = i.caller;
                return e
            },
            _filterClick: function(t, e) {
                var i = t.timeStamp || t.originalEvent.timeStamp,
                    n = o.DomEvent._lastClick && i - o.DomEvent._lastClick;
                return n && n > 100 && 500 > n || t.target._simulatedClick && !t._simulated ? void o.DomEvent.stop(t) : (o.DomEvent._lastClick = i, e(t))
            }
        }, o.DomEvent.on = o.DomEvent.addListener, o.DomEvent.off = o.DomEvent.removeListener, o.Draggable = o.Class.extend({
            includes: o.Mixin.Events,
            statics: {
                START: o.Browser.touch ? ["touchstart", "mousedown"] : ["mousedown"],
                END: {
                    mousedown: "mouseup",
                    touchstart: "touchend",
                    pointerdown: "touchend",
                    MSPointerDown: "touchend"
                },
                MOVE: {
                    mousedown: "mousemove",
                    touchstart: "touchmove",
                    pointerdown: "touchmove",
                    MSPointerDown: "touchmove"
                }
            },
            initialize: function(t, e) {
                this._element = t, this._dragStartTarget = e || t
            },
            enable: function() {
                if (!this._enabled) {
                    for (var t = o.Draggable.START.length - 1; t >= 0; t--) o.DomEvent.on(this._dragStartTarget, o.Draggable.START[t], this._onDown, this);
                    this._enabled = !0
                }
            },
            disable: function() {
                if (this._enabled) {
                    for (var t = o.Draggable.START.length - 1; t >= 0; t--) o.DomEvent.off(this._dragStartTarget, o.Draggable.START[t], this._onDown, this);
                    this._enabled = !1, this._moved = !1
                }
            },
            _onDown: function(t) {
                if (this._moved = !1, !t.shiftKey && (1 === t.which || 1 === t.button || t.touches) && (o.DomEvent.stopPropagation(t), !o.Draggable._disabled && (o.DomUtil.disableImageDrag(), o.DomUtil.disableTextSelection(), !this._moving))) {
                    var i = t.touches ? t.touches[0] : t;
                    this._startPoint = new o.Point(i.clientX, i.clientY), this._startPos = this._newPos = o.DomUtil.getPosition(this._element), o.DomEvent.on(e, o.Draggable.MOVE[t.type], this._onMove, this).on(e, o.Draggable.END[t.type], this._onUp, this)
                }
            },
            _onMove: function(t) {
                if (t.touches && t.touches.length > 1) return void(this._moved = !0);
                var i = t.touches && 1 === t.touches.length ? t.touches[0] : t,
                    n = new o.Point(i.clientX, i.clientY),
                    s = n.subtract(this._startPoint);
                (s.x || s.y) && (o.Browser.touch && Math.abs(s.x) + Math.abs(s.y) < 3 || (o.DomEvent.preventDefault(t), this._moved || (this.fire("dragstart"), this._moved = !0, this._startPos = o.DomUtil.getPosition(this._element).subtract(s), o.DomUtil.addClass(e.body, "leaflet-dragging"), this._lastTarget = t.target || t.srcElement, o.DomUtil.addClass(this._lastTarget, "leaflet-drag-target")), this._newPos = this._startPos.add(s), this._moving = !0, o.Util.cancelAnimFrame(this._animRequest), this._animRequest = o.Util.requestAnimFrame(this._updatePosition, this, !0, this._dragStartTarget)))
            },
            _updatePosition: function() {
                this.fire("predrag"), o.DomUtil.setPosition(this._element, this._newPos), this.fire("drag")
            },
            _onUp: function() {
                o.DomUtil.removeClass(e.body, "leaflet-dragging"), this._lastTarget && (o.DomUtil.removeClass(this._lastTarget, "leaflet-drag-target"), this._lastTarget = null);
                for (var t in o.Draggable.MOVE) o.DomEvent.off(e, o.Draggable.MOVE[t], this._onMove).off(e, o.Draggable.END[t], this._onUp);
                o.DomUtil.enableImageDrag(), o.DomUtil.enableTextSelection(), this._moved && this._moving && (o.Util.cancelAnimFrame(this._animRequest), this.fire("dragend", {
                    distance: this._newPos.distanceTo(this._startPos)
                })), this._moving = !1
            }
        }), o.Handler = o.Class.extend({
            initialize: function(t) {
                this._map = t
            },
            enable: function() {
                this._enabled || (this._enabled = !0, this.addHooks())
            },
            disable: function() {
                this._enabled && (this._enabled = !1, this.removeHooks())
            },
            enabled: function() {
                return !!this._enabled
            }
        }), o.Map.mergeOptions({
            dragging: !0,
            inertia: !o.Browser.android23,
            inertiaDeceleration: 3400,
            inertiaMaxSpeed: 1 / 0,
            inertiaThreshold: o.Browser.touch ? 32 : 18,
            easeLinearity: .25,
            worldCopyJump: !1
        }), o.Map.Drag = o.Handler.extend({
            addHooks: function() {
                if (!this._draggable) {
                    var t = this._map;
                    this._draggable = new o.Draggable(t._mapPane, t._container), this._draggable.on({
                        dragstart: this._onDragStart,
                        drag: this._onDrag,
                        dragend: this._onDragEnd
                    }, this), t.options.worldCopyJump && (this._draggable.on("predrag", this._onPreDrag, this), t.on("viewreset", this._onViewReset, this), t.whenReady(this._onViewReset, this))
                }
                this._draggable.enable()
            },
            removeHooks: function() {
                this._draggable.disable()
            },
            moved: function() {
                return this._draggable && this._draggable._moved
            },
            _onDragStart: function() {
                var t = this._map;
                t._panAnim && t._panAnim.stop(), t.fire("movestart").fire("dragstart"), t.options.inertia && (this._positions = [], this._times = [])
            },
            _onDrag: function() {
                if (this._map.options.inertia) {
                    var t = this._lastTime = +new Date,
                        e = this._lastPos = this._draggable._newPos;
                    this._positions.push(e), this._times.push(t), t - this._times[0] > 200 && (this._positions.shift(), this._times.shift())
                }
                this._map.fire("move").fire("drag")
            },
            _onViewReset: function() {
                var t = this._map.getSize()._divideBy(2),
                    e = this._map.latLngToLayerPoint([0, 0]);
                this._initialWorldOffset = e.subtract(t).x, this._worldWidth = this._map.project([0, 180]).x
            },
            _onPreDrag: function() {
                var t = this._worldWidth,
                    e = Math.round(t / 2),
                    i = this._initialWorldOffset,
                    n = this._draggable._newPos.x,
                    o = (n - e + i) % t + e - i,
                    s = (n + e + i) % t - e - i,
                    a = Math.abs(o + i) < Math.abs(s + i) ? o : s;
                this._draggable._newPos.x = a
            },
            _onDragEnd: function(t) {
                var e = this._map,
                    i = e.options,
                    n = +new Date - this._lastTime,
                    s = !i.inertia || n > i.inertiaThreshold || !this._positions[0];
                if (e.fire("dragend", t), s) e.fire("moveend");
                else {
                    var a = this._lastPos.subtract(this._positions[0]),
                        r = (this._lastTime + n - this._times[0]) / 1e3,
                        h = i.easeLinearity,
                        l = a.multiplyBy(h / r),
                        u = l.distanceTo([0, 0]),
                        c = Math.min(i.inertiaMaxSpeed, u),
                        d = l.multiplyBy(c / u),
                        p = c / (i.inertiaDeceleration * h),
                        _ = d.multiplyBy(-p / 2).round();
                    _.x && _.y ? (_ = e._limitOffset(_, e.options.maxBounds), o.Util.requestAnimFrame(function() {
                        e.panBy(_, {
                            duration: p,
                            easeLinearity: h,
                            noMoveStart: !0
                        })
                    })) : e.fire("moveend")
                }
            }
        }), o.Map.addInitHook("addHandler", "dragging", o.Map.Drag), o.Map.mergeOptions({
            doubleClickZoom: !0
        }), o.Map.DoubleClickZoom = o.Handler.extend({
            addHooks: function() {
                this._map.on("dblclick", this._onDoubleClick, this)
            },
            removeHooks: function() {
                this._map.off("dblclick", this._onDoubleClick, this)
            },
            _onDoubleClick: function(t) {
                var e = this._map,
                    i = e.getZoom() + (t.originalEvent.shiftKey ? -1 : 1);
                "center" === e.options.doubleClickZoom ? e.setZoom(i) : e.setZoomAround(t.containerPoint, i)
            }
        }), o.Map.addInitHook("addHandler", "doubleClickZoom", o.Map.DoubleClickZoom), o.Map.mergeOptions({
            scrollWheelZoom: !0
        }), o.Map.ScrollWheelZoom = o.Handler.extend({
            addHooks: function() {
                o.DomEvent.on(this._map._container, "mousewheel", this._onWheelScroll, this), o.DomEvent.on(this._map._container, "MozMousePixelScroll", o.DomEvent.preventDefault), this._delta = 0
            },
            removeHooks: function() {
                o.DomEvent.off(this._map._container, "mousewheel", this._onWheelScroll), o.DomEvent.off(this._map._container, "MozMousePixelScroll", o.DomEvent.preventDefault)
            },
            _onWheelScroll: function(t) {
                var e = o.DomEvent.getWheelDelta(t);
                this._delta += e, this._lastMousePos = this._map.mouseEventToContainerPoint(t), this._startTime || (this._startTime = +new Date);
                var i = Math.max(40 - (+new Date - this._startTime), 0);
                clearTimeout(this._timer), this._timer = setTimeout(o.bind(this._performZoom, this), i), o.DomEvent.preventDefault(t), o.DomEvent.stopPropagation(t)
            },
            _performZoom: function() {
                var t = this._map,
                    e = this._delta,
                    i = t.getZoom();
                e = e > 0 ? Math.ceil(e) : Math.floor(e), e = Math.max(Math.min(e, 4), -4), e = t._limitZoom(i + e) - i, this._delta = 0, this._startTime = null, e && ("center" === t.options.scrollWheelZoom ? t.setZoom(i + e) : t.setZoomAround(this._lastMousePos, i + e))
            }
        }), o.Map.addInitHook("addHandler", "scrollWheelZoom", o.Map.ScrollWheelZoom), o.extend(o.DomEvent, {
            _touchstart: o.Browser.msPointer ? "MSPointerDown" : o.Browser.pointer ? "pointerdown" : "touchstart",
            _touchend: o.Browser.msPointer ? "MSPointerUp" : o.Browser.pointer ? "pointerup" : "touchend",
            addDoubleTapListener: function(t, i, n) {
                function s(t) {
                    var e;
                    if (o.Browser.pointer ? (_.push(t.pointerId), e = _.length) : e = t.touches.length, !(e > 1)) {
                        var i = Date.now(),
                            n = i - (r || i);
                        h = t.touches ? t.touches[0] : t, l = n > 0 && u >= n, r = i
                    }
                }

                function a(t) {
                    if (o.Browser.pointer) {
                        var e = _.indexOf(t.pointerId);
                        if (-1 === e) return;
                        _.splice(e, 1)
                    }
                    if (l) {
                        if (o.Browser.pointer) {
                            var n, s = {};
                            for (var a in h) n = h[a], "function" == typeof n ? s[a] = n.bind(h) : s[a] = n;
                            h = s
                        }
                        h.type = "dblclick", i(h), r = null
                    }
                }
                var r, h, l = !1,
                    u = 250,
                    c = "_leaflet_",
                    d = this._touchstart,
                    p = this._touchend,
                    _ = [];
                t[c + d + n] = s, t[c + p + n] = a;
                var m = o.Browser.pointer ? e.documentElement : t;
                return t.addEventListener(d, s, !1), m.addEventListener(p, a, !1), o.Browser.pointer && m.addEventListener(o.DomEvent.POINTER_CANCEL, a, !1), this
            },
            removeDoubleTapListener: function(t, i) {
                var n = "_leaflet_";
                return t.removeEventListener(this._touchstart, t[n + this._touchstart + i], !1), (o.Browser.pointer ? e.documentElement : t).removeEventListener(this._touchend, t[n + this._touchend + i], !1), o.Browser.pointer && e.documentElement.removeEventListener(o.DomEvent.POINTER_CANCEL, t[n + this._touchend + i], !1), this
            }
        }), o.extend(o.DomEvent, {
            POINTER_DOWN: o.Browser.msPointer ? "MSPointerDown" : "pointerdown",
            POINTER_MOVE: o.Browser.msPointer ? "MSPointerMove" : "pointermove",
            POINTER_UP: o.Browser.msPointer ? "MSPointerUp" : "pointerup",
            POINTER_CANCEL: o.Browser.msPointer ? "MSPointerCancel" : "pointercancel",
            _pointers: [],
            _pointerDocumentListener: !1,
            addPointerListener: function(t, e, i, n) {
                switch (e) {
                    case "touchstart":
                        return this.addPointerListenerStart(t, e, i, n);
                    case "touchend":
                        return this.addPointerListenerEnd(t, e, i, n);
                    case "touchmove":
                        return this.addPointerListenerMove(t, e, i, n);
                    default:
                        throw "Unknown touch event type"
                }
            },
            addPointerListenerStart: function(t, i, n, s) {
                var a = "_leaflet_",
                    r = this._pointers,
                    h = function(t) {
                        "mouse" !== t.pointerType && t.pointerType !== t.MSPOINTER_TYPE_MOUSE && o.DomEvent.preventDefault(t);
                        for (var e = !1, i = 0; i < r.length; i++)
                            if (r[i].pointerId === t.pointerId) {
                                e = !0;
                                break
                            }
                        e || r.push(t), t.touches = r.slice(), t.changedTouches = [t], n(t)
                    };
                if (t[a + "touchstart" + s] = h, t.addEventListener(this.POINTER_DOWN, h, !1), !this._pointerDocumentListener) {
                    var l = function(t) {
                        for (var e = 0; e < r.length; e++)
                            if (r[e].pointerId === t.pointerId) {
                                r.splice(e, 1);
                                break
                            }
                    };
                    e.documentElement.addEventListener(this.POINTER_UP, l, !1), e.documentElement.addEventListener(this.POINTER_CANCEL, l, !1), this._pointerDocumentListener = !0
                }
                return this
            },
            addPointerListenerMove: function(t, e, i, n) {
                function o(t) {
                    if (t.pointerType !== t.MSPOINTER_TYPE_MOUSE && "mouse" !== t.pointerType || 0 !== t.buttons) {
                        for (var e = 0; e < a.length; e++)
                            if (a[e].pointerId === t.pointerId) {
                                a[e] = t;
                                break
                            }
                        t.touches = a.slice(), t.changedTouches = [t], i(t)
                    }
                }
                var s = "_leaflet_",
                    a = this._pointers;
                return t[s + "touchmove" + n] = o, t.addEventListener(this.POINTER_MOVE, o, !1), this
            },
            addPointerListenerEnd: function(t, e, i, n) {
                var o = "_leaflet_",
                    s = this._pointers,
                    a = function(t) {
                        for (var e = 0; e < s.length; e++)
                            if (s[e].pointerId === t.pointerId) {
                                s.splice(e, 1);
                                break
                            }
                        t.touches = s.slice(), t.changedTouches = [t], i(t)
                    };
                return t[o + "touchend" + n] = a, t.addEventListener(this.POINTER_UP, a, !1), t.addEventListener(this.POINTER_CANCEL, a, !1), this
            },
            removePointerListener: function(t, e, i) {
                var n = "_leaflet_",
                    o = t[n + e + i];
                switch (e) {
                    case "touchstart":
                        t.removeEventListener(this.POINTER_DOWN, o, !1);
                        break;
                    case "touchmove":
                        t.removeEventListener(this.POINTER_MOVE, o, !1);
                        break;
                    case "touchend":
                        t.removeEventListener(this.POINTER_UP, o, !1), t.removeEventListener(this.POINTER_CANCEL, o, !1)
                }
                return this
            }
        }), o.Map.mergeOptions({
            touchZoom: o.Browser.touch && !o.Browser.android23,
            bounceAtZoomLimits: !0
        }), o.Map.TouchZoom = o.Handler.extend({
            addHooks: function() {
                o.DomEvent.on(this._map._container, "touchstart", this._onTouchStart, this)
            },
            removeHooks: function() {
                o.DomEvent.off(this._map._container, "touchstart", this._onTouchStart, this)
            },
            _onTouchStart: function(t) {
                var i = this._map;
                if (t.touches && 2 === t.touches.length && !i._animatingZoom && !this._zooming) {
                    var n = i.mouseEventToLayerPoint(t.touches[0]),
                        s = i.mouseEventToLayerPoint(t.touches[1]),
                        a = i._getCenterLayerPoint();
                    this._startCenter = n.add(s)._divideBy(2), this._startDist = n.distanceTo(s), this._moved = !1, this._zooming = !0, this._centerOffset = a.subtract(this._startCenter), i._panAnim && i._panAnim.stop(), o.DomEvent.on(e, "touchmove", this._onTouchMove, this).on(e, "touchend", this._onTouchEnd, this), o.DomEvent.preventDefault(t)
                }
            },
            _onTouchMove: function(t) {
                var e = this._map;
                if (t.touches && 2 === t.touches.length && this._zooming) {
                    var i = e.mouseEventToLayerPoint(t.touches[0]),
                        n = e.mouseEventToLayerPoint(t.touches[1]);
                    this._scale = i.distanceTo(n) / this._startDist, this._delta = i._add(n)._divideBy(2)._subtract(this._startCenter), 1 !== this._scale && (e.options.bounceAtZoomLimits || !(e.getZoom() === e.getMinZoom() && this._scale < 1 || e.getZoom() === e.getMaxZoom() && this._scale > 1)) && (this._moved || (o.DomUtil.addClass(e._mapPane, "leaflet-touching"), e.fire("movestart").fire("zoomstart"), this._moved = !0), o.Util.cancelAnimFrame(this._animRequest), this._animRequest = o.Util.requestAnimFrame(this._updateOnMove, this, !0, this._map._container), o.DomEvent.preventDefault(t))
                }
            },
            _updateOnMove: function() {
                var t = this._map,
                    e = this._getScaleOrigin(),
                    i = t.layerPointToLatLng(e),
                    n = t.getScaleZoom(this._scale);
                t._animateZoom(i, n, this._startCenter, this._scale, this._delta, !1, !0)
            },
            _onTouchEnd: function() {
                if (!this._moved || !this._zooming) return void(this._zooming = !1);
                var t = this._map;
                this._zooming = !1, o.DomUtil.removeClass(t._mapPane, "leaflet-touching"), o.Util.cancelAnimFrame(this._animRequest), o.DomEvent.off(e, "touchmove", this._onTouchMove).off(e, "touchend", this._onTouchEnd);
                var i = this._getScaleOrigin(),
                    n = t.layerPointToLatLng(i),
                    s = t.getZoom(),
                    a = t.getScaleZoom(this._scale) - s,
                    r = a > 0 ? Math.ceil(a) : Math.floor(a),
                    h = t._limitZoom(s + r),
                    l = t.getZoomScale(h) / this._scale;
                t._animateZoom(n, h, i, l)
            },
            _getScaleOrigin: function() {
                var t = this._centerOffset.subtract(this._delta).divideBy(this._scale);
                return this._startCenter.add(t)
            }
        }), o.Map.addInitHook("addHandler", "touchZoom", o.Map.TouchZoom), o.Map.mergeOptions({
            tap: !0,
            tapTolerance: 15
        }), o.Map.Tap = o.Handler.extend({
            addHooks: function() {
                o.DomEvent.on(this._map._container, "touchstart", this._onDown, this)
            },
            removeHooks: function() {
                o.DomEvent.off(this._map._container, "touchstart", this._onDown, this)
            },
            _onDown: function(t) {
                if (t.touches) {
                    if (o.DomEvent.preventDefault(t), this._fireClick = !0, t.touches.length > 1) return this._fireClick = !1, void clearTimeout(this._holdTimeout);
                    var i = t.touches[0],
                        n = i.target;
                    this._startPos = this._newPos = new o.Point(i.clientX, i.clientY), n.tagName && "a" === n.tagName.toLowerCase() && o.DomUtil.addClass(n, "leaflet-active"), this._holdTimeout = setTimeout(o.bind(function() {
                        this._isTapValid() && (this._fireClick = !1, this._onUp(), this._simulateEvent("contextmenu", i))
                    }, this), 1e3), o.DomEvent.on(e, "touchmove", this._onMove, this).on(e, "touchend", this._onUp, this)
                }
            },
            _onUp: function(t) {
                if (clearTimeout(this._holdTimeout), o.DomEvent.off(e, "touchmove", this._onMove, this).off(e, "touchend", this._onUp, this), this._fireClick && t && t.changedTouches) {
                    var i = t.changedTouches[0],
                        n = i.target;
                    n && n.tagName && "a" === n.tagName.toLowerCase() && o.DomUtil.removeClass(n, "leaflet-active"), this._isTapValid() && this._simulateEvent("click", i)
                }
            },
            _isTapValid: function() {
                return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance
            },
            _onMove: function(t) {
                var e = t.touches[0];
                this._newPos = new o.Point(e.clientX, e.clientY)
            },
            _simulateEvent: function(i, n) {
                var o = e.createEvent("MouseEvents");
                o._simulated = !0, n.target._simulatedClick = !0, o.initMouseEvent(i, !0, !0, t, 1, n.screenX, n.screenY, n.clientX, n.clientY, !1, !1, !1, !1, 0, null), n.target.dispatchEvent(o)
            }
        }), o.Browser.touch && !o.Browser.pointer && o.Map.addInitHook("addHandler", "tap", o.Map.Tap), o.Map.mergeOptions({
            boxZoom: !0
        }), o.Map.BoxZoom = o.Handler.extend({
            initialize: function(t) {
                this._map = t, this._container = t._container, this._pane = t._panes.overlayPane, this._moved = !1
            },
            addHooks: function() {
                o.DomEvent.on(this._container, "mousedown", this._onMouseDown, this)
            },
            removeHooks: function() {
                o.DomEvent.off(this._container, "mousedown", this._onMouseDown), this._moved = !1
            },
            moved: function() {
                return this._moved
            },
            _onMouseDown: function(t) {
                return this._moved = !1, !t.shiftKey || 1 !== t.which && 1 !== t.button ? !1 : (o.DomUtil.disableTextSelection(), o.DomUtil.disableImageDrag(), this._startLayerPoint = this._map.mouseEventToLayerPoint(t), void o.DomEvent.on(e, "mousemove", this._onMouseMove, this).on(e, "mouseup", this._onMouseUp, this).on(e, "keydown", this._onKeyDown, this))
            },
            _onMouseMove: function(t) {
                this._moved || (this._box = o.DomUtil.create("div", "leaflet-zoom-box", this._pane), o.DomUtil.setPosition(this._box, this._startLayerPoint), this._container.style.cursor = "crosshair", this._map.fire("boxzoomstart"));
                var e = this._startLayerPoint,
                    i = this._box,
                    n = this._map.mouseEventToLayerPoint(t),
                    s = n.subtract(e),
                    a = new o.Point(Math.min(n.x, e.x), Math.min(n.y, e.y));
                o.DomUtil.setPosition(i, a), this._moved = !0, i.style.width = Math.max(0, Math.abs(s.x) - 4) + "px", i.style.height = Math.max(0, Math.abs(s.y) - 4) + "px"
            },
            _finish: function() {
                this._moved && (this._pane.removeChild(this._box), this._container.style.cursor = ""), o.DomUtil.enableTextSelection(), o.DomUtil.enableImageDrag(), o.DomEvent.off(e, "mousemove", this._onMouseMove).off(e, "mouseup", this._onMouseUp).off(e, "keydown", this._onKeyDown)
            },
            _onMouseUp: function(t) {
                this._finish();
                var e = this._map,
                    i = e.mouseEventToLayerPoint(t);
                if (!this._startLayerPoint.equals(i)) {
                    var n = new o.LatLngBounds(e.layerPointToLatLng(this._startLayerPoint), e.layerPointToLatLng(i));
                    e.fitBounds(n), e.fire("boxzoomend", {
                        boxZoomBounds: n
                    })
                }
            },
            _onKeyDown: function(t) {
                27 === t.keyCode && this._finish()
            }
        }), o.Map.addInitHook("addHandler", "boxZoom", o.Map.BoxZoom), o.Map.mergeOptions({
            keyboard: !0,
            keyboardPanOffset: 80,
            keyboardZoomOffset: 1
        }), o.Map.Keyboard = o.Handler.extend({
            keyCodes: {
                left: [37],
                right: [39],
                down: [40],
                up: [38],
                zoomIn: [187, 107, 61, 171],
                zoomOut: [189, 109, 173]
            },
            initialize: function(t) {
                this._map = t, this._setPanOffset(t.options.keyboardPanOffset), this._setZoomOffset(t.options.keyboardZoomOffset)
            },
            addHooks: function() {
                var t = this._map._container; - 1 === t.tabIndex && (t.tabIndex = "0"), o.DomEvent.on(t, "focus", this._onFocus, this).on(t, "blur", this._onBlur, this).on(t, "mousedown", this._onMouseDown, this), this._map.on("focus", this._addHooks, this).on("blur", this._removeHooks, this)
            },
            removeHooks: function() {
                this._removeHooks();
                var t = this._map._container;
                o.DomEvent.off(t, "focus", this._onFocus, this).off(t, "blur", this._onBlur, this).off(t, "mousedown", this._onMouseDown, this), this._map.off("focus", this._addHooks, this).off("blur", this._removeHooks, this)
            },
            _onMouseDown: function() {
                if (!this._focused) {
                    var i = e.body,
                        n = e.documentElement,
                        o = i.scrollTop || n.scrollTop,
                        s = i.scrollLeft || n.scrollLeft;
                    this._map._container.focus(), t.scrollTo(s, o)
                }
            },
            _onFocus: function() {
                this._focused = !0, this._map.fire("focus")
            },
            _onBlur: function() {
                this._focused = !1, this._map.fire("blur")
            },
            _setPanOffset: function(t) {
                var e, i, n = this._panKeys = {},
                    o = this.keyCodes;
                for (e = 0, i = o.left.length; i > e; e++) n[o.left[e]] = [-1 * t, 0];
                for (e = 0, i = o.right.length; i > e; e++) n[o.right[e]] = [t, 0];
                for (e = 0, i = o.down.length; i > e; e++) n[o.down[e]] = [0, t];
                for (e = 0, i = o.up.length; i > e; e++) n[o.up[e]] = [0, -1 * t]
            },
            _setZoomOffset: function(t) {
                var e, i, n = this._zoomKeys = {},
                    o = this.keyCodes;
                for (e = 0, i = o.zoomIn.length; i > e; e++) n[o.zoomIn[e]] = t;
                for (e = 0, i = o.zoomOut.length; i > e; e++) n[o.zoomOut[e]] = -t
            },
            _addHooks: function() {
                o.DomEvent.on(e, "keydown", this._onKeyDown, this)
            },
            _removeHooks: function() {
                o.DomEvent.off(e, "keydown", this._onKeyDown, this)
            },
            _onKeyDown: function(t) {
                var e = t.keyCode,
                    i = this._map;
                if (e in this._panKeys) {
                    if (i._panAnim && i._panAnim._inProgress) return;
                    i.panBy(this._panKeys[e]), i.options.maxBounds && i.panInsideBounds(i.options.maxBounds)
                } else {
                    if (!(e in this._zoomKeys)) return;
                    i.setZoom(i.getZoom() + this._zoomKeys[e])
                }
                o.DomEvent.stop(t)
            }
        }), o.Map.addInitHook("addHandler", "keyboard", o.Map.Keyboard), o.Handler.MarkerDrag = o.Handler.extend({
            initialize: function(t) {
                this._marker = t
            },
            addHooks: function() {
                var t = this._marker._icon;
                this._draggable || (this._draggable = new o.Draggable(t, t)), this._draggable.on("dragstart", this._onDragStart, this).on("drag", this._onDrag, this).on("dragend", this._onDragEnd, this), this._draggable.enable(), o.DomUtil.addClass(this._marker._icon, "leaflet-marker-draggable")
            },
            removeHooks: function() {
                this._draggable.off("dragstart", this._onDragStart, this).off("drag", this._onDrag, this).off("dragend", this._onDragEnd, this), this._draggable.disable(), o.DomUtil.removeClass(this._marker._icon, "leaflet-marker-draggable")
            },
            moved: function() {
                return this._draggable && this._draggable._moved
            },
            _onDragStart: function() {
                this._marker.closePopup().fire("movestart").fire("dragstart")
            },
            _onDrag: function() {
                var t = this._marker,
                    e = t._shadow,
                    i = o.DomUtil.getPosition(t._icon),
                    n = t._map.layerPointToLatLng(i);
                e && o.DomUtil.setPosition(e, i), t._latlng = n, t.fire("move", {
                    latlng: n
                }).fire("drag")
            },
            _onDragEnd: function(t) {
                this._marker.fire("moveend").fire("dragend", t)
            }
        }), o.Control = o.Class.extend({
            options: {
                position: "topright"
            },
            initialize: function(t) {
                o.setOptions(this, t)
            },
            getPosition: function() {
                return this.options.position
            },
            setPosition: function(t) {
                var e = this._map;
                return e && e.removeControl(this), this.options.position = t, e && e.addControl(this), this
            },
            getContainer: function() {
                return this._container
            },
            addTo: function(t) {
                this._map = t;
                var e = this._container = this.onAdd(t),
                    i = this.getPosition(),
                    n = t._controlCorners[i];
                return o.DomUtil.addClass(e, "leaflet-control"), -1 !== i.indexOf("bottom") ? n.insertBefore(e, n.firstChild) : n.appendChild(e), this
            },
            removeFrom: function(t) {
                var e = this.getPosition(),
                    i = t._controlCorners[e];
                return i.removeChild(this._container), this._map = null, this.onRemove && this.onRemove(t), this
            },
            _refocusOnMap: function() {
                this._map && this._map.getContainer().focus()
            }
        }), o.control = function(t) {
            return new o.Control(t)
        }, o.Map.include({
            addControl: function(t) {
                return t.addTo(this), this
            },
            removeControl: function(t) {
                return t.removeFrom(this), this
            },
            _initControlPos: function() {
                function t(t, s) {
                    var a = i + t + " " + i + s;
                    e[t + s] = o.DomUtil.create("div", a, n)
                }
                var e = this._controlCorners = {},
                    i = "leaflet-",
                    n = this._controlContainer = o.DomUtil.create("div", i + "control-container", this._container);
                t("top", "left"), t("top", "right"), t("bottom", "left"), t("bottom", "right")
            },
            _clearControlPos: function() {
                this._container.removeChild(this._controlContainer)
            }
        }), o.Control.Zoom = o.Control.extend({
            options: {
                position: "topleft",
                zoomInText: "+",
                zoomInTitle: "Zoom in",
                zoomOutText: "-",
                zoomOutTitle: "Zoom out"
            },
            onAdd: function(t) {
                var e = "leaflet-control-zoom",
                    i = o.DomUtil.create("div", e + " leaflet-bar");
                return this._map = t, this._zoomInButton = this._createButton(this.options.zoomInText, this.options.zoomInTitle, e + "-in", i, this._zoomIn, this), this._zoomOutButton = this._createButton(this.options.zoomOutText, this.options.zoomOutTitle, e + "-out", i, this._zoomOut, this), this._updateDisabled(), t.on("zoomend zoomlevelschange", this._updateDisabled, this), i
            },
            onRemove: function(t) {
                t.off("zoomend zoomlevelschange", this._updateDisabled, this)
            },
            _zoomIn: function(t) {
                this._map.zoomIn(t.shiftKey ? 3 : 1)
            },
            _zoomOut: function(t) {
                this._map.zoomOut(t.shiftKey ? 3 : 1)
            },
            _createButton: function(t, e, i, n, s, a) {
                var r = o.DomUtil.create("a", i, n);
                r.innerHTML = t, r.href = "#", r.title = e;
                var h = o.DomEvent.stopPropagation;
                return o.DomEvent.on(r, "click", h).on(r, "mousedown", h).on(r, "dblclick", h).on(r, "click", o.DomEvent.preventDefault).on(r, "click", s, a).on(r, "click", this._refocusOnMap, a), r
            },
            _updateDisabled: function() {
                var t = this._map,
                    e = "leaflet-disabled";
                o.DomUtil.removeClass(this._zoomInButton, e), o.DomUtil.removeClass(this._zoomOutButton, e), t._zoom === t.getMinZoom() && o.DomUtil.addClass(this._zoomOutButton, e), t._zoom === t.getMaxZoom() && o.DomUtil.addClass(this._zoomInButton, e)
            }
        }), o.Map.mergeOptions({
            zoomControl: !0
        }), o.Map.addInitHook(function() {
            this.options.zoomControl && (this.zoomControl = new o.Control.Zoom, this.addControl(this.zoomControl))
        }), o.control.zoom = function(t) {
            return new o.Control.Zoom(t)
        }, o.Control.Attribution = o.Control.extend({
            options: {
                position: "bottomright",
                prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
            },
            initialize: function(t) {
                o.setOptions(this, t), this._attributions = {}
            },
            onAdd: function(t) {
                this._container = o.DomUtil.create("div", "leaflet-control-attribution"), o.DomEvent.disableClickPropagation(this._container);
                for (var e in t._layers) t._layers[e].getAttribution && this.addAttribution(t._layers[e].getAttribution());
                return t.on("layeradd", this._onLayerAdd, this).on("layerremove", this._onLayerRemove, this), this._update(), this._container
            },
            onRemove: function(t) {
                t.off("layeradd", this._onLayerAdd).off("layerremove", this._onLayerRemove)
            },
            setPrefix: function(t) {
                return this.options.prefix = t, this._update(), this
            },
            addAttribution: function(t) {
                return t ? (this._attributions[t] || (this._attributions[t] = 0), this._attributions[t]++, this._update(), this) : void 0
            },
            removeAttribution: function(t) {
                return t ? (this._attributions[t] && (this._attributions[t]--, this._update()), this) : void 0
            },
            _update: function() {
                if (this._map) {
                    var t = [];
                    for (var e in this._attributions) this._attributions[e] && t.push(e);
                    var i = [];
                    this.options.prefix && i.push(this.options.prefix), t.length && i.push(t.join(", ")), this._container.innerHTML = i.join(" | ")
                }
            },
            _onLayerAdd: function(t) {
                t.layer.getAttribution && this.addAttribution(t.layer.getAttribution())
            },
            _onLayerRemove: function(t) {
                t.layer.getAttribution && this.removeAttribution(t.layer.getAttribution())
            }
        }), o.Map.mergeOptions({
            attributionControl: !0
        }), o.Map.addInitHook(function() {
            this.options.attributionControl && (this.attributionControl = (new o.Control.Attribution).addTo(this))
        }), o.control.attribution = function(t) {
            return new o.Control.Attribution(t)
        }, o.Control.Scale = o.Control.extend({
            options: {
                position: "bottomleft",
                maxWidth: 100,
                metric: !0,
                imperial: !0,
                updateWhenIdle: !1
            },
            onAdd: function(t) {
                this._map = t;
                var e = "leaflet-control-scale",
                    i = o.DomUtil.create("div", e),
                    n = this.options;
                return this._addScales(n, e, i), t.on(n.updateWhenIdle ? "moveend" : "move", this._update, this), t.whenReady(this._update, this), i
            },
            onRemove: function(t) {
                t.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this)
            },
            _addScales: function(t, e, i) {
                t.metric && (this._mScale = o.DomUtil.create("div", e + "-line", i)), t.imperial && (this._iScale = o.DomUtil.create("div", e + "-line", i))
            },
            _update: function() {
                var t = this._map.getBounds(),
                    e = t.getCenter().lat,
                    i = 6378137 * Math.PI * Math.cos(e * Math.PI / 180),
                    n = i * (t.getNorthEast().lng - t.getSouthWest().lng) / 180,
                    o = this._map.getSize(),
                    s = this.options,
                    a = 0;
                o.x > 0 && (a = n * (s.maxWidth / o.x)), this._updateScales(s, a)
            },
            _updateScales: function(t, e) {
                t.metric && e && this._updateMetric(e), t.imperial && e && this._updateImperial(e)
            },
            _updateMetric: function(t) {
                var e = this._getRoundNum(t);
                this._mScale.style.width = this._getScaleWidth(e / t) + "px", this._mScale.innerHTML = 1e3 > e ? e + " m" : e / 1e3 + " km"
            },
            _updateImperial: function(t) {
                var e, i, n, o = 3.2808399 * t,
                    s = this._iScale;
                o > 5280 ? (e = o / 5280, i = this._getRoundNum(e), s.style.width = this._getScaleWidth(i / e) + "px", s.innerHTML = i + " mi") : (n = this._getRoundNum(o), s.style.width = this._getScaleWidth(n / o) + "px", s.innerHTML = n + " ft")
            },
            _getScaleWidth: function(t) {
                return Math.round(this.options.maxWidth * t) - 10
            },
            _getRoundNum: function(t) {
                var e = Math.pow(10, (Math.floor(t) + "").length - 1),
                    i = t / e;
                return i = i >= 10 ? 10 : i >= 5 ? 5 : i >= 3 ? 3 : i >= 2 ? 2 : 1, e * i
            }
        }), o.control.scale = function(t) {
            return new o.Control.Scale(t)
        }, o.Control.Layers = o.Control.extend({
            options: {
                collapsed: !0,
                position: "topright",
                autoZIndex: !0
            },
            initialize: function(t, e, i) {
                o.setOptions(this, i), this._layers = {}, this._lastZIndex = 0, this._handlingClick = !1;
                for (var n in t) this._addLayer(t[n], n);
                for (n in e) this._addLayer(e[n], n, !0)
            },
            onAdd: function(t) {
                return this._initLayout(), this._update(), t.on("layeradd", this._onLayerChange, this).on("layerremove", this._onLayerChange, this), this._container
            },
            onRemove: function(t) {
                t.off("layeradd", this._onLayerChange, this).off("layerremove", this._onLayerChange, this)
            },
            addBaseLayer: function(t, e) {
                return this._addLayer(t, e), this._update(), this
            },
            addOverlay: function(t, e) {
                return this._addLayer(t, e, !0), this._update(), this
            },
            removeLayer: function(t) {
                var e = o.stamp(t);
                return delete this._layers[e], this._update(), this
            },
            _initLayout: function() {
                var t = "leaflet-control-layers",
                    e = this._container = o.DomUtil.create("div", t);
                e.setAttribute("aria-haspopup", !0), o.Browser.touch ? o.DomEvent.on(e, "click", o.DomEvent.stopPropagation) : o.DomEvent.disableClickPropagation(e).disableScrollPropagation(e);
                var i = this._form = o.DomUtil.create("form", t + "-list");
                if (this.options.collapsed) {
                    o.Browser.android || o.DomEvent.on(e, "mouseover", this._expand, this).on(e, "mouseout", this._collapse, this);
                    var n = this._layersLink = o.DomUtil.create("a", t + "-toggle", e);
                    n.href = "#", n.title = "Layers", o.Browser.touch ? o.DomEvent.on(n, "click", o.DomEvent.stop).on(n, "click", this._expand, this) : o.DomEvent.on(n, "focus", this._expand, this), o.DomEvent.on(i, "click", function() {
                        setTimeout(o.bind(this._onInputClick, this), 0)
                    }, this), this._map.on("click", this._collapse, this)
                } else this._expand();
                this._baseLayersList = o.DomUtil.create("div", t + "-base", i), this._separator = o.DomUtil.create("div", t + "-separator", i), this._overlaysList = o.DomUtil.create("div", t + "-overlays", i), e.appendChild(i)
            },
            _addLayer: function(t, e, i) {
                var n = o.stamp(t);
                this._layers[n] = {
                    layer: t,
                    name: e,
                    overlay: i
                }, this.options.autoZIndex && t.setZIndex && (this._lastZIndex++, t.setZIndex(this._lastZIndex))
            },
            _update: function() {
                if (this._container) {
                    this._baseLayersList.innerHTML = "", this._overlaysList.innerHTML = "";
                    var t, e, i = !1,
                        n = !1;
                    for (t in this._layers) e = this._layers[t], this._addItem(e), n = n || e.overlay, i = i || !e.overlay;
                    this._separator.style.display = n && i ? "" : "none"
                }
            },
            _onLayerChange: function(t) {
                var e = this._layers[o.stamp(t.layer)];
                if (e) {
                    this._handlingClick || this._update();
                    var i = e.overlay ? "layeradd" === t.type ? "overlayadd" : "overlayremove" : "layeradd" === t.type ? "baselayerchange" : null;
                    i && this._map.fire(i, e)
                }
            },
            _createRadioElement: function(t, i) {
                var n = '<input type="radio" class="leaflet-control-layers-selector" name="' + t + '"';
                i && (n += ' checked="checked"'), n += "/>";
                var o = e.createElement("div");
                return o.innerHTML = n, o.firstChild
            },
            _addItem: function(t) {
                var i, n = e.createElement("label"),
                    s = this._map.hasLayer(t.layer);
                t.overlay ? (i = e.createElement("input"), i.type = "checkbox", i.className = "leaflet-control-layers-selector", i.defaultChecked = s) : i = this._createRadioElement("leaflet-base-layers", s), i.layerId = o.stamp(t.layer), o.DomEvent.on(i, "click", this._onInputClick, this);
                var a = e.createElement("span");
                a.innerHTML = " " + t.name, n.appendChild(i), n.appendChild(a);
                var r = t.overlay ? this._overlaysList : this._baseLayersList;
                return r.appendChild(n), n
            },
            _onInputClick: function() {
                var t, e, i, n = this._form.getElementsByTagName("input"),
                    o = n.length;
                for (this._handlingClick = !0, t = 0; o > t; t++) e = n[t], i = this._layers[e.layerId], e.checked && !this._map.hasLayer(i.layer) ? this._map.addLayer(i.layer) : !e.checked && this._map.hasLayer(i.layer) && this._map.removeLayer(i.layer);
                this._handlingClick = !1, this._refocusOnMap()
            },
            _expand: function() {
                o.DomUtil.addClass(this._container, "leaflet-control-layers-expanded")
            },
            _collapse: function() {
                this._container.className = this._container.className.replace(" leaflet-control-layers-expanded", "")
            }
        }), o.control.layers = function(t, e, i) {
            return new o.Control.Layers(t, e, i)
        }, o.PosAnimation = o.Class.extend({
            includes: o.Mixin.Events,
            run: function(t, e, i, n) {
                this.stop(), this._el = t, this._inProgress = !0, this._newPos = e, this.fire("start"), t.style[o.DomUtil.TRANSITION] = "all " + (i || .25) + "s cubic-bezier(0,0," + (n || .5) + ",1)", o.DomEvent.on(t, o.DomUtil.TRANSITION_END, this._onTransitionEnd, this), o.DomUtil.setPosition(t, e), o.Util.falseFn(t.offsetWidth), this._stepTimer = setInterval(o.bind(this._onStep, this), 50)
            },
            stop: function() {
                this._inProgress && (o.DomUtil.setPosition(this._el, this._getPos()), this._onTransitionEnd(), o.Util.falseFn(this._el.offsetWidth))
            },
            _onStep: function() {
                var t = this._getPos();
                return t ? (this._el._leaflet_pos = t, void this.fire("step")) : void this._onTransitionEnd()
            },
            _transformRe: /([-+]?(?:\d*\.)?\d+)\D*, ([-+]?(?:\d*\.)?\d+)\D*\)/,
            _getPos: function() {
                var e, i, n, s = this._el,
                    a = t.getComputedStyle(s);
                if (o.Browser.any3d) {
                    if (n = a[o.DomUtil.TRANSFORM].match(this._transformRe), !n) return;
                    e = parseFloat(n[1]), i = parseFloat(n[2])
                } else e = parseFloat(a.left), i = parseFloat(a.top);
                return new o.Point(e, i, !0)
            },
            _onTransitionEnd: function() {
                o.DomEvent.off(this._el, o.DomUtil.TRANSITION_END, this._onTransitionEnd, this), this._inProgress && (this._inProgress = !1, this._el.style[o.DomUtil.TRANSITION] = "", this._el._leaflet_pos = this._newPos, clearInterval(this._stepTimer), this.fire("step").fire("end"))
            }
        }), o.Map.include({
            setView: function(t, e, n) {
                if (e = e === i ? this._zoom : this._limitZoom(e), t = this._limitCenter(o.latLng(t), e, this.options.maxBounds), n = n || {}, this._panAnim && this._panAnim.stop(), this._loaded && !n.reset && n !== !0) {
                    n.animate !== i && (n.zoom = o.extend({
                        animate: n.animate
                    }, n.zoom), n.pan = o.extend({
                        animate: n.animate
                    }, n.pan));
                    var s = this._zoom !== e ? this._tryAnimatedZoom && this._tryAnimatedZoom(t, e, n.zoom) : this._tryAnimatedPan(t, n.pan);
                    if (s) return clearTimeout(this._sizeTimer), this
                }
                return this._resetView(t, e), this
            },
            panBy: function(t, e) {
                if (t = o.point(t).round(), e = e || {}, !t.x && !t.y) return this;
                if (this._panAnim || (this._panAnim = new o.PosAnimation, this._panAnim.on({
                        step: this._onPanTransitionStep,
                        end: this._onPanTransitionEnd
                    }, this)), e.noMoveStart || this.fire("movestart"), e.animate !== !1) {
                    o.DomUtil.addClass(this._mapPane, "leaflet-pan-anim");
                    var i = this._getMapPanePos().subtract(t);
                    this._panAnim.run(this._mapPane, i, e.duration || .25, e.easeLinearity)
                } else this._rawPanBy(t), this.fire("move").fire("moveend");
                return this
            },
            _onPanTransitionStep: function() {
                this.fire("move")
            },
            _onPanTransitionEnd: function() {
                o.DomUtil.removeClass(this._mapPane, "leaflet-pan-anim"), this.fire("moveend")
            },
            _tryAnimatedPan: function(t, e) {
                var i = this._getCenterOffset(t)._floor();
                return (e && e.animate) === !0 || this.getSize().contains(i) ? (this.panBy(i, e), !0) : !1
            }
        }), o.PosAnimation = o.DomUtil.TRANSITION ? o.PosAnimation : o.PosAnimation.extend({
            run: function(t, e, i, n) {
                this.stop(), this._el = t, this._inProgress = !0, this._duration = i || .25, this._easeOutPower = 1 / Math.max(n || .5, .2), this._startPos = o.DomUtil.getPosition(t), this._offset = e.subtract(this._startPos), this._startTime = +new Date, this.fire("start"), this._animate()
            },
            stop: function() {
                this._inProgress && (this._step(), this._complete())
            },
            _animate: function() {
                this._animId = o.Util.requestAnimFrame(this._animate, this), this._step()
            },
            _step: function() {
                var t = +new Date - this._startTime,
                    e = 1e3 * this._duration;
                e > t ? this._runFrame(this._easeOut(t / e)) : (this._runFrame(1), this._complete())
            },
            _runFrame: function(t) {
                var e = this._startPos.add(this._offset.multiplyBy(t));
                o.DomUtil.setPosition(this._el, e), this.fire("step")
            },
            _complete: function() {
                o.Util.cancelAnimFrame(this._animId), this._inProgress = !1, this.fire("end")
            },
            _easeOut: function(t) {
                return 1 - Math.pow(1 - t, this._easeOutPower)
            }
        }), o.Map.mergeOptions({
            zoomAnimation: !0,
            zoomAnimationThreshold: 4
        }), o.DomUtil.TRANSITION && o.Map.addInitHook(function() {
            this._zoomAnimated = this.options.zoomAnimation && o.DomUtil.TRANSITION && o.Browser.any3d && !o.Browser.android23 && !o.Browser.mobileOpera, this._zoomAnimated && o.DomEvent.on(this._mapPane, o.DomUtil.TRANSITION_END, this._catchTransitionEnd, this)
        }), o.Map.include(o.DomUtil.TRANSITION ? {
            _catchTransitionEnd: function(t) {
                this._animatingZoom && t.propertyName.indexOf("transform") >= 0 && this._onZoomTransitionEnd()
            },
            _nothingToAnimate: function() {
                return !this._container.getElementsByClassName("leaflet-zoom-animated").length
            },
            _tryAnimatedZoom: function(t, e, i) {
                if (this._animatingZoom) return !0;
                if (i = i || {}, !this._zoomAnimated || i.animate === !1 || this._nothingToAnimate() || Math.abs(e - this._zoom) > this.options.zoomAnimationThreshold) return !1;
                var n = this.getZoomScale(e),
                    o = this._getCenterOffset(t)._divideBy(1 - 1 / n),
                    s = this._getCenterLayerPoint()._add(o);
                return i.animate === !0 || this.getSize().contains(o) ? (this.fire("movestart").fire("zoomstart"), this._animateZoom(t, e, s, n, null, !0), !0) : !1
            },
            _animateZoom: function(t, e, i, n, s, a, r) {
                r || (this._animatingZoom = !0), o.DomUtil.addClass(this._mapPane, "leaflet-zoom-anim"), this._animateToCenter = t, this._animateToZoom = e, o.Draggable && (o.Draggable._disabled = !0), o.Util.requestAnimFrame(function() {
                    this.fire("zoomanim", {
                        center: t,
                        zoom: e,
                        origin: i,
                        scale: n,
                        delta: s,
                        backwards: a
                    }), setTimeout(o.bind(this._onZoomTransitionEnd, this), 250)
                }, this)
            },
            _onZoomTransitionEnd: function() {
                this._animatingZoom && (this._animatingZoom = !1, o.DomUtil.removeClass(this._mapPane, "leaflet-zoom-anim"), o.Util.requestAnimFrame(function() {
                    this._resetView(this._animateToCenter, this._animateToZoom, !0, !0), o.Draggable && (o.Draggable._disabled = !1)
                }, this))
            }
        } : {}), o.TileLayer.include({
            _animateZoom: function(t) {
                this._animating || (this._animating = !0, this._prepareBgBuffer());
                var e = this._bgBuffer,
                    i = o.DomUtil.TRANSFORM,
                    n = t.delta ? o.DomUtil.getTranslateString(t.delta) : e.style[i],
                    s = o.DomUtil.getScaleString(t.scale, t.origin);
                e.style[i] = t.backwards ? s + " " + n : n + " " + s
            },
            _endZoomAnim: function() {
                var t = this._tileContainer,
                    e = this._bgBuffer;
                t.style.visibility = "", t.parentNode.appendChild(t), o.Util.falseFn(e.offsetWidth);
                var i = this._map.getZoom();
                (i > this.options.maxZoom || i < this.options.minZoom) && this._clearBgBuffer(), this._animating = !1
            },
            _clearBgBuffer: function() {
                var t = this._map;
                !t || t._animatingZoom || t.touchZoom._zooming || (this._bgBuffer.innerHTML = "", this._bgBuffer.style[o.DomUtil.TRANSFORM] = "")
            },
            _prepareBgBuffer: function() {
                var t = this._tileContainer,
                    e = this._bgBuffer,
                    i = this._getLoadedTilesPercentage(e),
                    n = this._getLoadedTilesPercentage(t);
                return e && i > .5 && .5 > n ? (t.style.visibility = "hidden", void this._stopLoadingImages(t)) : (e.style.visibility = "hidden", e.style[o.DomUtil.TRANSFORM] = "", this._tileContainer = e, e = this._bgBuffer = t, this._stopLoadingImages(e), void clearTimeout(this._clearBgBufferTimer))
            },
            _getLoadedTilesPercentage: function(t) {
                var e, i, n = t.getElementsByTagName("img"),
                    o = 0;
                for (e = 0, i = n.length; i > e; e++) n[e].complete && o++;
                return o / i
            },
            _stopLoadingImages: function(t) {
                var e, i, n, s = Array.prototype.slice.call(t.getElementsByTagName("img"));
                for (e = 0, i = s.length; i > e; e++) n = s[e], n.complete || (n.onload = o.Util.falseFn, n.onerror = o.Util.falseFn, n.src = o.Util.emptyImageUrl, n.parentNode.removeChild(n))
            }
        }), o.Map.include({
            _defaultLocateOptions: {
                watch: !1,
                setView: !1,
                maxZoom: 1 / 0,
                timeout: 1e4,
                maximumAge: 0,
                enableHighAccuracy: !1
            },
            locate: function(t) {
                if (t = this._locateOptions = o.extend(this._defaultLocateOptions, t), !navigator.geolocation) return this._handleGeolocationError({
                    code: 0,
                    message: "Geolocation not supported."
                }), this;
                var e = o.bind(this._handleGeolocationResponse, this),
                    i = o.bind(this._handleGeolocationError, this);
                return t.watch ? this._locationWatchId = navigator.geolocation.watchPosition(e, i, t) : navigator.geolocation.getCurrentPosition(e, i, t), this
            },
            stopLocate: function() {
                return navigator.geolocation && navigator.geolocation.clearWatch(this._locationWatchId), this._locateOptions && (this._locateOptions.setView = !1), this
            },
            _handleGeolocationError: function(t) {
                var e = t.code,
                    i = t.message || (1 === e ? "permission denied" : 2 === e ? "position unavailable" : "timeout");
                this._locateOptions.setView && !this._loaded && this.fitWorld(), this.fire("locationerror", {
                    code: e,
                    message: "Geolocation error: " + i + "."
                })
            },
            _handleGeolocationResponse: function(t) {
                var e = t.coords.latitude,
                    i = t.coords.longitude,
                    n = new o.LatLng(e, i),
                    s = 180 * t.coords.accuracy / 40075017,
                    a = s / Math.cos(o.LatLng.DEG_TO_RAD * e),
                    r = o.latLngBounds([e - s, i - a], [e + s, i + a]),
                    h = this._locateOptions;
                if (h.setView) {
                    var l = Math.min(this.getBoundsZoom(r), h.maxZoom);
                    this.setView(n, l)
                }
                var u = {
                    latlng: n,
                    bounds: r,
                    timestamp: t.timestamp
                };
                for (var c in t.coords) "number" == typeof t.coords[c] && (u[c] = t.coords[c]);
                this.fire("locationfound", u)
            }
        })
}(window, document);

L.MarkerCluster = L.Marker.extend({
    initialize: function(group, zoom, a, b) {
        L.Marker.prototype.initialize.call(this, a ? (a._cLatLng || a.getLatLng()) : new L.LatLng(0, 0), {
            icon: this
        });
        this._group = group;
        this._zoom = zoom;
        this._markers = [];
        this._childClusters = [];
        this._childCount = 0;
        this._iconNeedsUpdate = true;
        this._boundsNeedUpdate = true;
        this._bounds = new L.LatLngBounds();
        if (a) {
            this._addChild(a);
        }
        if (b) {
            this._addChild(b);
        }
    },
    getAllChildMarkers: function(storageArray) {
        storageArray = storageArray || [];
        for (var i = this._childClusters.length - 1; i >= 0; i--) {
            this._childClusters[i].getAllChildMarkers(storageArray);
        }
        for (var j = this._markers.length - 1; j >= 0; j--) {
            storageArray.push(this._markers[j]);
        }
        return storageArray;
    },
    getChildCount: function() {
        return this._childCount;
    },
    zoomToBounds: function() {
        var childClusters = this._childClusters.slice(),
            map = this._group._map,
            boundsZoom = map.getBoundsZoom(this._bounds),
            zoom = this._zoom + 1,
            mapZoom = map.getZoom(),
            i;
        while (childClusters.length > 0 && boundsZoom > zoom) {
            zoom++;
            var newClusters = [];
            for (i = 0; i < childClusters.length; i++) {
                newClusters = newClusters.concat(childClusters[i]._childClusters);
            }
            childClusters = newClusters;
        }
        if (boundsZoom > zoom) {
            this._group._map.setView(this._latlng, zoom);
        } else if (boundsZoom <= mapZoom) {
            this._group._map.setView(this._latlng, mapZoom + 1);
        } else {
            this._group._map.fitBounds(this._bounds);
        }
    },
    getBounds: function() {
        var bounds = new L.LatLngBounds();
        bounds.extend(this._bounds);
        return bounds;
    },
    _updateIcon: function() {
        this._iconNeedsUpdate = true;
        if (this._icon) {
            this.setIcon(this);
        }
    },
    createIcon: function() {
        if (this._iconNeedsUpdate) {
            this._iconObj = this._group.options.iconCreateFunction(this);
            this._iconNeedsUpdate = false;
        }
        return this._iconObj.createIcon();
    },
    createShadow: function() {
        return this._iconObj.createShadow();
    },
    _addChild: function(new1, isNotificationFromChild) {
        this._iconNeedsUpdate = true;
        this._boundsNeedUpdate = true;
        this._setClusterCenter(new1);
        if (new1 instanceof L.MarkerCluster) {
            if (!isNotificationFromChild) {
                this._childClusters.push(new1);
                new1.__parent = this;
            }
            this._childCount += new1._childCount;
        } else {
            if (!isNotificationFromChild) {
                this._markers.push(new1);
            }
            this._childCount++;
        }
        if (this.__parent) {
            this.__parent._addChild(new1, true);
        }
    },
    _setClusterCenter: function(child) {
        if (!this._cLatLng) {
            this._cLatLng = child._cLatLng || child._latlng;
        }
    },
    _resetBounds: function() {
        var bounds = this._bounds;
        if (bounds._southWest) {
            bounds._southWest.lat = Infinity;
            bounds._southWest.lng = Infinity;
        }
        if (bounds._northEast) {
            bounds._northEast.lat = -Infinity;
            bounds._northEast.lng = -Infinity;
        }
    },
    _recalculateBounds: function() {
        var markers = this._markers,
            childClusters = this._childClusters,
            latSum = 0,
            lngSum = 0,
            totalCount = this._childCount,
            i, child, childLatLng, childCount;
        if (totalCount === 0) {
            return;
        }
        this._resetBounds();
        for (i = 0; i < markers.length; i++) {
            childLatLng = markers[i]._latlng;
            this._bounds.extend(childLatLng);
            latSum += childLatLng.lat;
            lngSum += childLatLng.lng;
        }
        for (i = 0; i < childClusters.length; i++) {
            child = childClusters[i];
            if (child._boundsNeedUpdate) {
                child._recalculateBounds();
            }
            this._bounds.extend(child._bounds);
            childLatLng = child._wLatLng;
            childCount = child._childCount;
            latSum += childLatLng.lat * childCount;
            lngSum += childLatLng.lng * childCount;
        }
        this._latlng = this._wLatLng = new L.LatLng(latSum / totalCount, lngSum / totalCount);
        this._boundsNeedUpdate = false;
    },
    _addToMap: function(startPos) {
        if (startPos) {
            this._backupLatlng = this._latlng;
            this.setLatLng(startPos);
        }
        this._group._featureGroup.addLayer(this);
    },
    _recursivelyAnimateChildrenIn: function(bounds, center, maxZoom) {
        this._recursively(bounds, 0, maxZoom - 1, function(c) {
            var markers = c._markers,
                i, m;
            for (i = markers.length - 1; i >= 0; i--) {
                m = markers[i];
                if (m._icon) {
                    m._setPos(center);
                    m.clusterHide();
                }
            }
        }, function(c) {
            var childClusters = c._childClusters,
                j, cm;
            for (j = childClusters.length - 1; j >= 0; j--) {
                cm = childClusters[j];
                if (cm._icon) {
                    cm._setPos(center);
                    cm.clusterHide();
                }
            }
        });
    },
    _recursivelyAnimateChildrenInAndAddSelfToMap: function(bounds, previousZoomLevel, newZoomLevel) {
        this._recursively(bounds, newZoomLevel, 0, function(c) {
            c._recursivelyAnimateChildrenIn(bounds, c._group._map.latLngToLayerPoint(c.getLatLng()).round(), previousZoomLevel);
            if (c._isSingleParent() && previousZoomLevel - 1 === newZoomLevel) {
                c.clusterShow();
                c._recursivelyRemoveChildrenFromMap(bounds, previousZoomLevel);
            } else {
                c.clusterHide();
            }
            c._addToMap();
        });
    },
    _recursivelyBecomeVisible: function(bounds, zoomLevel) {
        this._recursively(bounds, 0, zoomLevel, null, function(c) {
            c.clusterShow();
        });
    },
    _recursivelyAddChildrenToMap: function(startPos, zoomLevel, bounds) {
        this._recursively(bounds, -1, zoomLevel, function(c) {
            if (zoomLevel === c._zoom) {
                return;
            }
            for (var i = c._markers.length - 1; i >= 0; i--) {
                var nm = c._markers[i];
                if (!bounds.contains(nm._latlng)) {
                    continue;
                }
                if (startPos) {
                    nm._backupLatlng = nm.getLatLng();
                    nm.setLatLng(startPos);
                    if (nm.clusterHide) {
                        nm.clusterHide();
                    }
                }
                c._group._featureGroup.addLayer(nm);
            }
        }, function(c) {
            c._addToMap(startPos);
        });
    },
    _recursivelyRestoreChildPositions: function(zoomLevel) {
        for (var i = this._markers.length - 1; i >= 0; i--) {
            var nm = this._markers[i];
            if (nm._backupLatlng) {
                nm.setLatLng(nm._backupLatlng);
                delete nm._backupLatlng;
            }
        }
        if (zoomLevel - 1 === this._zoom) {
            for (var j = this._childClusters.length - 1; j >= 0; j--) {
                this._childClusters[j]._restorePosition();
            }
        } else {
            for (var k = this._childClusters.length - 1; k >= 0; k--) {
                this._childClusters[k]._recursivelyRestoreChildPositions(zoomLevel);
            }
        }
    },
    _restorePosition: function() {
        if (this._backupLatlng) {
            this.setLatLng(this._backupLatlng);
            delete this._backupLatlng;
        }
    },
    _recursivelyRemoveChildrenFromMap: function(previousBounds, zoomLevel, exceptBounds) {
        var m, i;
        this._recursively(previousBounds, -1, zoomLevel - 1, function(c) {
            for (i = c._markers.length - 1; i >= 0; i--) {
                m = c._markers[i];
                if (!exceptBounds || !exceptBounds.contains(m._latlng)) {
                    c._group._featureGroup.removeLayer(m);
                    if (m.clusterShow) {
                        m.clusterShow();
                    }
                }
            }
        }, function(c) {
            for (i = c._childClusters.length - 1; i >= 0; i--) {
                m = c._childClusters[i];
                if (!exceptBounds || !exceptBounds.contains(m._latlng)) {
                    c._group._featureGroup.removeLayer(m);
                    if (m.clusterShow) {
                        m.clusterShow();
                    }
                }
            }
        });
    },
    _recursively: function(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel) {
        var childClusters = this._childClusters,
            zoom = this._zoom,
            i, c;
        if (zoomLevelToStart > zoom) {
            for (i = childClusters.length - 1; i >= 0; i--) {
                c = childClusters[i];
                if (boundsToApplyTo.intersects(c._bounds)) {
                    c._recursively(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel);
                }
            }
        } else {
            if (runAtEveryLevel) {
                runAtEveryLevel(this);
            }
            if (runAtBottomLevel && this._zoom === zoomLevelToStop) {
                runAtBottomLevel(this);
            }
            if (zoomLevelToStop > zoom) {
                for (i = childClusters.length - 1; i >= 0; i--) {
                    c = childClusters[i];
                    if (boundsToApplyTo.intersects(c._bounds)) {
                        c._recursively(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel);
                    }
                }
            }
        }
    },
    _isSingleParent: function() {
        return this._childClusters.length > 0 && this._childClusters[0]._childCount === this._childCount;
    }
});

(function(root, factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        define('pdfjs-dist/build/pdf.worker', ['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.pdfjsDistBuildPdfWorker = {}));
    }
}(this, function(exports) {
    'use strict';
    var pdfjsVersion = '1.4.20';
    var pdfjsBuild = 'b15f335';
    var pdfjsFilePath = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : null;
    var pdfjsLibs = {};
    (function pdfjsWrapper() {
        (function(root, factory) {
            {
                factory((root.pdfjsCoreArithmeticDecoder = {}));
            }
        }(this, function(exports) {
            var ArithmeticDecoder = (function ArithmeticDecoderClosure() {
                var QeTable = [{
                    qe: 0x5601,
                    nmps: 1,
                    nlps: 1,
                    switchFlag: 1
                }, {
                    qe: 0x3401,
                    nmps: 2,
                    nlps: 6,
                    switchFlag: 0
                }, {
                    qe: 0x1801,
                    nmps: 3,
                    nlps: 9,
                    switchFlag: 0
                }, {
                    qe: 0x0AC1,
                    nmps: 4,
                    nlps: 12,
                    switchFlag: 0
                }, {
                    qe: 0x0521,
                    nmps: 5,
                    nlps: 29,
                    switchFlag: 0
                }, {
                    qe: 0x0221,
                    nmps: 38,
                    nlps: 33,
                    switchFlag: 0
                }, {
                    qe: 0x5601,
                    nmps: 7,
                    nlps: 6,
                    switchFlag: 1
                }, {
                    qe: 0x5401,
                    nmps: 8,
                    nlps: 14,
                    switchFlag: 0
                }, {
                    qe: 0x4801,
                    nmps: 9,
                    nlps: 14,
                    switchFlag: 0
                }, {
                    qe: 0x3801,
                    nmps: 10,
                    nlps: 14,
                    switchFlag: 0
                }, {
                    qe: 0x3001,
                    nmps: 11,
                    nlps: 17,
                    switchFlag: 0
                }, {
                    qe: 0x2401,
                    nmps: 12,
                    nlps: 18,
                    switchFlag: 0
                }, {
                    qe: 0x1C01,
                    nmps: 13,
                    nlps: 20,
                    switchFlag: 0
                }, {
                    qe: 0x1601,
                    nmps: 29,
                    nlps: 21,
                    switchFlag: 0
                }, {
                    qe: 0x5601,
                    nmps: 15,
                    nlps: 14,
                    switchFlag: 1
                }, {
                    qe: 0x5401,
                    nmps: 16,
                    nlps: 14,
                    switchFlag: 0
                }, {
                    qe: 0x5101,
                    nmps: 17,
                    nlps: 15,
                    switchFlag: 0
                }, {
                    qe: 0x4801,
                    nmps: 18,
                    nlps: 16,
                    switchFlag: 0
                }, {
                    qe: 0x3801,
                    nmps: 19,
                    nlps: 17,
                    switchFlag: 0
                }, {
                    qe: 0x3401,
                    nmps: 20,
                    nlps: 18,
                    switchFlag: 0
                }, {
                    qe: 0x3001,
                    nmps: 21,
                    nlps: 19,
                    switchFlag: 0
                }, {
                    qe: 0x2801,
                    nmps: 22,
                    nlps: 19,
                    switchFlag: 0
                }, {
                    qe: 0x2401,
                    nmps: 23,
                    nlps: 20,
                    switchFlag: 0
                }, {
                    qe: 0x2201,
                    nmps: 24,
                    nlps: 21,
                    switchFlag: 0
                }, {
                    qe: 0x1C01,
                    nmps: 25,
                    nlps: 22,
                    switchFlag: 0
                }, {
                    qe: 0x1801,
                    nmps: 26,
                    nlps: 23,
                    switchFlag: 0
                }, {
                    qe: 0x1601,
                    nmps: 27,
                    nlps: 24,
                    switchFlag: 0
                }, {
                    qe: 0x1401,
                    nmps: 28,
                    nlps: 25,
                    switchFlag: 0
                }, {
                    qe: 0x1201,
                    nmps: 29,
                    nlps: 26,
                    switchFlag: 0
                }, {
                    qe: 0x1101,
                    nmps: 30,
                    nlps: 27,
                    switchFlag: 0
                }, {
                    qe: 0x0AC1,
                    nmps: 31,
                    nlps: 28,
                    switchFlag: 0
                }, {
                    qe: 0x09C1,
                    nmps: 32,
                    nlps: 29,
                    switchFlag: 0
                }, {
                    qe: 0x08A1,
                    nmps: 33,
                    nlps: 30,
                    switchFlag: 0
                }, {
                    qe: 0x0521,
                    nmps: 34,
                    nlps: 31,
                    switchFlag: 0
                }, {
                    qe: 0x0441,
                    nmps: 35,
                    nlps: 32,
                    switchFlag: 0
                }, {
                    qe: 0x02A1,
                    nmps: 36,
                    nlps: 33,
                    switchFlag: 0
                }, {
                    qe: 0x0221,
                    nmps: 37,
                    nlps: 34,
                    switchFlag: 0
                }, {
                    qe: 0x0141,
                    nmps: 38,
                    nlps: 35,
                    switchFlag: 0
                }, {
                    qe: 0x0111,
                    nmps: 39,
                    nlps: 36,
                    switchFlag: 0
                }, {
                    qe: 0x0085,
                    nmps: 40,
                    nlps: 37,
                    switchFlag: 0
                }, {
                    qe: 0x0049,
                    nmps: 41,
                    nlps: 38,
                    switchFlag: 0
                }, {
                    qe: 0x0025,
                    nmps: 42,
                    nlps: 39,
                    switchFlag: 0
                }, {
                    qe: 0x0015,
                    nmps: 43,
                    nlps: 40,
                    switchFlag: 0
                }, {
                    qe: 0x0009,
                    nmps: 44,
                    nlps: 41,
                    switchFlag: 0
                }, {
                    qe: 0x0005,
                    nmps: 45,
                    nlps: 42,
                    switchFlag: 0
                }, {
                    qe: 0x0001,
                    nmps: 45,
                    nlps: 43,
                    switchFlag: 0
                }, {
                    qe: 0x5601,
                    nmps: 46,
                    nlps: 46,
                    switchFlag: 0
                }];

                function ArithmeticDecoder(data, start, end) {
                    this.data = data;
                    this.bp = start;
                    this.dataEnd = end;
                    this.chigh = data[start];
                    this.clow = 0;
                    this.byteIn();
                    this.chigh = ((this.chigh << 7) & 0xFFFF) | ((this.clow >> 9) & 0x7F);
                    this.clow = (this.clow << 7) & 0xFFFF;
                    this.ct -= 7;
                    this.a = 0x8000;
                }
                ArithmeticDecoder.prototype = {
                    byteIn: function ArithmeticDecoder_byteIn() {
                        var data = this.data;
                        var bp = this.bp;
                        if (data[bp] === 0xFF) {
                            var b1 = data[bp + 1];
                            if (b1 > 0x8F) {
                                this.clow += 0xFF00;
                                this.ct = 8;
                            } else {
                                bp++;
                                this.clow += (data[bp] << 9);
                                this.ct = 7;
                                this.bp = bp;
                            }
                        } else {
                            bp++;
                            this.clow += bp < this.dataEnd ? (data[bp] << 8) : 0xFF00;
                            this.ct = 8;
                            this.bp = bp;
                        }
                        if (this.clow > 0xFFFF) {
                            this.chigh += (this.clow >> 16);
                            this.clow &= 0xFFFF;
                        }
                    },
                    readBit: function ArithmeticDecoder_readBit(contexts, pos) {
                        var cx_index = contexts[pos] >> 1,
                            cx_mps = contexts[pos] & 1;
                        var qeTableIcx = QeTable[cx_index];
                        var qeIcx = qeTableIcx.qe;
                        var d;
                        var a = this.a - qeIcx;
                        if (this.chigh < qeIcx) {
                            if (a < qeIcx) {
                                a = qeIcx;
                                d = cx_mps;
                                cx_index = qeTableIcx.nmps;
                            } else {
                                a = qeIcx;
                                d = 1 ^ cx_mps;
                                if (qeTableIcx.switchFlag === 1) {
                                    cx_mps = d;
                                }
                                cx_index = qeTableIcx.nlps;
                            }
                        } else {
                            this.chigh -= qeIcx;
                            if ((a & 0x8000) !== 0) {
                                this.a = a;
                                return cx_mps;
                            }
                            if (a < qeIcx) {
                                d = 1 ^ cx_mps;
                                if (qeTableIcx.switchFlag === 1) {
                                    cx_mps = d;
                                }
                                cx_index = qeTableIcx.nlps;
                            } else {
                                d = cx_mps;
                                cx_index = qeTableIcx.nmps;
                            }
                        }
                        do {
                            if (this.ct === 0) {
                                this.byteIn();
                            }
                            a <<= 1;
                            this.chigh = ((this.chigh << 1) & 0xFFFF) | ((this.clow >> 15) & 1);
                            this.clow = (this.clow << 1) & 0xFFFF;
                            this.ct--;
                        } while ((a & 0x8000) === 0);
                        this.a = a;
                        contexts[pos] = cx_index << 1 | cx_mps;
                        return d;
                    }
                };
                return ArithmeticDecoder;
            })();
            exports.ArithmeticDecoder = ArithmeticDecoder;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsCoreCharsets = {}));
            }
        }(this, function(exports) {
            var ISOAdobeCharset = ['.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand', 'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring', 'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE', 'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu', 'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn', 'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright', 'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex', 'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex', 'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute', 'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute', 'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute', 'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave', 'yacute', 'ydieresis', 'zcaron'];
            var ExpertCharset = ['.notdef', 'space', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior', 'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader', 'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon', 'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior', 'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall', 'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall', 'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall', 'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall', 'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall', 'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', 'onequarter', 'onehalf', 'threequarters', 'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];
            var ExpertSubsetCharset = ['.notdef', 'space', 'dollaroldstyle', 'dollarsuperior', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader', 'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon', 'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior', 'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior', 'parenrightinferior', 'hyphensuperior', 'colonmonetary', 'onefitted', 'rupiah', 'centoldstyle', 'figuredash', 'hypheninferior', 'onequarter', 'onehalf', 'threequarters', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior'];
            exports.ISOAdobeCharset = ISOAdobeCharset;
            exports.ExpertCharset = ExpertCharset;
            exports.ExpertSubsetCharset = ExpertSubsetCharset;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsCoreGlyphList = {}));
            }
        }(this, function(exports) {
            var GlyphsUnicode = {
                A: 0x0041,
                AE: 0x00C6,
                AEacute: 0x01FC,
                AEmacron: 0x01E2,
                AEsmall: 0xF7E6,
                Aacute: 0x00C1,
                Aacutesmall: 0xF7E1,
                Abreve: 0x0102,
                Abreveacute: 0x1EAE,
                Abrevecyrillic: 0x04D0,
                Abrevedotbelow: 0x1EB6,
                Abrevegrave: 0x1EB0,
                Abrevehookabove: 0x1EB2,
                Abrevetilde: 0x1EB4,
                Acaron: 0x01CD,
                Acircle: 0x24B6,
                Acircumflex: 0x00C2,
                Acircumflexacute: 0x1EA4,
                Acircumflexdotbelow: 0x1EAC,
                Acircumflexgrave: 0x1EA6,
                Acircumflexhookabove: 0x1EA8,
                Acircumflexsmall: 0xF7E2,
                Acircumflextilde: 0x1EAA,
                Acute: 0xF6C9,
                Acutesmall: 0xF7B4,
                Acyrillic: 0x0410,
                Adblgrave: 0x0200,
                Adieresis: 0x00C4,
                Adieresiscyrillic: 0x04D2,
                Adieresismacron: 0x01DE,
                Adieresissmall: 0xF7E4,
                Adotbelow: 0x1EA0,
                Adotmacron: 0x01E0,
                Agrave: 0x00C0,
                Agravesmall: 0xF7E0,
                Ahookabove: 0x1EA2,
                Aiecyrillic: 0x04D4,
                Ainvertedbreve: 0x0202,
                Alpha: 0x0391,
                Alphatonos: 0x0386,
                Amacron: 0x0100,
                Amonospace: 0xFF21,
                Aogonek: 0x0104,
                Aring: 0x00C5,
                Aringacute: 0x01FA,
                Aringbelow: 0x1E00,
                Aringsmall: 0xF7E5,
                Asmall: 0xF761,
                Atilde: 0x00C3,
                Atildesmall: 0xF7E3,
                Aybarmenian: 0x0531,
                B: 0x0042,
                Bcircle: 0x24B7,
                Bdotaccent: 0x1E02,
                Bdotbelow: 0x1E04,
                Becyrillic: 0x0411,
                Benarmenian: 0x0532,
                Beta: 0x0392,
                Bhook: 0x0181,
                Blinebelow: 0x1E06,
                Bmonospace: 0xFF22,
                Brevesmall: 0xF6F4,
                Bsmall: 0xF762,
                Btopbar: 0x0182,
                C: 0x0043,
                Caarmenian: 0x053E,
                Cacute: 0x0106,
                Caron: 0xF6CA,
                Caronsmall: 0xF6F5,
                Ccaron: 0x010C,
                Ccedilla: 0x00C7,
                Ccedillaacute: 0x1E08,
                Ccedillasmall: 0xF7E7,
                Ccircle: 0x24B8,
                Ccircumflex: 0x0108,
                Cdot: 0x010A,
                Cdotaccent: 0x010A,
                Cedillasmall: 0xF7B8,
                Chaarmenian: 0x0549,
                Cheabkhasiancyrillic: 0x04BC,
                Checyrillic: 0x0427,
                Chedescenderabkhasiancyrillic: 0x04BE,
                Chedescendercyrillic: 0x04B6,
                Chedieresiscyrillic: 0x04F4,
                Cheharmenian: 0x0543,
                Chekhakassiancyrillic: 0x04CB,
                Cheverticalstrokecyrillic: 0x04B8,
                Chi: 0x03A7,
                Chook: 0x0187,
                Circumflexsmall: 0xF6F6,
                Cmonospace: 0xFF23,
                Coarmenian: 0x0551,
                Csmall: 0xF763,
                D: 0x0044,
                DZ: 0x01F1,
                DZcaron: 0x01C4,
                Daarmenian: 0x0534,
                Dafrican: 0x0189,
                Dcaron: 0x010E,
                Dcedilla: 0x1E10,
                Dcircle: 0x24B9,
                Dcircumflexbelow: 0x1E12,
                Dcroat: 0x0110,
                Ddotaccent: 0x1E0A,
                Ddotbelow: 0x1E0C,
                Decyrillic: 0x0414,
                Deicoptic: 0x03EE,
                Delta: 0x2206,
                Deltagreek: 0x0394,
                Dhook: 0x018A,
                Dieresis: 0xF6CB,
                DieresisAcute: 0xF6CC,
                DieresisGrave: 0xF6CD,
                Dieresissmall: 0xF7A8,
                Digammagreek: 0x03DC,
                Djecyrillic: 0x0402,
                Dlinebelow: 0x1E0E,
                Dmonospace: 0xFF24,
                Dotaccentsmall: 0xF6F7,
                Dslash: 0x0110,
                Dsmall: 0xF764,
                Dtopbar: 0x018B,
                Dz: 0x01F2,
                Dzcaron: 0x01C5,
                Dzeabkhasiancyrillic: 0x04E0,
                Dzecyrillic: 0x0405,
                Dzhecyrillic: 0x040F,
                E: 0x0045,
                Eacute: 0x00C9,
                Eacutesmall: 0xF7E9,
                Ebreve: 0x0114,
                Ecaron: 0x011A,
                Ecedillabreve: 0x1E1C,
                Echarmenian: 0x0535,
                Ecircle: 0x24BA,
                Ecircumflex: 0x00CA,
                Ecircumflexacute: 0x1EBE,
                Ecircumflexbelow: 0x1E18,
                Ecircumflexdotbelow: 0x1EC6,
                Ecircumflexgrave: 0x1EC0,
                Ecircumflexhookabove: 0x1EC2,
                Ecircumflexsmall: 0xF7EA,
                Ecircumflextilde: 0x1EC4,
                Ecyrillic: 0x0404,
                Edblgrave: 0x0204,
                Edieresis: 0x00CB,
                Edieresissmall: 0xF7EB,
                Edot: 0x0116,
                Edotaccent: 0x0116,
                Edotbelow: 0x1EB8,
                Efcyrillic: 0x0424,
                Egrave: 0x00C8,
                Egravesmall: 0xF7E8,
                Eharmenian: 0x0537,
                Ehookabove: 0x1EBA,
                Eightroman: 0x2167,
                Einvertedbreve: 0x0206,
                Eiotifiedcyrillic: 0x0464,
                Elcyrillic: 0x041B,
                Elevenroman: 0x216A,
                Emacron: 0x0112,
                Emacronacute: 0x1E16,
                Emacrongrave: 0x1E14,
                Emcyrillic: 0x041C,
                Emonospace: 0xFF25,
                Encyrillic: 0x041D,
                Endescendercyrillic: 0x04A2,
                Eng: 0x014A,
                Enghecyrillic: 0x04A4,
                Enhookcyrillic: 0x04C7,
                Eogonek: 0x0118,
                Eopen: 0x0190,
                Epsilon: 0x0395,
                Epsilontonos: 0x0388,
                Ercyrillic: 0x0420,
                Ereversed: 0x018E,
                Ereversedcyrillic: 0x042D,
                Escyrillic: 0x0421,
                Esdescendercyrillic: 0x04AA,
                Esh: 0x01A9,
                Esmall: 0xF765,
                Eta: 0x0397,
                Etarmenian: 0x0538,
                Etatonos: 0x0389,
                Eth: 0x00D0,
                Ethsmall: 0xF7F0,
                Etilde: 0x1EBC,
                Etildebelow: 0x1E1A,
                Euro: 0x20AC,
                Ezh: 0x01B7,
                Ezhcaron: 0x01EE,
                Ezhreversed: 0x01B8,
                F: 0x0046,
                Fcircle: 0x24BB,
                Fdotaccent: 0x1E1E,
                Feharmenian: 0x0556,
                Feicoptic: 0x03E4,
                Fhook: 0x0191,
                Fitacyrillic: 0x0472,
                Fiveroman: 0x2164,
                Fmonospace: 0xFF26,
                Fourroman: 0x2163,
                Fsmall: 0xF766,
                G: 0x0047,
                GBsquare: 0x3387,
                Gacute: 0x01F4,
                Gamma: 0x0393,
                Gammaafrican: 0x0194,
                Gangiacoptic: 0x03EA,
                Gbreve: 0x011E,
                Gcaron: 0x01E6,
                Gcedilla: 0x0122,
                Gcircle: 0x24BC,
                Gcircumflex: 0x011C,
                Gcommaaccent: 0x0122,
                Gdot: 0x0120,
                Gdotaccent: 0x0120,
                Gecyrillic: 0x0413,
                Ghadarmenian: 0x0542,
                Ghemiddlehookcyrillic: 0x0494,
                Ghestrokecyrillic: 0x0492,
                Gheupturncyrillic: 0x0490,
                Ghook: 0x0193,
                Gimarmenian: 0x0533,
                Gjecyrillic: 0x0403,
                Gmacron: 0x1E20,
                Gmonospace: 0xFF27,
                Grave: 0xF6CE,
                Gravesmall: 0xF760,
                Gsmall: 0xF767,
                Gsmallhook: 0x029B,
                Gstroke: 0x01E4,
                H: 0x0048,
                H18533: 0x25CF,
                H18543: 0x25AA,
                H18551: 0x25AB,
                H22073: 0x25A1,
                HPsquare: 0x33CB,
                Haabkhasiancyrillic: 0x04A8,
                Hadescendercyrillic: 0x04B2,
                Hardsigncyrillic: 0x042A,
                Hbar: 0x0126,
                Hbrevebelow: 0x1E2A,
                Hcedilla: 0x1E28,
                Hcircle: 0x24BD,
                Hcircumflex: 0x0124,
                Hdieresis: 0x1E26,
                Hdotaccent: 0x1E22,
                Hdotbelow: 0x1E24,
                Hmonospace: 0xFF28,
                Hoarmenian: 0x0540,
                Horicoptic: 0x03E8,
                Hsmall: 0xF768,
                Hungarumlaut: 0xF6CF,
                Hungarumlautsmall: 0xF6F8,
                Hzsquare: 0x3390,
                I: 0x0049,
                IAcyrillic: 0x042F,
                IJ: 0x0132,
                IUcyrillic: 0x042E,
                Iacute: 0x00CD,
                Iacutesmall: 0xF7ED,
                Ibreve: 0x012C,
                Icaron: 0x01CF,
                Icircle: 0x24BE,
                Icircumflex: 0x00CE,
                Icircumflexsmall: 0xF7EE,
                Icyrillic: 0x0406,
                Idblgrave: 0x0208,
                Idieresis: 0x00CF,
                Idieresisacute: 0x1E2E,
                Idieresiscyrillic: 0x04E4,
                Idieresissmall: 0xF7EF,
                Idot: 0x0130,
                Idotaccent: 0x0130,
                Idotbelow: 0x1ECA,
                Iebrevecyrillic: 0x04D6,
                Iecyrillic: 0x0415,
                Ifraktur: 0x2111,
                Igrave: 0x00CC,
                Igravesmall: 0xF7EC,
                Ihookabove: 0x1EC8,
                Iicyrillic: 0x0418,
                Iinvertedbreve: 0x020A,
                Iishortcyrillic: 0x0419,
                Imacron: 0x012A,
                Imacroncyrillic: 0x04E2,
                Imonospace: 0xFF29,
                Iniarmenian: 0x053B,
                Iocyrillic: 0x0401,
                Iogonek: 0x012E,
                Iota: 0x0399,
                Iotaafrican: 0x0196,
                Iotadieresis: 0x03AA,
                Iotatonos: 0x038A,
                Ismall: 0xF769,
                Istroke: 0x0197,
                Itilde: 0x0128,
                Itildebelow: 0x1E2C,
                Izhitsacyrillic: 0x0474,
                Izhitsadblgravecyrillic: 0x0476,
                J: 0x004A,
                Jaarmenian: 0x0541,
                Jcircle: 0x24BF,
                Jcircumflex: 0x0134,
                Jecyrillic: 0x0408,
                Jheharmenian: 0x054B,
                Jmonospace: 0xFF2A,
                Jsmall: 0xF76A,
                K: 0x004B,
                KBsquare: 0x3385,
                KKsquare: 0x33CD,
                Kabashkircyrillic: 0x04A0,
                Kacute: 0x1E30,
                Kacyrillic: 0x041A,
                Kadescendercyrillic: 0x049A,
                Kahookcyrillic: 0x04C3,
                Kappa: 0x039A,
                Kastrokecyrillic: 0x049E,
                Kaverticalstrokecyrillic: 0x049C,
                Kcaron: 0x01E8,
                Kcedilla: 0x0136,
                Kcircle: 0x24C0,
                Kcommaaccent: 0x0136,
                Kdotbelow: 0x1E32,
                Keharmenian: 0x0554,
                Kenarmenian: 0x053F,
                Khacyrillic: 0x0425,
                Kheicoptic: 0x03E6,
                Khook: 0x0198,
                Kjecyrillic: 0x040C,
                Klinebelow: 0x1E34,
                Kmonospace: 0xFF2B,
                Koppacyrillic: 0x0480,
                Koppagreek: 0x03DE,
                Ksicyrillic: 0x046E,
                Ksmall: 0xF76B,
                L: 0x004C,
                LJ: 0x01C7,
                LL: 0xF6BF,
                Lacute: 0x0139,
                Lambda: 0x039B,
                Lcaron: 0x013D,
                Lcedilla: 0x013B,
                Lcircle: 0x24C1,
                Lcircumflexbelow: 0x1E3C,
                Lcommaaccent: 0x013B,
                Ldot: 0x013F,
                Ldotaccent: 0x013F,
                Ldotbelow: 0x1E36,
                Ldotbelowmacron: 0x1E38,
                Liwnarmenian: 0x053C,
                Lj: 0x01C8,
                Ljecyrillic: 0x0409,
                Llinebelow: 0x1E3A,
                Lmonospace: 0xFF2C,
                Lslash: 0x0141,
                Lslashsmall: 0xF6F9,
                Lsmall: 0xF76C,
                M: 0x004D,
                MBsquare: 0x3386,
                Macron: 0xF6D0,
                Macronsmall: 0xF7AF,
                Macute: 0x1E3E,
                Mcircle: 0x24C2,
                Mdotaccent: 0x1E40,
                Mdotbelow: 0x1E42,
                Menarmenian: 0x0544,
                Mmonospace: 0xFF2D,
                Msmall: 0xF76D,
                Mturned: 0x019C,
                Mu: 0x039C,
                N: 0x004E,
                NJ: 0x01CA,
                Nacute: 0x0143,
                Ncaron: 0x0147,
                Ncedilla: 0x0145,
                Ncircle: 0x24C3,
                Ncircumflexbelow: 0x1E4A,
                Ncommaaccent: 0x0145,
                Ndotaccent: 0x1E44,
                Ndotbelow: 0x1E46,
                Nhookleft: 0x019D,
                Nineroman: 0x2168,
                Nj: 0x01CB,
                Njecyrillic: 0x040A,
                Nlinebelow: 0x1E48,
                Nmonospace: 0xFF2E,
                Nowarmenian: 0x0546,
                Nsmall: 0xF76E,
                Ntilde: 0x00D1,
                Ntildesmall: 0xF7F1,
                Nu: 0x039D,
                O: 0x004F,
                OE: 0x0152,
                OEsmall: 0xF6FA,
                Oacute: 0x00D3,
                Oacutesmall: 0xF7F3,
                Obarredcyrillic: 0x04E8,
                Obarreddieresiscyrillic: 0x04EA,
                Obreve: 0x014E,
                Ocaron: 0x01D1,
                Ocenteredtilde: 0x019F,
                Ocircle: 0x24C4,
                Ocircumflex: 0x00D4,
                Ocircumflexacute: 0x1ED0,
                Ocircumflexdotbelow: 0x1ED8,
                Ocircumflexgrave: 0x1ED2,
                Ocircumflexhookabove: 0x1ED4,
                Ocircumflexsmall: 0xF7F4,
                Ocircumflextilde: 0x1ED6,
                Ocyrillic: 0x041E,
                Odblacute: 0x0150,
                Odblgrave: 0x020C,
                Odieresis: 0x00D6,
                Odieresiscyrillic: 0x04E6,
                Odieresissmall: 0xF7F6,
                Odotbelow: 0x1ECC,
                Ogoneksmall: 0xF6FB,
                Ograve: 0x00D2,
                Ogravesmall: 0xF7F2,
                Oharmenian: 0x0555,
                Ohm: 0x2126,
                Ohookabove: 0x1ECE,
                Ohorn: 0x01A0,
                Ohornacute: 0x1EDA,
                Ohorndotbelow: 0x1EE2,
                Ohorngrave: 0x1EDC,
                Ohornhookabove: 0x1EDE,
                Ohorntilde: 0x1EE0,
                Ohungarumlaut: 0x0150,
                Oi: 0x01A2,
                Oinvertedbreve: 0x020E,
                Omacron: 0x014C,
                Omacronacute: 0x1E52,
                Omacrongrave: 0x1E50,
                Omega: 0x2126,
                Omegacyrillic: 0x0460,
                Omegagreek: 0x03A9,
                Omegaroundcyrillic: 0x047A,
                Omegatitlocyrillic: 0x047C,
                Omegatonos: 0x038F,
                Omicron: 0x039F,
                Omicrontonos: 0x038C,
                Omonospace: 0xFF2F,
                Oneroman: 0x2160,
                Oogonek: 0x01EA,
                Oogonekmacron: 0x01EC,
                Oopen: 0x0186,
                Oslash: 0x00D8,
                Oslashacute: 0x01FE,
                Oslashsmall: 0xF7F8,
                Osmall: 0xF76F,
                Ostrokeacute: 0x01FE,
                Otcyrillic: 0x047E,
                Otilde: 0x00D5,
                Otildeacute: 0x1E4C,
                Otildedieresis: 0x1E4E,
                Otildesmall: 0xF7F5,
                P: 0x0050,
                Pacute: 0x1E54,
                Pcircle: 0x24C5,
                Pdotaccent: 0x1E56,
                Pecyrillic: 0x041F,
                Peharmenian: 0x054A,
                Pemiddlehookcyrillic: 0x04A6,
                Phi: 0x03A6,
                Phook: 0x01A4,
                Pi: 0x03A0,
                Piwrarmenian: 0x0553,
                Pmonospace: 0xFF30,
                Psi: 0x03A8,
                Psicyrillic: 0x0470,
                Psmall: 0xF770,
                Q: 0x0051,
                Qcircle: 0x24C6,
                Qmonospace: 0xFF31,
                Qsmall: 0xF771,
                R: 0x0052,
                Raarmenian: 0x054C,
                Racute: 0x0154,
                Rcaron: 0x0158,
                Rcedilla: 0x0156,
                Rcircle: 0x24C7,
                Rcommaaccent: 0x0156,
                Rdblgrave: 0x0210,
                Rdotaccent: 0x1E58,
                Rdotbelow: 0x1E5A,
                Rdotbelowmacron: 0x1E5C,
                Reharmenian: 0x0550,
                Rfraktur: 0x211C,
                Rho: 0x03A1,
                Ringsmall: 0xF6FC,
                Rinvertedbreve: 0x0212,
                Rlinebelow: 0x1E5E,
                Rmonospace: 0xFF32,
                Rsmall: 0xF772,
                Rsmallinverted: 0x0281,
                Rsmallinvertedsuperior: 0x02B6,
                S: 0x0053,
                SF010000: 0x250C,
                SF020000: 0x2514,
                SF030000: 0x2510,
                SF040000: 0x2518,
                SF050000: 0x253C,
                SF060000: 0x252C,
                SF070000: 0x2534,
                SF080000: 0x251C,
                SF090000: 0x2524,
                SF100000: 0x2500,
                SF110000: 0x2502,
                SF190000: 0x2561,
                SF200000: 0x2562,
                SF210000: 0x2556,
                SF220000: 0x2555,
                SF230000: 0x2563,
                SF240000: 0x2551,
                SF250000: 0x2557,
                SF260000: 0x255D,
                SF270000: 0x255C,
                SF280000: 0x255B,
                SF360000: 0x255E,
                SF370000: 0x255F,
                SF380000: 0x255A,
                SF390000: 0x2554,
                SF400000: 0x2569,
                SF410000: 0x2566,
                SF420000: 0x2560,
                SF430000: 0x2550,
                SF440000: 0x256C,
                SF450000: 0x2567,
                SF460000: 0x2568,
                SF470000: 0x2564,
                SF480000: 0x2565,
                SF490000: 0x2559,
                SF500000: 0x2558,
                SF510000: 0x2552,
                SF520000: 0x2553,
                SF530000: 0x256B,
                SF540000: 0x256A,
                Sacute: 0x015A,
                Sacutedotaccent: 0x1E64,
                Sampigreek: 0x03E0,
                Scaron: 0x0160,
                Scarondotaccent: 0x1E66,
                Scaronsmall: 0xF6FD,
                Scedilla: 0x015E,
                Schwa: 0x018F,
                Schwacyrillic: 0x04D8,
                Schwadieresiscyrillic: 0x04DA,
                Scircle: 0x24C8,
                Scircumflex: 0x015C,
                Scommaaccent: 0x0218,
                Sdotaccent: 0x1E60,
                Sdotbelow: 0x1E62,
                Sdotbelowdotaccent: 0x1E68,
                Seharmenian: 0x054D,
                Sevenroman: 0x2166,
                Shaarmenian: 0x0547,
                Shacyrillic: 0x0428,
                Shchacyrillic: 0x0429,
                Sheicoptic: 0x03E2,
                Shhacyrillic: 0x04BA,
                Shimacoptic: 0x03EC,
                Sigma: 0x03A3,
                Sixroman: 0x2165,
                Smonospace: 0xFF33,
                Softsigncyrillic: 0x042C,
                Ssmall: 0xF773,
                Stigmagreek: 0x03DA,
                T: 0x0054,
                Tau: 0x03A4,
                Tbar: 0x0166,
                Tcaron: 0x0164,
                Tcedilla: 0x0162,
                Tcircle: 0x24C9,
                Tcircumflexbelow: 0x1E70,
                Tcommaaccent: 0x0162,
                Tdotaccent: 0x1E6A,
                Tdotbelow: 0x1E6C,
                Tecyrillic: 0x0422,
                Tedescendercyrillic: 0x04AC,
                Tenroman: 0x2169,
                Tetsecyrillic: 0x04B4,
                Theta: 0x0398,
                Thook: 0x01AC,
                Thorn: 0x00DE,
                Thornsmall: 0xF7FE,
                Threeroman: 0x2162,
                Tildesmall: 0xF6FE,
                Tiwnarmenian: 0x054F,
                Tlinebelow: 0x1E6E,
                Tmonospace: 0xFF34,
                Toarmenian: 0x0539,
                Tonefive: 0x01BC,
                Tonesix: 0x0184,
                Tonetwo: 0x01A7,
                Tretroflexhook: 0x01AE,
                Tsecyrillic: 0x0426,
                Tshecyrillic: 0x040B,
                Tsmall: 0xF774,
                Twelveroman: 0x216B,
                Tworoman: 0x2161,
                U: 0x0055,
                Uacute: 0x00DA,
                Uacutesmall: 0xF7FA,
                Ubreve: 0x016C,
                Ucaron: 0x01D3,
                Ucircle: 0x24CA,
                Ucircumflex: 0x00DB,
                Ucircumflexbelow: 0x1E76,
                Ucircumflexsmall: 0xF7FB,
                Ucyrillic: 0x0423,
                Udblacute: 0x0170,
                Udblgrave: 0x0214,
                Udieresis: 0x00DC,
                Udieresisacute: 0x01D7,
                Udieresisbelow: 0x1E72,
                Udieresiscaron: 0x01D9,
                Udieresiscyrillic: 0x04F0,
                Udieresisgrave: 0x01DB,
                Udieresismacron: 0x01D5,
                Udieresissmall: 0xF7FC,
                Udotbelow: 0x1EE4,
                Ugrave: 0x00D9,
                Ugravesmall: 0xF7F9,
                Uhookabove: 0x1EE6,
                Uhorn: 0x01AF,
                Uhornacute: 0x1EE8,
                Uhorndotbelow: 0x1EF0,
                Uhorngrave: 0x1EEA,
                Uhornhookabove: 0x1EEC,
                Uhorntilde: 0x1EEE,
                Uhungarumlaut: 0x0170,
                Uhungarumlautcyrillic: 0x04F2,
                Uinvertedbreve: 0x0216,
                Ukcyrillic: 0x0478,
                Umacron: 0x016A,
                Umacroncyrillic: 0x04EE,
                Umacrondieresis: 0x1E7A,
                Umonospace: 0xFF35,
                Uogonek: 0x0172,
                Upsilon: 0x03A5,
                Upsilon1: 0x03D2,
                Upsilonacutehooksymbolgreek: 0x03D3,
                Upsilonafrican: 0x01B1,
                Upsilondieresis: 0x03AB,
                Upsilondieresishooksymbolgreek: 0x03D4,
                Upsilonhooksymbol: 0x03D2,
                Upsilontonos: 0x038E,
                Uring: 0x016E,
                Ushortcyrillic: 0x040E,
                Usmall: 0xF775,
                Ustraightcyrillic: 0x04AE,
                Ustraightstrokecyrillic: 0x04B0,
                Utilde: 0x0168,
                Utildeacute: 0x1E78,
                Utildebelow: 0x1E74,
                V: 0x0056,
                Vcircle: 0x24CB,
                Vdotbelow: 0x1E7E,
                Vecyrillic: 0x0412,
                Vewarmenian: 0x054E,
                Vhook: 0x01B2,
                Vmonospace: 0xFF36,
                Voarmenian: 0x0548,
                Vsmall: 0xF776,
                Vtilde: 0x1E7C,
                W: 0x0057,
                Wacute: 0x1E82,
                Wcircle: 0x24CC,
                Wcircumflex: 0x0174,
                Wdieresis: 0x1E84,
                Wdotaccent: 0x1E86,
                Wdotbelow: 0x1E88,
                Wgrave: 0x1E80,
                Wmonospace: 0xFF37,
                Wsmall: 0xF777,
                X: 0x0058,
                Xcircle: 0x24CD,
                Xdieresis: 0x1E8C,
                Xdotaccent: 0x1E8A,
                Xeharmenian: 0x053D,
                Xi: 0x039E,
                Xmonospace: 0xFF38,
                Xsmall: 0xF778,
                Y: 0x0059,
                Yacute: 0x00DD,
                Yacutesmall: 0xF7FD,
                Yatcyrillic: 0x0462,
                Ycircle: 0x24CE,
                Ycircumflex: 0x0176,
                Ydieresis: 0x0178,
                Ydieresissmall: 0xF7FF,
                Ydotaccent: 0x1E8E,
                Ydotbelow: 0x1EF4,
                Yericyrillic: 0x042B,
                Yerudieresiscyrillic: 0x04F8,
                Ygrave: 0x1EF2,
                Yhook: 0x01B3,
                Yhookabove: 0x1EF6,
                Yiarmenian: 0x0545,
                Yicyrillic: 0x0407,
                Yiwnarmenian: 0x0552,
                Ymonospace: 0xFF39,
                Ysmall: 0xF779,
                Ytilde: 0x1EF8,
                Yusbigcyrillic: 0x046A,
                Yusbigiotifiedcyrillic: 0x046C,
                Yuslittlecyrillic: 0x0466,
                Yuslittleiotifiedcyrillic: 0x0468,
                Z: 0x005A,
                Zaarmenian: 0x0536,
                Zacute: 0x0179,
                Zcaron: 0x017D,
                Zcaronsmall: 0xF6FF,
                Zcircle: 0x24CF,
                Zcircumflex: 0x1E90,
                Zdot: 0x017B,
                Zdotaccent: 0x017B,
                Zdotbelow: 0x1E92,
                Zecyrillic: 0x0417,
                Zedescendercyrillic: 0x0498,
                Zedieresiscyrillic: 0x04DE,
                Zeta: 0x0396,
                Zhearmenian: 0x053A,
                Zhebrevecyrillic: 0x04C1,
                Zhecyrillic: 0x0416,
                Zhedescendercyrillic: 0x0496,
                Zhedieresiscyrillic: 0x04DC,
                Zlinebelow: 0x1E94,
                Zmonospace: 0xFF3A,
                Zsmall: 0xF77A,
                Zstroke: 0x01B5,
                a: 0x0061,
                aabengali: 0x0986,
                aacute: 0x00E1,
                aadeva: 0x0906,
                aagujarati: 0x0A86,
                aagurmukhi: 0x0A06,
                aamatragurmukhi: 0x0A3E,
                aarusquare: 0x3303,
                aavowelsignbengali: 0x09BE,
                aavowelsigndeva: 0x093E,
                aavowelsigngujarati: 0x0ABE,
                abbreviationmarkarmenian: 0x055F,
                abbreviationsigndeva: 0x0970,
                abengali: 0x0985,
                abopomofo: 0x311A,
                abreve: 0x0103,
                abreveacute: 0x1EAF,
                abrevecyrillic: 0x04D1,
                abrevedotbelow: 0x1EB7,
                abrevegrave: 0x1EB1,
                abrevehookabove: 0x1EB3,
                abrevetilde: 0x1EB5,
                acaron: 0x01CE,
                acircle: 0x24D0,
                acircumflex: 0x00E2,
                acircumflexacute: 0x1EA5,
                acircumflexdotbelow: 0x1EAD,
                acircumflexgrave: 0x1EA7,
                acircumflexhookabove: 0x1EA9,
                acircumflextilde: 0x1EAB,
                acute: 0x00B4,
                acutebelowcmb: 0x0317,
                acutecmb: 0x0301,
                acutecomb: 0x0301,
                acutedeva: 0x0954,
                acutelowmod: 0x02CF,
                acutetonecmb: 0x0341,
                acyrillic: 0x0430,
                adblgrave: 0x0201,
                addakgurmukhi: 0x0A71,
                adeva: 0x0905,
                adieresis: 0x00E4,
                adieresiscyrillic: 0x04D3,
                adieresismacron: 0x01DF,
                adotbelow: 0x1EA1,
                adotmacron: 0x01E1,
                ae: 0x00E6,
                aeacute: 0x01FD,
                aekorean: 0x3150,
                aemacron: 0x01E3,
                afii00208: 0x2015,
                afii08941: 0x20A4,
                afii10017: 0x0410,
                afii10018: 0x0411,
                afii10019: 0x0412,
                afii10020: 0x0413,
                afii10021: 0x0414,
                afii10022: 0x0415,
                afii10023: 0x0401,
                afii10024: 0x0416,
                afii10025: 0x0417,
                afii10026: 0x0418,
                afii10027: 0x0419,
                afii10028: 0x041A,
                afii10029: 0x041B,
                afii10030: 0x041C,
                afii10031: 0x041D,
                afii10032: 0x041E,
                afii10033: 0x041F,
                afii10034: 0x0420,
                afii10035: 0x0421,
                afii10036: 0x0422,
                afii10037: 0x0423,
                afii10038: 0x0424,
                afii10039: 0x0425,
                afii10040: 0x0426,
                afii10041: 0x0427,
                afii10042: 0x0428,
                afii10043: 0x0429,
                afii10044: 0x042A,
                afii10045: 0x042B,
                afii10046: 0x042C,
                afii10047: 0x042D,
                afii10048: 0x042E,
                afii10049: 0x042F,
                afii10050: 0x0490,
                afii10051: 0x0402,
                afii10052: 0x0403,
                afii10053: 0x0404,
                afii10054: 0x0405,
                afii10055: 0x0406,
                afii10056: 0x0407,
                afii10057: 0x0408,
                afii10058: 0x0409,
                afii10059: 0x040A,
                afii10060: 0x040B,
                afii10061: 0x040C,
                afii10062: 0x040E,
                afii10063: 0xF6C4,
                afii10064: 0xF6C5,
                afii10065: 0x0430,
                afii10066: 0x0431,
                afii10067: 0x0432,
                afii10068: 0x0433,
                afii10069: 0x0434,
                afii10070: 0x0435,
                afii10071: 0x0451,
                afii10072: 0x0436,
                afii10073: 0x0437,
                afii10074: 0x0438,
                afii10075: 0x0439,
                afii10076: 0x043A,
                afii10077: 0x043B,
                afii10078: 0x043C,
                afii10079: 0x043D,
                afii10080: 0x043E,
                afii10081: 0x043F,
                afii10082: 0x0440,
                afii10083: 0x0441,
                afii10084: 0x0442,
                afii10085: 0x0443,
                afii10086: 0x0444,
                afii10087: 0x0445,
                afii10088: 0x0446,
                afii10089: 0x0447,
                afii10090: 0x0448,
                afii10091: 0x0449,
                afii10092: 0x044A,
                afii10093: 0x044B,
                afii10094: 0x044C,
                afii10095: 0x044D,
                afii10096: 0x044E,
                afii10097: 0x044F,
                afii10098: 0x0491,
                afii10099: 0x0452,
                afii10100: 0x0453,
                afii10101: 0x0454,
                afii10102: 0x0455,
                afii10103: 0x0456,
                afii10104: 0x0457,
                afii10105: 0x0458,
                afii10106: 0x0459,
                afii10107: 0x045A,
                afii10108: 0x045B,
                afii10109: 0x045C,
                afii10110: 0x045E,
                afii10145: 0x040F,
                afii10146: 0x0462,
                afii10147: 0x0472,
                afii10148: 0x0474,
                afii10192: 0xF6C6,
                afii10193: 0x045F,
                afii10194: 0x0463,
                afii10195: 0x0473,
                afii10196: 0x0475,
                afii10831: 0xF6C7,
                afii10832: 0xF6C8,
                afii10846: 0x04D9,
                afii299: 0x200E,
                afii300: 0x200F,
                afii301: 0x200D,
                afii57381: 0x066A,
                afii57388: 0x060C,
                afii57392: 0x0660,
                afii57393: 0x0661,
                afii57394: 0x0662,
                afii57395: 0x0663,
                afii57396: 0x0664,
                afii57397: 0x0665,
                afii57398: 0x0666,
                afii57399: 0x0667,
                afii57400: 0x0668,
                afii57401: 0x0669,
                afii57403: 0x061B,
                afii57407: 0x061F,
                afii57409: 0x0621,
                afii57410: 0x0622,
                afii57411: 0x0623,
                afii57412: 0x0624,
                afii57413: 0x0625,
                afii57414: 0x0626,
                afii57415: 0x0627,
                afii57416: 0x0628,
                afii57417: 0x0629,
                afii57418: 0x062A,
                afii57419: 0x062B,
                afii57420: 0x062C,
                afii57421: 0x062D,
                afii57422: 0x062E,
                afii57423: 0x062F,
                afii57424: 0x0630,
                afii57425: 0x0631,
                afii57426: 0x0632,
                afii57427: 0x0633,
                afii57428: 0x0634,
                afii57429: 0x0635,
                afii57430: 0x0636,
                afii57431: 0x0637,
                afii57432: 0x0638,
                afii57433: 0x0639,
                afii57434: 0x063A,
                afii57440: 0x0640,
                afii57441: 0x0641,
                afii57442: 0x0642,
                afii57443: 0x0643,
                afii57444: 0x0644,
                afii57445: 0x0645,
                afii57446: 0x0646,
                afii57448: 0x0648,
                afii57449: 0x0649,
                afii57450: 0x064A,
                afii57451: 0x064B,
                afii57452: 0x064C,
                afii57453: 0x064D,
                afii57454: 0x064E,
                afii57455: 0x064F,
                afii57456: 0x0650,
                afii57457: 0x0651,
                afii57458: 0x0652,
                afii57470: 0x0647,
                afii57505: 0x06A4,
                afii57506: 0x067E,
                afii57507: 0x0686,
                afii57508: 0x0698,
                afii57509: 0x06AF,
                afii57511: 0x0679,
                afii57512: 0x0688,
                afii57513: 0x0691,
                afii57514: 0x06BA,
                afii57519: 0x06D2,
                afii57534: 0x06D5,
                afii57636: 0x20AA,
                afii57645: 0x05BE,
                afii57658: 0x05C3,
                afii57664: 0x05D0,
                afii57665: 0x05D1,
                afii57666: 0x05D2,
                afii57667: 0x05D3,
                afii57668: 0x05D4,
                afii57669: 0x05D5,
                afii57670: 0x05D6,
                afii57671: 0x05D7,
                afii57672: 0x05D8,
                afii57673: 0x05D9,
                afii57674: 0x05DA,
                afii57675: 0x05DB,
                afii57676: 0x05DC,
                afii57677: 0x05DD,
                afii57678: 0x05DE,
                afii57679: 0x05DF,
                afii57680: 0x05E0,
                afii57681: 0x05E1,
                afii57682: 0x05E2,
                afii57683: 0x05E3,
                afii57684: 0x05E4,
                afii57685: 0x05E5,
                afii57686: 0x05E6,
                afii57687: 0x05E7,
                afii57688: 0x05E8,
                afii57689: 0x05E9,
                afii57690: 0x05EA,
                afii57694: 0xFB2A,
                afii57695: 0xFB2B,
                afii57700: 0xFB4B,
                afii57705: 0xFB1F,
                afii57716: 0x05F0,
                afii57717: 0x05F1,
                afii57718: 0x05F2,
                afii57723: 0xFB35,
                afii57793: 0x05B4,
                afii57794: 0x05B5,
                afii57795: 0x05B6,
                afii57796: 0x05BB,
                afii57797: 0x05B8,
                afii57798: 0x05B7,
                afii57799: 0x05B0,
                afii57800: 0x05B2,
                afii57801: 0x05B1,
                afii57802: 0x05B3,
                afii57803: 0x05C2,
                afii57804: 0x05C1,
                afii57806: 0x05B9,
                afii57807: 0x05BC,
                afii57839: 0x05BD,
                afii57841: 0x05BF,
                afii57842: 0x05C0,
                afii57929: 0x02BC,
                afii61248: 0x2105,
                afii61289: 0x2113,
                afii61352: 0x2116,
                afii61573: 0x202C,
                afii61574: 0x202D,
                afii61575: 0x202E,
                afii61664: 0x200C,
                afii63167: 0x066D,
                afii64937: 0x02BD,
                agrave: 0x00E0,
                agujarati: 0x0A85,
                agurmukhi: 0x0A05,
                ahiragana: 0x3042,
                ahookabove: 0x1EA3,
                aibengali: 0x0990,
                aibopomofo: 0x311E,
                aideva: 0x0910,
                aiecyrillic: 0x04D5,
                aigujarati: 0x0A90,
                aigurmukhi: 0x0A10,
                aimatragurmukhi: 0x0A48,
                ainarabic: 0x0639,
                ainfinalarabic: 0xFECA,
                aininitialarabic: 0xFECB,
                ainmedialarabic: 0xFECC,
                ainvertedbreve: 0x0203,
                aivowelsignbengali: 0x09C8,
                aivowelsigndeva: 0x0948,
                aivowelsigngujarati: 0x0AC8,
                akatakana: 0x30A2,
                akatakanahalfwidth: 0xFF71,
                akorean: 0x314F,
                alef: 0x05D0,
                alefarabic: 0x0627,
                alefdageshhebrew: 0xFB30,
                aleffinalarabic: 0xFE8E,
                alefhamzaabovearabic: 0x0623,
                alefhamzaabovefinalarabic: 0xFE84,
                alefhamzabelowarabic: 0x0625,
                alefhamzabelowfinalarabic: 0xFE88,
                alefhebrew: 0x05D0,
                aleflamedhebrew: 0xFB4F,
                alefmaddaabovearabic: 0x0622,
                alefmaddaabovefinalarabic: 0xFE82,
                alefmaksuraarabic: 0x0649,
                alefmaksurafinalarabic: 0xFEF0,
                alefmaksurainitialarabic: 0xFEF3,
                alefmaksuramedialarabic: 0xFEF4,
                alefpatahhebrew: 0xFB2E,
                alefqamatshebrew: 0xFB2F,
                aleph: 0x2135,
                allequal: 0x224C,
                alpha: 0x03B1,
                alphatonos: 0x03AC,
                amacron: 0x0101,
                amonospace: 0xFF41,
                ampersand: 0x0026,
                ampersandmonospace: 0xFF06,
                ampersandsmall: 0xF726,
                amsquare: 0x33C2,
                anbopomofo: 0x3122,
                angbopomofo: 0x3124,
                angbracketleft: 0x3008,
                angbracketright: 0x3009,
                angkhankhuthai: 0x0E5A,
                angle: 0x2220,
                anglebracketleft: 0x3008,
                anglebracketleftvertical: 0xFE3F,
                anglebracketright: 0x3009,
                anglebracketrightvertical: 0xFE40,
                angleleft: 0x2329,
                angleright: 0x232A,
                angstrom: 0x212B,
                anoteleia: 0x0387,
                anudattadeva: 0x0952,
                anusvarabengali: 0x0982,
                anusvaradeva: 0x0902,
                anusvaragujarati: 0x0A82,
                aogonek: 0x0105,
                apaatosquare: 0x3300,
                aparen: 0x249C,
                apostrophearmenian: 0x055A,
                apostrophemod: 0x02BC,
                apple: 0xF8FF,
                approaches: 0x2250,
                approxequal: 0x2248,
                approxequalorimage: 0x2252,
                approximatelyequal: 0x2245,
                araeaekorean: 0x318E,
                araeakorean: 0x318D,
                arc: 0x2312,
                arighthalfring: 0x1E9A,
                aring: 0x00E5,
                aringacute: 0x01FB,
                aringbelow: 0x1E01,
                arrowboth: 0x2194,
                arrowdashdown: 0x21E3,
                arrowdashleft: 0x21E0,
                arrowdashright: 0x21E2,
                arrowdashup: 0x21E1,
                arrowdblboth: 0x21D4,
                arrowdbldown: 0x21D3,
                arrowdblleft: 0x21D0,
                arrowdblright: 0x21D2,
                arrowdblup: 0x21D1,
                arrowdown: 0x2193,
                arrowdownleft: 0x2199,
                arrowdownright: 0x2198,
                arrowdownwhite: 0x21E9,
                arrowheaddownmod: 0x02C5,
                arrowheadleftmod: 0x02C2,
                arrowheadrightmod: 0x02C3,
                arrowheadupmod: 0x02C4,
                arrowhorizex: 0xF8E7,
                arrowleft: 0x2190,
                arrowleftdbl: 0x21D0,
                arrowleftdblstroke: 0x21CD,
                arrowleftoverright: 0x21C6,
                arrowleftwhite: 0x21E6,
                arrowright: 0x2192,
                arrowrightdblstroke: 0x21CF,
                arrowrightheavy: 0x279E,
                arrowrightoverleft: 0x21C4,
                arrowrightwhite: 0x21E8,
                arrowtableft: 0x21E4,
                arrowtabright: 0x21E5,
                arrowup: 0x2191,
                arrowupdn: 0x2195,
                arrowupdnbse: 0x21A8,
                arrowupdownbase: 0x21A8,
                arrowupleft: 0x2196,
                arrowupleftofdown: 0x21C5,
                arrowupright: 0x2197,
                arrowupwhite: 0x21E7,
                arrowvertex: 0xF8E6,
                asciicircum: 0x005E,
                asciicircummonospace: 0xFF3E,
                asciitilde: 0x007E,
                asciitildemonospace: 0xFF5E,
                ascript: 0x0251,
                ascriptturned: 0x0252,
                asmallhiragana: 0x3041,
                asmallkatakana: 0x30A1,
                asmallkatakanahalfwidth: 0xFF67,
                asterisk: 0x002A,
                asteriskaltonearabic: 0x066D,
                asteriskarabic: 0x066D,
                asteriskmath: 0x2217,
                asteriskmonospace: 0xFF0A,
                asterisksmall: 0xFE61,
                asterism: 0x2042,
                asuperior: 0xF6E9,
                asymptoticallyequal: 0x2243,
                at: 0x0040,
                atilde: 0x00E3,
                atmonospace: 0xFF20,
                atsmall: 0xFE6B,
                aturned: 0x0250,
                aubengali: 0x0994,
                aubopomofo: 0x3120,
                audeva: 0x0914,
                augujarati: 0x0A94,
                augurmukhi: 0x0A14,
                aulengthmarkbengali: 0x09D7,
                aumatragurmukhi: 0x0A4C,
                auvowelsignbengali: 0x09CC,
                auvowelsigndeva: 0x094C,
                auvowelsigngujarati: 0x0ACC,
                avagrahadeva: 0x093D,
                aybarmenian: 0x0561,
                ayin: 0x05E2,
                ayinaltonehebrew: 0xFB20,
                ayinhebrew: 0x05E2,
                b: 0x0062,
                babengali: 0x09AC,
                backslash: 0x005C,
                backslashmonospace: 0xFF3C,
                badeva: 0x092C,
                bagujarati: 0x0AAC,
                bagurmukhi: 0x0A2C,
                bahiragana: 0x3070,
                bahtthai: 0x0E3F,
                bakatakana: 0x30D0,
                bar: 0x007C,
                barmonospace: 0xFF5C,
                bbopomofo: 0x3105,
                bcircle: 0x24D1,
                bdotaccent: 0x1E03,
                bdotbelow: 0x1E05,
                beamedsixteenthnotes: 0x266C,
                because: 0x2235,
                becyrillic: 0x0431,
                beharabic: 0x0628,
                behfinalarabic: 0xFE90,
                behinitialarabic: 0xFE91,
                behiragana: 0x3079,
                behmedialarabic: 0xFE92,
                behmeeminitialarabic: 0xFC9F,
                behmeemisolatedarabic: 0xFC08,
                behnoonfinalarabic: 0xFC6D,
                bekatakana: 0x30D9,
                benarmenian: 0x0562,
                bet: 0x05D1,
                beta: 0x03B2,
                betasymbolgreek: 0x03D0,
                betdagesh: 0xFB31,
                betdageshhebrew: 0xFB31,
                bethebrew: 0x05D1,
                betrafehebrew: 0xFB4C,
                bhabengali: 0x09AD,
                bhadeva: 0x092D,
                bhagujarati: 0x0AAD,
                bhagurmukhi: 0x0A2D,
                bhook: 0x0253,
                bihiragana: 0x3073,
                bikatakana: 0x30D3,
                bilabialclick: 0x0298,
                bindigurmukhi: 0x0A02,
                birusquare: 0x3331,
                blackcircle: 0x25CF,
                blackdiamond: 0x25C6,
                blackdownpointingtriangle: 0x25BC,
                blackleftpointingpointer: 0x25C4,
                blackleftpointingtriangle: 0x25C0,
                blacklenticularbracketleft: 0x3010,
                blacklenticularbracketleftvertical: 0xFE3B,
                blacklenticularbracketright: 0x3011,
                blacklenticularbracketrightvertical: 0xFE3C,
                blacklowerlefttriangle: 0x25E3,
                blacklowerrighttriangle: 0x25E2,
                blackrectangle: 0x25AC,
                blackrightpointingpointer: 0x25BA,
                blackrightpointingtriangle: 0x25B6,
                blacksmallsquare: 0x25AA,
                blacksmilingface: 0x263B,
                blacksquare: 0x25A0,
                blackstar: 0x2605,
                blackupperlefttriangle: 0x25E4,
                blackupperrighttriangle: 0x25E5,
                blackuppointingsmalltriangle: 0x25B4,
                blackuppointingtriangle: 0x25B2,
                blank: 0x2423,
                blinebelow: 0x1E07,
                block: 0x2588,
                bmonospace: 0xFF42,
                bobaimaithai: 0x0E1A,
                bohiragana: 0x307C,
                bokatakana: 0x30DC,
                bparen: 0x249D,
                bqsquare: 0x33C3,
                braceex: 0xF8F4,
                braceleft: 0x007B,
                braceleftbt: 0xF8F3,
                braceleftmid: 0xF8F2,
                braceleftmonospace: 0xFF5B,
                braceleftsmall: 0xFE5B,
                bracelefttp: 0xF8F1,
                braceleftvertical: 0xFE37,
                braceright: 0x007D,
                bracerightbt: 0xF8FE,
                bracerightmid: 0xF8FD,
                bracerightmonospace: 0xFF5D,
                bracerightsmall: 0xFE5C,
                bracerighttp: 0xF8FC,
                bracerightvertical: 0xFE38,
                bracketleft: 0x005B,
                bracketleftbt: 0xF8F0,
                bracketleftex: 0xF8EF,
                bracketleftmonospace: 0xFF3B,
                bracketlefttp: 0xF8EE,
                bracketright: 0x005D,
                bracketrightbt: 0xF8FB,
                bracketrightex: 0xF8FA,
                bracketrightmonospace: 0xFF3D,
                bracketrighttp: 0xF8F9,
                breve: 0x02D8,
                brevebelowcmb: 0x032E,
                brevecmb: 0x0306,
                breveinvertedbelowcmb: 0x032F,
                breveinvertedcmb: 0x0311,
                breveinverteddoublecmb: 0x0361,
                bridgebelowcmb: 0x032A,
                bridgeinvertedbelowcmb: 0x033A,
                brokenbar: 0x00A6,
                bstroke: 0x0180,
                bsuperior: 0xF6EA,
                btopbar: 0x0183,
                buhiragana: 0x3076,
                bukatakana: 0x30D6,
                bullet: 0x2022,
                bulletinverse: 0x25D8,
                bulletoperator: 0x2219,
                bullseye: 0x25CE,
                c: 0x0063,
                caarmenian: 0x056E,
                cabengali: 0x099A,
                cacute: 0x0107,
                cadeva: 0x091A,
                cagujarati: 0x0A9A,
                cagurmukhi: 0x0A1A,
                calsquare: 0x3388,
                candrabindubengali: 0x0981,
                candrabinducmb: 0x0310,
                candrabindudeva: 0x0901,
                candrabindugujarati: 0x0A81,
                capslock: 0x21EA,
                careof: 0x2105,
                caron: 0x02C7,
                caronbelowcmb: 0x032C,
                caroncmb: 0x030C,
                carriagereturn: 0x21B5,
                cbopomofo: 0x3118,
                ccaron: 0x010D,
                ccedilla: 0x00E7,
                ccedillaacute: 0x1E09,
                ccircle: 0x24D2,
                ccircumflex: 0x0109,
                ccurl: 0x0255,
                cdot: 0x010B,
                cdotaccent: 0x010B,
                cdsquare: 0x33C5,
                cedilla: 0x00B8,
                cedillacmb: 0x0327,
                cent: 0x00A2,
                centigrade: 0x2103,
                centinferior: 0xF6DF,
                centmonospace: 0xFFE0,
                centoldstyle: 0xF7A2,
                centsuperior: 0xF6E0,
                chaarmenian: 0x0579,
                chabengali: 0x099B,
                chadeva: 0x091B,
                chagujarati: 0x0A9B,
                chagurmukhi: 0x0A1B,
                chbopomofo: 0x3114,
                cheabkhasiancyrillic: 0x04BD,
                checkmark: 0x2713,
                checyrillic: 0x0447,
                chedescenderabkhasiancyrillic: 0x04BF,
                chedescendercyrillic: 0x04B7,
                chedieresiscyrillic: 0x04F5,
                cheharmenian: 0x0573,
                chekhakassiancyrillic: 0x04CC,
                cheverticalstrokecyrillic: 0x04B9,
                chi: 0x03C7,
                chieuchacirclekorean: 0x3277,
                chieuchaparenkorean: 0x3217,
                chieuchcirclekorean: 0x3269,
                chieuchkorean: 0x314A,
                chieuchparenkorean: 0x3209,
                chochangthai: 0x0E0A,
                chochanthai: 0x0E08,
                chochingthai: 0x0E09,
                chochoethai: 0x0E0C,
                chook: 0x0188,
                cieucacirclekorean: 0x3276,
                cieucaparenkorean: 0x3216,
                cieuccirclekorean: 0x3268,
                cieuckorean: 0x3148,
                cieucparenkorean: 0x3208,
                cieucuparenkorean: 0x321C,
                circle: 0x25CB,
                circlecopyrt: 0x00A9,
                circlemultiply: 0x2297,
                circleot: 0x2299,
                circleplus: 0x2295,
                circlepostalmark: 0x3036,
                circlewithlefthalfblack: 0x25D0,
                circlewithrighthalfblack: 0x25D1,
                circumflex: 0x02C6,
                circumflexbelowcmb: 0x032D,
                circumflexcmb: 0x0302,
                clear: 0x2327,
                clickalveolar: 0x01C2,
                clickdental: 0x01C0,
                clicklateral: 0x01C1,
                clickretroflex: 0x01C3,
                club: 0x2663,
                clubsuitblack: 0x2663,
                clubsuitwhite: 0x2667,
                cmcubedsquare: 0x33A4,
                cmonospace: 0xFF43,
                cmsquaredsquare: 0x33A0,
                coarmenian: 0x0581,
                colon: 0x003A,
                colonmonetary: 0x20A1,
                colonmonospace: 0xFF1A,
                colonsign: 0x20A1,
                colonsmall: 0xFE55,
                colontriangularhalfmod: 0x02D1,
                colontriangularmod: 0x02D0,
                comma: 0x002C,
                commaabovecmb: 0x0313,
                commaaboverightcmb: 0x0315,
                commaaccent: 0xF6C3,
                commaarabic: 0x060C,
                commaarmenian: 0x055D,
                commainferior: 0xF6E1,
                commamonospace: 0xFF0C,
                commareversedabovecmb: 0x0314,
                commareversedmod: 0x02BD,
                commasmall: 0xFE50,
                commasuperior: 0xF6E2,
                commaturnedabovecmb: 0x0312,
                commaturnedmod: 0x02BB,
                compass: 0x263C,
                congruent: 0x2245,
                contourintegral: 0x222E,
                control: 0x2303,
                controlACK: 0x0006,
                controlBEL: 0x0007,
                controlBS: 0x0008,
                controlCAN: 0x0018,
                controlCR: 0x000D,
                controlDC1: 0x0011,
                controlDC2: 0x0012,
                controlDC3: 0x0013,
                controlDC4: 0x0014,
                controlDEL: 0x007F,
                controlDLE: 0x0010,
                controlEM: 0x0019,
                controlENQ: 0x0005,
                controlEOT: 0x0004,
                controlESC: 0x001B,
                controlETB: 0x0017,
                controlETX: 0x0003,
                controlFF: 0x000C,
                controlFS: 0x001C,
                controlGS: 0x001D,
                controlHT: 0x0009,
                controlLF: 0x000A,
                controlNAK: 0x0015,
                controlRS: 0x001E,
                controlSI: 0x000F,
                controlSO: 0x000E,
                controlSOT: 0x0002,
                controlSTX: 0x0001,
                controlSUB: 0x001A,
                controlSYN: 0x0016,
                controlUS: 0x001F,
                controlVT: 0x000B,
                copyright: 0x00A9,
                copyrightsans: 0xF8E9,
                copyrightserif: 0xF6D9,
                cornerbracketleft: 0x300C,
                cornerbracketlefthalfwidth: 0xFF62,
                cornerbracketleftvertical: 0xFE41,
                cornerbracketright: 0x300D,
                cornerbracketrighthalfwidth: 0xFF63,
                cornerbracketrightvertical: 0xFE42,
                corporationsquare: 0x337F,
                cosquare: 0x33C7,
                coverkgsquare: 0x33C6,
                cparen: 0x249E,
                cruzeiro: 0x20A2,
                cstretched: 0x0297,
                curlyand: 0x22CF,
                curlyor: 0x22CE,
                currency: 0x00A4,
                cyrBreve: 0xF6D1,
                cyrFlex: 0xF6D2,
                cyrbreve: 0xF6D4,
                cyrflex: 0xF6D5,
                d: 0x0064,
                daarmenian: 0x0564,
                dabengali: 0x09A6,
                dadarabic: 0x0636,
                dadeva: 0x0926,
                dadfinalarabic: 0xFEBE,
                dadinitialarabic: 0xFEBF,
                dadmedialarabic: 0xFEC0,
                dagesh: 0x05BC,
                dageshhebrew: 0x05BC,
                dagger: 0x2020,
                daggerdbl: 0x2021,
                dagujarati: 0x0AA6,
                dagurmukhi: 0x0A26,
                dahiragana: 0x3060,
                dakatakana: 0x30C0,
                dalarabic: 0x062F,
                dalet: 0x05D3,
                daletdagesh: 0xFB33,
                daletdageshhebrew: 0xFB33,
                dalethebrew: 0x05D3,
                dalfinalarabic: 0xFEAA,
                dammaarabic: 0x064F,
                dammalowarabic: 0x064F,
                dammatanaltonearabic: 0x064C,
                dammatanarabic: 0x064C,
                danda: 0x0964,
                dargahebrew: 0x05A7,
                dargalefthebrew: 0x05A7,
                dasiapneumatacyrilliccmb: 0x0485,
                dblGrave: 0xF6D3,
                dblanglebracketleft: 0x300A,
                dblanglebracketleftvertical: 0xFE3D,
                dblanglebracketright: 0x300B,
                dblanglebracketrightvertical: 0xFE3E,
                dblarchinvertedbelowcmb: 0x032B,
                dblarrowleft: 0x21D4,
                dblarrowright: 0x21D2,
                dbldanda: 0x0965,
                dblgrave: 0xF6D6,
                dblgravecmb: 0x030F,
                dblintegral: 0x222C,
                dbllowline: 0x2017,
                dbllowlinecmb: 0x0333,
                dbloverlinecmb: 0x033F,
                dblprimemod: 0x02BA,
                dblverticalbar: 0x2016,
                dblverticallineabovecmb: 0x030E,
                dbopomofo: 0x3109,
                dbsquare: 0x33C8,
                dcaron: 0x010F,
                dcedilla: 0x1E11,
                dcircle: 0x24D3,
                dcircumflexbelow: 0x1E13,
                dcroat: 0x0111,
                ddabengali: 0x09A1,
                ddadeva: 0x0921,
                ddagujarati: 0x0AA1,
                ddagurmukhi: 0x0A21,
                ddalarabic: 0x0688,
                ddalfinalarabic: 0xFB89,
                dddhadeva: 0x095C,
                ddhabengali: 0x09A2,
                ddhadeva: 0x0922,
                ddhagujarati: 0x0AA2,
                ddhagurmukhi: 0x0A22,
                ddotaccent: 0x1E0B,
                ddotbelow: 0x1E0D,
                decimalseparatorarabic: 0x066B,
                decimalseparatorpersian: 0x066B,
                decyrillic: 0x0434,
                degree: 0x00B0,
                dehihebrew: 0x05AD,
                dehiragana: 0x3067,
                deicoptic: 0x03EF,
                dekatakana: 0x30C7,
                deleteleft: 0x232B,
                deleteright: 0x2326,
                delta: 0x03B4,
                deltaturned: 0x018D,
                denominatorminusonenumeratorbengali: 0x09F8,
                dezh: 0x02A4,
                dhabengali: 0x09A7,
                dhadeva: 0x0927,
                dhagujarati: 0x0AA7,
                dhagurmukhi: 0x0A27,
                dhook: 0x0257,
                dialytikatonos: 0x0385,
                dialytikatonoscmb: 0x0344,
                diamond: 0x2666,
                diamondsuitwhite: 0x2662,
                dieresis: 0x00A8,
                dieresisacute: 0xF6D7,
                dieresisbelowcmb: 0x0324,
                dieresiscmb: 0x0308,
                dieresisgrave: 0xF6D8,
                dieresistonos: 0x0385,
                dihiragana: 0x3062,
                dikatakana: 0x30C2,
                dittomark: 0x3003,
                divide: 0x00F7,
                divides: 0x2223,
                divisionslash: 0x2215,
                djecyrillic: 0x0452,
                dkshade: 0x2593,
                dlinebelow: 0x1E0F,
                dlsquare: 0x3397,
                dmacron: 0x0111,
                dmonospace: 0xFF44,
                dnblock: 0x2584,
                dochadathai: 0x0E0E,
                dodekthai: 0x0E14,
                dohiragana: 0x3069,
                dokatakana: 0x30C9,
                dollar: 0x0024,
                dollarinferior: 0xF6E3,
                dollarmonospace: 0xFF04,
                dollaroldstyle: 0xF724,
                dollarsmall: 0xFE69,
                dollarsuperior: 0xF6E4,
                dong: 0x20AB,
                dorusquare: 0x3326,
                dotaccent: 0x02D9,
                dotaccentcmb: 0x0307,
                dotbelowcmb: 0x0323,
                dotbelowcomb: 0x0323,
                dotkatakana: 0x30FB,
                dotlessi: 0x0131,
                dotlessj: 0xF6BE,
                dotlessjstrokehook: 0x0284,
                dotmath: 0x22C5,
                dottedcircle: 0x25CC,
                doubleyodpatah: 0xFB1F,
                doubleyodpatahhebrew: 0xFB1F,
                downtackbelowcmb: 0x031E,
                downtackmod: 0x02D5,
                dparen: 0x249F,
                dsuperior: 0xF6EB,
                dtail: 0x0256,
                dtopbar: 0x018C,
                duhiragana: 0x3065,
                dukatakana: 0x30C5,
                dz: 0x01F3,
                dzaltone: 0x02A3,
                dzcaron: 0x01C6,
                dzcurl: 0x02A5,
                dzeabkhasiancyrillic: 0x04E1,
                dzecyrillic: 0x0455,
                dzhecyrillic: 0x045F,
                e: 0x0065,
                eacute: 0x00E9,
                earth: 0x2641,
                ebengali: 0x098F,
                ebopomofo: 0x311C,
                ebreve: 0x0115,
                ecandradeva: 0x090D,
                ecandragujarati: 0x0A8D,
                ecandravowelsigndeva: 0x0945,
                ecandravowelsigngujarati: 0x0AC5,
                ecaron: 0x011B,
                ecedillabreve: 0x1E1D,
                echarmenian: 0x0565,
                echyiwnarmenian: 0x0587,
                ecircle: 0x24D4,
                ecircumflex: 0x00EA,
                ecircumflexacute: 0x1EBF,
                ecircumflexbelow: 0x1E19,
                ecircumflexdotbelow: 0x1EC7,
                ecircumflexgrave: 0x1EC1,
                ecircumflexhookabove: 0x1EC3,
                ecircumflextilde: 0x1EC5,
                ecyrillic: 0x0454,
                edblgrave: 0x0205,
                edeva: 0x090F,
                edieresis: 0x00EB,
                edot: 0x0117,
                edotaccent: 0x0117,
                edotbelow: 0x1EB9,
                eegurmukhi: 0x0A0F,
                eematragurmukhi: 0x0A47,
                efcyrillic: 0x0444,
                egrave: 0x00E8,
                egujarati: 0x0A8F,
                eharmenian: 0x0567,
                ehbopomofo: 0x311D,
                ehiragana: 0x3048,
                ehookabove: 0x1EBB,
                eibopomofo: 0x311F,
                eight: 0x0038,
                eightarabic: 0x0668,
                eightbengali: 0x09EE,
                eightcircle: 0x2467,
                eightcircleinversesansserif: 0x2791,
                eightdeva: 0x096E,
                eighteencircle: 0x2471,
                eighteenparen: 0x2485,
                eighteenperiod: 0x2499,
                eightgujarati: 0x0AEE,
                eightgurmukhi: 0x0A6E,
                eighthackarabic: 0x0668,
                eighthangzhou: 0x3028,
                eighthnotebeamed: 0x266B,
                eightideographicparen: 0x3227,
                eightinferior: 0x2088,
                eightmonospace: 0xFF18,
                eightoldstyle: 0xF738,
                eightparen: 0x247B,
                eightperiod: 0x248F,
                eightpersian: 0x06F8,
                eightroman: 0x2177,
                eightsuperior: 0x2078,
                eightthai: 0x0E58,
                einvertedbreve: 0x0207,
                eiotifiedcyrillic: 0x0465,
                ekatakana: 0x30A8,
                ekatakanahalfwidth: 0xFF74,
                ekonkargurmukhi: 0x0A74,
                ekorean: 0x3154,
                elcyrillic: 0x043B,
                element: 0x2208,
                elevencircle: 0x246A,
                elevenparen: 0x247E,
                elevenperiod: 0x2492,
                elevenroman: 0x217A,
                ellipsis: 0x2026,
                ellipsisvertical: 0x22EE,
                emacron: 0x0113,
                emacronacute: 0x1E17,
                emacrongrave: 0x1E15,
                emcyrillic: 0x043C,
                emdash: 0x2014,
                emdashvertical: 0xFE31,
                emonospace: 0xFF45,
                emphasismarkarmenian: 0x055B,
                emptyset: 0x2205,
                enbopomofo: 0x3123,
                encyrillic: 0x043D,
                endash: 0x2013,
                endashvertical: 0xFE32,
                endescendercyrillic: 0x04A3,
                eng: 0x014B,
                engbopomofo: 0x3125,
                enghecyrillic: 0x04A5,
                enhookcyrillic: 0x04C8,
                enspace: 0x2002,
                eogonek: 0x0119,
                eokorean: 0x3153,
                eopen: 0x025B,
                eopenclosed: 0x029A,
                eopenreversed: 0x025C,
                eopenreversedclosed: 0x025E,
                eopenreversedhook: 0x025D,
                eparen: 0x24A0,
                epsilon: 0x03B5,
                epsilontonos: 0x03AD,
                equal: 0x003D,
                equalmonospace: 0xFF1D,
                equalsmall: 0xFE66,
                equalsuperior: 0x207C,
                equivalence: 0x2261,
                erbopomofo: 0x3126,
                ercyrillic: 0x0440,
                ereversed: 0x0258,
                ereversedcyrillic: 0x044D,
                escyrillic: 0x0441,
                esdescendercyrillic: 0x04AB,
                esh: 0x0283,
                eshcurl: 0x0286,
                eshortdeva: 0x090E,
                eshortvowelsigndeva: 0x0946,
                eshreversedloop: 0x01AA,
                eshsquatreversed: 0x0285,
                esmallhiragana: 0x3047,
                esmallkatakana: 0x30A7,
                esmallkatakanahalfwidth: 0xFF6A,
                estimated: 0x212E,
                esuperior: 0xF6EC,
                eta: 0x03B7,
                etarmenian: 0x0568,
                etatonos: 0x03AE,
                eth: 0x00F0,
                etilde: 0x1EBD,
                etildebelow: 0x1E1B,
                etnahtafoukhhebrew: 0x0591,
                etnahtafoukhlefthebrew: 0x0591,
                etnahtahebrew: 0x0591,
                etnahtalefthebrew: 0x0591,
                eturned: 0x01DD,
                eukorean: 0x3161,
                euro: 0x20AC,
                evowelsignbengali: 0x09C7,
                evowelsigndeva: 0x0947,
                evowelsigngujarati: 0x0AC7,
                exclam: 0x0021,
                exclamarmenian: 0x055C,
                exclamdbl: 0x203C,
                exclamdown: 0x00A1,
                exclamdownsmall: 0xF7A1,
                exclammonospace: 0xFF01,
                exclamsmall: 0xF721,
                existential: 0x2203,
                ezh: 0x0292,
                ezhcaron: 0x01EF,
                ezhcurl: 0x0293,
                ezhreversed: 0x01B9,
                ezhtail: 0x01BA,
                f: 0x0066,
                fadeva: 0x095E,
                fagurmukhi: 0x0A5E,
                fahrenheit: 0x2109,
                fathaarabic: 0x064E,
                fathalowarabic: 0x064E,
                fathatanarabic: 0x064B,
                fbopomofo: 0x3108,
                fcircle: 0x24D5,
                fdotaccent: 0x1E1F,
                feharabic: 0x0641,
                feharmenian: 0x0586,
                fehfinalarabic: 0xFED2,
                fehinitialarabic: 0xFED3,
                fehmedialarabic: 0xFED4,
                feicoptic: 0x03E5,
                female: 0x2640,
                ff: 0xFB00,
                ffi: 0xFB03,
                ffl: 0xFB04,
                fi: 0xFB01,
                fifteencircle: 0x246E,
                fifteenparen: 0x2482,
                fifteenperiod: 0x2496,
                figuredash: 0x2012,
                filledbox: 0x25A0,
                filledrect: 0x25AC,
                finalkaf: 0x05DA,
                finalkafdagesh: 0xFB3A,
                finalkafdageshhebrew: 0xFB3A,
                finalkafhebrew: 0x05DA,
                finalmem: 0x05DD,
                finalmemhebrew: 0x05DD,
                finalnun: 0x05DF,
                finalnunhebrew: 0x05DF,
                finalpe: 0x05E3,
                finalpehebrew: 0x05E3,
                finaltsadi: 0x05E5,
                finaltsadihebrew: 0x05E5,
                firsttonechinese: 0x02C9,
                fisheye: 0x25C9,
                fitacyrillic: 0x0473,
                five: 0x0035,
                fivearabic: 0x0665,
                fivebengali: 0x09EB,
                fivecircle: 0x2464,
                fivecircleinversesansserif: 0x278E,
                fivedeva: 0x096B,
                fiveeighths: 0x215D,
                fivegujarati: 0x0AEB,
                fivegurmukhi: 0x0A6B,
                fivehackarabic: 0x0665,
                fivehangzhou: 0x3025,
                fiveideographicparen: 0x3224,
                fiveinferior: 0x2085,
                fivemonospace: 0xFF15,
                fiveoldstyle: 0xF735,
                fiveparen: 0x2478,
                fiveperiod: 0x248C,
                fivepersian: 0x06F5,
                fiveroman: 0x2174,
                fivesuperior: 0x2075,
                fivethai: 0x0E55,
                fl: 0xFB02,
                florin: 0x0192,
                fmonospace: 0xFF46,
                fmsquare: 0x3399,
                fofanthai: 0x0E1F,
                fofathai: 0x0E1D,
                fongmanthai: 0x0E4F,
                forall: 0x2200,
                four: 0x0034,
                fourarabic: 0x0664,
                fourbengali: 0x09EA,
                fourcircle: 0x2463,
                fourcircleinversesansserif: 0x278D,
                fourdeva: 0x096A,
                fourgujarati: 0x0AEA,
                fourgurmukhi: 0x0A6A,
                fourhackarabic: 0x0664,
                fourhangzhou: 0x3024,
                fourideographicparen: 0x3223,
                fourinferior: 0x2084,
                fourmonospace: 0xFF14,
                fournumeratorbengali: 0x09F7,
                fouroldstyle: 0xF734,
                fourparen: 0x2477,
                fourperiod: 0x248B,
                fourpersian: 0x06F4,
                fourroman: 0x2173,
                foursuperior: 0x2074,
                fourteencircle: 0x246D,
                fourteenparen: 0x2481,
                fourteenperiod: 0x2495,
                fourthai: 0x0E54,
                fourthtonechinese: 0x02CB,
                fparen: 0x24A1,
                fraction: 0x2044,
                franc: 0x20A3,
                g: 0x0067,
                gabengali: 0x0997,
                gacute: 0x01F5,
                gadeva: 0x0917,
                gafarabic: 0x06AF,
                gaffinalarabic: 0xFB93,
                gafinitialarabic: 0xFB94,
                gafmedialarabic: 0xFB95,
                gagujarati: 0x0A97,
                gagurmukhi: 0x0A17,
                gahiragana: 0x304C,
                gakatakana: 0x30AC,
                gamma: 0x03B3,
                gammalatinsmall: 0x0263,
                gammasuperior: 0x02E0,
                gangiacoptic: 0x03EB,
                gbopomofo: 0x310D,
                gbreve: 0x011F,
                gcaron: 0x01E7,
                gcedilla: 0x0123,
                gcircle: 0x24D6,
                gcircumflex: 0x011D,
                gcommaaccent: 0x0123,
                gdot: 0x0121,
                gdotaccent: 0x0121,
                gecyrillic: 0x0433,
                gehiragana: 0x3052,
                gekatakana: 0x30B2,
                geometricallyequal: 0x2251,
                gereshaccenthebrew: 0x059C,
                gereshhebrew: 0x05F3,
                gereshmuqdamhebrew: 0x059D,
                germandbls: 0x00DF,
                gershayimaccenthebrew: 0x059E,
                gershayimhebrew: 0x05F4,
                getamark: 0x3013,
                ghabengali: 0x0998,
                ghadarmenian: 0x0572,
                ghadeva: 0x0918,
                ghagujarati: 0x0A98,
                ghagurmukhi: 0x0A18,
                ghainarabic: 0x063A,
                ghainfinalarabic: 0xFECE,
                ghaininitialarabic: 0xFECF,
                ghainmedialarabic: 0xFED0,
                ghemiddlehookcyrillic: 0x0495,
                ghestrokecyrillic: 0x0493,
                gheupturncyrillic: 0x0491,
                ghhadeva: 0x095A,
                ghhagurmukhi: 0x0A5A,
                ghook: 0x0260,
                ghzsquare: 0x3393,
                gihiragana: 0x304E,
                gikatakana: 0x30AE,
                gimarmenian: 0x0563,
                gimel: 0x05D2,
                gimeldagesh: 0xFB32,
                gimeldageshhebrew: 0xFB32,
                gimelhebrew: 0x05D2,
                gjecyrillic: 0x0453,
                glottalinvertedstroke: 0x01BE,
                glottalstop: 0x0294,
                glottalstopinverted: 0x0296,
                glottalstopmod: 0x02C0,
                glottalstopreversed: 0x0295,
                glottalstopreversedmod: 0x02C1,
                glottalstopreversedsuperior: 0x02E4,
                glottalstopstroke: 0x02A1,
                glottalstopstrokereversed: 0x02A2,
                gmacron: 0x1E21,
                gmonospace: 0xFF47,
                gohiragana: 0x3054,
                gokatakana: 0x30B4,
                gparen: 0x24A2,
                gpasquare: 0x33AC,
                gradient: 0x2207,
                grave: 0x0060,
                gravebelowcmb: 0x0316,
                gravecmb: 0x0300,
                gravecomb: 0x0300,
                gravedeva: 0x0953,
                gravelowmod: 0x02CE,
                gravemonospace: 0xFF40,
                gravetonecmb: 0x0340,
                greater: 0x003E,
                greaterequal: 0x2265,
                greaterequalorless: 0x22DB,
                greatermonospace: 0xFF1E,
                greaterorequivalent: 0x2273,
                greaterorless: 0x2277,
                greateroverequal: 0x2267,
                greatersmall: 0xFE65,
                gscript: 0x0261,
                gstroke: 0x01E5,
                guhiragana: 0x3050,
                guillemotleft: 0x00AB,
                guillemotright: 0x00BB,
                guilsinglleft: 0x2039,
                guilsinglright: 0x203A,
                gukatakana: 0x30B0,
                guramusquare: 0x3318,
                gysquare: 0x33C9,
                h: 0x0068,
                haabkhasiancyrillic: 0x04A9,
                haaltonearabic: 0x06C1,
                habengali: 0x09B9,
                hadescendercyrillic: 0x04B3,
                hadeva: 0x0939,
                hagujarati: 0x0AB9,
                hagurmukhi: 0x0A39,
                haharabic: 0x062D,
                hahfinalarabic: 0xFEA2,
                hahinitialarabic: 0xFEA3,
                hahiragana: 0x306F,
                hahmedialarabic: 0xFEA4,
                haitusquare: 0x332A,
                hakatakana: 0x30CF,
                hakatakanahalfwidth: 0xFF8A,
                halantgurmukhi: 0x0A4D,
                hamzaarabic: 0x0621,
                hamzalowarabic: 0x0621,
                hangulfiller: 0x3164,
                hardsigncyrillic: 0x044A,
                harpoonleftbarbup: 0x21BC,
                harpoonrightbarbup: 0x21C0,
                hasquare: 0x33CA,
                hatafpatah: 0x05B2,
                hatafpatah16: 0x05B2,
                hatafpatah23: 0x05B2,
                hatafpatah2f: 0x05B2,
                hatafpatahhebrew: 0x05B2,
                hatafpatahnarrowhebrew: 0x05B2,
                hatafpatahquarterhebrew: 0x05B2,
                hatafpatahwidehebrew: 0x05B2,
                hatafqamats: 0x05B3,
                hatafqamats1b: 0x05B3,
                hatafqamats28: 0x05B3,
                hatafqamats34: 0x05B3,
                hatafqamatshebrew: 0x05B3,
                hatafqamatsnarrowhebrew: 0x05B3,
                hatafqamatsquarterhebrew: 0x05B3,
                hatafqamatswidehebrew: 0x05B3,
                hatafsegol: 0x05B1,
                hatafsegol17: 0x05B1,
                hatafsegol24: 0x05B1,
                hatafsegol30: 0x05B1,
                hatafsegolhebrew: 0x05B1,
                hatafsegolnarrowhebrew: 0x05B1,
                hatafsegolquarterhebrew: 0x05B1,
                hatafsegolwidehebrew: 0x05B1,
                hbar: 0x0127,
                hbopomofo: 0x310F,
                hbrevebelow: 0x1E2B,
                hcedilla: 0x1E29,
                hcircle: 0x24D7,
                hcircumflex: 0x0125,
                hdieresis: 0x1E27,
                hdotaccent: 0x1E23,
                hdotbelow: 0x1E25,
                he: 0x05D4,
                heart: 0x2665,
                heartsuitblack: 0x2665,
                heartsuitwhite: 0x2661,
                hedagesh: 0xFB34,
                hedageshhebrew: 0xFB34,
                hehaltonearabic: 0x06C1,
                heharabic: 0x0647,
                hehebrew: 0x05D4,
                hehfinalaltonearabic: 0xFBA7,
                hehfinalalttwoarabic: 0xFEEA,
                hehfinalarabic: 0xFEEA,
                hehhamzaabovefinalarabic: 0xFBA5,
                hehhamzaaboveisolatedarabic: 0xFBA4,
                hehinitialaltonearabic: 0xFBA8,
                hehinitialarabic: 0xFEEB,
                hehiragana: 0x3078,
                hehmedialaltonearabic: 0xFBA9,
                hehmedialarabic: 0xFEEC,
                heiseierasquare: 0x337B,
                hekatakana: 0x30D8,
                hekatakanahalfwidth: 0xFF8D,
                hekutaarusquare: 0x3336,
                henghook: 0x0267,
                herutusquare: 0x3339,
                het: 0x05D7,
                hethebrew: 0x05D7,
                hhook: 0x0266,
                hhooksuperior: 0x02B1,
                hieuhacirclekorean: 0x327B,
                hieuhaparenkorean: 0x321B,
                hieuhcirclekorean: 0x326D,
                hieuhkorean: 0x314E,
                hieuhparenkorean: 0x320D,
                hihiragana: 0x3072,
                hikatakana: 0x30D2,
                hikatakanahalfwidth: 0xFF8B,
                hiriq: 0x05B4,
                hiriq14: 0x05B4,
                hiriq21: 0x05B4,
                hiriq2d: 0x05B4,
                hiriqhebrew: 0x05B4,
                hiriqnarrowhebrew: 0x05B4,
                hiriqquarterhebrew: 0x05B4,
                hiriqwidehebrew: 0x05B4,
                hlinebelow: 0x1E96,
                hmonospace: 0xFF48,
                hoarmenian: 0x0570,
                hohipthai: 0x0E2B,
                hohiragana: 0x307B,
                hokatakana: 0x30DB,
                hokatakanahalfwidth: 0xFF8E,
                holam: 0x05B9,
                holam19: 0x05B9,
                holam26: 0x05B9,
                holam32: 0x05B9,
                holamhebrew: 0x05B9,
                holamnarrowhebrew: 0x05B9,
                holamquarterhebrew: 0x05B9,
                holamwidehebrew: 0x05B9,
                honokhukthai: 0x0E2E,
                hookabovecomb: 0x0309,
                hookcmb: 0x0309,
                hookpalatalizedbelowcmb: 0x0321,
                hookretroflexbelowcmb: 0x0322,
                hoonsquare: 0x3342,
                horicoptic: 0x03E9,
                horizontalbar: 0x2015,
                horncmb: 0x031B,
                hotsprings: 0x2668,
                house: 0x2302,
                hparen: 0x24A3,
                hsuperior: 0x02B0,
                hturned: 0x0265,
                huhiragana: 0x3075,
                huiitosquare: 0x3333,
                hukatakana: 0x30D5,
                hukatakanahalfwidth: 0xFF8C,
                hungarumlaut: 0x02DD,
                hungarumlautcmb: 0x030B,
                hv: 0x0195,
                hyphen: 0x002D,
                hypheninferior: 0xF6E5,
                hyphenmonospace: 0xFF0D,
                hyphensmall: 0xFE63,
                hyphensuperior: 0xF6E6,
                hyphentwo: 0x2010,
                i: 0x0069,
                iacute: 0x00ED,
                iacyrillic: 0x044F,
                ibengali: 0x0987,
                ibopomofo: 0x3127,
                ibreve: 0x012D,
                icaron: 0x01D0,
                icircle: 0x24D8,
                icircumflex: 0x00EE,
                icyrillic: 0x0456,
                idblgrave: 0x0209,
                ideographearthcircle: 0x328F,
                ideographfirecircle: 0x328B,
                ideographicallianceparen: 0x323F,
                ideographiccallparen: 0x323A,
                ideographiccentrecircle: 0x32A5,
                ideographicclose: 0x3006,
                ideographiccomma: 0x3001,
                ideographiccommaleft: 0xFF64,
                ideographiccongratulationparen: 0x3237,
                ideographiccorrectcircle: 0x32A3,
                ideographicearthparen: 0x322F,
                ideographicenterpriseparen: 0x323D,
                ideographicexcellentcircle: 0x329D,
                ideographicfestivalparen: 0x3240,
                ideographicfinancialcircle: 0x3296,
                ideographicfinancialparen: 0x3236,
                ideographicfireparen: 0x322B,
                ideographichaveparen: 0x3232,
                ideographichighcircle: 0x32A4,
                ideographiciterationmark: 0x3005,
                ideographiclaborcircle: 0x3298,
                ideographiclaborparen: 0x3238,
                ideographicleftcircle: 0x32A7,
                ideographiclowcircle: 0x32A6,
                ideographicmedicinecircle: 0x32A9,
                ideographicmetalparen: 0x322E,
                ideographicmoonparen: 0x322A,
                ideographicnameparen: 0x3234,
                ideographicperiod: 0x3002,
                ideographicprintcircle: 0x329E,
                ideographicreachparen: 0x3243,
                ideographicrepresentparen: 0x3239,
                ideographicresourceparen: 0x323E,
                ideographicrightcircle: 0x32A8,
                ideographicsecretcircle: 0x3299,
                ideographicselfparen: 0x3242,
                ideographicsocietyparen: 0x3233,
                ideographicspace: 0x3000,
                ideographicspecialparen: 0x3235,
                ideographicstockparen: 0x3231,
                ideographicstudyparen: 0x323B,
                ideographicsunparen: 0x3230,
                ideographicsuperviseparen: 0x323C,
                ideographicwaterparen: 0x322C,
                ideographicwoodparen: 0x322D,
                ideographiczero: 0x3007,
                ideographmetalcircle: 0x328E,
                ideographmooncircle: 0x328A,
                ideographnamecircle: 0x3294,
                ideographsuncircle: 0x3290,
                ideographwatercircle: 0x328C,
                ideographwoodcircle: 0x328D,
                ideva: 0x0907,
                idieresis: 0x00EF,
                idieresisacute: 0x1E2F,
                idieresiscyrillic: 0x04E5,
                idotbelow: 0x1ECB,
                iebrevecyrillic: 0x04D7,
                iecyrillic: 0x0435,
                ieungacirclekorean: 0x3275,
                ieungaparenkorean: 0x3215,
                ieungcirclekorean: 0x3267,
                ieungkorean: 0x3147,
                ieungparenkorean: 0x3207,
                igrave: 0x00EC,
                igujarati: 0x0A87,
                igurmukhi: 0x0A07,
                ihiragana: 0x3044,
                ihookabove: 0x1EC9,
                iibengali: 0x0988,
                iicyrillic: 0x0438,
                iideva: 0x0908,
                iigujarati: 0x0A88,
                iigurmukhi: 0x0A08,
                iimatragurmukhi: 0x0A40,
                iinvertedbreve: 0x020B,
                iishortcyrillic: 0x0439,
                iivowelsignbengali: 0x09C0,
                iivowelsigndeva: 0x0940,
                iivowelsigngujarati: 0x0AC0,
                ij: 0x0133,
                ikatakana: 0x30A4,
                ikatakanahalfwidth: 0xFF72,
                ikorean: 0x3163,
                ilde: 0x02DC,
                iluyhebrew: 0x05AC,
                imacron: 0x012B,
                imacroncyrillic: 0x04E3,
                imageorapproximatelyequal: 0x2253,
                imatragurmukhi: 0x0A3F,
                imonospace: 0xFF49,
                increment: 0x2206,
                infinity: 0x221E,
                iniarmenian: 0x056B,
                integral: 0x222B,
                integralbottom: 0x2321,
                integralbt: 0x2321,
                integralex: 0xF8F5,
                integraltop: 0x2320,
                integraltp: 0x2320,
                intersection: 0x2229,
                intisquare: 0x3305,
                invbullet: 0x25D8,
                invcircle: 0x25D9,
                invsmileface: 0x263B,
                iocyrillic: 0x0451,
                iogonek: 0x012F,
                iota: 0x03B9,
                iotadieresis: 0x03CA,
                iotadieresistonos: 0x0390,
                iotalatin: 0x0269,
                iotatonos: 0x03AF,
                iparen: 0x24A4,
                irigurmukhi: 0x0A72,
                ismallhiragana: 0x3043,
                ismallkatakana: 0x30A3,
                ismallkatakanahalfwidth: 0xFF68,
                issharbengali: 0x09FA,
                istroke: 0x0268,
                isuperior: 0xF6ED,
                iterationhiragana: 0x309D,
                iterationkatakana: 0x30FD,
                itilde: 0x0129,
                itildebelow: 0x1E2D,
                iubopomofo: 0x3129,
                iucyrillic: 0x044E,
                ivowelsignbengali: 0x09BF,
                ivowelsigndeva: 0x093F,
                ivowelsigngujarati: 0x0ABF,
                izhitsacyrillic: 0x0475,
                izhitsadblgravecyrillic: 0x0477,
                j: 0x006A,
                jaarmenian: 0x0571,
                jabengali: 0x099C,
                jadeva: 0x091C,
                jagujarati: 0x0A9C,
                jagurmukhi: 0x0A1C,
                jbopomofo: 0x3110,
                jcaron: 0x01F0,
                jcircle: 0x24D9,
                jcircumflex: 0x0135,
                jcrossedtail: 0x029D,
                jdotlessstroke: 0x025F,
                jecyrillic: 0x0458,
                jeemarabic: 0x062C,
                jeemfinalarabic: 0xFE9E,
                jeeminitialarabic: 0xFE9F,
                jeemmedialarabic: 0xFEA0,
                jeharabic: 0x0698,
                jehfinalarabic: 0xFB8B,
                jhabengali: 0x099D,
                jhadeva: 0x091D,
                jhagujarati: 0x0A9D,
                jhagurmukhi: 0x0A1D,
                jheharmenian: 0x057B,
                jis: 0x3004,
                jmonospace: 0xFF4A,
                jparen: 0x24A5,
                jsuperior: 0x02B2,
                k: 0x006B,
                kabashkircyrillic: 0x04A1,
                kabengali: 0x0995,
                kacute: 0x1E31,
                kacyrillic: 0x043A,
                kadescendercyrillic: 0x049B,
                kadeva: 0x0915,
                kaf: 0x05DB,
                kafarabic: 0x0643,
                kafdagesh: 0xFB3B,
                kafdageshhebrew: 0xFB3B,
                kaffinalarabic: 0xFEDA,
                kafhebrew: 0x05DB,
                kafinitialarabic: 0xFEDB,
                kafmedialarabic: 0xFEDC,
                kafrafehebrew: 0xFB4D,
                kagujarati: 0x0A95,
                kagurmukhi: 0x0A15,
                kahiragana: 0x304B,
                kahookcyrillic: 0x04C4,
                kakatakana: 0x30AB,
                kakatakanahalfwidth: 0xFF76,
                kappa: 0x03BA,
                kappasymbolgreek: 0x03F0,
                kapyeounmieumkorean: 0x3171,
                kapyeounphieuphkorean: 0x3184,
                kapyeounpieupkorean: 0x3178,
                kapyeounssangpieupkorean: 0x3179,
                karoriisquare: 0x330D,
                kashidaautoarabic: 0x0640,
                kashidaautonosidebearingarabic: 0x0640,
                kasmallkatakana: 0x30F5,
                kasquare: 0x3384,
                kasraarabic: 0x0650,
                kasratanarabic: 0x064D,
                kastrokecyrillic: 0x049F,
                katahiraprolongmarkhalfwidth: 0xFF70,
                kaverticalstrokecyrillic: 0x049D,
                kbopomofo: 0x310E,
                kcalsquare: 0x3389,
                kcaron: 0x01E9,
                kcedilla: 0x0137,
                kcircle: 0x24DA,
                kcommaaccent: 0x0137,
                kdotbelow: 0x1E33,
                keharmenian: 0x0584,
                kehiragana: 0x3051,
                kekatakana: 0x30B1,
                kekatakanahalfwidth: 0xFF79,
                kenarmenian: 0x056F,
                kesmallkatakana: 0x30F6,
                kgreenlandic: 0x0138,
                khabengali: 0x0996,
                khacyrillic: 0x0445,
                khadeva: 0x0916,
                khagujarati: 0x0A96,
                khagurmukhi: 0x0A16,
                khaharabic: 0x062E,
                khahfinalarabic: 0xFEA6,
                khahinitialarabic: 0xFEA7,
                khahmedialarabic: 0xFEA8,
                kheicoptic: 0x03E7,
                khhadeva: 0x0959,
                khhagurmukhi: 0x0A59,
                khieukhacirclekorean: 0x3278,
                khieukhaparenkorean: 0x3218,
                khieukhcirclekorean: 0x326A,
                khieukhkorean: 0x314B,
                khieukhparenkorean: 0x320A,
                khokhaithai: 0x0E02,
                khokhonthai: 0x0E05,
                khokhuatthai: 0x0E03,
                khokhwaithai: 0x0E04,
                khomutthai: 0x0E5B,
                khook: 0x0199,
                khorakhangthai: 0x0E06,
                khzsquare: 0x3391,
                kihiragana: 0x304D,
                kikatakana: 0x30AD,
                kikatakanahalfwidth: 0xFF77,
                kiroguramusquare: 0x3315,
                kiromeetorusquare: 0x3316,
                kirosquare: 0x3314,
                kiyeokacirclekorean: 0x326E,
                kiyeokaparenkorean: 0x320E,
                kiyeokcirclekorean: 0x3260,
                kiyeokkorean: 0x3131,
                kiyeokparenkorean: 0x3200,
                kiyeoksioskorean: 0x3133,
                kjecyrillic: 0x045C,
                klinebelow: 0x1E35,
                klsquare: 0x3398,
                kmcubedsquare: 0x33A6,
                kmonospace: 0xFF4B,
                kmsquaredsquare: 0x33A2,
                kohiragana: 0x3053,
                kohmsquare: 0x33C0,
                kokaithai: 0x0E01,
                kokatakana: 0x30B3,
                kokatakanahalfwidth: 0xFF7A,
                kooposquare: 0x331E,
                koppacyrillic: 0x0481,
                koreanstandardsymbol: 0x327F,
                koroniscmb: 0x0343,
                kparen: 0x24A6,
                kpasquare: 0x33AA,
                ksicyrillic: 0x046F,
                ktsquare: 0x33CF,
                kturned: 0x029E,
                kuhiragana: 0x304F,
                kukatakana: 0x30AF,
                kukatakanahalfwidth: 0xFF78,
                kvsquare: 0x33B8,
                kwsquare: 0x33BE,
                l: 0x006C,
                labengali: 0x09B2,
                lacute: 0x013A,
                ladeva: 0x0932,
                lagujarati: 0x0AB2,
                lagurmukhi: 0x0A32,
                lakkhangyaothai: 0x0E45,
                lamaleffinalarabic: 0xFEFC,
                lamalefhamzaabovefinalarabic: 0xFEF8,
                lamalefhamzaaboveisolatedarabic: 0xFEF7,
                lamalefhamzabelowfinalarabic: 0xFEFA,
                lamalefhamzabelowisolatedarabic: 0xFEF9,
                lamalefisolatedarabic: 0xFEFB,
                lamalefmaddaabovefinalarabic: 0xFEF6,
                lamalefmaddaaboveisolatedarabic: 0xFEF5,
                lamarabic: 0x0644,
                lambda: 0x03BB,
                lambdastroke: 0x019B,
                lamed: 0x05DC,
                lameddagesh: 0xFB3C,
                lameddageshhebrew: 0xFB3C,
                lamedhebrew: 0x05DC,
                lamfinalarabic: 0xFEDE,
                lamhahinitialarabic: 0xFCCA,
                laminitialarabic: 0xFEDF,
                lamjeeminitialarabic: 0xFCC9,
                lamkhahinitialarabic: 0xFCCB,
                lamlamhehisolatedarabic: 0xFDF2,
                lammedialarabic: 0xFEE0,
                lammeemhahinitialarabic: 0xFD88,
                lammeeminitialarabic: 0xFCCC,
                largecircle: 0x25EF,
                lbar: 0x019A,
                lbelt: 0x026C,
                lbopomofo: 0x310C,
                lcaron: 0x013E,
                lcedilla: 0x013C,
                lcircle: 0x24DB,
                lcircumflexbelow: 0x1E3D,
                lcommaaccent: 0x013C,
                ldot: 0x0140,
                ldotaccent: 0x0140,
                ldotbelow: 0x1E37,
                ldotbelowmacron: 0x1E39,
                leftangleabovecmb: 0x031A,
                lefttackbelowcmb: 0x0318,
                less: 0x003C,
                lessequal: 0x2264,
                lessequalorgreater: 0x22DA,
                lessmonospace: 0xFF1C,
                lessorequivalent: 0x2272,
                lessorgreater: 0x2276,
                lessoverequal: 0x2266,
                lesssmall: 0xFE64,
                lezh: 0x026E,
                lfblock: 0x258C,
                lhookretroflex: 0x026D,
                lira: 0x20A4,
                liwnarmenian: 0x056C,
                lj: 0x01C9,
                ljecyrillic: 0x0459,
                ll: 0xF6C0,
                lladeva: 0x0933,
                llagujarati: 0x0AB3,
                llinebelow: 0x1E3B,
                llladeva: 0x0934,
                llvocalicbengali: 0x09E1,
                llvocalicdeva: 0x0961,
                llvocalicvowelsignbengali: 0x09E3,
                llvocalicvowelsigndeva: 0x0963,
                lmiddletilde: 0x026B,
                lmonospace: 0xFF4C,
                lmsquare: 0x33D0,
                lochulathai: 0x0E2C,
                logicaland: 0x2227,
                logicalnot: 0x00AC,
                logicalnotreversed: 0x2310,
                logicalor: 0x2228,
                lolingthai: 0x0E25,
                longs: 0x017F,
                lowlinecenterline: 0xFE4E,
                lowlinecmb: 0x0332,
                lowlinedashed: 0xFE4D,
                lozenge: 0x25CA,
                lparen: 0x24A7,
                lslash: 0x0142,
                lsquare: 0x2113,
                lsuperior: 0xF6EE,
                ltshade: 0x2591,
                luthai: 0x0E26,
                lvocalicbengali: 0x098C,
                lvocalicdeva: 0x090C,
                lvocalicvowelsignbengali: 0x09E2,
                lvocalicvowelsigndeva: 0x0962,
                lxsquare: 0x33D3,
                m: 0x006D,
                mabengali: 0x09AE,
                macron: 0x00AF,
                macronbelowcmb: 0x0331,
                macroncmb: 0x0304,
                macronlowmod: 0x02CD,
                macronmonospace: 0xFFE3,
                macute: 0x1E3F,
                madeva: 0x092E,
                magujarati: 0x0AAE,
                magurmukhi: 0x0A2E,
                mahapakhhebrew: 0x05A4,
                mahapakhlefthebrew: 0x05A4,
                mahiragana: 0x307E,
                maichattawalowleftthai: 0xF895,
                maichattawalowrightthai: 0xF894,
                maichattawathai: 0x0E4B,
                maichattawaupperleftthai: 0xF893,
                maieklowleftthai: 0xF88C,
                maieklowrightthai: 0xF88B,
                maiekthai: 0x0E48,
                maiekupperleftthai: 0xF88A,
                maihanakatleftthai: 0xF884,
                maihanakatthai: 0x0E31,
                maitaikhuleftthai: 0xF889,
                maitaikhuthai: 0x0E47,
                maitholowleftthai: 0xF88F,
                maitholowrightthai: 0xF88E,
                maithothai: 0x0E49,
                maithoupperleftthai: 0xF88D,
                maitrilowleftthai: 0xF892,
                maitrilowrightthai: 0xF891,
                maitrithai: 0x0E4A,
                maitriupperleftthai: 0xF890,
                maiyamokthai: 0x0E46,
                makatakana: 0x30DE,
                makatakanahalfwidth: 0xFF8F,
                male: 0x2642,
                mansyonsquare: 0x3347,
                maqafhebrew: 0x05BE,
                mars: 0x2642,
                masoracirclehebrew: 0x05AF,
                masquare: 0x3383,
                mbopomofo: 0x3107,
                mbsquare: 0x33D4,
                mcircle: 0x24DC,
                mcubedsquare: 0x33A5,
                mdotaccent: 0x1E41,
                mdotbelow: 0x1E43,
                meemarabic: 0x0645,
                meemfinalarabic: 0xFEE2,
                meeminitialarabic: 0xFEE3,
                meemmedialarabic: 0xFEE4,
                meemmeeminitialarabic: 0xFCD1,
                meemmeemisolatedarabic: 0xFC48,
                meetorusquare: 0x334D,
                mehiragana: 0x3081,
                meizierasquare: 0x337E,
                mekatakana: 0x30E1,
                mekatakanahalfwidth: 0xFF92,
                mem: 0x05DE,
                memdagesh: 0xFB3E,
                memdageshhebrew: 0xFB3E,
                memhebrew: 0x05DE,
                menarmenian: 0x0574,
                merkhahebrew: 0x05A5,
                merkhakefulahebrew: 0x05A6,
                merkhakefulalefthebrew: 0x05A6,
                merkhalefthebrew: 0x05A5,
                mhook: 0x0271,
                mhzsquare: 0x3392,
                middledotkatakanahalfwidth: 0xFF65,
                middot: 0x00B7,
                mieumacirclekorean: 0x3272,
                mieumaparenkorean: 0x3212,
                mieumcirclekorean: 0x3264,
                mieumkorean: 0x3141,
                mieumpansioskorean: 0x3170,
                mieumparenkorean: 0x3204,
                mieumpieupkorean: 0x316E,
                mieumsioskorean: 0x316F,
                mihiragana: 0x307F,
                mikatakana: 0x30DF,
                mikatakanahalfwidth: 0xFF90,
                minus: 0x2212,
                minusbelowcmb: 0x0320,
                minuscircle: 0x2296,
                minusmod: 0x02D7,
                minusplus: 0x2213,
                minute: 0x2032,
                miribaarusquare: 0x334A,
                mirisquare: 0x3349,
                mlonglegturned: 0x0270,
                mlsquare: 0x3396,
                mmcubedsquare: 0x33A3,
                mmonospace: 0xFF4D,
                mmsquaredsquare: 0x339F,
                mohiragana: 0x3082,
                mohmsquare: 0x33C1,
                mokatakana: 0x30E2,
                mokatakanahalfwidth: 0xFF93,
                molsquare: 0x33D6,
                momathai: 0x0E21,
                moverssquare: 0x33A7,
                moverssquaredsquare: 0x33A8,
                mparen: 0x24A8,
                mpasquare: 0x33AB,
                mssquare: 0x33B3,
                msuperior: 0xF6EF,
                mturned: 0x026F,
                mu: 0x00B5,
                mu1: 0x00B5,
                muasquare: 0x3382,
                muchgreater: 0x226B,
                muchless: 0x226A,
                mufsquare: 0x338C,
                mugreek: 0x03BC,
                mugsquare: 0x338D,
                muhiragana: 0x3080,
                mukatakana: 0x30E0,
                mukatakanahalfwidth: 0xFF91,
                mulsquare: 0x3395,
                multiply: 0x00D7,
                mumsquare: 0x339B,
                munahhebrew: 0x05A3,
                munahlefthebrew: 0x05A3,
                musicalnote: 0x266A,
                musicalnotedbl: 0x266B,
                musicflatsign: 0x266D,
                musicsharpsign: 0x266F,
                mussquare: 0x33B2,
                muvsquare: 0x33B6,
                muwsquare: 0x33BC,
                mvmegasquare: 0x33B9,
                mvsquare: 0x33B7,
                mwmegasquare: 0x33BF,
                mwsquare: 0x33BD,
                n: 0x006E,
                nabengali: 0x09A8,
                nabla: 0x2207,
                nacute: 0x0144,
                nadeva: 0x0928,
                nagujarati: 0x0AA8,
                nagurmukhi: 0x0A28,
                nahiragana: 0x306A,
                nakatakana: 0x30CA,
                nakatakanahalfwidth: 0xFF85,
                napostrophe: 0x0149,
                nasquare: 0x3381,
                nbopomofo: 0x310B,
                nbspace: 0x00A0,
                ncaron: 0x0148,
                ncedilla: 0x0146,
                ncircle: 0x24DD,
                ncircumflexbelow: 0x1E4B,
                ncommaaccent: 0x0146,
                ndotaccent: 0x1E45,
                ndotbelow: 0x1E47,
                nehiragana: 0x306D,
                nekatakana: 0x30CD,
                nekatakanahalfwidth: 0xFF88,
                newsheqelsign: 0x20AA,
                nfsquare: 0x338B,
                ngabengali: 0x0999,
                ngadeva: 0x0919,
                ngagujarati: 0x0A99,
                ngagurmukhi: 0x0A19,
                ngonguthai: 0x0E07,
                nhiragana: 0x3093,
                nhookleft: 0x0272,
                nhookretroflex: 0x0273,
                nieunacirclekorean: 0x326F,
                nieunaparenkorean: 0x320F,
                nieuncieuckorean: 0x3135,
                nieuncirclekorean: 0x3261,
                nieunhieuhkorean: 0x3136,
                nieunkorean: 0x3134,
                nieunpansioskorean: 0x3168,
                nieunparenkorean: 0x3201,
                nieunsioskorean: 0x3167,
                nieuntikeutkorean: 0x3166,
                nihiragana: 0x306B,
                nikatakana: 0x30CB,
                nikatakanahalfwidth: 0xFF86,
                nikhahitleftthai: 0xF899,
                nikhahitthai: 0x0E4D,
                nine: 0x0039,
                ninearabic: 0x0669,
                ninebengali: 0x09EF,
                ninecircle: 0x2468,
                ninecircleinversesansserif: 0x2792,
                ninedeva: 0x096F,
                ninegujarati: 0x0AEF,
                ninegurmukhi: 0x0A6F,
                ninehackarabic: 0x0669,
                ninehangzhou: 0x3029,
                nineideographicparen: 0x3228,
                nineinferior: 0x2089,
                ninemonospace: 0xFF19,
                nineoldstyle: 0xF739,
                nineparen: 0x247C,
                nineperiod: 0x2490,
                ninepersian: 0x06F9,
                nineroman: 0x2178,
                ninesuperior: 0x2079,
                nineteencircle: 0x2472,
                nineteenparen: 0x2486,
                nineteenperiod: 0x249A,
                ninethai: 0x0E59,
                nj: 0x01CC,
                njecyrillic: 0x045A,
                nkatakana: 0x30F3,
                nkatakanahalfwidth: 0xFF9D,
                nlegrightlong: 0x019E,
                nlinebelow: 0x1E49,
                nmonospace: 0xFF4E,
                nmsquare: 0x339A,
                nnabengali: 0x09A3,
                nnadeva: 0x0923,
                nnagujarati: 0x0AA3,
                nnagurmukhi: 0x0A23,
                nnnadeva: 0x0929,
                nohiragana: 0x306E,
                nokatakana: 0x30CE,
                nokatakanahalfwidth: 0xFF89,
                nonbreakingspace: 0x00A0,
                nonenthai: 0x0E13,
                nonuthai: 0x0E19,
                noonarabic: 0x0646,
                noonfinalarabic: 0xFEE6,
                noonghunnaarabic: 0x06BA,
                noonghunnafinalarabic: 0xFB9F,
                nooninitialarabic: 0xFEE7,
                noonjeeminitialarabic: 0xFCD2,
                noonjeemisolatedarabic: 0xFC4B,
                noonmedialarabic: 0xFEE8,
                noonmeeminitialarabic: 0xFCD5,
                noonmeemisolatedarabic: 0xFC4E,
                noonnoonfinalarabic: 0xFC8D,
                notcontains: 0x220C,
                notelement: 0x2209,
                notelementof: 0x2209,
                notequal: 0x2260,
                notgreater: 0x226F,
                notgreaternorequal: 0x2271,
                notgreaternorless: 0x2279,
                notidentical: 0x2262,
                notless: 0x226E,
                notlessnorequal: 0x2270,
                notparallel: 0x2226,
                notprecedes: 0x2280,
                notsubset: 0x2284,
                notsucceeds: 0x2281,
                notsuperset: 0x2285,
                nowarmenian: 0x0576,
                nparen: 0x24A9,
                nssquare: 0x33B1,
                nsuperior: 0x207F,
                ntilde: 0x00F1,
                nu: 0x03BD,
                nuhiragana: 0x306C,
                nukatakana: 0x30CC,
                nukatakanahalfwidth: 0xFF87,
                nuktabengali: 0x09BC,
                nuktadeva: 0x093C,
                nuktagujarati: 0x0ABC,
                nuktagurmukhi: 0x0A3C,
                numbersign: 0x0023,
                numbersignmonospace: 0xFF03,
                numbersignsmall: 0xFE5F,
                numeralsigngreek: 0x0374,
                numeralsignlowergreek: 0x0375,
                numero: 0x2116,
                nun: 0x05E0,
                nundagesh: 0xFB40,
                nundageshhebrew: 0xFB40,
                nunhebrew: 0x05E0,
                nvsquare: 0x33B5,
                nwsquare: 0x33BB,
                nyabengali: 0x099E,
                nyadeva: 0x091E,
                nyagujarati: 0x0A9E,
                nyagurmukhi: 0x0A1E,
                o: 0x006F,
                oacute: 0x00F3,
                oangthai: 0x0E2D,
                obarred: 0x0275,
                obarredcyrillic: 0x04E9,
                obarreddieresiscyrillic: 0x04EB,
                obengali: 0x0993,
                obopomofo: 0x311B,
                obreve: 0x014F,
                ocandradeva: 0x0911,
                ocandragujarati: 0x0A91,
                ocandravowelsigndeva: 0x0949,
                ocandravowelsigngujarati: 0x0AC9,
                ocaron: 0x01D2,
                ocircle: 0x24DE,
                ocircumflex: 0x00F4,
                ocircumflexacute: 0x1ED1,
                ocircumflexdotbelow: 0x1ED9,
                ocircumflexgrave: 0x1ED3,
                ocircumflexhookabove: 0x1ED5,
                ocircumflextilde: 0x1ED7,
                ocyrillic: 0x043E,
                odblacute: 0x0151,
                odblgrave: 0x020D,
                odeva: 0x0913,
                odieresis: 0x00F6,
                odieresiscyrillic: 0x04E7,
                odotbelow: 0x1ECD,
                oe: 0x0153,
                oekorean: 0x315A,
                ogonek: 0x02DB,
                ogonekcmb: 0x0328,
                ograve: 0x00F2,
                ogujarati: 0x0A93,
                oharmenian: 0x0585,
                ohiragana: 0x304A,
                ohookabove: 0x1ECF,
                ohorn: 0x01A1,
                ohornacute: 0x1EDB,
                ohorndotbelow: 0x1EE3,
                ohorngrave: 0x1EDD,
                ohornhookabove: 0x1EDF,
                ohorntilde: 0x1EE1,
                ohungarumlaut: 0x0151,
                oi: 0x01A3,
                oinvertedbreve: 0x020F,
                okatakana: 0x30AA,
                okatakanahalfwidth: 0xFF75,
                okorean: 0x3157,
                olehebrew: 0x05AB,
                omacron: 0x014D,
                omacronacute: 0x1E53,
                omacrongrave: 0x1E51,
                omdeva: 0x0950,
                omega: 0x03C9,
                omega1: 0x03D6,
                omegacyrillic: 0x0461,
                omegalatinclosed: 0x0277,
                omegaroundcyrillic: 0x047B,
                omegatitlocyrillic: 0x047D,
                omegatonos: 0x03CE,
                omgujarati: 0x0AD0,
                omicron: 0x03BF,
                omicrontonos: 0x03CC,
                omonospace: 0xFF4F,
                one: 0x0031,
                onearabic: 0x0661,
                onebengali: 0x09E7,
                onecircle: 0x2460,
                onecircleinversesansserif: 0x278A,
                onedeva: 0x0967,
                onedotenleader: 0x2024,
                oneeighth: 0x215B,
                onefitted: 0xF6DC,
                onegujarati: 0x0AE7,
                onegurmukhi: 0x0A67,
                onehackarabic: 0x0661,
                onehalf: 0x00BD,
                onehangzhou: 0x3021,
                oneideographicparen: 0x3220,
                oneinferior: 0x2081,
                onemonospace: 0xFF11,
                onenumeratorbengali: 0x09F4,
                oneoldstyle: 0xF731,
                oneparen: 0x2474,
                oneperiod: 0x2488,
                onepersian: 0x06F1,
                onequarter: 0x00BC,
                oneroman: 0x2170,
                onesuperior: 0x00B9,
                onethai: 0x0E51,
                onethird: 0x2153,
                oogonek: 0x01EB,
                oogonekmacron: 0x01ED,
                oogurmukhi: 0x0A13,
                oomatragurmukhi: 0x0A4B,
                oopen: 0x0254,
                oparen: 0x24AA,
                openbullet: 0x25E6,
                option: 0x2325,
                ordfeminine: 0x00AA,
                ordmasculine: 0x00BA,
                orthogonal: 0x221F,
                oshortdeva: 0x0912,
                oshortvowelsigndeva: 0x094A,
                oslash: 0x00F8,
                oslashacute: 0x01FF,
                osmallhiragana: 0x3049,
                osmallkatakana: 0x30A9,
                osmallkatakanahalfwidth: 0xFF6B,
                ostrokeacute: 0x01FF,
                osuperior: 0xF6F0,
                otcyrillic: 0x047F,
                otilde: 0x00F5,
                otildeacute: 0x1E4D,
                otildedieresis: 0x1E4F,
                oubopomofo: 0x3121,
                overline: 0x203E,
                overlinecenterline: 0xFE4A,
                overlinecmb: 0x0305,
                overlinedashed: 0xFE49,
                overlinedblwavy: 0xFE4C,
                overlinewavy: 0xFE4B,
                overscore: 0x00AF,
                ovowelsignbengali: 0x09CB,
                ovowelsigndeva: 0x094B,
                ovowelsigngujarati: 0x0ACB,
                p: 0x0070,
                paampssquare: 0x3380,
                paasentosquare: 0x332B,
                pabengali: 0x09AA,
                pacute: 0x1E55,
                padeva: 0x092A,
                pagedown: 0x21DF,
                pageup: 0x21DE,
                pagujarati: 0x0AAA,
                pagurmukhi: 0x0A2A,
                pahiragana: 0x3071,
                paiyannoithai: 0x0E2F,
                pakatakana: 0x30D1,
                palatalizationcyrilliccmb: 0x0484,
                palochkacyrillic: 0x04C0,
                pansioskorean: 0x317F,
                paragraph: 0x00B6,
                parallel: 0x2225,
                parenleft: 0x0028,
                parenleftaltonearabic: 0xFD3E,
                parenleftbt: 0xF8ED,
                parenleftex: 0xF8EC,
                parenleftinferior: 0x208D,
                parenleftmonospace: 0xFF08,
                parenleftsmall: 0xFE59,
                parenleftsuperior: 0x207D,
                parenlefttp: 0xF8EB,
                parenleftvertical: 0xFE35,
                parenright: 0x0029,
                parenrightaltonearabic: 0xFD3F,
                parenrightbt: 0xF8F8,
                parenrightex: 0xF8F7,
                parenrightinferior: 0x208E,
                parenrightmonospace: 0xFF09,
                parenrightsmall: 0xFE5A,
                parenrightsuperior: 0x207E,
                parenrighttp: 0xF8F6,
                parenrightvertical: 0xFE36,
                partialdiff: 0x2202,
                paseqhebrew: 0x05C0,
                pashtahebrew: 0x0599,
                pasquare: 0x33A9,
                patah: 0x05B7,
                patah11: 0x05B7,
                patah1d: 0x05B7,
                patah2a: 0x05B7,
                patahhebrew: 0x05B7,
                patahnarrowhebrew: 0x05B7,
                patahquarterhebrew: 0x05B7,
                patahwidehebrew: 0x05B7,
                pazerhebrew: 0x05A1,
                pbopomofo: 0x3106,
                pcircle: 0x24DF,
                pdotaccent: 0x1E57,
                pe: 0x05E4,
                pecyrillic: 0x043F,
                pedagesh: 0xFB44,
                pedageshhebrew: 0xFB44,
                peezisquare: 0x333B,
                pefinaldageshhebrew: 0xFB43,
                peharabic: 0x067E,
                peharmenian: 0x057A,
                pehebrew: 0x05E4,
                pehfinalarabic: 0xFB57,
                pehinitialarabic: 0xFB58,
                pehiragana: 0x307A,
                pehmedialarabic: 0xFB59,
                pekatakana: 0x30DA,
                pemiddlehookcyrillic: 0x04A7,
                perafehebrew: 0xFB4E,
                percent: 0x0025,
                percentarabic: 0x066A,
                percentmonospace: 0xFF05,
                percentsmall: 0xFE6A,
                period: 0x002E,
                periodarmenian: 0x0589,
                periodcentered: 0x00B7,
                periodhalfwidth: 0xFF61,
                periodinferior: 0xF6E7,
                periodmonospace: 0xFF0E,
                periodsmall: 0xFE52,
                periodsuperior: 0xF6E8,
                perispomenigreekcmb: 0x0342,
                perpendicular: 0x22A5,
                perthousand: 0x2030,
                peseta: 0x20A7,
                pfsquare: 0x338A,
                phabengali: 0x09AB,
                phadeva: 0x092B,
                phagujarati: 0x0AAB,
                phagurmukhi: 0x0A2B,
                phi: 0x03C6,
                phi1: 0x03D5,
                phieuphacirclekorean: 0x327A,
                phieuphaparenkorean: 0x321A,
                phieuphcirclekorean: 0x326C,
                phieuphkorean: 0x314D,
                phieuphparenkorean: 0x320C,
                philatin: 0x0278,
                phinthuthai: 0x0E3A,
                phisymbolgreek: 0x03D5,
                phook: 0x01A5,
                phophanthai: 0x0E1E,
                phophungthai: 0x0E1C,
                phosamphaothai: 0x0E20,
                pi: 0x03C0,
                pieupacirclekorean: 0x3273,
                pieupaparenkorean: 0x3213,
                pieupcieuckorean: 0x3176,
                pieupcirclekorean: 0x3265,
                pieupkiyeokkorean: 0x3172,
                pieupkorean: 0x3142,
                pieupparenkorean: 0x3205,
                pieupsioskiyeokkorean: 0x3174,
                pieupsioskorean: 0x3144,
                pieupsiostikeutkorean: 0x3175,
                pieupthieuthkorean: 0x3177,
                pieuptikeutkorean: 0x3173,
                pihiragana: 0x3074,
                pikatakana: 0x30D4,
                pisymbolgreek: 0x03D6,
                piwrarmenian: 0x0583,
                plus: 0x002B,
                plusbelowcmb: 0x031F,
                pluscircle: 0x2295,
                plusminus: 0x00B1,
                plusmod: 0x02D6,
                plusmonospace: 0xFF0B,
                plussmall: 0xFE62,
                plussuperior: 0x207A,
                pmonospace: 0xFF50,
                pmsquare: 0x33D8,
                pohiragana: 0x307D,
                pointingindexdownwhite: 0x261F,
                pointingindexleftwhite: 0x261C,
                pointingindexrightwhite: 0x261E,
                pointingindexupwhite: 0x261D,
                pokatakana: 0x30DD,
                poplathai: 0x0E1B,
                postalmark: 0x3012,
                postalmarkface: 0x3020,
                pparen: 0x24AB,
                precedes: 0x227A,
                prescription: 0x211E,
                primemod: 0x02B9,
                primereversed: 0x2035,
                product: 0x220F,
                projective: 0x2305,
                prolongedkana: 0x30FC,
                propellor: 0x2318,
                propersubset: 0x2282,
                propersuperset: 0x2283,
                proportion: 0x2237,
                proportional: 0x221D,
                psi: 0x03C8,
                psicyrillic: 0x0471,
                psilipneumatacyrilliccmb: 0x0486,
                pssquare: 0x33B0,
                puhiragana: 0x3077,
                pukatakana: 0x30D7,
                pvsquare: 0x33B4,
                pwsquare: 0x33BA,
                q: 0x0071,
                qadeva: 0x0958,
                qadmahebrew: 0x05A8,
                qafarabic: 0x0642,
                qaffinalarabic: 0xFED6,
                qafinitialarabic: 0xFED7,
                qafmedialarabic: 0xFED8,
                qamats: 0x05B8,
                qamats10: 0x05B8,
                qamats1a: 0x05B8,
                qamats1c: 0x05B8,
                qamats27: 0x05B8,
                qamats29: 0x05B8,
                qamats33: 0x05B8,
                qamatsde: 0x05B8,
                qamatshebrew: 0x05B8,
                qamatsnarrowhebrew: 0x05B8,
                qamatsqatanhebrew: 0x05B8,
                qamatsqatannarrowhebrew: 0x05B8,
                qamatsqatanquarterhebrew: 0x05B8,
                qamatsqatanwidehebrew: 0x05B8,
                qamatsquarterhebrew: 0x05B8,
                qamatswidehebrew: 0x05B8,
                qarneyparahebrew: 0x059F,
                qbopomofo: 0x3111,
                qcircle: 0x24E0,
                qhook: 0x02A0,
                qmonospace: 0xFF51,
                qof: 0x05E7,
                qofdagesh: 0xFB47,
                qofdageshhebrew: 0xFB47,
                qofhebrew: 0x05E7,
                qparen: 0x24AC,
                quarternote: 0x2669,
                qubuts: 0x05BB,
                qubuts18: 0x05BB,
                qubuts25: 0x05BB,
                qubuts31: 0x05BB,
                qubutshebrew: 0x05BB,
                qubutsnarrowhebrew: 0x05BB,
                qubutsquarterhebrew: 0x05BB,
                qubutswidehebrew: 0x05BB,
                question: 0x003F,
                questionarabic: 0x061F,
                questionarmenian: 0x055E,
                questiondown: 0x00BF,
                questiondownsmall: 0xF7BF,
                questiongreek: 0x037E,
                questionmonospace: 0xFF1F,
                questionsmall: 0xF73F,
                quotedbl: 0x0022,
                quotedblbase: 0x201E,
                quotedblleft: 0x201C,
                quotedblmonospace: 0xFF02,
                quotedblprime: 0x301E,
                quotedblprimereversed: 0x301D,
                quotedblright: 0x201D,
                quoteleft: 0x2018,
                quoteleftreversed: 0x201B,
                quotereversed: 0x201B,
                quoteright: 0x2019,
                quoterightn: 0x0149,
                quotesinglbase: 0x201A,
                quotesingle: 0x0027,
                quotesinglemonospace: 0xFF07,
                r: 0x0072,
                raarmenian: 0x057C,
                rabengali: 0x09B0,
                racute: 0x0155,
                radeva: 0x0930,
                radical: 0x221A,
                radicalex: 0xF8E5,
                radoverssquare: 0x33AE,
                radoverssquaredsquare: 0x33AF,
                radsquare: 0x33AD,
                rafe: 0x05BF,
                rafehebrew: 0x05BF,
                ragujarati: 0x0AB0,
                ragurmukhi: 0x0A30,
                rahiragana: 0x3089,
                rakatakana: 0x30E9,
                rakatakanahalfwidth: 0xFF97,
                ralowerdiagonalbengali: 0x09F1,
                ramiddlediagonalbengali: 0x09F0,
                ramshorn: 0x0264,
                ratio: 0x2236,
                rbopomofo: 0x3116,
                rcaron: 0x0159,
                rcedilla: 0x0157,
                rcircle: 0x24E1,
                rcommaaccent: 0x0157,
                rdblgrave: 0x0211,
                rdotaccent: 0x1E59,
                rdotbelow: 0x1E5B,
                rdotbelowmacron: 0x1E5D,
                referencemark: 0x203B,
                reflexsubset: 0x2286,
                reflexsuperset: 0x2287,
                registered: 0x00AE,
                registersans: 0xF8E8,
                registerserif: 0xF6DA,
                reharabic: 0x0631,
                reharmenian: 0x0580,
                rehfinalarabic: 0xFEAE,
                rehiragana: 0x308C,
                rekatakana: 0x30EC,
                rekatakanahalfwidth: 0xFF9A,
                resh: 0x05E8,
                reshdageshhebrew: 0xFB48,
                reshhebrew: 0x05E8,
                reversedtilde: 0x223D,
                reviahebrew: 0x0597,
                reviamugrashhebrew: 0x0597,
                revlogicalnot: 0x2310,
                rfishhook: 0x027E,
                rfishhookreversed: 0x027F,
                rhabengali: 0x09DD,
                rhadeva: 0x095D,
                rho: 0x03C1,
                rhook: 0x027D,
                rhookturned: 0x027B,
                rhookturnedsuperior: 0x02B5,
                rhosymbolgreek: 0x03F1,
                rhotichookmod: 0x02DE,
                rieulacirclekorean: 0x3271,
                rieulaparenkorean: 0x3211,
                rieulcirclekorean: 0x3263,
                rieulhieuhkorean: 0x3140,
                rieulkiyeokkorean: 0x313A,
                rieulkiyeoksioskorean: 0x3169,
                rieulkorean: 0x3139,
                rieulmieumkorean: 0x313B,
                rieulpansioskorean: 0x316C,
                rieulparenkorean: 0x3203,
                rieulphieuphkorean: 0x313F,
                rieulpieupkorean: 0x313C,
                rieulpieupsioskorean: 0x316B,
                rieulsioskorean: 0x313D,
                rieulthieuthkorean: 0x313E,
                rieultikeutkorean: 0x316A,
                rieulyeorinhieuhkorean: 0x316D,
                rightangle: 0x221F,
                righttackbelowcmb: 0x0319,
                righttriangle: 0x22BF,
                rihiragana: 0x308A,
                rikatakana: 0x30EA,
                rikatakanahalfwidth: 0xFF98,
                ring: 0x02DA,
                ringbelowcmb: 0x0325,
                ringcmb: 0x030A,
                ringhalfleft: 0x02BF,
                ringhalfleftarmenian: 0x0559,
                ringhalfleftbelowcmb: 0x031C,
                ringhalfleftcentered: 0x02D3,
                ringhalfright: 0x02BE,
                ringhalfrightbelowcmb: 0x0339,
                ringhalfrightcentered: 0x02D2,
                rinvertedbreve: 0x0213,
                rittorusquare: 0x3351,
                rlinebelow: 0x1E5F,
                rlongleg: 0x027C,
                rlonglegturned: 0x027A,
                rmonospace: 0xFF52,
                rohiragana: 0x308D,
                rokatakana: 0x30ED,
                rokatakanahalfwidth: 0xFF9B,
                roruathai: 0x0E23,
                rparen: 0x24AD,
                rrabengali: 0x09DC,
                rradeva: 0x0931,
                rragurmukhi: 0x0A5C,
                rreharabic: 0x0691,
                rrehfinalarabic: 0xFB8D,
                rrvocalicbengali: 0x09E0,
                rrvocalicdeva: 0x0960,
                rrvocalicgujarati: 0x0AE0,
                rrvocalicvowelsignbengali: 0x09C4,
                rrvocalicvowelsigndeva: 0x0944,
                rrvocalicvowelsigngujarati: 0x0AC4,
                rsuperior: 0xF6F1,
                rtblock: 0x2590,
                rturned: 0x0279,
                rturnedsuperior: 0x02B4,
                ruhiragana: 0x308B,
                rukatakana: 0x30EB,
                rukatakanahalfwidth: 0xFF99,
                rupeemarkbengali: 0x09F2,
                rupeesignbengali: 0x09F3,
                rupiah: 0xF6DD,
                ruthai: 0x0E24,
                rvocalicbengali: 0x098B,
                rvocalicdeva: 0x090B,
                rvocalicgujarati: 0x0A8B,
                rvocalicvowelsignbengali: 0x09C3,
                rvocalicvowelsigndeva: 0x0943,
                rvocalicvowelsigngujarati: 0x0AC3,
                s: 0x0073,
                sabengali: 0x09B8,
                sacute: 0x015B,
                sacutedotaccent: 0x1E65,
                sadarabic: 0x0635,
                sadeva: 0x0938,
                sadfinalarabic: 0xFEBA,
                sadinitialarabic: 0xFEBB,
                sadmedialarabic: 0xFEBC,
                sagujarati: 0x0AB8,
                sagurmukhi: 0x0A38,
                sahiragana: 0x3055,
                sakatakana: 0x30B5,
                sakatakanahalfwidth: 0xFF7B,
                sallallahoualayhewasallamarabic: 0xFDFA,
                samekh: 0x05E1,
                samekhdagesh: 0xFB41,
                samekhdageshhebrew: 0xFB41,
                samekhhebrew: 0x05E1,
                saraaathai: 0x0E32,
                saraaethai: 0x0E41,
                saraaimaimalaithai: 0x0E44,
                saraaimaimuanthai: 0x0E43,
                saraamthai: 0x0E33,
                saraathai: 0x0E30,
                saraethai: 0x0E40,
                saraiileftthai: 0xF886,
                saraiithai: 0x0E35,
                saraileftthai: 0xF885,
                saraithai: 0x0E34,
                saraothai: 0x0E42,
                saraueeleftthai: 0xF888,
                saraueethai: 0x0E37,
                saraueleftthai: 0xF887,
                sarauethai: 0x0E36,
                sarauthai: 0x0E38,
                sarauuthai: 0x0E39,
                sbopomofo: 0x3119,
                scaron: 0x0161,
                scarondotaccent: 0x1E67,
                scedilla: 0x015F,
                schwa: 0x0259,
                schwacyrillic: 0x04D9,
                schwadieresiscyrillic: 0x04DB,
                schwahook: 0x025A,
                scircle: 0x24E2,
                scircumflex: 0x015D,
                scommaaccent: 0x0219,
                sdotaccent: 0x1E61,
                sdotbelow: 0x1E63,
                sdotbelowdotaccent: 0x1E69,
                seagullbelowcmb: 0x033C,
                second: 0x2033,
                secondtonechinese: 0x02CA,
                section: 0x00A7,
                seenarabic: 0x0633,
                seenfinalarabic: 0xFEB2,
                seeninitialarabic: 0xFEB3,
                seenmedialarabic: 0xFEB4,
                segol: 0x05B6,
                segol13: 0x05B6,
                segol1f: 0x05B6,
                segol2c: 0x05B6,
                segolhebrew: 0x05B6,
                segolnarrowhebrew: 0x05B6,
                segolquarterhebrew: 0x05B6,
                segoltahebrew: 0x0592,
                segolwidehebrew: 0x05B6,
                seharmenian: 0x057D,
                sehiragana: 0x305B,
                sekatakana: 0x30BB,
                sekatakanahalfwidth: 0xFF7E,
                semicolon: 0x003B,
                semicolonarabic: 0x061B,
                semicolonmonospace: 0xFF1B,
                semicolonsmall: 0xFE54,
                semivoicedmarkkana: 0x309C,
                semivoicedmarkkanahalfwidth: 0xFF9F,
                sentisquare: 0x3322,
                sentosquare: 0x3323,
                seven: 0x0037,
                sevenarabic: 0x0667,
                sevenbengali: 0x09ED,
                sevencircle: 0x2466,
                sevencircleinversesansserif: 0x2790,
                sevendeva: 0x096D,
                seveneighths: 0x215E,
                sevengujarati: 0x0AED,
                sevengurmukhi: 0x0A6D,
                sevenhackarabic: 0x0667,
                sevenhangzhou: 0x3027,
                sevenideographicparen: 0x3226,
                seveninferior: 0x2087,
                sevenmonospace: 0xFF17,
                sevenoldstyle: 0xF737,
                sevenparen: 0x247A,
                sevenperiod: 0x248E,
                sevenpersian: 0x06F7,
                sevenroman: 0x2176,
                sevensuperior: 0x2077,
                seventeencircle: 0x2470,
                seventeenparen: 0x2484,
                seventeenperiod: 0x2498,
                seventhai: 0x0E57,
                sfthyphen: 0x00AD,
                shaarmenian: 0x0577,
                shabengali: 0x09B6,
                shacyrillic: 0x0448,
                shaddaarabic: 0x0651,
                shaddadammaarabic: 0xFC61,
                shaddadammatanarabic: 0xFC5E,
                shaddafathaarabic: 0xFC60,
                shaddakasraarabic: 0xFC62,
                shaddakasratanarabic: 0xFC5F,
                shade: 0x2592,
                shadedark: 0x2593,
                shadelight: 0x2591,
                shademedium: 0x2592,
                shadeva: 0x0936,
                shagujarati: 0x0AB6,
                shagurmukhi: 0x0A36,
                shalshelethebrew: 0x0593,
                shbopomofo: 0x3115,
                shchacyrillic: 0x0449,
                sheenarabic: 0x0634,
                sheenfinalarabic: 0xFEB6,
                sheeninitialarabic: 0xFEB7,
                sheenmedialarabic: 0xFEB8,
                sheicoptic: 0x03E3,
                sheqel: 0x20AA,
                sheqelhebrew: 0x20AA,
                sheva: 0x05B0,
                sheva115: 0x05B0,
                sheva15: 0x05B0,
                sheva22: 0x05B0,
                sheva2e: 0x05B0,
                shevahebrew: 0x05B0,
                shevanarrowhebrew: 0x05B0,
                shevaquarterhebrew: 0x05B0,
                shevawidehebrew: 0x05B0,
                shhacyrillic: 0x04BB,
                shimacoptic: 0x03ED,
                shin: 0x05E9,
                shindagesh: 0xFB49,
                shindageshhebrew: 0xFB49,
                shindageshshindot: 0xFB2C,
                shindageshshindothebrew: 0xFB2C,
                shindageshsindot: 0xFB2D,
                shindageshsindothebrew: 0xFB2D,
                shindothebrew: 0x05C1,
                shinhebrew: 0x05E9,
                shinshindot: 0xFB2A,
                shinshindothebrew: 0xFB2A,
                shinsindot: 0xFB2B,
                shinsindothebrew: 0xFB2B,
                shook: 0x0282,
                sigma: 0x03C3,
                sigma1: 0x03C2,
                sigmafinal: 0x03C2,
                sigmalunatesymbolgreek: 0x03F2,
                sihiragana: 0x3057,
                sikatakana: 0x30B7,
                sikatakanahalfwidth: 0xFF7C,
                siluqhebrew: 0x05BD,
                siluqlefthebrew: 0x05BD,
                similar: 0x223C,
                sindothebrew: 0x05C2,
                siosacirclekorean: 0x3274,
                siosaparenkorean: 0x3214,
                sioscieuckorean: 0x317E,
                sioscirclekorean: 0x3266,
                sioskiyeokkorean: 0x317A,
                sioskorean: 0x3145,
                siosnieunkorean: 0x317B,
                siosparenkorean: 0x3206,
                siospieupkorean: 0x317D,
                siostikeutkorean: 0x317C,
                six: 0x0036,
                sixarabic: 0x0666,
                sixbengali: 0x09EC,
                sixcircle: 0x2465,
                sixcircleinversesansserif: 0x278F,
                sixdeva: 0x096C,
                sixgujarati: 0x0AEC,
                sixgurmukhi: 0x0A6C,
                sixhackarabic: 0x0666,
                sixhangzhou: 0x3026,
                sixideographicparen: 0x3225,
                sixinferior: 0x2086,
                sixmonospace: 0xFF16,
                sixoldstyle: 0xF736,
                sixparen: 0x2479,
                sixperiod: 0x248D,
                sixpersian: 0x06F6,
                sixroman: 0x2175,
                sixsuperior: 0x2076,
                sixteencircle: 0x246F,
                sixteencurrencydenominatorbengali: 0x09F9,
                sixteenparen: 0x2483,
                sixteenperiod: 0x2497,
                sixthai: 0x0E56,
                slash: 0x002F,
                slashmonospace: 0xFF0F,
                slong: 0x017F,
                slongdotaccent: 0x1E9B,
                smileface: 0x263A,
                smonospace: 0xFF53,
                sofpasuqhebrew: 0x05C3,
                softhyphen: 0x00AD,
                softsigncyrillic: 0x044C,
                sohiragana: 0x305D,
                sokatakana: 0x30BD,
                sokatakanahalfwidth: 0xFF7F,
                soliduslongoverlaycmb: 0x0338,
                solidusshortoverlaycmb: 0x0337,
                sorusithai: 0x0E29,
                sosalathai: 0x0E28,
                sosothai: 0x0E0B,
                sosuathai: 0x0E2A,
                space: 0x0020,
                spacehackarabic: 0x0020,
                spade: 0x2660,
                spadesuitblack: 0x2660,
                spadesuitwhite: 0x2664,
                sparen: 0x24AE,
                squarebelowcmb: 0x033B,
                squarecc: 0x33C4,
                squarecm: 0x339D,
                squarediagonalcrosshatchfill: 0x25A9,
                squarehorizontalfill: 0x25A4,
                squarekg: 0x338F,
                squarekm: 0x339E,
                squarekmcapital: 0x33CE,
                squareln: 0x33D1,
                squarelog: 0x33D2,
                squaremg: 0x338E,
                squaremil: 0x33D5,
                squaremm: 0x339C,
                squaremsquared: 0x33A1,
                squareorthogonalcrosshatchfill: 0x25A6,
                squareupperlefttolowerrightfill: 0x25A7,
                squareupperrighttolowerleftfill: 0x25A8,
                squareverticalfill: 0x25A5,
                squarewhitewithsmallblack: 0x25A3,
                srsquare: 0x33DB,
                ssabengali: 0x09B7,
                ssadeva: 0x0937,
                ssagujarati: 0x0AB7,
                ssangcieuckorean: 0x3149,
                ssanghieuhkorean: 0x3185,
                ssangieungkorean: 0x3180,
                ssangkiyeokkorean: 0x3132,
                ssangnieunkorean: 0x3165,
                ssangpieupkorean: 0x3143,
                ssangsioskorean: 0x3146,
                ssangtikeutkorean: 0x3138,
                ssuperior: 0xF6F2,
                sterling: 0x00A3,
                sterlingmonospace: 0xFFE1,
                strokelongoverlaycmb: 0x0336,
                strokeshortoverlaycmb: 0x0335,
                subset: 0x2282,
                subsetnotequal: 0x228A,
                subsetorequal: 0x2286,
                succeeds: 0x227B,
                suchthat: 0x220B,
                suhiragana: 0x3059,
                sukatakana: 0x30B9,
                sukatakanahalfwidth: 0xFF7D,
                sukunarabic: 0x0652,
                summation: 0x2211,
                sun: 0x263C,
                superset: 0x2283,
                supersetnotequal: 0x228B,
                supersetorequal: 0x2287,
                svsquare: 0x33DC,
                syouwaerasquare: 0x337C,
                t: 0x0074,
                tabengali: 0x09A4,
                tackdown: 0x22A4,
                tackleft: 0x22A3,
                tadeva: 0x0924,
                tagujarati: 0x0AA4,
                tagurmukhi: 0x0A24,
                taharabic: 0x0637,
                tahfinalarabic: 0xFEC2,
                tahinitialarabic: 0xFEC3,
                tahiragana: 0x305F,
                tahmedialarabic: 0xFEC4,
                taisyouerasquare: 0x337D,
                takatakana: 0x30BF,
                takatakanahalfwidth: 0xFF80,
                tatweelarabic: 0x0640,
                tau: 0x03C4,
                tav: 0x05EA,
                tavdages: 0xFB4A,
                tavdagesh: 0xFB4A,
                tavdageshhebrew: 0xFB4A,
                tavhebrew: 0x05EA,
                tbar: 0x0167,
                tbopomofo: 0x310A,
                tcaron: 0x0165,
                tccurl: 0x02A8,
                tcedilla: 0x0163,
                tcheharabic: 0x0686,
                tchehfinalarabic: 0xFB7B,
                tchehinitialarabic: 0xFB7C,
                tchehmedialarabic: 0xFB7D,
                tcircle: 0x24E3,
                tcircumflexbelow: 0x1E71,
                tcommaaccent: 0x0163,
                tdieresis: 0x1E97,
                tdotaccent: 0x1E6B,
                tdotbelow: 0x1E6D,
                tecyrillic: 0x0442,
                tedescendercyrillic: 0x04AD,
                teharabic: 0x062A,
                tehfinalarabic: 0xFE96,
                tehhahinitialarabic: 0xFCA2,
                tehhahisolatedarabic: 0xFC0C,
                tehinitialarabic: 0xFE97,
                tehiragana: 0x3066,
                tehjeeminitialarabic: 0xFCA1,
                tehjeemisolatedarabic: 0xFC0B,
                tehmarbutaarabic: 0x0629,
                tehmarbutafinalarabic: 0xFE94,
                tehmedialarabic: 0xFE98,
                tehmeeminitialarabic: 0xFCA4,
                tehmeemisolatedarabic: 0xFC0E,
                tehnoonfinalarabic: 0xFC73,
                tekatakana: 0x30C6,
                tekatakanahalfwidth: 0xFF83,
                telephone: 0x2121,
                telephoneblack: 0x260E,
                telishagedolahebrew: 0x05A0,
                telishaqetanahebrew: 0x05A9,
                tencircle: 0x2469,
                tenideographicparen: 0x3229,
                tenparen: 0x247D,
                tenperiod: 0x2491,
                tenroman: 0x2179,
                tesh: 0x02A7,
                tet: 0x05D8,
                tetdagesh: 0xFB38,
                tetdageshhebrew: 0xFB38,
                tethebrew: 0x05D8,
                tetsecyrillic: 0x04B5,
                tevirhebrew: 0x059B,
                tevirlefthebrew: 0x059B,
                thabengali: 0x09A5,
                thadeva: 0x0925,
                thagujarati: 0x0AA5,
                thagurmukhi: 0x0A25,
                thalarabic: 0x0630,
                thalfinalarabic: 0xFEAC,
                thanthakhatlowleftthai: 0xF898,
                thanthakhatlowrightthai: 0xF897,
                thanthakhatthai: 0x0E4C,
                thanthakhatupperleftthai: 0xF896,
                theharabic: 0x062B,
                thehfinalarabic: 0xFE9A,
                thehinitialarabic: 0xFE9B,
                thehmedialarabic: 0xFE9C,
                thereexists: 0x2203,
                therefore: 0x2234,
                theta: 0x03B8,
                theta1: 0x03D1,
                thetasymbolgreek: 0x03D1,
                thieuthacirclekorean: 0x3279,
                thieuthaparenkorean: 0x3219,
                thieuthcirclekorean: 0x326B,
                thieuthkorean: 0x314C,
                thieuthparenkorean: 0x320B,
                thirteencircle: 0x246C,
                thirteenparen: 0x2480,
                thirteenperiod: 0x2494,
                thonangmonthothai: 0x0E11,
                thook: 0x01AD,
                thophuthaothai: 0x0E12,
                thorn: 0x00FE,
                thothahanthai: 0x0E17,
                thothanthai: 0x0E10,
                thothongthai: 0x0E18,
                thothungthai: 0x0E16,
                thousandcyrillic: 0x0482,
                thousandsseparatorarabic: 0x066C,
                thousandsseparatorpersian: 0x066C,
                three: 0x0033,
                threearabic: 0x0663,
                threebengali: 0x09E9,
                threecircle: 0x2462,
                threecircleinversesansserif: 0x278C,
                threedeva: 0x0969,
                threeeighths: 0x215C,
                threegujarati: 0x0AE9,
                threegurmukhi: 0x0A69,
                threehackarabic: 0x0663,
                threehangzhou: 0x3023,
                threeideographicparen: 0x3222,
                threeinferior: 0x2083,
                threemonospace: 0xFF13,
                threenumeratorbengali: 0x09F6,
                threeoldstyle: 0xF733,
                threeparen: 0x2476,
                threeperiod: 0x248A,
                threepersian: 0x06F3,
                threequarters: 0x00BE,
                threequartersemdash: 0xF6DE,
                threeroman: 0x2172,
                threesuperior: 0x00B3,
                threethai: 0x0E53,
                thzsquare: 0x3394,
                tihiragana: 0x3061,
                tikatakana: 0x30C1,
                tikatakanahalfwidth: 0xFF81,
                tikeutacirclekorean: 0x3270,
                tikeutaparenkorean: 0x3210,
                tikeutcirclekorean: 0x3262,
                tikeutkorean: 0x3137,
                tikeutparenkorean: 0x3202,
                tilde: 0x02DC,
                tildebelowcmb: 0x0330,
                tildecmb: 0x0303,
                tildecomb: 0x0303,
                tildedoublecmb: 0x0360,
                tildeoperator: 0x223C,
                tildeoverlaycmb: 0x0334,
                tildeverticalcmb: 0x033E,
                timescircle: 0x2297,
                tipehahebrew: 0x0596,
                tipehalefthebrew: 0x0596,
                tippigurmukhi: 0x0A70,
                titlocyrilliccmb: 0x0483,
                tiwnarmenian: 0x057F,
                tlinebelow: 0x1E6F,
                tmonospace: 0xFF54,
                toarmenian: 0x0569,
                tohiragana: 0x3068,
                tokatakana: 0x30C8,
                tokatakanahalfwidth: 0xFF84,
                tonebarextrahighmod: 0x02E5,
                tonebarextralowmod: 0x02E9,
                tonebarhighmod: 0x02E6,
                tonebarlowmod: 0x02E8,
                tonebarmidmod: 0x02E7,
                tonefive: 0x01BD,
                tonesix: 0x0185,
                tonetwo: 0x01A8,
                tonos: 0x0384,
                tonsquare: 0x3327,
                topatakthai: 0x0E0F,
                tortoiseshellbracketleft: 0x3014,
                tortoiseshellbracketleftsmall: 0xFE5D,
                tortoiseshellbracketleftvertical: 0xFE39,
                tortoiseshellbracketright: 0x3015,
                tortoiseshellbracketrightsmall: 0xFE5E,
                tortoiseshellbracketrightvertical: 0xFE3A,
                totaothai: 0x0E15,
                tpalatalhook: 0x01AB,
                tparen: 0x24AF,
                trademark: 0x2122,
                trademarksans: 0xF8EA,
                trademarkserif: 0xF6DB,
                tretroflexhook: 0x0288,
                triagdn: 0x25BC,
                triaglf: 0x25C4,
                triagrt: 0x25BA,
                triagup: 0x25B2,
                ts: 0x02A6,
                tsadi: 0x05E6,
                tsadidagesh: 0xFB46,
                tsadidageshhebrew: 0xFB46,
                tsadihebrew: 0x05E6,
                tsecyrillic: 0x0446,
                tsere: 0x05B5,
                tsere12: 0x05B5,
                tsere1e: 0x05B5,
                tsere2b: 0x05B5,
                tserehebrew: 0x05B5,
                tserenarrowhebrew: 0x05B5,
                tserequarterhebrew: 0x05B5,
                tserewidehebrew: 0x05B5,
                tshecyrillic: 0x045B,
                tsuperior: 0xF6F3,
                ttabengali: 0x099F,
                ttadeva: 0x091F,
                ttagujarati: 0x0A9F,
                ttagurmukhi: 0x0A1F,
                tteharabic: 0x0679,
                ttehfinalarabic: 0xFB67,
                ttehinitialarabic: 0xFB68,
                ttehmedialarabic: 0xFB69,
                tthabengali: 0x09A0,
                tthadeva: 0x0920,
                tthagujarati: 0x0AA0,
                tthagurmukhi: 0x0A20,
                tturned: 0x0287,
                tuhiragana: 0x3064,
                tukatakana: 0x30C4,
                tukatakanahalfwidth: 0xFF82,
                tusmallhiragana: 0x3063,
                tusmallkatakana: 0x30C3,
                tusmallkatakanahalfwidth: 0xFF6F,
                twelvecircle: 0x246B,
                twelveparen: 0x247F,
                twelveperiod: 0x2493,
                twelveroman: 0x217B,
                twentycircle: 0x2473,
                twentyhangzhou: 0x5344,
                twentyparen: 0x2487,
                twentyperiod: 0x249B,
                two: 0x0032,
                twoarabic: 0x0662,
                twobengali: 0x09E8,
                twocircle: 0x2461,
                twocircleinversesansserif: 0x278B,
                twodeva: 0x0968,
                twodotenleader: 0x2025,
                twodotleader: 0x2025,
                twodotleadervertical: 0xFE30,
                twogujarati: 0x0AE8,
                twogurmukhi: 0x0A68,
                twohackarabic: 0x0662,
                twohangzhou: 0x3022,
                twoideographicparen: 0x3221,
                twoinferior: 0x2082,
                twomonospace: 0xFF12,
                twonumeratorbengali: 0x09F5,
                twooldstyle: 0xF732,
                twoparen: 0x2475,
                twoperiod: 0x2489,
                twopersian: 0x06F2,
                tworoman: 0x2171,
                twostroke: 0x01BB,
                twosuperior: 0x00B2,
                twothai: 0x0E52,
                twothirds: 0x2154,
                u: 0x0075,
                uacute: 0x00FA,
                ubar: 0x0289,
                ubengali: 0x0989,
                ubopomofo: 0x3128,
                ubreve: 0x016D,
                ucaron: 0x01D4,
                ucircle: 0x24E4,
                ucircumflex: 0x00FB,
                ucircumflexbelow: 0x1E77,
                ucyrillic: 0x0443,
                udattadeva: 0x0951,
                udblacute: 0x0171,
                udblgrave: 0x0215,
                udeva: 0x0909,
                udieresis: 0x00FC,
                udieresisacute: 0x01D8,
                udieresisbelow: 0x1E73,
                udieresiscaron: 0x01DA,
                udieresiscyrillic: 0x04F1,
                udieresisgrave: 0x01DC,
                udieresismacron: 0x01D6,
                udotbelow: 0x1EE5,
                ugrave: 0x00F9,
                ugujarati: 0x0A89,
                ugurmukhi: 0x0A09,
                uhiragana: 0x3046,
                uhookabove: 0x1EE7,
                uhorn: 0x01B0,
                uhornacute: 0x1EE9,
                uhorndotbelow: 0x1EF1,
                uhorngrave: 0x1EEB,
                uhornhookabove: 0x1EED,
                uhorntilde: 0x1EEF,
                uhungarumlaut: 0x0171,
                uhungarumlautcyrillic: 0x04F3,
                uinvertedbreve: 0x0217,
                ukatakana: 0x30A6,
                ukatakanahalfwidth: 0xFF73,
                ukcyrillic: 0x0479,
                ukorean: 0x315C,
                umacron: 0x016B,
                umacroncyrillic: 0x04EF,
                umacrondieresis: 0x1E7B,
                umatragurmukhi: 0x0A41,
                umonospace: 0xFF55,
                underscore: 0x005F,
                underscoredbl: 0x2017,
                underscoremonospace: 0xFF3F,
                underscorevertical: 0xFE33,
                underscorewavy: 0xFE4F,
                union: 0x222A,
                universal: 0x2200,
                uogonek: 0x0173,
                uparen: 0x24B0,
                upblock: 0x2580,
                upperdothebrew: 0x05C4,
                upsilon: 0x03C5,
                upsilondieresis: 0x03CB,
                upsilondieresistonos: 0x03B0,
                upsilonlatin: 0x028A,
                upsilontonos: 0x03CD,
                uptackbelowcmb: 0x031D,
                uptackmod: 0x02D4,
                uragurmukhi: 0x0A73,
                uring: 0x016F,
                ushortcyrillic: 0x045E,
                usmallhiragana: 0x3045,
                usmallkatakana: 0x30A5,
                usmallkatakanahalfwidth: 0xFF69,
                ustraightcyrillic: 0x04AF,
                ustraightstrokecyrillic: 0x04B1,
                utilde: 0x0169,
                utildeacute: 0x1E79,
                utildebelow: 0x1E75,
                uubengali: 0x098A,
                uudeva: 0x090A,
                uugujarati: 0x0A8A,
                uugurmukhi: 0x0A0A,
                uumatragurmukhi: 0x0A42,
                uuvowelsignbengali: 0x09C2,
                uuvowelsigndeva: 0x0942,
                uuvowelsigngujarati: 0x0AC2,
                uvowelsignbengali: 0x09C1,
                uvowelsigndeva: 0x0941,
                uvowelsigngujarati: 0x0AC1,
                v: 0x0076,
                vadeva: 0x0935,
                vagujarati: 0x0AB5,
                vagurmukhi: 0x0A35,
                vakatakana: 0x30F7,
                vav: 0x05D5,
                vavdagesh: 0xFB35,
                vavdagesh65: 0xFB35,
                vavdageshhebrew: 0xFB35,
                vavhebrew: 0x05D5,
                vavholam: 0xFB4B,
                vavholamhebrew: 0xFB4B,
                vavvavhebrew: 0x05F0,
                vavyodhebrew: 0x05F1,
                vcircle: 0x24E5,
                vdotbelow: 0x1E7F,
                vecyrillic: 0x0432,
                veharabic: 0x06A4,
                vehfinalarabic: 0xFB6B,
                vehinitialarabic: 0xFB6C,
                vehmedialarabic: 0xFB6D,
                vekatakana: 0x30F9,
                venus: 0x2640,
                verticalbar: 0x007C,
                verticallineabovecmb: 0x030D,
                verticallinebelowcmb: 0x0329,
                verticallinelowmod: 0x02CC,
                verticallinemod: 0x02C8,
                vewarmenian: 0x057E,
                vhook: 0x028B,
                vikatakana: 0x30F8,
                viramabengali: 0x09CD,
                viramadeva: 0x094D,
                viramagujarati: 0x0ACD,
                visargabengali: 0x0983,
                visargadeva: 0x0903,
                visargagujarati: 0x0A83,
                vmonospace: 0xFF56,
                voarmenian: 0x0578,
                voicediterationhiragana: 0x309E,
                voicediterationkatakana: 0x30FE,
                voicedmarkkana: 0x309B,
                voicedmarkkanahalfwidth: 0xFF9E,
                vokatakana: 0x30FA,
                vparen: 0x24B1,
                vtilde: 0x1E7D,
                vturned: 0x028C,
                vuhiragana: 0x3094,
                vukatakana: 0x30F4,
                w: 0x0077,
                wacute: 0x1E83,
                waekorean: 0x3159,
                wahiragana: 0x308F,
                wakatakana: 0x30EF,
                wakatakanahalfwidth: 0xFF9C,
                wakorean: 0x3158,
                wasmallhiragana: 0x308E,
                wasmallkatakana: 0x30EE,
                wattosquare: 0x3357,
                wavedash: 0x301C,
                wavyunderscorevertical: 0xFE34,
                wawarabic: 0x0648,
                wawfinalarabic: 0xFEEE,
                wawhamzaabovearabic: 0x0624,
                wawhamzaabovefinalarabic: 0xFE86,
                wbsquare: 0x33DD,
                wcircle: 0x24E6,
                wcircumflex: 0x0175,
                wdieresis: 0x1E85,
                wdotaccent: 0x1E87,
                wdotbelow: 0x1E89,
                wehiragana: 0x3091,
                weierstrass: 0x2118,
                wekatakana: 0x30F1,
                wekorean: 0x315E,
                weokorean: 0x315D,
                wgrave: 0x1E81,
                whitebullet: 0x25E6,
                whitecircle: 0x25CB,
                whitecircleinverse: 0x25D9,
                whitecornerbracketleft: 0x300E,
                whitecornerbracketleftvertical: 0xFE43,
                whitecornerbracketright: 0x300F,
                whitecornerbracketrightvertical: 0xFE44,
                whitediamond: 0x25C7,
                whitediamondcontainingblacksmalldiamond: 0x25C8,
                whitedownpointingsmalltriangle: 0x25BF,
                whitedownpointingtriangle: 0x25BD,
                whiteleftpointingsmalltriangle: 0x25C3,
                whiteleftpointingtriangle: 0x25C1,
                whitelenticularbracketleft: 0x3016,
                whitelenticularbracketright: 0x3017,
                whiterightpointingsmalltriangle: 0x25B9,
                whiterightpointingtriangle: 0x25B7,
                whitesmallsquare: 0x25AB,
                whitesmilingface: 0x263A,
                whitesquare: 0x25A1,
                whitestar: 0x2606,
                whitetelephone: 0x260F,
                whitetortoiseshellbracketleft: 0x3018,
                whitetortoiseshellbracketright: 0x3019,
                whiteuppointingsmalltriangle: 0x25B5,
                whiteuppointingtriangle: 0x25B3,
                wihiragana: 0x3090,
                wikatakana: 0x30F0,
                wikorean: 0x315F,
                wmonospace: 0xFF57,
                wohiragana: 0x3092,
                wokatakana: 0x30F2,
                wokatakanahalfwidth: 0xFF66,
                won: 0x20A9,
                wonmonospace: 0xFFE6,
                wowaenthai: 0x0E27,
                wparen: 0x24B2,
                wring: 0x1E98,
                wsuperior: 0x02B7,
                wturned: 0x028D,
                wynn: 0x01BF,
                x: 0x0078,
                xabovecmb: 0x033D,
                xbopomofo: 0x3112,
                xcircle: 0x24E7,
                xdieresis: 0x1E8D,
                xdotaccent: 0x1E8B,
                xeharmenian: 0x056D,
                xi: 0x03BE,
                xmonospace: 0xFF58,
                xparen: 0x24B3,
                xsuperior: 0x02E3,
                y: 0x0079,
                yaadosquare: 0x334E,
                yabengali: 0x09AF,
                yacute: 0x00FD,
                yadeva: 0x092F,
                yaekorean: 0x3152,
                yagujarati: 0x0AAF,
                yagurmukhi: 0x0A2F,
                yahiragana: 0x3084,
                yakatakana: 0x30E4,
                yakatakanahalfwidth: 0xFF94,
                yakorean: 0x3151,
                yamakkanthai: 0x0E4E,
                yasmallhiragana: 0x3083,
                yasmallkatakana: 0x30E3,
                yasmallkatakanahalfwidth: 0xFF6C,
                yatcyrillic: 0x0463,
                ycircle: 0x24E8,
                ycircumflex: 0x0177,
                ydieresis: 0x00FF,
                ydotaccent: 0x1E8F,
                ydotbelow: 0x1EF5,
                yeharabic: 0x064A,
                yehbarreearabic: 0x06D2,
                yehbarreefinalarabic: 0xFBAF,
                yehfinalarabic: 0xFEF2,
                yehhamzaabovearabic: 0x0626,
                yehhamzaabovefinalarabic: 0xFE8A,
                yehhamzaaboveinitialarabic: 0xFE8B,
                yehhamzaabovemedialarabic: 0xFE8C,
                yehinitialarabic: 0xFEF3,
                yehmedialarabic: 0xFEF4,
                yehmeeminitialarabic: 0xFCDD,
                yehmeemisolatedarabic: 0xFC58,
                yehnoonfinalarabic: 0xFC94,
                yehthreedotsbelowarabic: 0x06D1,
                yekorean: 0x3156,
                yen: 0x00A5,
                yenmonospace: 0xFFE5,
                yeokorean: 0x3155,
                yeorinhieuhkorean: 0x3186,
                yerahbenyomohebrew: 0x05AA,
                yerahbenyomolefthebrew: 0x05AA,
                yericyrillic: 0x044B,
                yerudieresiscyrillic: 0x04F9,
                yesieungkorean: 0x3181,
                yesieungpansioskorean: 0x3183,
                yesieungsioskorean: 0x3182,
                yetivhebrew: 0x059A,
                ygrave: 0x1EF3,
                yhook: 0x01B4,
                yhookabove: 0x1EF7,
                yiarmenian: 0x0575,
                yicyrillic: 0x0457,
                yikorean: 0x3162,
                yinyang: 0x262F,
                yiwnarmenian: 0x0582,
                ymonospace: 0xFF59,
                yod: 0x05D9,
                yoddagesh: 0xFB39,
                yoddageshhebrew: 0xFB39,
                yodhebrew: 0x05D9,
                yodyodhebrew: 0x05F2,
                yodyodpatahhebrew: 0xFB1F,
                yohiragana: 0x3088,
                yoikorean: 0x3189,
                yokatakana: 0x30E8,
                yokatakanahalfwidth: 0xFF96,
                yokorean: 0x315B,
                yosmallhiragana: 0x3087,
                yosmallkatakana: 0x30E7,
                yosmallkatakanahalfwidth: 0xFF6E,
                yotgreek: 0x03F3,
                yoyaekorean: 0x3188,
                yoyakorean: 0x3187,
                yoyakthai: 0x0E22,
                yoyingthai: 0x0E0D,
                yparen: 0x24B4,
                ypogegrammeni: 0x037A,
                ypogegrammenigreekcmb: 0x0345,
                yr: 0x01A6,
                yring: 0x1E99,
                ysuperior: 0x02B8,
                ytilde: 0x1EF9,
                yturned: 0x028E,
                yuhiragana: 0x3086,
                yuikorean: 0x318C,
                yukatakana: 0x30E6,
                yukatakanahalfwidth: 0xFF95,
                yukorean: 0x3160,
                yusbigcyrillic: 0x046B,
                yusbigiotifiedcyrillic: 0x046D,
                yuslittlecyrillic: 0x0467,
                yuslittleiotifiedcyrillic: 0x0469,
                yusmallhiragana: 0x3085,
                yusmallkatakana: 0x30E5,
                yusmallkatakanahalfwidth: 0xFF6D,
                yuyekorean: 0x318B,
                yuyeokorean: 0x318A,
                yyabengali: 0x09DF,
                yyadeva: 0x095F,
                z: 0x007A,
                zaarmenian: 0x0566,
                zacute: 0x017A,
                zadeva: 0x095B,
                zagurmukhi: 0x0A5B,
                zaharabic: 0x0638,
                zahfinalarabic: 0xFEC6,
                zahinitialarabic: 0xFEC7,
                zahiragana: 0x3056,
                zahmedialarabic: 0xFEC8,
                zainarabic: 0x0632,
                zainfinalarabic: 0xFEB0,
                zakatakana: 0x30B6,
                zaqefgadolhebrew: 0x0595,
                zaqefqatanhebrew: 0x0594,
                zarqahebrew: 0x0598,
                zayin: 0x05D6,
                zayindagesh: 0xFB36,
                zayindageshhebrew: 0xFB36,
                zayinhebrew: 0x05D6,
                zbopomofo: 0x3117,
                zcaron: 0x017E,
                zcircle: 0x24E9,
                zcircumflex: 0x1E91,
                zcurl: 0x0291,
                zdot: 0x017C,
                zdotaccent: 0x017C,
                zdotbelow: 0x1E93,
                zecyrillic: 0x0437,
                zedescendercyrillic: 0x0499,
                zedieresiscyrillic: 0x04DF,
                zehiragana: 0x305C,
                zekatakana: 0x30BC,
                zero: 0x0030,
                zeroarabic: 0x0660,
                zerobengali: 0x09E6,
                zerodeva: 0x0966,
                zerogujarati: 0x0AE6,
                zerogurmukhi: 0x0A66,
                zerohackarabic: 0x0660,
                zeroinferior: 0x2080,
                zeromonospace: 0xFF10,
                zerooldstyle: 0xF730,
                zeropersian: 0x06F0,
                zerosuperior: 0x2070,
                zerothai: 0x0E50,
                zerowidthjoiner: 0xFEFF,
                zerowidthnonjoiner: 0x200C,
                zerowidthspace: 0x200B,
                zeta: 0x03B6,
                zhbopomofo: 0x3113,
                zhearmenian: 0x056A,
                zhebrevecyrillic: 0x04C2,
                zhecyrillic: 0x0436,
                zhedescendercyrillic: 0x0497,
                zhedieresiscyrillic: 0x04DD,
                zihiragana: 0x3058,
                zikatakana: 0x30B8,
                zinorhebrew: 0x05AE,
                zlinebelow: 0x1E95,
                zmonospace: 0xFF5A,
                zohiragana: 0x305E,
                zokatakana: 0x30BE,
                zparen: 0x24B5,
                zretroflexhook: 0x0290,
                zstroke: 0x01B6,
                zuhiragana: 0x305A,
                zukatakana: 0x30BA,
                '.notdef': 0x0000
            };
            var DingbatsGlyphsUnicode = {
                space: 0x0020,
                a1: 0x2701,
                a2: 0x2702,
                a202: 0x2703,
                a3: 0x2704,
                a4: 0x260E,
                a5: 0x2706,
                a119: 0x2707,
                a118: 0x2708,
                a117: 0x2709,
                a11: 0x261B,
                a12: 0x261E,
                a13: 0x270C,
                a14: 0x270D,
                a15: 0x270E,
                a16: 0x270F,
                a105: 0x2710,
                a17: 0x2711,
                a18: 0x2712,
                a19: 0x2713,
                a20: 0x2714,
                a21: 0x2715,
                a22: 0x2716,
                a23: 0x2717,
                a24: 0x2718,
                a25: 0x2719,
                a26: 0x271A,
                a27: 0x271B,
                a28: 0x271C,
                a6: 0x271D,
                a7: 0x271E,
                a8: 0x271F,
                a9: 0x2720,
                a10: 0x2721,
                a29: 0x2722,
                a30: 0x2723,
                a31: 0x2724,
                a32: 0x2725,
                a33: 0x2726,
                a34: 0x2727,
                a35: 0x2605,
                a36: 0x2729,
                a37: 0x272A,
                a38: 0x272B,
                a39: 0x272C,
                a40: 0x272D,
                a41: 0x272E,
                a42: 0x272F,
                a43: 0x2730,
                a44: 0x2731,
                a45: 0x2732,
                a46: 0x2733,
                a47: 0x2734,
                a48: 0x2735,
                a49: 0x2736,
                a50: 0x2737,
                a51: 0x2738,
                a52: 0x2739,
                a53: 0x273A,
                a54: 0x273B,
                a55: 0x273C,
                a56: 0x273D,
                a57: 0x273E,
                a58: 0x273F,
                a59: 0x2740,
                a60: 0x2741,
                a61: 0x2742,
                a62: 0x2743,
                a63: 0x2744,
                a64: 0x2745,
                a65: 0x2746,
                a66: 0x2747,
                a67: 0x2748,
                a68: 0x2749,
                a69: 0x274A,
                a70: 0x274B,
                a71: 0x25CF,
                a72: 0x274D,
                a73: 0x25A0,
                a74: 0x274F,
                a203: 0x2750,
                a75: 0x2751,
                a204: 0x2752,
                a76: 0x25B2,
                a77: 0x25BC,
                a78: 0x25C6,
                a79: 0x2756,
                a81: 0x25D7,
                a82: 0x2758,
                a83: 0x2759,
                a84: 0x275A,
                a97: 0x275B,
                a98: 0x275C,
                a99: 0x275D,
                a100: 0x275E,
                a101: 0x2761,
                a102: 0x2762,
                a103: 0x2763,
                a104: 0x2764,
                a106: 0x2765,
                a107: 0x2766,
                a108: 0x2767,
                a112: 0x2663,
                a111: 0x2666,
                a110: 0x2665,
                a109: 0x2660,
                a120: 0x2460,
                a121: 0x2461,
                a122: 0x2462,
                a123: 0x2463,
                a124: 0x2464,
                a125: 0x2465,
                a126: 0x2466,
                a127: 0x2467,
                a128: 0x2468,
                a129: 0x2469,
                a130: 0x2776,
                a131: 0x2777,
                a132: 0x2778,
                a133: 0x2779,
                a134: 0x277A,
                a135: 0x277B,
                a136: 0x277C,
                a137: 0x277D,
                a138: 0x277E,
                a139: 0x277F,
                a140: 0x2780,
                a141: 0x2781,
                a142: 0x2782,
                a143: 0x2783,
                a144: 0x2784,
                a145: 0x2785,
                a146: 0x2786,
                a147: 0x2787,
                a148: 0x2788,
                a149: 0x2789,
                a150: 0x278A,
                a151: 0x278B,
                a152: 0x278C,
                a153: 0x278D,
                a154: 0x278E,
                a155: 0x278F,
                a156: 0x2790,
                a157: 0x2791,
                a158: 0x2792,
                a159: 0x2793,
                a160: 0x2794,
                a161: 0x2192,
                a163: 0x2194,
                a164: 0x2195,
                a196: 0x2798,
                a165: 0x2799,
                a192: 0x279A,
                a166: 0x279B,
                a167: 0x279C,
                a168: 0x279D,
                a169: 0x279E,
                a170: 0x279F,
                a171: 0x27A0,
                a172: 0x27A1,
                a173: 0x27A2,
                a162: 0x27A3,
                a174: 0x27A4,
                a175: 0x27A5,
                a176: 0x27A6,
                a177: 0x27A7,
                a178: 0x27A8,
                a179: 0x27A9,
                a193: 0x27AA,
                a180: 0x27AB,
                a199: 0x27AC,
                a181: 0x27AD,
                a200: 0x27AE,
                a182: 0x27AF,
                a201: 0x27B1,
                a183: 0x27B2,
                a184: 0x27B3,
                a197: 0x27B4,
                a185: 0x27B5,
                a194: 0x27B6,
                a198: 0x27B7,
                a186: 0x27B8,
                a195: 0x27B9,
                a187: 0x27BA,
                a188: 0x27BB,
                a189: 0x27BC,
                a190: 0x27BD,
                a191: 0x27BE,
                a89: 0x2768,
                a90: 0x2769,
                a93: 0x276A,
                a94: 0x276B,
                a91: 0x276C,
                a92: 0x276D,
                a205: 0x276E,
                a85: 0x276F,
                a206: 0x2770,
                a86: 0x2771,
                a87: 0x2772,
                a88: 0x2773,
                a95: 0x2774,
                a96: 0x2775,
                '.notdef': 0x0000
            };
            exports.GlyphsUnicode = GlyphsUnicode;
            exports.DingbatsGlyphsUnicode = DingbatsGlyphsUnicode;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsCoreJpg = {}));
            }
        }(this, function(exports) {
            var JpegImage = (function jpegImage() {
                var dctZigZag = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);
                var dctCos1 = 4017;
                var dctSin1 = 799;
                var dctCos3 = 3406;
                var dctSin3 = 2276;
                var dctCos6 = 1567;
                var dctSin6 = 3784;
                var dctSqrt2 = 5793;
                var dctSqrt1d2 = 2896;

                function constructor() {}

                function buildHuffmanTable(codeLengths, values) {
                    var k = 0,
                        code = [],
                        i, j, length = 16;
                    while (length > 0 && !codeLengths[length - 1]) {
                        length--;
                    }
                    code.push({
                        children: [],
                        index: 0
                    });
                    var p = code[0],
                        q;
                    for (i = 0; i < length; i++) {
                        for (j = 0; j < codeLengths[i]; j++) {
                            p = code.pop();
                            p.children[p.index] = values[k];
                            while (p.index > 0) {
                                p = code.pop();
                            }
                            p.index++;
                            code.push(p);
                            while (code.length <= i) {
                                code.push(q = {
                                    children: [],
                                    index: 0
                                });
                                p.children[p.index] = q.children;
                                p = q;
                            }
                            k++;
                        }
                        if (i + 1 < length) {
                            code.push(q = {
                                children: [],
                                index: 0
                            });
                            p.children[p.index] = q.children;
                            p = q;
                        }
                    }
                    return code[0].children;
                }

                function getBlockBufferOffset(component, row, col) {
                    return 64 * ((component.blocksPerLine + 1) * row + col);
                }

                function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive) {
                    var mcusPerLine = frame.mcusPerLine;
                    var progressive = frame.progressive;
                    var startOffset = offset,
                        bitsData = 0,
                        bitsCount = 0;

                    function readBit() {
                        if (bitsCount > 0) {
                            bitsCount--;
                            return (bitsData >> bitsCount) & 1;
                        }
                        bitsData = data[offset++];
                        if (bitsData === 0xFF) {
                            var nextByte = data[offset++];
                            if (nextByte) {
                                throw 'unexpected marker: ' +
                                    ((bitsData << 8) | nextByte).toString(16);
                            }
                        }
                        bitsCount = 7;
                        return bitsData >>> 7;
                    }

                    function decodeHuffman(tree) {
                        var node = tree;
                        while (true) {
                            node = node[readBit()];
                            if (typeof node === 'number') {
                                return node;
                            }
                            if (typeof node !== 'object') {
                                throw 'invalid huffman sequence';
                            }
                        }
                    }

                    function receive(length) {
                        var n = 0;
                        while (length > 0) {
                            n = (n << 1) | readBit();
                            length--;
                        }
                        return n;
                    }

                    function receiveAndExtend(length) {
                        if (length === 1) {
                            return readBit() === 1 ? 1 : -1;
                        }
                        var n = receive(length);
                        if (n >= 1 << (length - 1)) {
                            return n;
                        }
                        return n + (-1 << length) + 1;
                    }

                    function decodeBaseline(component, offset) {
                        var t = decodeHuffman(component.huffmanTableDC);
                        var diff = t === 0 ? 0 : receiveAndExtend(t);
                        component.blockData[offset] = (component.pred += diff);
                        var k = 1;
                        while (k < 64) {
                            var rs = decodeHuffman(component.huffmanTableAC);
                            var s = rs & 15,
                                r = rs >> 4;
                            if (s === 0) {
                                if (r < 15) {
                                    break;
                                }
                                k += 16;
                                continue;
                            }
                            k += r;
                            var z = dctZigZag[k];
                            component.blockData[offset + z] = receiveAndExtend(s);
                            k++;
                        }
                    }

                    function decodeDCFirst(component, offset) {
                        var t = decodeHuffman(component.huffmanTableDC);
                        var diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);
                        component.blockData[offset] = (component.pred += diff);
                    }

                    function decodeDCSuccessive(component, offset) {
                        component.blockData[offset] |= readBit() << successive;
                    }
                    var eobrun = 0;

                    function decodeACFirst(component, offset) {
                        if (eobrun > 0) {
                            eobrun--;
                            return;
                        }
                        var k = spectralStart,
                            e = spectralEnd;
                        while (k <= e) {
                            var rs = decodeHuffman(component.huffmanTableAC);
                            var s = rs & 15,
                                r = rs >> 4;
                            if (s === 0) {
                                if (r < 15) {
                                    eobrun = receive(r) + (1 << r) - 1;
                                    break;
                                }
                                k += 16;
                                continue;
                            }
                            k += r;
                            var z = dctZigZag[k];
                            component.blockData[offset + z] = receiveAndExtend(s) * (1 << successive);
                            k++;
                        }
                    }
                    var successiveACState = 0,
                        successiveACNextValue;

                    function decodeACSuccessive(component, offset) {
                        var k = spectralStart;
                        var e = spectralEnd;
                        var r = 0;
                        var s;
                        var rs;
                        while (k <= e) {
                            var z = dctZigZag[k];
                            switch (successiveACState) {
                                case 0:
                                    rs = decodeHuffman(component.huffmanTableAC);
                                    s = rs & 15;
                                    r = rs >> 4;
                                    if (s === 0) {
                                        if (r < 15) {
                                            eobrun = receive(r) + (1 << r);
                                            successiveACState = 4;
                                        } else {
                                            r = 16;
                                            successiveACState = 1;
                                        }
                                    } else {
                                        if (s !== 1) {
                                            throw 'invalid ACn encoding';
                                        }
                                        successiveACNextValue = receiveAndExtend(s);
                                        successiveACState = r ? 2 : 3;
                                    }
                                    continue;
                                case 1:
                                case 2:
                                    if (component.blockData[offset + z]) {
                                        component.blockData[offset + z] += (readBit() << successive);
                                    } else {
                                        r--;
                                        if (r === 0) {
                                            successiveACState = successiveACState === 2 ? 3 : 0;
                                        }
                                    }
                                    break;
                                case 3:
                                    if (component.blockData[offset + z]) {
                                        component.blockData[offset + z] += (readBit() << successive);
                                    } else {
                                        component.blockData[offset + z] = successiveACNextValue << successive;
                                        successiveACState = 0;
                                    }
                                    break;
                                case 4:
                                    if (component.blockData[offset + z]) {
                                        component.blockData[offset + z] += (readBit() << successive);
                                    }
                                    break;
                            }
                            k++;
                        }
                        if (successiveACState === 4) {
                            eobrun--;
                            if (eobrun === 0) {
                                successiveACState = 0;
                            }
                        }
                    }

                    function decodeMcu(component, decode, mcu, row, col) {
                        var mcuRow = (mcu / mcusPerLine) | 0;
                        var mcuCol = mcu % mcusPerLine;
                        var blockRow = mcuRow * component.v + row;
                        var blockCol = mcuCol * component.h + col;
                        var offset = getBlockBufferOffset(component, blockRow, blockCol);
                        decode(component, offset);
                    }

                    function decodeBlock(component, decode, mcu) {
                        var blockRow = (mcu / component.blocksPerLine) | 0;
                        var blockCol = mcu % component.blocksPerLine;
                        var offset = getBlockBufferOffset(component, blockRow, blockCol);
                        decode(component, offset);
                    }
                    var componentsLength = components.length;
                    var component, i, j, k, n;
                    var decodeFn;
                    if (progressive) {
                        if (spectralStart === 0) {
                            decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
                        } else {
                            decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
                        }
                    } else {
                        decodeFn = decodeBaseline;
                    }
                    var mcu = 0,
                        marker;
                    var mcuExpected;
                    if (componentsLength === 1) {
                        mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
                    } else {
                        mcuExpected = mcusPerLine * frame.mcusPerColumn;
                    }
                    if (!resetInterval) {
                        resetInterval = mcuExpected;
                    }
                    var h, v;
                    while (mcu < mcuExpected) {
                        for (i = 0; i < componentsLength; i++) {
                            components[i].pred = 0;
                        }
                        eobrun = 0;
                        if (componentsLength === 1) {
                            component = components[0];
                            for (n = 0; n < resetInterval; n++) {
                                decodeBlock(component, decodeFn, mcu);
                                mcu++;
                            }
                        } else {
                            for (n = 0; n < resetInterval; n++) {
                                for (i = 0; i < componentsLength; i++) {
                                    component = components[i];
                                    h = component.h;
                                    v = component.v;
                                    for (j = 0; j < v; j++) {
                                        for (k = 0; k < h; k++) {
                                            decodeMcu(component, decodeFn, mcu, j, k);
                                        }
                                    }
                                }
                                mcu++;
                            }
                        }
                        bitsCount = 0;
                        marker = (data[offset] << 8) | data[offset + 1];
                        if (marker <= 0xFF00) {
                            throw 'marker was not found';
                        }
                        if (marker >= 0xFFD0 && marker <= 0xFFD7) {
                            offset += 2;
                        } else {
                            break;
                        }
                    }
                    return offset - startOffset;
                }

                function quantizeAndInverse(component, blockBufferOffset, p) {
                    var qt = component.quantizationTable,
                        blockData = component.blockData;
                    var v0, v1, v2, v3, v4, v5, v6, v7;
                    var p0, p1, p2, p3, p4, p5, p6, p7;
                    var t;
                    for (var row = 0; row < 64; row += 8) {
                        p0 = blockData[blockBufferOffset + row];
                        p1 = blockData[blockBufferOffset + row + 1];
                        p2 = blockData[blockBufferOffset + row + 2];
                        p3 = blockData[blockBufferOffset + row + 3];
                        p4 = blockData[blockBufferOffset + row + 4];
                        p5 = blockData[blockBufferOffset + row + 5];
                        p6 = blockData[blockBufferOffset + row + 6];
                        p7 = blockData[blockBufferOffset + row + 7];
                        p0 *= qt[row];
                        if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
                            t = (dctSqrt2 * p0 + 512) >> 10;
                            p[row] = t;
                            p[row + 1] = t;
                            p[row + 2] = t;
                            p[row + 3] = t;
                            p[row + 4] = t;
                            p[row + 5] = t;
                            p[row + 6] = t;
                            p[row + 7] = t;
                            continue;
                        }
                        p1 *= qt[row + 1];
                        p2 *= qt[row + 2];
                        p3 *= qt[row + 3];
                        p4 *= qt[row + 4];
                        p5 *= qt[row + 5];
                        p6 *= qt[row + 6];
                        p7 *= qt[row + 7];
                        v0 = (dctSqrt2 * p0 + 128) >> 8;
                        v1 = (dctSqrt2 * p4 + 128) >> 8;
                        v2 = p2;
                        v3 = p6;
                        v4 = (dctSqrt1d2 * (p1 - p7) + 128) >> 8;
                        v7 = (dctSqrt1d2 * (p1 + p7) + 128) >> 8;
                        v5 = p3 << 4;
                        v6 = p5 << 4;
                        v0 = (v0 + v1 + 1) >> 1;
                        v1 = v0 - v1;
                        t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;
                        v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;
                        v3 = t;
                        v4 = (v4 + v6 + 1) >> 1;
                        v6 = v4 - v6;
                        v7 = (v7 + v5 + 1) >> 1;
                        v5 = v7 - v5;
                        v0 = (v0 + v3 + 1) >> 1;
                        v3 = v0 - v3;
                        v1 = (v1 + v2 + 1) >> 1;
                        v2 = v1 - v2;
                        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
                        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
                        v7 = t;
                        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
                        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
                        v6 = t;
                        p[row] = v0 + v7;
                        p[row + 7] = v0 - v7;
                        p[row + 1] = v1 + v6;
                        p[row + 6] = v1 - v6;
                        p[row + 2] = v2 + v5;
                        p[row + 5] = v2 - v5;
                        p[row + 3] = v3 + v4;
                        p[row + 4] = v3 - v4;
                    }
                    for (var col = 0; col < 8; ++col) {
                        p0 = p[col];
                        p1 = p[col + 8];
                        p2 = p[col + 16];
                        p3 = p[col + 24];
                        p4 = p[col + 32];
                        p5 = p[col + 40];
                        p6 = p[col + 48];
                        p7 = p[col + 56];
                        if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
                            t = (dctSqrt2 * p0 + 8192) >> 14;
                            t = (t < -2040) ? 0 : (t >= 2024) ? 255 : (t + 2056) >> 4;
                            blockData[blockBufferOffset + col] = t;
                            blockData[blockBufferOffset + col + 8] = t;
                            blockData[blockBufferOffset + col + 16] = t;
                            blockData[blockBufferOffset + col + 24] = t;
                            blockData[blockBufferOffset + col + 32] = t;
                            blockData[blockBufferOffset + col + 40] = t;
                            blockData[blockBufferOffset + col + 48] = t;
                            blockData[blockBufferOffset + col + 56] = t;
                            continue;
                        }
                        v0 = (dctSqrt2 * p0 + 2048) >> 12;
                        v1 = (dctSqrt2 * p4 + 2048) >> 12;
                        v2 = p2;
                        v3 = p6;
                        v4 = (dctSqrt1d2 * (p1 - p7) + 2048) >> 12;
                        v7 = (dctSqrt1d2 * (p1 + p7) + 2048) >> 12;
                        v5 = p3;
                        v6 = p5;
                        v0 = ((v0 + v1 + 1) >> 1) + 4112;
                        v1 = v0 - v1;
                        t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;
                        v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;
                        v3 = t;
                        v4 = (v4 + v6 + 1) >> 1;
                        v6 = v4 - v6;
                        v7 = (v7 + v5 + 1) >> 1;
                        v5 = v7 - v5;
                        v0 = (v0 + v3 + 1) >> 1;
                        v3 = v0 - v3;
                        v1 = (v1 + v2 + 1) >> 1;
                        v2 = v1 - v2;
                        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
                        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
                        v7 = t;
                        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
                        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
                        v6 = t;
                        p0 = v0 + v7;
                        p7 = v0 - v7;
                        p1 = v1 + v6;
                        p6 = v1 - v6;
                        p2 = v2 + v5;
                        p5 = v2 - v5;
                        p3 = v3 + v4;
                        p4 = v3 - v4;
                        p0 = (p0 < 16) ? 0 : (p0 >= 4080) ? 255 : p0 >> 4;
                        p1 = (p1 < 16) ? 0 : (p1 >= 4080) ? 255 : p1 >> 4;
                        p2 = (p2 < 16) ? 0 : (p2 >= 4080) ? 255 : p2 >> 4;
                        p3 = (p3 < 16) ? 0 : (p3 >= 4080) ? 255 : p3 >> 4;
                        p4 = (p4 < 16) ? 0 : (p4 >= 4080) ? 255 : p4 >> 4;
                        p5 = (p5 < 16) ? 0 : (p5 >= 4080) ? 255 : p5 >> 4;
                        p6 = (p6 < 16) ? 0 : (p6 >= 4080) ? 255 : p6 >> 4;
                        p7 = (p7 < 16) ? 0 : (p7 >= 4080) ? 255 : p7 >> 4;
                        blockData[blockBufferOffset + col] = p0;
                        blockData[blockBufferOffset + col + 8] = p1;
                        blockData[blockBufferOffset + col + 16] = p2;
                        blockData[blockBufferOffset + col + 24] = p3;
                        blockData[blockBufferOffset + col + 32] = p4;
                        blockData[blockBufferOffset + col + 40] = p5;
                        blockData[blockBufferOffset + col + 48] = p6;
                        blockData[blockBufferOffset + col + 56] = p7;
                    }
                }

                function buildComponentData(frame, component) {
                    var blocksPerLine = component.blocksPerLine;
                    var blocksPerColumn = component.blocksPerColumn;
                    var computationBuffer = new Int16Array(64);
                    for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
                        for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
                            var offset = getBlockBufferOffset(component, blockRow, blockCol);
                            quantizeAndInverse(component, offset, computationBuffer);
                        }
                    }
                    return component.blockData;
                }

                function clamp0to255(a) {
                    return a <= 0 ? 0 : a >= 255 ? 255 : a;
                }
                constructor.prototype = {
                    parse: function parse(data) {
                        function readUint16() {
                            var value = (data[offset] << 8) | data[offset + 1];
                            offset += 2;
                            return value;
                        }

                        function readDataBlock() {
                            var length = readUint16();
                            var array = data.subarray(offset, offset + length - 2);
                            offset += array.length;
                            return array;
                        }

                        function prepareComponents(frame) {
                            var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / frame.maxH);
                            var mcusPerColumn = Math.ceil(frame.scanLines / 8 / frame.maxV);
                            for (var i = 0; i < frame.components.length; i++) {
                                component = frame.components[i];
                                var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / frame.maxH);
                                var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / frame.maxV);
                                var blocksPerLineForMcu = mcusPerLine * component.h;
                                var blocksPerColumnForMcu = mcusPerColumn * component.v;
                                var blocksBufferSize = 64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);
                                component.blockData = new Int16Array(blocksBufferSize);
                                component.blocksPerLine = blocksPerLine;
                                component.blocksPerColumn = blocksPerColumn;
                            }
                            frame.mcusPerLine = mcusPerLine;
                            frame.mcusPerColumn = mcusPerColumn;
                        }
                        var offset = 0;
                        var jfif = null;
                        var adobe = null;
                        var frame, resetInterval;
                        var quantizationTables = [];
                        var huffmanTablesAC = [],
                            huffmanTablesDC = [];
                        var fileMarker = readUint16();
                        if (fileMarker !== 0xFFD8) {
                            throw 'SOI not found';
                        }
                        fileMarker = readUint16();
                        while (fileMarker !== 0xFFD9) {
                            var i, j, l;
                            switch (fileMarker) {
                                case 0xFFE0:
                                case 0xFFE1:
                                case 0xFFE2:
                                case 0xFFE3:
                                case 0xFFE4:
                                case 0xFFE5:
                                case 0xFFE6:
                                case 0xFFE7:
                                case 0xFFE8:
                                case 0xFFE9:
                                case 0xFFEA:
                                case 0xFFEB:
                                case 0xFFEC:
                                case 0xFFED:
                                case 0xFFEE:
                                case 0xFFEF:
                                case 0xFFFE:
                                    var appData = readDataBlock();
                                    if (fileMarker === 0xFFE0) {
                                        if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49 && appData[3] === 0x46 && appData[4] === 0) {
                                            jfif = {
                                                version: {
                                                    major: appData[5],
                                                    minor: appData[6]
                                                },
                                                densityUnits: appData[7],
                                                xDensity: (appData[8] << 8) | appData[9],
                                                yDensity: (appData[10] << 8) | appData[11],
                                                thumbWidth: appData[12],
                                                thumbHeight: appData[13],
                                                thumbData: appData.subarray(14, 14 +
                                                    3 * appData[12] * appData[13])
                                            };
                                        }
                                    }
                                    if (fileMarker === 0xFFEE) {
                                        if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F && appData[3] === 0x62 && appData[4] === 0x65) {
                                            adobe = {
                                                version: (appData[5] << 8) | appData[6],
                                                flags0: (appData[7] << 8) | appData[8],
                                                flags1: (appData[9] << 8) | appData[10],
                                                transformCode: appData[11]
                                            };
                                        }
                                    }
                                    break;
                                case 0xFFDB:
                                    var quantizationTablesLength = readUint16();
                                    var quantizationTablesEnd = quantizationTablesLength + offset - 2;
                                    var z;
                                    while (offset < quantizationTablesEnd) {
                                        var quantizationTableSpec = data[offset++];
                                        var tableData = new Uint16Array(64);
                                        if ((quantizationTableSpec >> 4) === 0) {
                                            for (j = 0; j < 64; j++) {
                                                z = dctZigZag[j];
                                                tableData[z] = data[offset++];
                                            }
                                        } else if ((quantizationTableSpec >> 4) === 1) {
                                            for (j = 0; j < 64; j++) {
                                                z = dctZigZag[j];
                                                tableData[z] = readUint16();
                                            }
                                        } else {
                                            throw 'DQT: invalid table spec';
                                        }
                                        quantizationTables[quantizationTableSpec & 15] = tableData;
                                    }
                                    break;
                                case 0xFFC0:
                                case 0xFFC1:
                                case 0xFFC2:
                                    if (frame) {
                                        throw 'Only single frame JPEGs supported';
                                    }
                                    readUint16();
                                    frame = {};
                                    frame.extended = (fileMarker === 0xFFC1);
                                    frame.progressive = (fileMarker === 0xFFC2);
                                    frame.precision = data[offset++];
                                    frame.scanLines = readUint16();
                                    frame.samplesPerLine = readUint16();
                                    frame.components = [];
                                    frame.componentIds = {};
                                    var componentsCount = data[offset++],
                                        componentId;
                                    var maxH = 0,
                                        maxV = 0;
                                    for (i = 0; i < componentsCount; i++) {
                                        componentId = data[offset];
                                        var h = data[offset + 1] >> 4;
                                        var v = data[offset + 1] & 15;
                                        if (maxH < h) {
                                            maxH = h;
                                        }
                                        if (maxV < v) {
                                            maxV = v;
                                        }
                                        var qId = data[offset + 2];
                                        l = frame.components.push({
                                            h: h,
                                            v: v,
                                            quantizationTable: quantizationTables[qId]
                                        });
                                        frame.componentIds[componentId] = l - 1;
                                        offset += 3;
                                    }
                                    frame.maxH = maxH;
                                    frame.maxV = maxV;
                                    prepareComponents(frame);
                                    break;
                                case 0xFFC4:
                                    var huffmanLength = readUint16();
                                    for (i = 2; i < huffmanLength;) {
                                        var huffmanTableSpec = data[offset++];
                                        var codeLengths = new Uint8Array(16);
                                        var codeLengthSum = 0;
                                        for (j = 0; j < 16; j++, offset++) {
                                            codeLengthSum += (codeLengths[j] = data[offset]);
                                        }
                                        var huffmanValues = new Uint8Array(codeLengthSum);
                                        for (j = 0; j < codeLengthSum; j++, offset++) {
                                            huffmanValues[j] = data[offset];
                                        }
                                        i += 17 + codeLengthSum;
                                        ((huffmanTableSpec >> 4) === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
                                    }
                                    break;
                                case 0xFFDD:
                                    readUint16();
                                    resetInterval = readUint16();
                                    break;
                                case 0xFFDA:
                                    var scanLength = readUint16();
                                    var selectorsCount = data[offset++];
                                    var components = [],
                                        component;
                                    for (i = 0; i < selectorsCount; i++) {
                                        var componentIndex = frame.componentIds[data[offset++]];
                                        component = frame.components[componentIndex];
                                        var tableSpec = data[offset++];
                                        component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
                                        component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
                                        components.push(component);
                                    }
                                    var spectralStart = data[offset++];
                                    var spectralEnd = data[offset++];
                                    var successiveApproximation = data[offset++];
                                    var processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15);
                                    offset += processed;
                                    break;
                                case 0xFFFF:
                                    if (data[offset] !== 0xFF) {
                                        offset--;
                                    }
                                    break;
                                default:
                                    if (data[offset - 3] === 0xFF && data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {
                                        offset -= 3;
                                        break;
                                    }
                                    throw 'unknown JPEG marker ' + fileMarker.toString(16);
                            }
                            fileMarker = readUint16();
                        }
                        this.width = frame.samplesPerLine;
                        this.height = frame.scanLines;
                        this.jfif = jfif;
                        this.adobe = adobe;
                        this.components = [];
                        for (i = 0; i < frame.components.length; i++) {
                            component = frame.components[i];
                            this.components.push({
                                output: buildComponentData(frame, component),
                                scaleX: component.h / frame.maxH,
                                scaleY: component.v / frame.maxV,
                                blocksPerLine: component.blocksPerLine,
                                blocksPerColumn: component.blocksPerColumn
                            });
                        }
                        this.numComponents = this.components.length;
                    },
                    _getLinearizedBlockData: function getLinearizedBlockData(width, height) {
                        var scaleX = this.width / width,
                            scaleY = this.height / height;
                        var component, componentScaleX, componentScaleY, blocksPerScanline;
                        var x, y, i, j, k;
                        var index;
                        var offset = 0;
                        var output;
                        var numComponents = this.components.length;
                        var dataLength = width * height * numComponents;
                        var data = new Uint8Array(dataLength);
                        var xScaleBlockOffset = new Uint32Array(width);
                        var mask3LSB = 0xfffffff8;
                        for (i = 0; i < numComponents; i++) {
                            component = this.components[i];
                            componentScaleX = component.scaleX * scaleX;
                            componentScaleY = component.scaleY * scaleY;
                            offset = i;
                            output = component.output;
                            blocksPerScanline = (component.blocksPerLine + 1) << 3;
                            for (x = 0; x < width; x++) {
                                j = 0 | (x * componentScaleX);
                                xScaleBlockOffset[x] = ((j & mask3LSB) << 3) | (j & 7);
                            }
                            for (y = 0; y < height; y++) {
                                j = 0 | (y * componentScaleY);
                                index = blocksPerScanline * (j & mask3LSB) | ((j & 7) << 3);
                                for (x = 0; x < width; x++) {
                                    data[offset] = output[index + xScaleBlockOffset[x]];
                                    offset += numComponents;
                                }
                            }
                        }
                        var transform = this.decodeTransform;
                        if (transform) {
                            for (i = 0; i < dataLength;) {
                                for (j = 0, k = 0; j < numComponents; j++, i++, k += 2) {
                                    data[i] = ((data[i] * transform[k]) >> 8) + transform[k + 1];
                                }
                            }
                        }
                        return data;
                    },
                    _isColorConversionNeeded: function isColorConversionNeeded() {
                        if (this.adobe && this.adobe.transformCode) {
                            return true;
                        } else if (this.numComponents === 3) {
                            return true;
                        } else {
                            return false;
                        }
                    },
                    _convertYccToRgb: function convertYccToRgb(data) {
                        var Y, Cb, Cr;
                        for (var i = 0, length = data.length; i < length; i += 3) {
                            Y = data[i];
                            Cb = data[i + 1];
                            Cr = data[i + 2];
                            data[i] = clamp0to255(Y - 179.456 + 1.402 * Cr);
                            data[i + 1] = clamp0to255(Y + 135.459 - 0.344 * Cb - 0.714 * Cr);
                            data[i + 2] = clamp0to255(Y - 226.816 + 1.772 * Cb);
                        }
                        return data;
                    },
                    _convertYcckToRgb: function convertYcckToRgb(data) {
                        var Y, Cb, Cr, k;
                        var offset = 0;
                        for (var i = 0, length = data.length; i < length; i += 4) {
                            Y = data[i];
                            Cb = data[i + 1];
                            Cr = data[i + 2];
                            k = data[i + 3];
                            var r = -122.67195406894 +
                                Cb * (-6.60635669420364e-5 * Cb + 0.000437130475926232 * Cr -
                                    5.4080610064599e-5 * Y + 0.00048449797120281 * k -
                                    0.154362151871126) +
                                Cr * (-0.000957964378445773 * Cr + 0.000817076911346625 * Y -
                                    0.00477271405408747 * k + 1.53380253221734) +
                                Y * (0.000961250184130688 * Y - 0.00266257332283933 * k +
                                    0.48357088451265) +
                                k * (-0.000336197177618394 * k + 0.484791561490776);
                            var g = 107.268039397724 +
                                Cb * (2.19927104525741e-5 * Cb - 0.000640992018297945 * Cr +
                                    0.000659397001245577 * Y + 0.000426105652938837 * k -
                                    0.176491792462875) +
                                Cr * (-0.000778269941513683 * Cr + 0.00130872261408275 * Y +
                                    0.000770482631801132 * k - 0.151051492775562) +
                                Y * (0.00126935368114843 * Y - 0.00265090189010898 * k +
                                    0.25802910206845) +
                                k * (-0.000318913117588328 * k - 0.213742400323665);
                            var b = -20.810012546947 +
                                Cb * (-0.000570115196973677 * Cb - 2.63409051004589e-5 * Cr +
                                    0.0020741088115012 * Y - 0.00288260236853442 * k +
                                    0.814272968359295) +
                                Cr * (-1.53496057440975e-5 * Cr - 0.000132689043961446 * Y +
                                    0.000560833691242812 * k - 0.195152027534049) +
                                Y * (0.00174418132927582 * Y - 0.00255243321439347 * k +
                                    0.116935020465145) +
                                k * (-0.000343531996510555 * k + 0.24165260232407);
                            data[offset++] = clamp0to255(r);
                            data[offset++] = clamp0to255(g);
                            data[offset++] = clamp0to255(b);
                        }
                        return data;
                    },
                    _convertYcckToCmyk: function convertYcckToCmyk(data) {
                        var Y, Cb, Cr;
                        for (var i = 0, length = data.length; i < length; i += 4) {
                            Y = data[i];
                            Cb = data[i + 1];
                            Cr = data[i + 2];
                            data[i] = clamp0to255(434.456 - Y - 1.402 * Cr);
                            data[i + 1] = clamp0to255(119.541 - Y + 0.344 * Cb + 0.714 * Cr);
                            data[i + 2] = clamp0to255(481.816 - Y - 1.772 * Cb);
                        }
                        return data;
                    },
                    _convertCmykToRgb: function convertCmykToRgb(data) {
                        var c, m, y, k;
                        var offset = 0;
                        var min = -255 * 255 * 255;
                        var scale = 1 / 255 / 255;
                        for (var i = 0, length = data.length; i < length; i += 4) {
                            c = data[i];
                            m = data[i + 1];
                            y = data[i + 2];
                            k = data[i + 3];
                            var r = c * (-4.387332384609988 * c + 54.48615194189176 * m +
                                    18.82290502165302 * y + 212.25662451639585 * k -
                                    72734.4411664936) +
                                m * (1.7149763477362134 * m - 5.6096736904047315 * y -
                                    17.873870861415444 * k - 1401.7366389350734) +
                                y * (-2.5217340131683033 * y - 21.248923337353073 * k +
                                    4465.541406466231) -
                                k * (21.86122147463605 * k + 48317.86113160301);
                            var g = c * (8.841041422036149 * c + 60.118027045597366 * m +
                                    6.871425592049007 * y + 31.159100130055922 * k -
                                    20220.756542821975) +
                                m * (-15.310361306967817 * m + 17.575251261109482 * y +
                                    131.35250912493976 * k - 48691.05921601825) +
                                y * (4.444339102852739 * y + 9.8632861493405 * k -
                                    6341.191035517494) -
                                k * (20.737325471181034 * k + 47890.15695978492);
                            var b = c * (0.8842522430003296 * c + 8.078677503112928 * m +
                                    30.89978309703729 * y - 0.23883238689178934 * k -
                                    3616.812083916688) +
                                m * (10.49593273432072 * m + 63.02378494754052 * y +
                                    50.606957656360734 * k - 28620.90484698408) +
                                y * (0.03296041114873217 * y + 115.60384449646641 * k -
                                    49363.43385999684) -
                                k * (22.33816807309886 * k + 45932.16563550634);
                            data[offset++] = r >= 0 ? 255 : r <= min ? 0 : 255 + r * scale | 0;
                            data[offset++] = g >= 0 ? 255 : g <= min ? 0 : 255 + g * scale | 0;
                            data[offset++] = b >= 0 ? 255 : b <= min ? 0 : 255 + b * scale | 0;
                        }
                        return data;
                    },
                    getData: function getData(width, height, forceRGBoutput) {
                        if (this.numComponents > 4) {
                            throw 'Unsupported color mode';
                        }
                        var data = this._getLinearizedBlockData(width, height);
                        if (this.numComponents === 3) {
                            return this._convertYccToRgb(data);
                        } else if (this.numComponents === 4) {
                            if (this._isColorConversionNeeded()) {
                                if (forceRGBoutput) {
                                    return this._convertYcckToRgb(data);
                                } else {
                                    return this._convertYcckToCmyk(data);
                                }
                            } else if (forceRGBoutput) {
                                return this._convertCmykToRgb(data);
                            }
                        }
                        return data;
                    }
                };
                return constructor;
            })();
            exports.JpegImage = JpegImage;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsCoreMetrics = {}));
            }
        }(this, function(exports) {
            var Metrics = {
                'Courier': 600,
                'Courier-Bold': 600,
                'Courier-BoldOblique': 600,
                'Courier-Oblique': 600,
                'Helvetica': {
                    'space': 278,
                    'exclam': 278,
                    'quotedbl': 355,
                    'numbersign': 556,
                    'dollar': 556,
                    'percent': 889,
                    'ampersand': 667,
                    'quoteright': 222,
                    'parenleft': 333,
                    'parenright': 333,
                    'asterisk': 389,
                    'plus': 584,
                    'comma': 278,
                    'hyphen': 333,
                    'period': 278,
                    'slash': 278,
                    'zero': 556,
                    'one': 556,
                    'two': 556,
                    'three': 556,
                    'four': 556,
                    'five': 556,
                    'six': 556,
                    'seven': 556,
                    'eight': 556,
                    'nine': 556,
                    'colon': 278,
                    'semicolon': 278,
                    'less': 584,
                    'equal': 584,
                    'greater': 584,
                    'question': 556,
                    'at': 1015,
                    'A': 667,
                    'B': 667,
                    'C': 722,
                    'D': 722,
                    'E': 667,
                    'F': 611,
                    'G': 778,
                    'H': 722,
                    'I': 278,
                    'J': 500,
                    'K': 667,
                    'L': 556,
                    'M': 833,
                    'N': 722,
                    'O': 778,
                    'P': 667,
                    'Q': 778,
                    'R': 722,
                    'S': 667,
                    'T': 611,
                    'U': 722,
                    'V': 667,
                    'W': 944,
                    'X': 667,
                    'Y': 667,
                    'Z': 611,
                    'bracketleft': 278,
                    'backslash': 278,
                    'bracketright': 278,
                    'asciicircum': 469,
                    'underscore': 556,
                    'quoteleft': 222,
                    'a': 556,
                    'b': 556,
                    'c': 500,
                    'd': 556,
                    'e': 556,
                    'f': 278,
                    'g': 556,
                    'h': 556,
                    'i': 222,
                    'j': 222,
                    'k': 500,
                    'l': 222,
                    'm': 833,
                    'n': 556,
                    'o': 556,
                    'p': 556,
                    'q': 556,
                    'r': 333,
                    's': 500,
                    't': 278,
                    'u': 556,
                    'v': 500,
                    'w': 722,
                    'x': 500,
                    'y': 500,
                    'z': 500,
                    'braceleft': 334,
                    'bar': 260,
                    'braceright': 334,
                    'asciitilde': 584,
                    'exclamdown': 333,
                    'cent': 556,
                    'sterling': 556,
                    'fraction': 167,
                    'yen': 556,
                    'florin': 556,
                    'section': 556,
                    'currency': 556,
                    'quotesingle': 191,
                    'quotedblleft': 333,
                    'guillemotleft': 556,
                    'guilsinglleft': 333,
                    'guilsinglright': 333,
                    'fi': 500,
                    'fl': 500,
                    'endash': 556,
                    'dagger': 556,
                    'daggerdbl': 556,
                    'periodcentered': 278,
                    'paragraph': 537,
                    'bullet': 350,
                    'quotesinglbase': 222,
                    'quotedblbase': 333,
                    'quotedblright': 333,
                    'guillemotright': 556,
                    'ellipsis': 1000,
                    'perthousand': 1000,
                    'questiondown': 611,
                    'grave': 333,
                    'acute': 333,
                    'circumflex': 333,
                    'tilde': 333,
                    'macron': 333,
                    'breve': 333,
                    'dotaccent': 333,
                    'dieresis': 333,
                    'ring': 333,
                    'cedilla': 333,
                    'hungarumlaut': 333,
                    'ogonek': 333,
                    'caron': 333,
                    'emdash': 1000,
                    'AE': 1000,
                    'ordfeminine': 370,
                    'Lslash': 556,
                    'Oslash': 778,
                    'OE': 1000,
                    'ordmasculine': 365,
                    'ae': 889,
                    'dotlessi': 278,
                    'lslash': 222,
                    'oslash': 611,
                    'oe': 944,
                    'germandbls': 611,
                    'Idieresis': 278,
                    'eacute': 556,
                    'abreve': 556,
                    'uhungarumlaut': 556,
                    'ecaron': 556,
                    'Ydieresis': 667,
                    'divide': 584,
                    'Yacute': 667,
                    'Acircumflex': 667,
                    'aacute': 556,
                    'Ucircumflex': 722,
                    'yacute': 500,
                    'scommaaccent': 500,
                    'ecircumflex': 556,
                    'Uring': 722,
                    'Udieresis': 722,
                    'aogonek': 556,
                    'Uacute': 722,
                    'uogonek': 556,
                    'Edieresis': 667,
                    'Dcroat': 722,
                    'commaaccent': 250,
                    'copyright': 737,
                    'Emacron': 667,
                    'ccaron': 500,
                    'aring': 556,
                    'Ncommaaccent': 722,
                    'lacute': 222,
                    'agrave': 556,
                    'Tcommaaccent': 611,
                    'Cacute': 722,
                    'atilde': 556,
                    'Edotaccent': 667,
                    'scaron': 500,
                    'scedilla': 500,
                    'iacute': 278,
                    'lozenge': 471,
                    'Rcaron': 722,
                    'Gcommaaccent': 778,
                    'ucircumflex': 556,
                    'acircumflex': 556,
                    'Amacron': 667,
                    'rcaron': 333,
                    'ccedilla': 500,
                    'Zdotaccent': 611,
                    'Thorn': 667,
                    'Omacron': 778,
                    'Racute': 722,
                    'Sacute': 667,
                    'dcaron': 643,
                    'Umacron': 722,
                    'uring': 556,
                    'threesuperior': 333,
                    'Ograve': 778,
                    'Agrave': 667,
                    'Abreve': 667,
                    'multiply': 584,
                    'uacute': 556,
                    'Tcaron': 611,
                    'partialdiff': 476,
                    'ydieresis': 500,
                    'Nacute': 722,
                    'icircumflex': 278,
                    'Ecircumflex': 667,
                    'adieresis': 556,
                    'edieresis': 556,
                    'cacute': 500,
                    'nacute': 556,
                    'umacron': 556,
                    'Ncaron': 722,
                    'Iacute': 278,
                    'plusminus': 584,
                    'brokenbar': 260,
                    'registered': 737,
                    'Gbreve': 778,
                    'Idotaccent': 278,
                    'summation': 600,
                    'Egrave': 667,
                    'racute': 333,
                    'omacron': 556,
                    'Zacute': 611,
                    'Zcaron': 611,
                    'greaterequal': 549,
                    'Eth': 722,
                    'Ccedilla': 722,
                    'lcommaaccent': 222,
                    'tcaron': 317,
                    'eogonek': 556,
                    'Uogonek': 722,
                    'Aacute': 667,
                    'Adieresis': 667,
                    'egrave': 556,
                    'zacute': 500,
                    'iogonek': 222,
                    'Oacute': 778,
                    'oacute': 556,
                    'amacron': 556,
                    'sacute': 500,
                    'idieresis': 278,
                    'Ocircumflex': 778,
                    'Ugrave': 722,
                    'Delta': 612,
                    'thorn': 556,
                    'twosuperior': 333,
                    'Odieresis': 778,
                    'mu': 556,
                    'igrave': 278,
                    'ohungarumlaut': 556,
                    'Eogonek': 667,
                    'dcroat': 556,
                    'threequarters': 834,
                    'Scedilla': 667,
                    'lcaron': 299,
                    'Kcommaaccent': 667,
                    'Lacute': 556,
                    'trademark': 1000,
                    'edotaccent': 556,
                    'Igrave': 278,
                    'Imacron': 278,
                    'Lcaron': 556,
                    'onehalf': 834,
                    'lessequal': 549,
                    'ocircumflex': 556,
                    'ntilde': 556,
                    'Uhungarumlaut': 722,
                    'Eacute': 667,
                    'emacron': 556,
                    'gbreve': 556,
                    'onequarter': 834,
                    'Scaron': 667,
                    'Scommaaccent': 667,
                    'Ohungarumlaut': 778,
                    'degree': 400,
                    'ograve': 556,
                    'Ccaron': 722,
                    'ugrave': 556,
                    'radical': 453,
                    'Dcaron': 722,
                    'rcommaaccent': 333,
                    'Ntilde': 722,
                    'otilde': 556,
                    'Rcommaaccent': 722,
                    'Lcommaaccent': 556,
                    'Atilde': 667,
                    'Aogonek': 667,
                    'Aring': 667,
                    'Otilde': 778,
                    'zdotaccent': 500,
                    'Ecaron': 667,
                    'Iogonek': 278,
                    'kcommaaccent': 500,
                    'minus': 584,
                    'Icircumflex': 278,
                    'ncaron': 556,
                    'tcommaaccent': 278,
                    'logicalnot': 584,
                    'odieresis': 556,
                    'udieresis': 556,
                    'notequal': 549,
                    'gcommaaccent': 556,
                    'eth': 556,
                    'zcaron': 500,
                    'ncommaaccent': 556,
                    'onesuperior': 333,
                    'imacron': 278,
                    'Euro': 556
                },
                'Helvetica-Bold': {
                    'space': 278,
                    'exclam': 333,
                    'quotedbl': 474,
                    'numbersign': 556,
                    'dollar': 556,
                    'percent': 889,
                    'ampersand': 722,
                    'quoteright': 278,
                    'parenleft': 333,
                    'parenright': 333,
                    'asterisk': 389,
                    'plus': 584,
                    'comma': 278,
                    'hyphen': 333,
                    'period': 278,
                    'slash': 278,
                    'zero': 556,
                    'one': 556,
                    'two': 556,
                    'three': 556,
                    'four': 556,
                    'five': 556,
                    'six': 556,
                    'seven': 556,
                    'eight': 556,
                    'nine': 556,
                    'colon': 333,
                    'semicolon': 333,
                    'less': 584,
                    'equal': 584,
                    'greater': 584,
                    'question': 611,
                    'at': 975,
                    'A': 722,
                    'B': 722,
                    'C': 722,
                    'D': 722,
                    'E': 667,
                    'F': 611,
                    'G': 778,
                    'H': 722,
                    'I': 278,
                    'J': 556,
                    'K': 722,
                    'L': 611,
                    'M': 833,
                    'N': 722,
                    'O': 778,
                    'P': 667,
                    'Q': 778,
                    'R': 722,
                    'S': 667,
                    'T': 611,
                    'U': 722,
                    'V': 667,
                    'W': 944,
                    'X': 667,
                    'Y': 667,
                    'Z': 611,
                    'bracketleft': 333,
                    'backslash': 278,
                    'bracketright': 333,
                    'asciicircum': 584,
                    'underscore': 556,
                    'quoteleft': 278,
                    'a': 556,
                    'b': 611,
                    'c': 556,
                    'd': 611,
                    'e': 556,
                    'f': 333,
                    'g': 611,
                    'h': 611,
                    'i': 278,
                    'j': 278,
                    'k': 556,
                    'l': 278,
                    'm': 889,
                    'n': 611,
                    'o': 611,
                    'p': 611,
                    'q': 611,
                    'r': 389,
                    's': 556,
                    't': 333,
                    'u': 611,
                    'v': 556,
                    'w': 778,
                    'x': 556,
                    'y': 556,
                    'z': 500,
                    'braceleft': 389,
                    'bar': 280,
                    'braceright': 389,
                    'asciitilde': 584,
                    'exclamdown': 333,
                    'cent': 556,
                    'sterling': 556,
                    'fraction': 167,
                    'yen': 556,
                    'florin': 556,
                    'section': 556,
                    'currency': 556,
                    'quotesingle': 238,
                    'quotedblleft': 500,
                    'guillemotleft': 556,
                    'guilsinglleft': 333,
                    'guilsinglright': 333,
                    'fi': 611,
                    'fl': 611,
                    'endash': 556,
                    'dagger': 556,
                    'daggerdbl': 556,
                    'periodcentered': 278,
                    'paragraph': 556,
                    'bullet': 350,
                    'quotesinglbase': 278,
                    'quotedblbase': 500,
                    'quotedblright': 500,
                    'guillemotright': 556,
                    'ellipsis': 1000,
                    'perthousand': 1000,
                    'questiondown': 611,
                    'grave': 333,
                    'acute': 333,
                    'circumflex': 333,
                    'tilde': 333,
                    'macron': 333,
                    'breve': 333,
                    'dotaccent': 333,
                    'dieresis': 333,
                    'ring': 333,
                    'cedilla': 333,
                    'hungarumlaut': 333,
                    'ogonek': 333,
                    'caron': 333,
                    'emdash': 1000,
                    'AE': 1000,
                    'ordfeminine': 370,
                    'Lslash': 611,
                    'Oslash': 778,
                    'OE': 1000,
                    'ordmasculine': 365,
                    'ae': 889,
                    'dotlessi': 278,
                    'lslash': 278,
                    'oslash': 611,
                    'oe': 944,
                    'germandbls': 611,
                    'Idieresis': 278,
                    'eacute': 556,
                    'abreve': 556,
                    'uhungarumlaut': 611,
                    'ecaron': 556,
                    'Ydieresis': 667,
                    'divide': 584,
                    'Yacute': 667,
                    'Acircumflex': 722,
                    'aacute': 556,
                    'Ucircumflex': 722,
                    'yacute': 556,
                    'scommaaccent': 556,
                    'ecircumflex': 556,
                    'Uring': 722,
                    'Udieresis': 722,
                    'aogonek': 556,
                    'Uacute': 722,
                    'uogonek': 611,
                    'Edieresis': 667,
                    'Dcroat': 722,
                    'commaaccent': 250,
                    'copyright': 737,
                    'Emacron': 667,
                    'ccaron': 556,
                    'aring': 556,
                    'Ncommaaccent': 722,
                    'lacute': 278,
                    'agrave': 556,
                    'Tcommaaccent': 611,
                    'Cacute': 722,
                    'atilde': 556,
                    'Edotaccent': 667,
                    'scaron': 556,
                    'scedilla': 556,
                    'iacute': 278,
                    'lozenge': 494,
                    'Rcaron': 722,
                    'Gcommaaccent': 778,
                    'ucircumflex': 611,
                    'acircumflex': 556,
                    'Amacron': 722,
                    'rcaron': 389,
                    'ccedilla': 556,
                    'Zdotaccent': 611,
                    'Thorn': 667,
                    'Omacron': 778,
                    'Racute': 722,
                    'Sacute': 667,
                    'dcaron': 743,
                    'Umacron': 722,
                    'uring': 611,
                    'threesuperior': 333,
                    'Ograve': 778,
                    'Agrave': 722,
                    'Abreve': 722,
                    'multiply': 584,
                    'uacute': 611,
                    'Tcaron': 611,
                    'partialdiff': 494,
                    'ydieresis': 556,
                    'Nacute': 722,
                    'icircumflex': 278,
                    'Ecircumflex': 667,
                    'adieresis': 556,
                    'edieresis': 556,
                    'cacute': 556,
                    'nacute': 611,
                    'umacron': 611,
                    'Ncaron': 722,
                    'Iacute': 278,
                    'plusminus': 584,
                    'brokenbar': 280,
                    'registered': 737,
                    'Gbreve': 778,
                    'Idotaccent': 278,
                    'summation': 600,
                    'Egrave': 667,
                    'racute': 389,
                    'omacron': 611,
                    'Zacute': 611,
                    'Zcaron': 611,
                    'greaterequal': 549,
                    'Eth': 722,
                    'Ccedilla': 722,
                    'lcommaaccent': 278,
                    'tcaron': 389,
                    'eogonek': 556,
                    'Uogonek': 722,
                    'Aacute': 722,
                    'Adieresis': 722,
                    'egrave': 556,
                    'zacute': 500,
                    'iogonek': 278,
                    'Oacute': 778,
                    'oacute': 611,
                    'amacron': 556,
                    'sacute': 556,
                    'idieresis': 278,
                    'Ocircumflex': 778,
                    'Ugrave': 722,
                    'Delta': 612,
                    'thorn': 611,
                    'twosuperior': 333,
                    'Odieresis': 778,
                    'mu': 611,
                    'igrave': 278,
                    'ohungarumlaut': 611,
                    'Eogonek': 667,
                    'dcroat': 611,
                    'threequarters': 834,
                    'Scedilla': 667,
                    'lcaron': 400,
                    'Kcommaaccent': 722,
                    'Lacute': 611,
                    'trademark': 1000,
                    'edotaccent': 556,
                    'Igrave': 278,
                    'Imacron': 278,
                    'Lcaron': 611,
                    'onehalf': 834,
                    'lessequal': 549,
                    'ocircumflex': 611,
                    'ntilde': 611,
                    'Uhungarumlaut': 722,
                    'Eacute': 667,
                    'emacron': 556,
                    'gbreve': 611,
                    'onequarter': 834,
                    'Scaron': 667,
                    'Scommaaccent': 667,
                    'Ohungarumlaut': 778,
                    'degree': 400,
                    'ograve': 611,
                    'Ccaron': 722,
                    'ugrave': 611,
                    'radical': 549,
                    'Dcaron': 722,
                    'rcommaaccent': 389,
                    'Ntilde': 722,
                    'otilde': 611,
                    'Rcommaaccent': 722,
                    'Lcommaaccent': 611,
                    'Atilde': 722,
                    'Aogonek': 722,
                    'Aring': 722,
                    'Otilde': 778,
                    'zdotaccent': 500,
                    'Ecaron': 667,
                    'Iogonek': 278,
                    'kcommaaccent': 556,
                    'minus': 584,
                    'Icircumflex': 278,
                    'ncaron': 611,
                    'tcommaaccent': 333,
                    'logicalnot': 584,
                    'odieresis': 611,
                    'udieresis': 611,
                    'notequal': 549,
                    'gcommaaccent': 611,
                    'eth': 611,
                    'zcaron': 500,
                    'ncommaaccent': 611,
                    'onesuperior': 333,
                    'imacron': 278,
                    'Euro': 556
                },
                'Helvetica-BoldOblique': {
                    'space': 278,
                    'exclam': 333,
                    'quotedbl': 474,
                    'numbersign': 556,
                    'dollar': 556,
                    'percent': 889,
                    'ampersand': 722,
                    'quoteright': 278,
                    'parenleft': 333,
                    'parenright': 333,
                    'asterisk': 389,
                    'plus': 584,
                    'comma': 278,
                    'hyphen': 333,
                    'period': 278,
                    'slash': 278,
                    'zero': 556,
                    'one': 556,
                    'two': 556,
                    'three': 556,
                    'four': 556,
                    'five': 556,
                    'six': 556,
                    'seven': 556,
                    'eight': 556,
                    'nine': 556,
                    'colon': 333,
                    'semicolon': 333,
                    'less': 584,
                    'equal': 584,
                    'greater': 584,
                    'question': 611,
                    'at': 975,
                    'A': 722,
                    'B': 722,
                    'C': 722,
                    'D': 722,
                    'E': 667,
                    'F': 611,
                    'G': 778,
                    'H': 722,
                    'I': 278,
                    'J': 556,
                    'K': 722,
                    'L': 611,
                    'M': 833,
                    'N': 722,
                    'O': 778,
                    'P': 667,
                    'Q': 778,
                    'R': 722,
                    'S': 667,
                    'T': 611,
                    'U': 722,
                    'V': 667,
                    'W': 944,
                    'X': 667,
                    'Y': 667,
                    'Z': 611,
                    'bracketleft': 333,
                    'backslash': 278,
                    'bracketright': 333,
                    'asciicircum': 584,
                    'underscore': 556,
                    'quoteleft': 278,
                    'a': 556,
                    'b': 611,
                    'c': 556,
                    'd': 611,
                    'e': 556,
                    'f': 333,
                    'g': 611,
                    'h': 611,
                    'i': 278,
                    'j': 278,
                    'k': 556,
                    'l': 278,
                    'm': 889,
                    'n': 611,
                    'o': 611,
                    'p': 611,
                    'q': 611,
                    'r': 389,
                    's': 556,
                    't': 333,
                    'u': 611,
                    'v': 556,
                    'w': 778,
                    'x': 556,
                    'y': 556,
                    'z': 500,
                    'braceleft': 389,
                    'bar': 280,
                    'braceright': 389,
                    'asciitilde': 584,
                    'exclamdown': 333,
                    'cent': 556,
                    'sterling': 556,
                    'fraction': 167,
                    'yen': 556,
                    'florin': 556,
                    'section': 556,
                    'currency': 556,
                    'quotesingle': 238,
                    'quotedblleft': 500,
                    'guillemotleft': 556,
                    'guilsinglleft': 333,
                    'guilsinglright': 333,
                    'fi': 611,
                    'fl': 611,
                    'endash': 556,
                    'dagger': 556,
                    'daggerdbl': 556,
                    'periodcentered': 278,
                    'paragraph': 556,
                    'bullet': 350,
                    'quotesinglbase': 278,
                    'quotedblbase': 500,
                    'quotedblright': 500,
                    'guillemotright': 556,
                    'ellipsis': 1000,
                    'perthousand': 1000,
                    'questiondown': 611,
                    'grave': 333,
                    'acute': 333,
                    'circumflex': 333,
                    'tilde': 333,
                    'macron': 333,
                    'breve': 333,
                    'dotaccent': 333,
                    'dieresis': 333,
                    'ring': 333,
                    'cedilla': 333,
                    'hungarumlaut': 333,
                    'ogonek': 333,
                    'caron': 333,
                    'emdash': 1000,
                    'AE': 1000,
                    'ordfeminine': 370,
                    'Lslash': 611,
                    'Oslash': 778,
                    'OE': 1000,
                    'ordmasculine': 365,
                    'ae': 889,
                    'dotlessi': 278,
                    'lslash': 278,
                    'oslash': 611,
                    'oe': 944,
                    'germandbls': 611,
                    'Idieresis': 278,
                    'eacute': 556,
                    'abreve': 556,
                    'uhungarumlaut': 611,
                    'ecaron': 556,
                    'Ydieresis': 667,
                    'divide': 584,
                    'Yacute': 667,
                    'Acircumflex': 722,
                    'aacute': 556,
                    'Ucircumflex': 722,
                    'yacute': 556,
                    'scommaaccent': 556,
                    'ecircumflex': 556,
                    'Uring': 722,
                    'Udieresis': 722,
                    'aogonek': 556,
                    'Uacute': 722,
                    'uogonek': 611,
                    'Edieresis': 667,
                    'Dcroat': 722,
                    'commaaccent': 250,
                    'copyright': 737,
                    'Emacron': 667,
                    'ccaron': 556,
                    'aring': 556,
                    'Ncommaaccent': 722,
                    'lacute': 278,
                    'agrave': 556,
                    'Tcommaaccent': 611,
                    'Cacute': 722,
                    'atilde': 556,
                    'Edotaccent': 667,
                    'scaron': 556,
                    'scedilla': 556,
                    'iacute': 278,
                    'lozenge': 494,
                    'Rcaron': 722,
                    'Gcommaaccent': 778,
                    'ucircumflex': 611,
                    'acircumflex': 556,
                    'Amacron': 722,
                    'rcaron': 389,
                    'ccedilla': 556,
                    'Zdotaccent': 611,
                    'Thorn': 667,
                    'Omacron': 778,
                    'Racute': 722,
                    'Sacute': 667,
                    'dcaron': 743,
                    'Umacron': 722,
                    'uring': 611,
                    'threesuperior': 333,
                    'Ograve': 778,
                    'Agrave': 722,
                    'Abreve': 722,
                    'multiply': 584,
                    'uacute': 611,
                    'Tcaron': 611,
                    'partialdiff': 494,
                    'ydieresis': 556,
                    'Nacute': 722,
                    'icircumflex': 278,
                    'Ecircumflex': 667,
                    'adieresis': 556,
                    'edieresis': 556,
                    'cacute': 556,
                    'nacute': 611,
                    'umacron': 611,
                    'Ncaron': 722,
                    'Iacute': 278,
                    'plusminus': 584,
                    'brokenbar': 280,
                    'registered': 737,
                    'Gbreve': 778,
                    'Idotaccent': 278,
                    'summation': 600,
                    'Egrave': 667,
                    'racute': 389,
                    'omacron': 611,
                    'Zacute': 611,
                    'Zcaron': 611,
                    'greaterequal': 549,
                    'Eth': 722,
                    'Ccedilla': 722,
                    'lcommaaccent': 278,
                    'tcaron': 389,
                    'eogonek': 556,
                    'Uogonek': 722,
                    'Aacute': 722,
                    'Adieresis': 722,
                    'egrave': 556,
                    'zacute': 500,
                    'iogonek': 278,
                    'Oacute': 778,
                    'oacute': 611,
                    'amacron': 556,
                    'sacute': 556,
                    'idieresis': 278,
                    'Ocircumflex': 778,
                    'Ugrave': 722,
                    'Delta': 612,
                    'thorn': 611,
                    'twosuperior': 333,
                    'Odieresis': 778,
                    'mu': 611,
                    'igrave': 278,
                    'ohungarumlaut': 611,
                    'Eogonek': 667,
                    'dcroat': 611,
                    'threequarters': 834,
                    'Scedilla': 667,
                    'lcaron': 400,
                    'Kcommaaccent': 722,
                    'Lacute': 611,
                    'trademark': 1000,
                    'edotaccent': 556,
                    'Igrave': 278,
                    'Imacron': 278,
                    'Lcaron': 611,
                    'onehalf': 834,
                    'lessequal': 549,
                    'ocircumflex': 611,
                    'ntilde': 611,
                    'Uhungarumlaut': 722,
                    'Eacute': 667,
                    'emacron': 556,
                    'gbreve': 611,
                    'onequarter': 834,
                    'Scaron': 667,
                    'Scommaaccent': 667,
                    'Ohungarumlaut': 778,
                    'degree': 400,
                    'ograve': 611,
                    'Ccaron': 722,
                    'ugrave': 611,
                    'radical': 549,
                    'Dcaron': 722,
                    'rcommaaccent': 389,
                    'Ntilde': 722,
                    'otilde': 611,
                    'Rcommaaccent': 722,
                    'Lcommaaccent': 611,
                    'Atilde': 722,
                    'Aogonek': 722,
                    'Aring': 722,
                    'Otilde': 778,
                    'zdotaccent': 500,
                    'Ecaron': 667,
                    'Iogonek': 278,
                    'kcommaaccent': 556,
                    'minus': 584,
                    'Icircumflex': 278,
                    'ncaron': 611,
                    'tcommaaccent': 333,
                    'logicalnot': 584,
                    'odieresis': 611,
                    'udieresis': 611,
                    'notequal': 549,
                    'gcommaaccent': 611,
                    'eth': 611,
                    'zcaron': 500,
                    'ncommaaccent': 611,
                    'onesuperior': 333,
                    'imacron': 278,
                    'Euro': 556
                },
                'Helvetica-Oblique': {
                    'space': 278,
                    'exclam': 278,
                    'quotedbl': 355,
                    'numbersign': 556,
                    'dollar': 556,
                    'percent': 889,
                    'ampersand': 667,
                    'quoteright': 222,
                    'parenleft': 333,
                    'parenright': 333,
                    'asterisk': 389,
                    'plus': 584,
                    'comma': 278,
                    'hyphen': 333,
                    'period': 278,
                    'slash': 278,
                    'zero': 556,
                    'one': 556,
                    'two': 556,
                    'three': 556,
                    'four': 556,
                    'five': 556,
                    'six': 556,
                    'seven': 556,
                    'eight': 556,
                    'nine': 556,
                    'colon': 278,
                    'semicolon': 278,
                    'less': 584,
                    'equal': 584,
                    'greater': 584,
                    'question': 556,
                    'at': 1015,
                    'A': 667,
                    'B': 667,
                    'C': 722,
                    'D': 722,
                    'E': 667,
                    'F': 611,
                    'G': 778,
                    'H': 722,
                    'I': 278,
                    'J': 500,
                    'K': 667,
                    'L': 556,
                    'M': 833,
                    'N': 722,
                    'O': 778,
                    'P': 667,
                    'Q': 778,
                    'R': 722,
                    'S': 667,
                    'T': 611,
                    'U': 722,
                    'V': 667,
                    'W': 944,
                    'X': 667,
                    'Y': 667,
                    'Z': 611,
                    'bracketleft': 278,
                    'backslash': 278,
                    'bracketright': 278,
                    'asciicircum': 469,
                    'underscore': 556,
                    'quoteleft': 222,
                    'a': 556,
                    'b': 556,
                    'c': 500,
                    'd': 556,
                    'e': 556,
                    'f': 278,
                    'g': 556,
                    'h': 556,
                    'i': 222,
                    'j': 222,
                    'k': 500,
                    'l': 222,
                    'm': 833,
                    'n': 556,
                    'o': 556,
                    'p': 556,
                    'q': 556,
                    'r': 333,
                    's': 500,
                    't': 278,
                    'u': 556,
                    'v': 500,
                    'w': 722,
                    'x': 500,
                    'y': 500,
                    'z': 500,
                    'braceleft': 334,
                    'bar': 260,
                    'braceright': 334,
                    'asciitilde': 584,
                    'exclamdown': 333,
                    'cent': 556,
                    'sterling': 556,
                    'fraction': 167,
                    'yen': 556,
                    'florin': 556,
                    'section': 556,
                    'currency': 556,
                    'quotesingle': 191,
                    'quotedblleft': 333,
                    'guillemotleft': 556,
                    'guilsinglleft': 333,
                    'guilsinglright': 333,
                    'fi': 500,
                    'fl': 500,
                    'endash': 556,
                    'dagger': 556,
                    'daggerdbl': 556,
                    'periodcentered': 278,
                    'paragraph': 537,
                    'bullet': 350,
                    'quotesinglbase': 222,
                    'quotedblbase': 333,
                    'quotedblright': 333,
                    'guillemotright': 556,
                    'ellipsis': 1000,
                    'perthousand': 1000,
                    'questiondown': 611,
                    'grave': 333,
                    'acute': 333,
                    'circumflex': 333,
                    'tilde': 333,
                    'macron': 333,
                    'breve': 333,
                    'dotaccent': 333,
                    'dieresis': 333,
                    'ring': 333,
                    'cedilla': 333,
                    'hungarumlaut': 333,
                    'ogonek': 333,
                    'caron': 333,
                    'emdash': 1000,
                    'AE': 1000,
                    'ordfeminine': 370,
                    'Lslash': 556,
                    'Oslash': 778,
                    'OE': 1000,
                    'ordmasculine': 365,
                    'ae': 889,
                    'dotlessi': 278,
                    'lslash': 222,
                    'oslash': 611,
                    'oe': 944,
                    'germandbls': 611,
                    'Idieresis': 278,
                    'eacute': 556,
                    'abreve': 556,
                    'uhungarumlaut': 556,
                    'ecaron': 556,
                    'Ydieresis': 667,
                    'divide': 584,
                    'Yacute': 667,
                    'Acircumflex': 667,
                    'aacute': 556,
                    'Ucircumflex': 722,
                    'yacute': 500,
                    'scommaaccent': 500,
                    'ecircumflex': 556,
                    'Uring': 722,
                    'Udieresis': 722,
                    'aogonek': 556,
                    'Uacute': 722,
                    'uogonek': 556,
                    'Edieresis': 667,
                    'Dcroat': 722,
                    'commaaccent': 250,
                    'copyright': 737,
                    'Emacron': 667,
                    'ccaron': 500,
                    'aring': 556,
                    'Ncommaaccent': 722,
                    'lacute': 222,
                    'agrave': 556,
                    'Tcommaaccent': 611,
                    'Cacute': 722,
                    'atilde': 556,
                    'Edotaccent': 667,
                    'scaron': 500,
                    'scedilla': 500,
                    'iacute': 278,
                    'lozenge': 471,
                    'Rcaron': 722,
                    'Gcommaaccent': 778,
                    'ucircumflex': 556,
                    'acircumflex': 556,
                    'Amacron': 667,
                    'rcaron': 333,
                    'ccedilla': 500,
                    'Zdotaccent': 611,
                    'Thorn': 667,
                    'Omacron': 778,
                    'Racute': 722,
                    'Sacute': 667,
                    'dcaron': 643,
                    'Umacron': 722,
                    'uring': 556,
                    'threesuperior': 333,
                    'Ograve': 778,
                    'Agrave': 667,
                    'Abreve': 667,
                    'multiply': 584,
                    'uacute': 556,
                    'Tcaron': 611,
                    'partialdiff': 476,
                    'ydieresis': 500,
                    'Nacute': 722,
                    'icircumflex': 278,
                    'Ecircumflex': 667,
                    'adieresis': 556,
                    'edieresis': 556,
                    'cacute': 500,
                    'nacute': 556,
                    'umacron': 556,
                    'Ncaron': 722,
                    'Iacute': 278,
                    'plusminus': 584,
                    'brokenbar': 260,
                    'registered': 737,
                    'Gbreve': 778,
                    'Idotaccent': 278,
                    'summation': 600,
                    'Egrave': 667,
                    'racute': 333,
                    'omacron': 556,
                    'Zacute': 611,
                    'Zcaron': 611,
                    'greaterequal': 549,
                    'Eth': 722,
                    'Ccedilla': 722,
                    'lcommaaccent': 222,
                    'tcaron': 317,
                    'eogonek': 556,
                    'Uogonek': 722,
                    'Aacute': 667,
                    'Adieresis': 667,
                    'egrave': 556,
                    'zacute': 500,
                    'iogonek': 222,
                    'Oacute': 778,
                    'oacute': 556,
                    'amacron': 556,
                    'sacute': 500,
                    'idieresis': 278,
                    'Ocircumflex': 778,
                    'Ugrave': 722,
                    'Delta': 612,
                    'thorn': 556,
                    'twosuperior': 333,
                    'Odieresis': 778,
                    'mu': 556,
                    'igrave': 278,
                    'ohungarumlaut': 556,
                    'Eogonek': 667,
                    'dcroat': 556,
                    'threequarters': 834,
                    'Scedilla': 667,
                    'lcaron': 299,
                    'Kcommaaccent': 667,
                    'Lacute': 556,
                    'trademark': 1000,
                    'edotaccent': 556,
                    'Igrave': 278,
                    'Imacron': 278,
                    'Lcaron': 556,
                    'onehalf': 834,
                    'lessequal': 549,
                    'ocircumflex': 556,
                    'ntilde': 556,
                    'Uhungarumlaut': 722,
                    'Eacute': 667,
                    'emacron': 556,
                    'gbreve': 556,
                    'onequarter': 834,
                    'Scaron': 667,
                    'Scommaaccent': 667,
                    'Ohungarumlaut': 778,
                    'degree': 400,
                    'ograve': 556,
                    'Ccaron': 722,
                    'ugrave': 556,
                    'radical': 453,
                    'Dcaron': 722,
                    'rcommaaccent': 333,
                    'Ntilde': 722,
                    'otilde': 556,
                    'Rcommaaccent': 722,
                    'Lcommaaccent': 556,
                    'Atilde': 667,
                    'Aogonek': 667,
                    'Aring': 667,
                    'Otilde': 778,
                    'zdotaccent': 500,
                    'Ecaron': 667,
                    'Iogonek': 278,
                    'kcommaaccent': 500,
                    'minus': 584,
                    'Icircumflex': 278,
                    'ncaron': 556,
                    'tcommaaccent': 278,
                    'logicalnot': 584,
                    'odieresis': 556,
                    'udieresis': 556,
                    'notequal': 549,
                    'gcommaaccent': 556,
                    'eth': 556,
                    'zcaron': 500,
                    'ncommaaccent': 556,
                    'onesuperior': 333,
                    'imacron': 278,
                    'Euro': 556
                },
                'Symbol': {
                    'space': 250,
                    'exclam': 333,
                    'universal': 713,
                    'numbersign': 500,
                    'existential': 549,
                    'percent': 833,
                    'ampersand': 778,
                    'suchthat': 439,
                    'parenleft': 333,
                    'parenright': 333,
                    'asteriskmath': 500,
                    'plus': 549,
                    'comma': 250,
                    'minus': 549,
                    'period': 250,
                    'slash': 278,
                    'zero': 500,
                    'one': 500,
                    'two': 500,
                    'three': 500,
                    'four': 500,
                    'five': 500,
                    'six': 500,
                    'seven': 500,
                    'eight': 500,
                    'nine': 500,
                    'colon': 278,
                    'semicolon': 278,
                    'less': 549,
                    'equal': 549,
                    'greater': 549,
                    'question': 444,
                    'congruent': 549,
                    'Alpha': 722,
                    'Beta': 667,
                    'Chi': 722,
                    'Delta': 612,
                    'Epsilon': 611,
                    'Phi': 763,
                    'Gamma': 603,
                    'Eta': 722,
                    'Iota': 333,
                    'theta1': 631,
                    'Kappa': 722,
                    'Lambda': 686,
                    'Mu': 889,
                    'Nu': 722,
                    'Omicron': 722,
                    'Pi': 768,
                    'Theta': 741,
                    'Rho': 556,
                    'Sigma': 592,
                    'Tau': 611,
                    'Upsilon': 690,
                    'sigma1': 439,
                    'Omega': 768,
                    'Xi': 645,
                    'Psi': 795,
                    'Zeta': 611,
                    'bracketleft': 333,
                    'therefore': 863,
                    'bracketright': 333,
                    'perpendicular': 658,
                    'underscore': 500,
                    'radicalex': 500,
                    'alpha': 631,
                    'beta': 549,
                    'chi': 549,
                    'delta': 494,
                    'epsilon': 439,
                    'phi': 521,
                    'gamma': 411,
                    'eta': 603,
                    'iota': 329,
                    'phi1': 603,
                    'kappa': 549,
                    'lambda': 549,
                    'mu': 576,
                    'nu': 521,
                    'omicron': 549,
                    'pi': 549,
                    'theta': 521,
                    'rho': 549,
                    'sigma': 603,
                    'tau': 439,
                    'upsilon': 576,
                    'omega1': 713,
                    'omega': 686,
                    'xi': 493,
                    'psi': 686,
                    'zeta': 494,
                    'braceleft': 480,
                    'bar': 200,
                    'braceright': 480,
                    'similar': 549,
                    'Euro': 750,
                    'Upsilon1': 620,
                    'minute': 247,
                    'lessequal': 549,
                    'fraction': 167,
                    'infinity': 713,
                    'florin': 500,
                    'club': 753,
                    'diamond': 753,
                    'heart': 753,
                    'spade': 753,
                    'arrowboth': 1042,
                    'arrowleft': 987,
                    'arrowup': 603,
                    'arrowright': 987,
                    'arrowdown': 603,
                    'degree': 400,
                    'plusminus': 549,
                    'second': 411,
                    'greaterequal': 549,
                    'multiply': 549,
                    'proportional': 713,
                    'partialdiff': 494,
                    'bullet': 460,
                    'divide': 549,
                    'notequal': 549,
                    'equivalence': 549,
                    'approxequal': 549,
                    'ellipsis': 1000,
                    'arrowvertex': 603,
                    'arrowhorizex': 1000,
                    'carriagereturn': 658,
                    'aleph': 823,
                    'Ifraktur': 686,
                    'Rfraktur': 795,
                    'weierstrass': 987,
                    'circlemultiply': 768,
                    'circleplus': 768,
                    'emptyset': 823,
                    'intersection': 768,
                    'union': 768,
                    'propersuperset': 713,
                    'reflexsuperset': 713,
                    'notsubset': 713,
                    'propersubset': 713,
                    'reflexsubset': 713,
                    'element': 713,
                    'notelement': 713,
                    'angle': 768,
                    'gradient': 713,
                    'registerserif': 790,
                    'copyrightserif': 790,
                    'trademarkserif': 890,
                    'product': 823,
                    'radical': 549,
                    'dotmath': 250,
                    'logicalnot': 713,
                    'logicaland': 603,
                    'logicalor': 603,
                    'arrowdblboth': 1042,
                    'arrowdblleft': 987,
                    'arrowdblup': 603,
                    'arrowdblright': 987,
                    'arrowdbldown': 603,
                    'lozenge': 494,
                    'angleleft': 329,
                    'registersans': 790,
                    'copyrightsans': 790,
                    'trademarksans': 786,
                    'summation': 713,
                    'parenlefttp': 384,
                    'parenleftex': 384,
                    'parenleftbt': 384,
                    'bracketlefttp': 384,
                    'bracketleftex': 384,
                    'bracketleftbt': 384,
                    'bracelefttp': 494,
                    'braceleftmid': 494,
                    'braceleftbt': 494,
                    'braceex': 494,
                    'angleright': 329,
                    'integral': 274,
                    'integraltp': 686,
                    'integralex': 686,
                    'integralbt': 686,
                    'parenrighttp': 384,
                    'parenrightex': 384,
                    'parenrightbt': 384,
                    'bracketrighttp': 384,
                    'bracketrightex': 384,
                    'bracketrightbt': 384,
                    'bracerighttp': 494,
                    'bracerightmid': 494,
                    'bracerightbt': 494,
                    'apple': 790
                },
                'Times-Roman': {
                    'space': 250,
                    'exclam': 333,
                    'quotedbl': 408,
                    'numbersign': 500,
                    'dollar': 500,
                    'percent': 833,
                    'ampersand': 778,
                    'quoteright': 333,
                    'parenleft': 333,
                    'parenright': 333,
                    'asterisk': 500,
                    'plus': 564,
                    'comma': 250,
                    'hyphen': 333,
                    'period': 250,
                    'slash': 278,
                    'zero': 500,
                    'one': 500,
                    'two': 500,
                    'three': 500,
                    'four': 500,
                    'five': 500,
                    'six': 500,
                    'seven': 500,
                    'eight': 500,
                    'nine': 500,
                    'colon': 278,
                    'semicolon': 278,
                    'less': 564,
                    'equal': 564,
                    'greater': 564,
                    'question': 444,
                    'at': 921,
                    'A': 722,
                    'B': 667,
                    'C': 667,
                    'D': 722,
                    'E': 611,
                    'F': 556,
                    'G': 722,
                    'H': 722,
                    'I': 333,
                    'J': 389,
                    'K': 722,
                    'L': 611,
                    'M': 889,
                    'N': 722,
                    'O': 722,
                    'P': 556,
                    'Q': 722,
                    'R': 667,
                    'S': 556,
                    'T': 611,
                    'U': 722,
                    'V': 722,
                    'W': 944,
                    'X': 722,
                    'Y': 722,
                    'Z': 611,
                    'bracketleft': 333,
                    'backslash': 278,
                    'bracketright': 333,
                    'asciicircum': 469,
                    'underscore': 500,
                    'quoteleft': 333,
                    'a': 444,
                    'b': 500,
                    'c': 444,
                    'd': 500,
                    'e': 444,
                    'f': 333,
                    'g': 500,
                    'h': 500,
                    'i': 278,
                    'j': 278,
                    'k': 500,
                    'l': 278,
                    'm': 778,
                    'n': 500,
                    'o': 500,
                    'p': 500,
                    'q': 500,
                    'r': 333,
                    's': 389,
                    't': 278,
                    'u': 500,
                    'v': 500,
                    'w': 722,
                    'x': 500,
                    'y': 500,
                    'z': 444,
                    'braceleft': 480,
                    'bar': 200,
                    'braceright': 480,
                    'asciitilde': 541,
                    'exclamdown': 333,
                    'cent': 500,
                    'sterling': 500,
                    'fraction': 167,
                    'yen': 500,
                    'florin': 500,
                    'section': 500,
                    'currency': 500,
                    'quotesingle': 180,
                    'quotedblleft': 444,
                    'guillemotleft': 500,
                    'guilsinglleft': 333,
                    'guilsinglright': 333,
                    'fi': 556,
                    'fl': 556,
                    'endash': 500,
                    'dagger': 500,
                    'daggerdbl': 500,
                    'periodcentered': 250,
                    'paragraph': 453,
                    'bullet': 350,
                    'quotesinglbase': 333,
                    'quotedblbase': 444,
                    'quotedblright': 444,
                    'guillemotright': 500,
                    'ellipsis': 1000,
                    'perthousand': 1000,
                    'questiondown': 444,
                    'grave': 333,
                    'acute': 333,
                    'circumflex': 333,
                    'tilde': 333,
                    'macron': 333,
                    'breve': 333,
                    'dotaccent': 333,
                    'dieresis': 333,
                    'ring': 333,
                    'cedilla': 333,
                    'hungarumlaut': 333,
                    'ogonek': 333,
                    'caron': 333,
                    'emdash': 1000,
                    'AE': 889,
                    'ordfeminine': 276,
                    'Lslash': 611,
                    'Oslash': 722,
                    'OE': 889,
                    'ordmasculine': 310,
                    'ae': 667,
                    'dotlessi': 278,
                    'lslash': 278,
                    'oslash': 500,
                    'oe': 722,
                    'germandbls': 500,
                    'Idieresis': 333,
                    'eacute': 444,
                    'abreve': 444,
                    'uhungarumlaut': 500,
                    'ecaron': 444,
                    'Ydieresis': 722,
                    'divide': 564,
                    'Yacute': 722,
                    'Acircumflex': 722,
                    'aacute': 444,
                    'Ucircumflex': 722,
                    'yacute': 500,
                    'scommaaccent': 389,
                    'ecircumflex': 444,
                    'Uring': 722,
                    'Udieresis': 722,
                    'aogonek': 444,
                    'Uacute': 722,
                    'uogonek': 500,
                    'Edieresis': 611,
                    'Dcroat': 722,
                    'commaaccent': 250,
                    'copyright': 760,
                    'Emacron': 611,
                    'ccaron': 444,
                    'aring': 444,
                    'Ncommaaccent': 722,
                    'lacute': 278,
                    'agrave': 444,
                    'Tcommaaccent': 611,
                    'Cacute': 667,
                    'atilde': 444,
                    'Edotaccent': 611,
                    'scaron': 389,
                    'scedilla': 389,
                    'iacute': 278,
                    'lozenge': 471,
                    'Rcaron': 667,
                    'Gcommaaccent': 722,
                    'ucircumflex': 500,
                    'acircumflex': 444,
                    'Amacron': 722,
                    'rcaron': 333,
                    'ccedilla': 444,
                    'Zdotaccent': 611,
                    'Thorn': 556,
                    'Omacron': 722,
                    'Racute': 667,
                    'Sacute': 556,
                    'dcaron': 588,
                    'Umacron': 722,
                    'uring': 500,
                    'threesuperior': 300,
                    'Ograve': 722,
                    'Agrave': 722,
                    'Abreve': 722,
                    'multiply': 564,
                    'uacute': 500,
                    'Tcaron': 611,
                    'partialdiff': 476,
                    'ydieresis': 500,
                    'Nacute': 722,
                    'icircumflex': 278,
                    'Ecircumflex': 611,
                    'adieresis': 444,
                    'edieresis': 444,
                    'cacute': 444,
                    'nacute': 500,
                    'umacron': 500,
                    'Ncaron': 722,
                    'Iacute': 333,
                    'plusminus': 564,
                    'brokenbar': 200,
                    'registered': 760,
                    'Gbreve': 722,
                    'Idotaccent': 333,
                    'summation': 600,
                    'Egrave': 611,
                    'racute': 333,
                    'omacron': 500,
                    'Zacute': 611,
                    'Zcaron': 611,
                    'greaterequal': 549,
                    'Eth': 722,
                    'Ccedilla': 667,
                    'lcommaaccent': 278,
                    'tcaron': 326,
                    'eogonek': 444,
                    'Uogonek': 722,
                    'Aacute': 722,
                    'Adieresis': 722,
                    'egrave': 444,
                    'zacute': 444,
                    'iogonek': 278,
                    'Oacute': 722,
                    'oacute': 500,
                    'amacron': 444,
                    'sacute': 389,
                    'idieresis': 278,
                    'Ocircumflex': 722,
                    'Ugrave': 722,
                    'Delta': 612,
                    'thorn': 500,
                    'twosuperior': 300,
                    'Odieresis': 722,
                    'mu': 500,
                    'igrave': 278,
                    'ohungarumlaut': 500,
                    'Eogonek': 611,
                    'dcroat': 500,
                    'threequarters': 750,
                    'Scedilla': 556,
                    'lcaron': 344,
                    'Kcommaaccent': 722,
                    'Lacute': 611,
                    'trademark': 980,
                    'edotaccent': 444,
                    'Igrave': 333,
                    'Imacron': 333,
                    'Lcaron': 611,
                    'onehalf': 750,
                    'lessequal': 549,
                    'ocircumflex': 500,
                    'ntilde': 500,
                    'Uhungarumlaut': 722,
                    'Eacute': 611,
                    'emacron': 444,
                    'gbreve': 500,
                    'onequarter': 750,
                    'Scaron': 556,
                    'Scommaaccent': 556,
                    'Ohungarumlaut': 722,
                    'degree': 400,
                    'ograve': 500,
                    'Ccaron': 667,
                    'ugrave': 500,
                    'radical': 453,
                    'Dcaron': 722,
                    'rcommaaccent': 333,
                    'Ntilde': 722,
                    'otilde': 500,
                    'Rcommaaccent': 667,
                    'Lcommaaccent': 611,
                    'Atilde': 722,
                    'Aogonek': 722,
                    'Aring': 722,
                    'Otilde': 722,
                    'zdotaccent': 444,
                    'Ecaron': 611,
                    'Iogonek': 333,
                    'kcommaaccent': 500,
                    'minus': 564,
                    'Icircumflex': 333,
                    'ncaron': 500,
                    'tcommaaccent': 278,
                    'logicalnot': 564,
                    'odieresis': 500,
                    'udieresis': 500,
                    'notequal': 549,
                    'gcommaaccent': 500,
                    'eth': 500,
                    'zcaron': 444,
                    'ncommaaccent': 500,
                    'onesuperior': 300,
                    'imacron': 278,
                    'Euro': 500
                },
                'Times-Bold': {
                    'space': 250,
                    'exclam': 333,
                    'quotedbl': 555,
                    'numbersign': 500,
                    'dollar': 500,
                    'percent': 1000,
                    'ampersand': 833,
                    'quoteright': 333,
                    'parenleft': 333,
                    'parenright': 333,
                    'asterisk': 500,
                    'plus': 570,
                    'comma': 250,
                    'hyphen': 333,
                    'period': 250,
                    'slash': 278,
                    'zero': 500,
                    'one': 500,
                    'two': 500,
                    'three': 500,
                    'four': 500,
                    'five': 500,
                    'six': 500,
                    'seven': 500,
                    'eight': 500,
                    'nine': 500,
                    'colon': 333,
                    'semicolon': 333,
                    'less': 570,
                    'equal': 570,
                    'greater': 570,
                    'question': 500,
                    'at': 930,
                    'A': 722,
                    'B': 667,
                    'C': 722,
                    'D': 722,
                    'E': 667,
                    'F': 611,
                    'G': 778,
                    'H': 778,
                    'I': 389,
                    'J': 500,
                    'K': 778,
                    'L': 667,
                    'M': 944,
                    'N': 722,
                    'O': 778,
                    'P': 611,
                    'Q': 778,
                    'R': 722,
                    'S': 556,
                    'T': 667,
                    'U': 722,
                    'V': 722,
                    'W': 1000,
                    'X': 722,
                    'Y': 722,
                    'Z': 667,
                    'bracketleft': 333,
                    'backslash': 278,
                    'bracketright': 333,
                    'asciicircum': 581,
                    'underscore': 500,
                    'quoteleft': 333,
                    'a': 500,
                    'b': 556,
                    'c': 444,
                    'd': 556,
                    'e': 444,
                    'f': 333,
                    'g': 500,
                    'h': 556,
                    'i': 278,
                    'j': 333,
                    'k': 556,
                    'l': 278,
                    'm': 833,
                    'n': 556,
                    'o': 500,
                    'p': 556,
                    'q': 556,
                    'r': 444,
                    's': 389,
                    't': 333,
                    'u': 556,
                    'v': 500,
                    'w': 722,
                    'x': 500,
                    'y': 500,
                    'z': 444,
                    'braceleft': 394,
                    'bar': 220,
                    'braceright': 394,
                    'asciitilde': 520,
                    'exclamdown': 333,
                    'cent': 500,
                    'sterling': 500,
                    'fraction': 167,
                    'yen': 500,
                    'florin': 500,
                    'section': 500,
                    'currency': 500,
                    'quotesingle': 278,
                    'quotedblleft': 500,
                    'guillemotleft': 500,
                    'guilsinglleft': 333,
                    'guilsinglright': 333,
                    'fi': 556,
                    'fl': 556,
                    'endash': 500,
                    'dagger': 500,
                    'daggerdbl': 500,
                    'periodcentered': 250,
                    'paragraph': 540,
                    'bullet': 350,
                    'quotesinglbase': 333,
                    'quotedblbase': 500,
                    'quotedblright': 500,
                    'guillemotright': 500,
                    'ellipsis': 1000,
                    'perthousand': 1000,
                    'questiondown': 500,
                    'grave': 333,
                    'acute': 333,
                    'circumflex': 333,
                    'tilde': 333,
                    'macron': 333,
                    'breve': 333,
                    'dotaccent': 333,
                    'dieresis': 333,
                    'ring': 333,
                    'cedilla': 333,
                    'hungarumlaut': 333,
                    'ogonek': 333,
                    'caron': 333,
                    'emdash': 1000,
                    'AE': 1000,
                    'ordfeminine': 300,
                    'Lslash': 667,
                    'Oslash': 778,
                    'OE': 1000,
                    'ordmasculine': 330,
                    'ae': 722,
                    'dotlessi': 278,
                    'lslash': 278,
                    'oslash': 500,
                    'oe': 722,
                    'germandbls': 556,
                    'Idieresis': 389,
                    'eacute': 444,
                    'abreve': 500,
                    'uhungarumlaut': 556,
                    'ecaron': 444,
                    'Ydieresis': 722,
                    'divide': 570,
                    'Yacute': 722,
                    'Acircumflex': 722,
                    'aacute': 500,
                    'Ucircumflex': 722,
                    'yacute': 500,
                    'scommaaccent': 389,
                    'ecircumflex': 444,
                    'Uring': 722,
                    'Udieresis': 722,
                    'aogonek': 500,
                    'Uacute': 722,
                    'uogonek': 556,
                    'Edieresis': 667,
                    'Dcroat': 722,
                    'commaaccent': 250,
                    'copyright': 747,
                    'Emacron': 667,
                    'ccaron': 444,
                    'aring': 500,
                    'Ncommaaccent': 722,
                    'lacute': 278,
                    'agrave': 500,
                    'Tcommaaccent': 667,
                    'Cacute': 722,
                    'atilde': 500,
                    'Edotaccent': 667,
                    'scaron': 389,
                    'scedilla': 389,
                    'iacute': 278,
                    'lozenge': 494,
                    'Rcaron': 722,
                    'Gcommaaccent': 778,
                    'ucircumflex': 556,
                    'acircumflex': 500,
                    'Amacron': 722,
                    'rcaron': 444,
                    'ccedilla': 444,
                    'Zdotaccent': 667,
                    'Thorn': 611,
                    'Omacron': 778,
                    'Racute': 722,
                    'Sacute': 556,
                    'dcaron': 672,
                    'Umacron': 722,
                    'uring': 556,
                    'threesuperior': 300,
                    'Ograve': 778,
                    'Agrave': 722,
                    'Abreve': 722,
                    'multiply': 570,
                    'uacute': 556,
                    'Tcaron': 667,
                    'partialdiff': 494,
                    'ydieresis': 500,
                    'Nacute': 722,
                    'icircumflex': 278,
                    'Ecircumflex': 667,
                    'adieresis': 500,
                    'edieresis': 444,
                    'cacute': 444,
                    'nacute': 556,
                    'umacron': 556,
                    'Ncaron': 722,
                    'Iacute': 389,
                    'plusminus': 570,
                    'brokenbar': 220,
                    'registered': 747,
                    'Gbreve': 778,
                    'Idotaccent': 389,
                    'summation': 600,
                    'Egrave': 667,
                    'racute': 444,
                    'omacron': 500,
                    'Zacute': 667,
                    'Zcaron': 667,
                    'greaterequal': 549,
                    'Eth': 722,
                    'Ccedilla': 722,
                    'lcommaaccent': 278,
                    'tcaron': 416,
                    'eogonek': 444,
                    'Uogonek': 722,
                    'Aacute': 722,
                    'Adieresis': 722,
                    'egrave': 444,
                    'zacute': 444,
                    'iogonek': 278,
                    'Oacute': 778,
                    'oacute': 500,
                    'amacron': 500,
                    'sacute': 389,
                    'idieresis': 278,
                    'Ocircumflex': 778,
                    'Ugrave': 722,
                    'Delta': 612,
                    'thorn': 556,
                    'twosuperior': 300,
                    'Odieresis': 778,
                    'mu': 556,
                    'igrave': 278,
                    'ohungarumlaut': 500,
                    'Eogonek': 667,
                    'dcroat': 556,
                    'threequarters': 750,
                    'Scedilla': 556,
                    'lcaron': 394,
                    'Kcommaaccent': 778,
                    'Lacute': 667,
                    'trademark': 1000,
                    'edotaccent': 444,
                    'Igrave': 389,
                    'Imacron': 389,
                    'Lcaron': 667,
                    'onehalf': 750,
                    'lessequal': 549,
                    'ocircumflex': 500,
                    'ntilde': 556,
                    'Uhungarumlaut': 722,
                    'Eacute': 667,
                    'emacron': 444,
                    'gbreve': 500,
                    'onequarter': 750,
                    'Scaron': 556,
                    'Scommaaccent': 556,
                    'Ohungarumlaut': 778,
                    'degree': 400,
                    'ograve': 500,
                    'Ccaron': 722,
                    'ugrave': 556,
                    'radical': 549,
                    'Dcaron': 722,
                    'rcommaaccent': 444,
                    'Ntilde': 722,
                    'otilde': 500,
                    'Rcommaaccent': 722,
                    'Lcommaaccent': 667,
                    'Atilde': 722,
                    'Aogonek': 722,
                    'Aring': 722,
                    'Otilde': 778,
                    'zdotaccent': 444,
                    'Ecaron': 667,
                    'Iogonek': 389,
                    'kcommaaccent': 556,
                    'minus': 570,
                    'Icircumflex': 389,
                    'ncaron': 556,
                    'tcommaaccent': 333,
                    'logicalnot': 570,
                    'odieresis': 500,
                    'udieresis': 556,
                    'notequal': 549,
                    'gcommaaccent': 500,
                    'eth': 500,
                    'zcaron': 444,
                    'ncommaaccent': 556,
                    'onesuperior': 300,
                    'imacron': 278,
                    'Euro': 500
                },
                'Times-BoldItalic': {
                    'space': 250,
                    'exclam': 389,
                    'quotedbl': 555,
                    'numbersign': 500,
                    'dollar': 500,
                    'percent': 833,
                    'ampersand': 778,
                    'quoteright': 333,
                    'parenleft': 333,
                    'parenright': 333,
                    'asterisk': 500,
                    'plus': 570,
                    'comma': 250,
                    'hyphen': 333,
                    'period': 250,
                    'slash': 278,
                    'zero': 500,
                    'one': 500,
                    'two': 500,
                    'three': 500,
                    'four': 500,
                    'five': 500,
                    'six': 500,
                    'seven': 500,
                    'eight': 500,
                    'nine': 500,
                    'colon': 333,
                    'semicolon': 333,
                    'less': 570,
                    'equal': 570,
                    'greater': 570,
                    'question': 500,
                    'at': 832,
                    'A': 667,
                    'B': 667,
                    'C': 667,
                    'D': 722,
                    'E': 667,
                    'F': 667,
                    'G': 722,
                    'H': 778,
                    'I': 389,
                    'J': 500,
                    'K': 667,
                    'L': 611,
                    'M': 889,
                    'N': 722,
                    'O': 722,
                    'P': 611,
                    'Q': 722,
                    'R': 667,
                    'S': 556,
                    'T': 611,
                    'U': 722,
                    'V': 667,
                    'W': 889,
                    'X': 667,
                    'Y': 611,
                    'Z': 611,
                    'bracketleft': 333,
                    'backslash': 278,
                    'bracketright': 333,
                    'asciicircum': 570,
                    'underscore': 500,
                    'quoteleft': 333,
                    'a': 500,
                    'b': 500,
                    'c': 444,
                    'd': 500,
                    'e': 444,
                    'f': 333,
                    'g': 500,
                    'h': 556,
                    'i': 278,
                    'j': 278,
                    'k': 500,
                    'l': 278,
                    'm': 778,
                    'n': 556,
                    'o': 500,
                    'p': 500,
                    'q': 500,
                    'r': 389,
                    's': 389,
                    't': 278,
                    'u': 556,
                    'v': 444,
                    'w': 667,
                    'x': 500,
                    'y': 444,
                    'z': 389,
                    'braceleft': 348,
                    'bar': 220,
                    'braceright': 348,
                    'asciitilde': 570,
                    'exclamdown': 389,
                    'cent': 500,
                    'sterling': 500,
                    'fraction': 167,
                    'yen': 500,
                    'florin': 500,
                    'section': 500,
                    'currency': 500,
                    'quotesingle': 278,
                    'quotedblleft': 500,
                    'guillemotleft': 500,
                    'guilsinglleft': 333,
                    'guilsinglright': 333,
                    'fi': 556,
                    'fl': 556,
                    'endash': 500,
                    'dagger': 500,
                    'daggerdbl': 500,
                    'periodcentered': 250,
                    'paragraph': 500,
                    'bullet': 350,
                    'quotesinglbase': 333,
                    'quotedblbase': 500,
                    'quotedblright': 500,
                    'guillemotright': 500,
                    'ellipsis': 1000,
                    'perthousand': 1000,
                    'questiondown': 500,
                    'grave': 333,
                    'acute': 333,
                    'circumflex': 333,
                    'tilde': 333,
                    'macron': 333,
                    'breve': 333,
                    'dotaccent': 333,
                    'dieresis': 333,
                    'ring': 333,
                    'cedilla': 333,
                    'hungarumlaut': 333,
                    'ogonek': 333,
                    'caron': 333,
                    'emdash': 1000,
                    'AE': 944,
                    'ordfeminine': 266,
                    'Lslash': 611,
                    'Oslash': 722,
                    'OE': 944,
                    'ordmasculine': 300,
                    'ae': 722,
                    'dotlessi': 278,
                    'lslash': 278,
                    'oslash': 500,
                    'oe': 722,
                    'germandbls': 500,
                    'Idieresis': 389,
                    'eacute': 444,
                    'abreve': 500,
                    'uhungarumlaut': 556,
                    'ecaron': 444,
                    'Ydieresis': 611,
                    'divide': 570,
                    'Yacute': 611,
                    'Acircumflex': 667,
                    'aacute': 500,
                    'Ucircumflex': 722,
                    'yacute': 444,
                    'scommaaccent': 389,
                    'ecircumflex': 444,
                    'Uring': 722,
                    'Udieresis': 722,
                    'aogonek': 500,
                    'Uacute': 722,
                    'uogonek': 556,
                    'Edieresis': 667,
                    'Dcroat': 722,
                    'commaaccent': 250,
                    'copyright': 747,
                    'Emacron': 667,
                    'ccaron': 444,
                    'aring': 500,
                    'Ncommaaccent': 722,
                    'lacute': 278,
                    'agrave': 500,
                    'Tcommaaccent': 611,
                    'Cacute': 667,
                    'atilde': 500,
                    'Edotaccent': 667,
                    'scaron': 389,
                    'scedilla': 389,
                    'iacute': 278,
                    'lozenge': 494,
                    'Rcaron': 667,
                    'Gcommaaccent': 722,
                    'ucircumflex': 556,
                    'acircumflex': 500,
                    'Amacron': 667,
                    'rcaron': 389,
                    'ccedilla': 444,
                    'Zdotaccent': 611,
                    'Thorn': 611,
                    'Omacron': 722,
                    'Racute': 667,
                    'Sacute': 556,
                    'dcaron': 608,
                    'Umacron': 722,
                    'uring': 556,
                    'threesuperior': 300,
                    'Ograve': 722,
                    'Agrave': 667,
                    'Abreve': 667,
                    'multiply': 570,
                    'uacute': 556,
                    'Tcaron': 611,
                    'partialdiff': 494,
                    'ydieresis': 444,
                    'Nacute': 722,
                    'icircumflex': 278,
                    'Ecircumflex': 667,
                    'adieresis': 500,
                    'edieresis': 444,
                    'cacute': 444,
                    'nacute': 556,
                    'umacron': 556,
                    'Ncaron': 722,
                    'Iacute': 389,
                    'plusminus': 570,
                    'brokenbar': 220,
                    'registered': 747,
                    'Gbreve': 722,
                    'Idotaccent': 389,
                    'summation': 600,
                    'Egrave': 667,
                    'racute': 389,
                    'omacron': 500,
                    'Zacute': 611,
                    'Zcaron': 611,
                    'greaterequal': 549,
                    'Eth': 722,
                    'Ccedilla': 667,
                    'lcommaaccent': 278,
                    'tcaron': 366,
                    'eogonek': 444,
                    'Uogonek': 722,
                    'Aacute': 667,
                    'Adieresis': 667,
                    'egrave': 444,
                    'zacute': 389,
                    'iogonek': 278,
                    'Oacute': 722,
                    'oacute': 500,
                    'amacron': 500,
                    'sacute': 389,
                    'idieresis': 278,
                    'Ocircumflex': 722,
                    'Ugrave': 722,
                    'Delta': 612,
                    'thorn': 500,
                    'twosuperior': 300,
                    'Odieresis': 722,
                    'mu': 576,
                    'igrave': 278,
                    'ohungarumlaut': 500,
                    'Eogonek': 667,
                    'dcroat': 500,
                    'threequarters': 750,
                    'Scedilla': 556,
                    'lcaron': 382,
                    'Kcommaaccent': 667,
                    'Lacute': 611,
                    'trademark': 1000,
                    'edotaccent': 444,
                    'Igrave': 389,
                    'Imacron': 389,
                    'Lcaron': 611,
                    'onehalf': 750,
                    'lessequal': 549,
                    'ocircumflex': 500,
                    'ntilde': 556,
                    'Uhungarumlaut': 722,
                    'Eacute': 667,
                    'emacron': 444,
                    'gbreve': 500,
                    'onequarter': 750,
                    'Scaron': 556,
                    'Scommaaccent': 556,
                    'Ohungarumlaut': 722,
                    'degree': 400,
                    'ograve': 500,
                    'Ccaron': 667,
                    'ugrave': 556,
                    'radical': 549,
                    'Dcaron': 722,
                    'rcommaaccent': 389,
                    'Ntilde': 722,
                    'otilde': 500,
                    'Rcommaaccent': 667,
                    'Lcommaaccent': 611,
                    'Atilde': 667,
                    'Aogonek': 667,
                    'Aring': 667,
                    'Otilde': 722,
                    'zdotaccent': 389,
                    'Ecaron': 667,
                    'Iogonek': 389,
                    'kcommaaccent': 500,
                    'minus': 606,
                    'Icircumflex': 389,
                    'ncaron': 556,
                    'tcommaaccent': 278,
                    'logicalnot': 606,
                    'odieresis': 500,
                    'udieresis': 556,
                    'notequal': 549,
                    'gcommaaccent': 500,
                    'eth': 500,
                    'zcaron': 389,
                    'ncommaaccent': 556,
                    'onesuperior': 300,
                    'imacron': 278,
                    'Euro': 500
                },
                'Times-Italic': {
                    'space': 250,
                    'exclam': 333,
                    'quotedbl': 420,
                    'numbersign': 500,
                    'dollar': 500,
                    'percent': 833,
                    'ampersand': 778,
                    'quoteright': 333,
                    'parenleft': 333,
                    'parenright': 333,
                    'asterisk': 500,
                    'plus': 675,
                    'comma': 250,
                    'hyphen': 333,
                    'period': 250,
                    'slash': 278,
                    'zero': 500,
                    'one': 500,
                    'two': 500,
                    'three': 500,
                    'four': 500,
                    'five': 500,
                    'six': 500,
                    'seven': 500,
                    'eight': 500,
                    'nine': 500,
                    'colon': 333,
                    'semicolon': 333,
                    'less': 675,
                    'equal': 675,
                    'greater': 675,
                    'question': 500,
                    'at': 920,
                    'A': 611,
                    'B': 611,
                    'C': 667,
                    'D': 722,
                    'E': 611,
                    'F': 611,
                    'G': 722,
                    'H': 722,
                    'I': 333,
                    'J': 444,
                    'K': 667,
                    'L': 556,
                    'M': 833,
                    'N': 667,
                    'O': 722,
                    'P': 611,
                    'Q': 722,
                    'R': 611,
                    'S': 500,
                    'T': 556,
                    'U': 722,
                    'V': 611,
                    'W': 833,
                    'X': 611,
                    'Y': 556,
                    'Z': 556,
                    'bracketleft': 389,
                    'backslash': 278,
                    'bracketright': 389,
                    'asciicircum': 422,
                    'underscore': 500,
                    'quoteleft': 333,
                    'a': 500,
                    'b': 500,
                    'c': 444,
                    'd': 500,
                    'e': 444,
                    'f': 278,
                    'g': 500,
                    'h': 500,
                    'i': 278,
                    'j': 278,
                    'k': 444,
                    'l': 278,
                    'm': 722,
                    'n': 500,
                    'o': 500,
                    'p': 500,
                    'q': 500,
                    'r': 389,
                    's': 389,
                    't': 278,
                    'u': 500,
                    'v': 444,
                    'w': 667,
                    'x': 444,
                    'y': 444,
                    'z': 389,
                    'braceleft': 400,
                    'bar': 275,
                    'braceright': 400,
                    'asciitilde': 541,
                    'exclamdown': 389,
                    'cent': 500,
                    'sterling': 500,
                    'fraction': 167,
                    'yen': 500,
                    'florin': 500,
                    'section': 500,
                    'currency': 500,
                    'quotesingle': 214,
                    'quotedblleft': 556,
                    'guillemotleft': 500,
                    'guilsinglleft': 333,
                    'guilsinglright': 333,
                    'fi': 500,
                    'fl': 500,
                    'endash': 500,
                    'dagger': 500,
                    'daggerdbl': 500,
                    'periodcentered': 250,
                    'paragraph': 523,
                    'bullet': 350,
                    'quotesinglbase': 333,
                    'quotedblbase': 556,
                    'quotedblright': 556,
                    'guillemotright': 500,
                    'ellipsis': 889,
                    'perthousand': 1000,
                    'questiondown': 500,
                    'grave': 333,
                    'acute': 333,
                    'circumflex': 333,
                    'tilde': 333,
                    'macron': 333,
                    'breve': 333,
                    'dotaccent': 333,
                    'dieresis': 333,
                    'ring': 333,
                    'cedilla': 333,
                    'hungarumlaut': 333,
                    'ogonek': 333,
                    'caron': 333,
                    'emdash': 889,
                    'AE': 889,
                    'ordfeminine': 276,
                    'Lslash': 556,
                    'Oslash': 722,
                    'OE': 944,
                    'ordmasculine': 310,
                    'ae': 667,
                    'dotlessi': 278,
                    'lslash': 278,
                    'oslash': 500,
                    'oe': 667,
                    'germandbls': 500,
                    'Idieresis': 333,
                    'eacute': 444,
                    'abreve': 500,
                    'uhungarumlaut': 500,
                    'ecaron': 444,
                    'Ydieresis': 556,
                    'divide': 675,
                    'Yacute': 556,
                    'Acircumflex': 611,
                    'aacute': 500,
                    'Ucircumflex': 722,
                    'yacute': 444,
                    'scommaaccent': 389,
                    'ecircumflex': 444,
                    'Uring': 722,
                    'Udieresis': 722,
                    'aogonek': 500,
                    'Uacute': 722,
                    'uogonek': 500,
                    'Edieresis': 611,
                    'Dcroat': 722,
                    'commaaccent': 250,
                    'copyright': 760,
                    'Emacron': 611,
                    'ccaron': 444,
                    'aring': 500,
                    'Ncommaaccent': 667,
                    'lacute': 278,
                    'agrave': 500,
                    'Tcommaaccent': 556,
                    'Cacute': 667,
                    'atilde': 500,
                    'Edotaccent': 611,
                    'scaron': 389,
                    'scedilla': 389,
                    'iacute': 278,
                    'lozenge': 471,
                    'Rcaron': 611,
                    'Gcommaaccent': 722,
                    'ucircumflex': 500,
                    'acircumflex': 500,
                    'Amacron': 611,
                    'rcaron': 389,
                    'ccedilla': 444,
                    'Zdotaccent': 556,
                    'Thorn': 611,
                    'Omacron': 722,
                    'Racute': 611,
                    'Sacute': 500,
                    'dcaron': 544,
                    'Umacron': 722,
                    'uring': 500,
                    'threesuperior': 300,
                    'Ograve': 722,
                    'Agrave': 611,
                    'Abreve': 611,
                    'multiply': 675,
                    'uacute': 500,
                    'Tcaron': 556,
                    'partialdiff': 476,
                    'ydieresis': 444,
                    'Nacute': 667,
                    'icircumflex': 278,
                    'Ecircumflex': 611,
                    'adieresis': 500,
                    'edieresis': 444,
                    'cacute': 444,
                    'nacute': 500,
                    'umacron': 500,
                    'Ncaron': 667,
                    'Iacute': 333,
                    'plusminus': 675,
                    'brokenbar': 275,
                    'registered': 760,
                    'Gbreve': 722,
                    'Idotaccent': 333,
                    'summation': 600,
                    'Egrave': 611,
                    'racute': 389,
                    'omacron': 500,
                    'Zacute': 556,
                    'Zcaron': 556,
                    'greaterequal': 549,
                    'Eth': 722,
                    'Ccedilla': 667,
                    'lcommaaccent': 278,
                    'tcaron': 300,
                    'eogonek': 444,
                    'Uogonek': 722,
                    'Aacute': 611,
                    'Adieresis': 611,
                    'egrave': 444,
                    'zacute': 389,
                    'iogonek': 278,
                    'Oacute': 722,
                    'oacute': 500,
                    'amacron': 500,
                    'sacute': 389,
                    'idieresis': 278,
                    'Ocircumflex': 722,
                    'Ugrave': 722,
                    'Delta': 612,
                    'thorn': 500,
                    'twosuperior': 300,
                    'Odieresis': 722,
                    'mu': 500,
                    'igrave': 278,
                    'ohungarumlaut': 500,
                    'Eogonek': 611,
                    'dcroat': 500,
                    'threequarters': 750,
                    'Scedilla': 500,
                    'lcaron': 300,
                    'Kcommaaccent': 667,
                    'Lacute': 556,
                    'trademark': 980,
                    'edotaccent': 444,
                    'Igrave': 333,
                    'Imacron': 333,
                    'Lcaron': 611,
                    'onehalf': 750,
                    'lessequal': 549,
                    'ocircumflex': 500,
                    'ntilde': 500,
                    'Uhungarumlaut': 722,
                    'Eacute': 611,
                    'emacron': 444,
                    'gbreve': 500,
                    'onequarter': 750,
                    'Scaron': 500,
                    'Scommaaccent': 500,
                    'Ohungarumlaut': 722,
                    'degree': 400,
                    'ograve': 500,
                    'Ccaron': 667,
                    'ugrave': 500,
                    'radical': 453,
                    'Dcaron': 722,
                    'rcommaaccent': 389,
                    'Ntilde': 667,
                    'otilde': 500,
                    'Rcommaaccent': 611,
                    'Lcommaaccent': 556,
                    'Atilde': 611,
                    'Aogonek': 611,
                    'Aring': 611,
                    'Otilde': 722,
                    'zdotaccent': 389,
                    'Ecaron': 611,
                    'Iogonek': 333,
                    'kcommaaccent': 444,
                    'minus': 675,
                    'Icircumflex': 333,
                    'ncaron': 500,
                    'tcommaaccent': 278,
                    'logicalnot': 675,
                    'odieresis': 500,
                    'udieresis': 500,
                    'notequal': 549,
                    'gcommaaccent': 500,
                    'eth': 500,
                    'zcaron': 389,
                    'ncommaaccent': 500,
                    'onesuperior': 300,
                    'imacron': 278,
                    'Euro': 500
                },
                'ZapfDingbats': {
                    'space': 278,
                    'a1': 974,
                    'a2': 961,
                    'a202': 974,
                    'a3': 980,
                    'a4': 719,
                    'a5': 789,
                    'a119': 790,
                    'a118': 791,
                    'a117': 690,
                    'a11': 960,
                    'a12': 939,
                    'a13': 549,
                    'a14': 855,
                    'a15': 911,
                    'a16': 933,
                    'a105': 911,
                    'a17': 945,
                    'a18': 974,
                    'a19': 755,
                    'a20': 846,
                    'a21': 762,
                    'a22': 761,
                    'a23': 571,
                    'a24': 677,
                    'a25': 763,
                    'a26': 760,
                    'a27': 759,
                    'a28': 754,
                    'a6': 494,
                    'a7': 552,
                    'a8': 537,
                    'a9': 577,
                    'a10': 692,
                    'a29': 786,
                    'a30': 788,
                    'a31': 788,
                    'a32': 790,
                    'a33': 793,
                    'a34': 794,
                    'a35': 816,
                    'a36': 823,
                    'a37': 789,
                    'a38': 841,
                    'a39': 823,
                    'a40': 833,
                    'a41': 816,
                    'a42': 831,
                    'a43': 923,
                    'a44': 744,
                    'a45': 723,
                    'a46': 749,
                    'a47': 790,
                    'a48': 792,
                    'a49': 695,
                    'a50': 776,
                    'a51': 768,
                    'a52': 792,
                    'a53': 759,
                    'a54': 707,
                    'a55': 708,
                    'a56': 682,
                    'a57': 701,
                    'a58': 826,
                    'a59': 815,
                    'a60': 789,
                    'a61': 789,
                    'a62': 707,
                    'a63': 687,
                    'a64': 696,
                    'a65': 689,
                    'a66': 786,
                    'a67': 787,
                    'a68': 713,
                    'a69': 791,
                    'a70': 785,
                    'a71': 791,
                    'a72': 873,
                    'a73': 761,
                    'a74': 762,
                    'a203': 762,
                    'a75': 759,
                    'a204': 759,
                    'a76': 892,
                    'a77': 892,
                    'a78': 788,
                    'a79': 784,
                    'a81': 438,
                    'a82': 138,
                    'a83': 277,
                    'a84': 415,
                    'a97': 392,
                    'a98': 392,
                    'a99': 668,
                    'a100': 668,
                    'a89': 390,
                    'a90': 390,
                    'a93': 317,
                    'a94': 317,
                    'a91': 276,
                    'a92': 276,
                    'a205': 509,
                    'a85': 509,
                    'a206': 410,
                    'a86': 410,
                    'a87': 234,
                    'a88': 234,
                    'a95': 334,
                    'a96': 334,
                    'a101': 732,
                    'a102': 544,
                    'a103': 544,
                    'a104': 910,
                    'a106': 667,
                    'a107': 760,
                    'a108': 760,
                    'a112': 776,
                    'a111': 595,
                    'a110': 694,
                    'a109': 626,
                    'a120': 788,
                    'a121': 788,
                    'a122': 788,
                    'a123': 788,
                    'a124': 788,
                    'a125': 788,
                    'a126': 788,
                    'a127': 788,
                    'a128': 788,
                    'a129': 788,
                    'a130': 788,
                    'a131': 788,
                    'a132': 788,
                    'a133': 788,
                    'a134': 788,
                    'a135': 788,
                    'a136': 788,
                    'a137': 788,
                    'a138': 788,
                    'a139': 788,
                    'a140': 788,
                    'a141': 788,
                    'a142': 788,
                    'a143': 788,
                    'a144': 788,
                    'a145': 788,
                    'a146': 788,
                    'a147': 788,
                    'a148': 788,
                    'a149': 788,
                    'a150': 788,
                    'a151': 788,
                    'a152': 788,
                    'a153': 788,
                    'a154': 788,
                    'a155': 788,
                    'a156': 788,
                    'a157': 788,
                    'a158': 788,
                    'a159': 788,
                    'a160': 894,
                    'a161': 838,
                    'a163': 1016,
                    'a164': 458,
                    'a196': 748,
                    'a165': 924,
                    'a192': 748,
                    'a166': 918,
                    'a167': 927,
                    'a168': 928,
                    'a169': 928,
                    'a170': 834,
                    'a171': 873,
                    'a172': 828,
                    'a173': 924,
                    'a162': 924,
                    'a174': 917,
                    'a175': 930,
                    'a176': 931,
                    'a177': 463,
                    'a178': 883,
                    'a179': 836,
                    'a193': 836,
                    'a180': 867,
                    'a199': 867,
                    'a181': 696,
                    'a200': 696,
                    'a182': 874,
                    'a201': 874,
                    'a183': 760,
                    'a184': 946,
                    'a197': 771,
                    'a185': 865,
                    'a194': 771,
                    'a198': 888,
                    'a186': 967,
                    'a195': 888,
                    'a187': 831,
                    'a188': 873,
                    'a189': 927,
                    'a190': 970,
                    'a191': 918
                }
            };
            exports.Metrics = Metrics;
        }));
        var NetworkManager = (function NetworkManagerClosure() {
            var OK_RESPONSE = 200;
            var PARTIAL_CONTENT_RESPONSE = 206;

            function NetworkManager(url, args) {
                this.url = url;
                args = args || {};
                this.isHttp = /^https?:/i.test(url);
                this.httpHeaders = (this.isHttp && args.httpHeaders) || {};
                this.withCredentials = args.withCredentials || false;
                this.getXhr = args.getXhr || function NetworkManager_getXhr() {
                    return new XMLHttpRequest();
                };
                this.currXhrId = 0;
                this.pendingRequests = {};
                this.loadedRequests = {};
            }

            function getArrayBuffer(xhr) {
                var data = xhr.response;
                if (typeof data !== 'string') {
                    return data;
                }
                var length = data.length;
                var array = new Uint8Array(length);
                for (var i = 0; i < length; i++) {
                    array[i] = data.charCodeAt(i) & 0xFF;
                }
                return array.buffer;
            }
            var supportsMozChunked = (function supportsMozChunkedClosure() {
                try {
                    var x = new XMLHttpRequest();
                    x.open('GET', 'https://example.com');
                    x.responseType = 'moz-chunked-arraybuffer';
                    return x.responseType === 'moz-chunked-arraybuffer';
                } catch (e) {
                    return false;
                }
            })();
            NetworkManager.prototype = {
                requestRange: function NetworkManager_requestRange(begin, end, listeners) {
                    var args = {
                        begin: begin,
                        end: end
                    };
                    for (var prop in listeners) {
                        args[prop] = listeners[prop];
                    }
                    return this.request(args);
                },
                requestFull: function NetworkManager_requestFull(listeners) {
                    return this.request(listeners);
                },
                request: function NetworkManager_request(args) {
                    var xhr = this.getXhr();
                    var xhrId = this.currXhrId++;
                    var pendingRequest = this.pendingRequests[xhrId] = {
                        xhr: xhr
                    };
                    xhr.open('GET', this.url);
                    xhr.withCredentials = this.withCredentials;
                    for (var property in this.httpHeaders) {
                        var value = this.httpHeaders[property];
                        if (typeof value === 'undefined') {
                            continue;
                        }
                        xhr.setRequestHeader(property, value);
                    }
                    if (this.isHttp && 'begin' in args && 'end' in args) {
                        var rangeStr = args.begin + '-' + (args.end - 1);
                        xhr.setRequestHeader('Range', 'bytes=' + rangeStr);
                        pendingRequest.expectedStatus = 206;
                    } else {
                        pendingRequest.expectedStatus = 200;
                    }
                    var useMozChunkedLoading = supportsMozChunked && !!args.onProgressiveData;
                    if (useMozChunkedLoading) {
                        xhr.responseType = 'moz-chunked-arraybuffer';
                        pendingRequest.onProgressiveData = args.onProgressiveData;
                        pendingRequest.mozChunked = true;
                    } else {
                        xhr.responseType = 'arraybuffer';
                    }
                    if (args.onError) {
                        xhr.onerror = function(evt) {
                            args.onError(xhr.status);
                        };
                    }
                    xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
                    xhr.onprogress = this.onProgress.bind(this, xhrId);
                    pendingRequest.onHeadersReceived = args.onHeadersReceived;
                    pendingRequest.onDone = args.onDone;
                    pendingRequest.onError = args.onError;
                    pendingRequest.onProgress = args.onProgress;
                    xhr.send(null);
                    return xhrId;
                },
                onProgress: function NetworkManager_onProgress(xhrId, evt) {
                    var pendingRequest = this.pendingRequests[xhrId];
                    if (!pendingRequest) {
                        return;
                    }
                    if (pendingRequest.mozChunked) {
                        var chunk = getArrayBuffer(pendingRequest.xhr);
                        pendingRequest.onProgressiveData(chunk);
                    }
                    var onProgress = pendingRequest.onProgress;
                    if (onProgress) {
                        onProgress(evt);
                    }
                },
                onStateChange: function NetworkManager_onStateChange(xhrId, evt) {
                    var pendingRequest = this.pendingRequests[xhrId];
                    if (!pendingRequest) {
                        return;
                    }
                    var xhr = pendingRequest.xhr;
                    if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
                        pendingRequest.onHeadersReceived();
                        delete pendingRequest.onHeadersReceived;
                    }
                    if (xhr.readyState !== 4) {
                        return;
                    }
                    if (!(xhrId in this.pendingRequests)) {
                        return;
                    }
                    delete this.pendingRequests[xhrId];
                    if (xhr.status === 0 && this.isHttp) {
                        if (pendingRequest.onError) {
                            pendingRequest.onError(xhr.status);
                        }
                        return;
                    }
                    var xhrStatus = xhr.status || OK_RESPONSE;
                    var ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;
                    if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
                        if (pendingRequest.onError) {
                            pendingRequest.onError(xhr.status);
                        }
                        return;
                    }
                    this.loadedRequests[xhrId] = true;
                    var chunk = getArrayBuffer(xhr);
                    if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
                        var rangeHeader = xhr.getResponseHeader('Content-Range');
                        var matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
                        var begin = parseInt(matches[1], 10);
                        pendingRequest.onDone({
                            begin: begin,
                            chunk: chunk
                        });
                    } else if (pendingRequest.onProgressiveData) {
                        pendingRequest.onDone(null);
                    } else if (chunk) {
                        pendingRequest.onDone({
                            begin: 0,
                            chunk: chunk
                        });
                    } else if (pendingRequest.onError) {
                        pendingRequest.onError(xhr.status);
                    }
                },
                hasPendingRequests: function NetworkManager_hasPendingRequests() {
                    for (var xhrId in this.pendingRequests) {
                        return true;
                    }
                    return false;
                },
                getRequestXhr: function NetworkManager_getXhr(xhrId) {
                    return this.pendingRequests[xhrId].xhr;
                },
                isStreamingRequest: function NetworkManager_isStreamingRequest(xhrId) {
                    return !!(this.pendingRequests[xhrId].onProgressiveData);
                },
                isPendingRequest: function NetworkManager_isPendingRequest(xhrId) {
                    return xhrId in this.pendingRequests;
                },
                isLoadedRequest: function NetworkManager_isLoadedRequest(xhrId) {
                    return xhrId in this.loadedRequests;
                },
                abortAllRequests: function NetworkManager_abortAllRequests() {
                    for (var xhrId in this.pendingRequests) {
                        this.abortRequest(xhrId | 0);
                    }
                },
                abortRequest: function NetworkManager_abortRequest(xhrId) {
                    var xhr = this.pendingRequests[xhrId].xhr;
                    delete this.pendingRequests[xhrId];
                    xhr.abort();
                }
            };
            return NetworkManager;
        })();
        (function(root, factory) {
            {
                factory((root.pdfjsCoreNetwork = {}));
            }
        }(this, function(exports) {
            exports.NetworkManager = NetworkManager;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsSharedGlobal = {}));
            }
        }(this, function(exports) {
            var globalScope = (typeof window !== 'undefined') ? window : (typeof global !== 'undefined') ? global : (typeof self !== 'undefined') ? self : this;
            var isWorker = (typeof window === 'undefined');
            if (!globalScope.PDFJS) {
                globalScope.PDFJS = {};
            }
            if (typeof pdfjsVersion !== 'undefined') {
                globalScope.PDFJS.version = pdfjsVersion;
            }
            if (typeof pdfjsVersion !== 'undefined') {
                globalScope.PDFJS.build = pdfjsBuild;
            }
            globalScope.PDFJS.pdfBug = false;
            exports.globalScope = globalScope;
            exports.isWorker = isWorker;
            exports.PDFJS = globalScope.PDFJS;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsCoreBidi = {}), root.pdfjsSharedGlobal);
            }
        }(this, function(exports, sharedGlobal) {
            var PDFJS = sharedGlobal.PDFJS;
            var bidi = PDFJS.bidi = (function bidiClosure() {
                var baseTypes = ['BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'S', 'B', 'S', 'WS', 'B', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'B', 'B', 'B', 'S', 'WS', 'ON', 'ON', 'ET', 'ET', 'ET', 'ON', 'ON', 'ON', 'ON', 'ON', 'ON', 'CS', 'ON', 'CS', 'ON', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'ON', 'ON', 'ON', 'ON', 'ON', 'ON', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'ON', 'ON', 'ON', 'ON', 'ON', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'ON', 'ON', 'ON', 'ON', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'B', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'CS', 'ON', 'ET', 'ET', 'ET', 'ET', 'ON', 'ON', 'ON', 'ON', 'L', 'ON', 'ON', 'ON', 'ON', 'ON', 'ET', 'ET', 'EN', 'EN', 'ON', 'L', 'ON', 'ON', 'ON', 'EN', 'L', 'ON', 'ON', 'ON', 'ON', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L'];
                var arabicTypes = ['AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'CS', 'AL', 'ON', 'ON', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AN', 'AN', 'AN', 'AN', 'AN', 'AN', 'AN', 'AN', 'AN', 'AN', 'ET', 'AN', 'AN', 'AL', 'AL', 'AL', 'NSM', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'ON', 'NSM', 'NSM', 'NSM', 'NSM', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL'];

                function isOdd(i) {
                    return (i & 1) !== 0;
                }

                function isEven(i) {
                    return (i & 1) === 0;
                }

                function findUnequal(arr, start, value) {
                    for (var j = start, jj = arr.length; j < jj; ++j) {
                        if (arr[j] !== value) {
                            return j;
                        }
                    }
                    return j;
                }

                function setValues(arr, start, end, value) {
                    for (var j = start; j < end; ++j) {
                        arr[j] = value;
                    }
                }

                function reverseValues(arr, start, end) {
                    for (var i = start, j = end - 1; i < j; ++i, --j) {
                        var temp = arr[i];
                        arr[i] = arr[j];
                        arr[j] = temp;
                    }
                }

                function createBidiText(str, isLTR, vertical) {
                    return {
                        str: str,
                        dir: (vertical ? 'ttb' : (isLTR ? 'ltr' : 'rtl'))
                    };
                }
                var chars = [];
                var types = [];

                function bidi(str, startLevel, vertical) {
                    var isLTR = true;
                    var strLength = str.length;
                    if (strLength === 0 || vertical) {
                        return createBidiText(str, isLTR, vertical);
                    }
                    chars.length = strLength;
                    types.length = strLength;
                    var numBidi = 0;
                    var i, ii;
                    for (i = 0; i < strLength; ++i) {
                        chars[i] = str.charAt(i);
                        var charCode = str.charCodeAt(i);
                        var charType = 'L';
                        if (charCode <= 0x00ff) {
                            charType = baseTypes[charCode];
                        } else if (0x0590 <= charCode && charCode <= 0x05f4) {
                            charType = 'R';
                        } else if (0x0600 <= charCode && charCode <= 0x06ff) {
                            charType = arabicTypes[charCode & 0xff];
                        } else if (0x0700 <= charCode && charCode <= 0x08AC) {
                            charType = 'AL';
                        }
                        if (charType === 'R' || charType === 'AL' || charType === 'AN') {
                            numBidi++;
                        }
                        types[i] = charType;
                    }
                    if (numBidi === 0) {
                        isLTR = true;
                        return createBidiText(str, isLTR);
                    }
                    if (startLevel === -1) {
                        if ((strLength / numBidi) < 0.3) {
                            isLTR = true;
                            startLevel = 0;
                        } else {
                            isLTR = false;
                            startLevel = 1;
                        }
                    }
                    var levels = [];
                    for (i = 0; i < strLength; ++i) {
                        levels[i] = startLevel;
                    }
                    var e = (isOdd(startLevel) ? 'R' : 'L');
                    var sor = e;
                    var eor = sor;
                    var lastType = sor;
                    for (i = 0; i < strLength; ++i) {
                        if (types[i] === 'NSM') {
                            types[i] = lastType;
                        } else {
                            lastType = types[i];
                        }
                    }
                    lastType = sor;
                    var t;
                    for (i = 0; i < strLength; ++i) {
                        t = types[i];
                        if (t === 'EN') {
                            types[i] = (lastType === 'AL') ? 'AN' : 'EN';
                        } else if (t === 'R' || t === 'L' || t === 'AL') {
                            lastType = t;
                        }
                    }
                    for (i = 0; i < strLength; ++i) {
                        t = types[i];
                        if (t === 'AL') {
                            types[i] = 'R';
                        }
                    }
                    for (i = 1; i < strLength - 1; ++i) {
                        if (types[i] === 'ES' && types[i - 1] === 'EN' && types[i + 1] === 'EN') {
                            types[i] = 'EN';
                        }
                        if (types[i] === 'CS' && (types[i - 1] === 'EN' || types[i - 1] === 'AN') && types[i + 1] === types[i - 1]) {
                            types[i] = types[i - 1];
                        }
                    }
                    for (i = 0; i < strLength; ++i) {
                        if (types[i] === 'EN') {
                            var j;
                            for (j = i - 1; j >= 0; --j) {
                                if (types[j] !== 'ET') {
                                    break;
                                }
                                types[j] = 'EN';
                            }
                            for (j = i + 1; j < strLength; --j) {
                                if (types[j] !== 'ET') {
                                    break;
                                }
                                types[j] = 'EN';
                            }
                        }
                    }
                    for (i = 0; i < strLength; ++i) {
                        t = types[i];
                        if (t === 'WS' || t === 'ES' || t === 'ET' || t === 'CS') {
                            types[i] = 'ON';
                        }
                    }
                    lastType = sor;
                    for (i = 0; i < strLength; ++i) {
                        t = types[i];
                        if (t === 'EN') {
                            types[i] = ((lastType === 'L') ? 'L' : 'EN');
                        } else if (t === 'R' || t === 'L') {
                            lastType = t;
                        }
                    }
                    for (i = 0; i < strLength; ++i) {
                        if (types[i] === 'ON') {
                            var end = findUnequal(types, i + 1, 'ON');
                            var before = sor;
                            if (i > 0) {
                                before = types[i - 1];
                            }
                            var after = eor;
                            if (end + 1 < strLength) {
                                after = types[end + 1];
                            }
                            if (before !== 'L') {
                                before = 'R';
                            }
                            if (after !== 'L') {
                                after = 'R';
                            }
                            if (before === after) {
                                setValues(types, i, end, before);
                            }
                            i = end - 1;
                        }
                    }
                    for (i = 0; i < strLength; ++i) {
                        if (types[i] === 'ON') {
                            types[i] = e;
                        }
                    }
                    for (i = 0; i < strLength; ++i) {
                        t = types[i];
                        if (isEven(levels[i])) {
                            if (t === 'R') {
                                levels[i] += 1;
                            } else if (t === 'AN' || t === 'EN') {
                                levels[i] += 2;
                            }
                        } else {
                            if (t === 'L' || t === 'AN' || t === 'EN') {
                                levels[i] += 1;
                            }
                        }
                    }
                    var highestLevel = -1;
                    var lowestOddLevel = 99;
                    var level;
                    for (i = 0, ii = levels.length; i < ii; ++i) {
                        level = levels[i];
                        if (highestLevel < level) {
                            highestLevel = level;
                        }
                        if (lowestOddLevel > level && isOdd(level)) {
                            lowestOddLevel = level;
                        }
                    }
                    for (level = highestLevel; level >= lowestOddLevel; --level) {
                        var start = -1;
                        for (i = 0, ii = levels.length; i < ii; ++i) {
                            if (levels[i] < level) {
                                if (start >= 0) {
                                    reverseValues(chars, start, i);
                                    start = -1;
                                }
                            } else if (start < 0) {
                                start = i;
                            }
                        }
                        if (start >= 0) {
                            reverseValues(chars, start, levels.length);
                        }
                    }
                    for (i = 0, ii = chars.length; i < ii; ++i) {
                        var ch = chars[i];
                        if (ch === '<' || ch === '>') {
                            chars[i] = '';
                        }
                    }
                    return createBidiText(chars.join(''), isLTR);
                }
                return bidi;
            })();
            exports.bidi = bidi;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsSharedUtil = {}), root.pdfjsSharedGlobal);
            }
        }(this, function(exports, sharedGlobal) {
            var PDFJS = sharedGlobal.PDFJS;
            var globalScope = sharedGlobal.globalScope;
            var FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];
            var TextRenderingMode = {
                FILL: 0,
                STROKE: 1,
                FILL_STROKE: 2,
                INVISIBLE: 3,
                FILL_ADD_TO_PATH: 4,
                STROKE_ADD_TO_PATH: 5,
                FILL_STROKE_ADD_TO_PATH: 6,
                ADD_TO_PATH: 7,
                FILL_STROKE_MASK: 3,
                ADD_TO_PATH_FLAG: 4
            };
            var ImageKind = {
                GRAYSCALE_1BPP: 1,
                RGB_24BPP: 2,
                RGBA_32BPP: 3
            };
            var AnnotationType = {
                TEXT: 1,
                LINK: 2,
                FREETEXT: 3,
                LINE: 4,
                SQUARE: 5,
                CIRCLE: 6,
                POLYGON: 7,
                POLYLINE: 8,
                HIGHLIGHT: 9,
                UNDERLINE: 10,
                SQUIGGLY: 11,
                STRIKEOUT: 12,
                STAMP: 13,
                CARET: 14,
                INK: 15,
                POPUP: 16,
                FILEATTACHMENT: 17,
                SOUND: 18,
                MOVIE: 19,
                WIDGET: 20,
                SCREEN: 21,
                PRINTERMARK: 22,
                TRAPNET: 23,
                WATERMARK: 24,
                THREED: 25,
                REDACT: 26
            };
            var AnnotationFlag = {
                INVISIBLE: 0x01,
                HIDDEN: 0x02,
                PRINT: 0x04,
                NOZOOM: 0x08,
                NOROTATE: 0x10,
                NOVIEW: 0x20,
                READONLY: 0x40,
                LOCKED: 0x80,
                TOGGLENOVIEW: 0x100,
                LOCKEDCONTENTS: 0x200
            };
            var AnnotationBorderStyleType = {
                SOLID: 1,
                DASHED: 2,
                BEVELED: 3,
                INSET: 4,
                UNDERLINE: 5
            };
            var StreamType = {
                UNKNOWN: 0,
                FLATE: 1,
                LZW: 2,
                DCT: 3,
                JPX: 4,
                JBIG: 5,
                A85: 6,
                AHX: 7,
                CCF: 8,
                RL: 9
            };
            var FontType = {
                UNKNOWN: 0,
                TYPE1: 1,
                TYPE1C: 2,
                CIDFONTTYPE0: 3,
                CIDFONTTYPE0C: 4,
                TRUETYPE: 5,
                CIDFONTTYPE2: 6,
                TYPE3: 7,
                OPENTYPE: 8,
                TYPE0: 9,
                MMTYPE1: 10
            };
            PDFJS.VERBOSITY_LEVELS = {
                errors: 0,
                warnings: 1,
                infos: 5
            };
            var OPS = PDFJS.OPS = {
                dependency: 1,
                setLineWidth: 2,
                setLineCap: 3,
                setLineJoin: 4,
                setMiterLimit: 5,
                setDash: 6,
                setRenderingIntent: 7,
                setFlatness: 8,
                setGState: 9,
                save: 10,
                restore: 11,
                transform: 12,
                moveTo: 13,
                lineTo: 14,
                curveTo: 15,
                curveTo2: 16,
                curveTo3: 17,
                closePath: 18,
                rectangle: 19,
                stroke: 20,
                closeStroke: 21,
                fill: 22,
                eoFill: 23,
                fillStroke: 24,
                eoFillStroke: 25,
                closeFillStroke: 26,
                closeEOFillStroke: 27,
                endPath: 28,
                clip: 29,
                eoClip: 30,
                beginText: 31,
                endText: 32,
                setCharSpacing: 33,
                setWordSpacing: 34,
                setHScale: 35,
                setLeading: 36,
                setFont: 37,
                setTextRenderingMode: 38,
                setTextRise: 39,
                moveText: 40,
                setLeadingMoveText: 41,
                setTextMatrix: 42,
                nextLine: 43,
                showText: 44,
                showSpacedText: 45,
                nextLineShowText: 46,
                nextLineSetSpacingShowText: 47,
                setCharWidth: 48,
                setCharWidthAndBounds: 49,
                setStrokeColorSpace: 50,
                setFillColorSpace: 51,
                setStrokeColor: 52,
                setStrokeColorN: 53,
                setFillColor: 54,
                setFillColorN: 55,
                setStrokeGray: 56,
                setFillGray: 57,
                setStrokeRGBColor: 58,
                setFillRGBColor: 59,
                setStrokeCMYKColor: 60,
                setFillCMYKColor: 61,
                shadingFill: 62,
                beginInlineImage: 63,
                beginImageData: 64,
                endInlineImage: 65,
                paintXObject: 66,
                markPoint: 67,
                markPointProps: 68,
                beginMarkedContent: 69,
                beginMarkedContentProps: 70,
                endMarkedContent: 71,
                beginCompat: 72,
                endCompat: 73,
                paintFormXObjectBegin: 74,
                paintFormXObjectEnd: 75,
                beginGroup: 76,
                endGroup: 77,
                beginAnnotations: 78,
                endAnnotations: 79,
                beginAnnotation: 80,
                endAnnotation: 81,
                paintJpegXObject: 82,
                paintImageMaskXObject: 83,
                paintImageMaskXObjectGroup: 84,
                paintImageXObject: 85,
                paintInlineImageXObject: 86,
                paintInlineImageXObjectGroup: 87,
                paintImageXObjectRepeat: 88,
                paintImageMaskXObjectRepeat: 89,
                paintSolidColorImageMask: 90,
                constructPath: 91
            };

            function info(msg) {
                if (PDFJS.verbosity >= PDFJS.VERBOSITY_LEVELS.infos) {
                    console.log('Info: ' + msg);
                }
            }

            function warn(msg) {
                if (PDFJS.verbosity >= PDFJS.VERBOSITY_LEVELS.warnings) {
                    console.log('Warning: ' + msg);
                }
            }

            function deprecated(details) {
                warn('Deprecated API usage: ' + details);
            }

            function error(msg) {
                if (PDFJS.verbosity >= PDFJS.VERBOSITY_LEVELS.errors) {
                    console.log('Error: ' + msg);
                    console.log(backtrace());
                }
                throw new Error(msg);
            }

            function backtrace() {
                try {
                    throw new Error();
                } catch (e) {
                    return e.stack ? e.stack.split('\n').slice(2).join('\n') : '';
                }
            }

            function assert(cond, msg) {
                if (!cond) {
                    error(msg);
                }
            }
            var UNSUPPORTED_FEATURES = PDFJS.UNSUPPORTED_FEATURES = {
                unknown: 'unknown',
                forms: 'forms',
                javaScript: 'javaScript',
                smask: 'smask',
                shadingPattern: 'shadingPattern',
                font: 'font'
            };

            function combineUrl(baseUrl, url) {
                if (!url) {
                    return baseUrl;
                }
                return new URL(url, baseUrl).href;
            }

            function isValidUrl(url, allowRelative) {
                if (!url) {
                    return false;
                }
                var protocol = /^[a-z][a-z0-9+\-.]*(?=:)/i.exec(url);
                if (!protocol) {
                    return allowRelative;
                }
                protocol = protocol[0].toLowerCase();
                switch (protocol) {
                    case 'http':
                    case 'https':
                    case 'ftp':
                    case 'mailto':
                    case 'tel':
                        return true;
                    default:
                        return false;
                }
            }
            PDFJS.isValidUrl = isValidUrl;

            function addLinkAttributes(link, params) {
                var url = params && params.url;
                link.href = link.title = (url ? removeNullCharacters(url) : '');
                if (url) {
                    if (isExternalLinkTargetSet()) {
                        link.target = LinkTargetStringMap[PDFJS.externalLinkTarget];
                    }
                    link.rel = PDFJS.externalLinkRel;
                }
            }
            PDFJS.addLinkAttributes = addLinkAttributes;

            function shadow(obj, prop, value) {
                Object.defineProperty(obj, prop, {
                    value: value,
                    enumerable: true,
                    configurable: true,
                    writable: false
                });
                return value;
            }
            PDFJS.shadow = shadow;
            var LinkTarget = PDFJS.LinkTarget = {
                NONE: 0,
                SELF: 1,
                BLANK: 2,
                PARENT: 3,
                TOP: 4,
            };
            var LinkTargetStringMap = ['', '_self', '_blank', '_parent', '_top'];

            function isExternalLinkTargetSet() {
                if (PDFJS.openExternalLinksInNewWindow) {
                    deprecated('PDFJS.openExternalLinksInNewWindow, please use ' + '"PDFJS.externalLinkTarget = PDFJS.LinkTarget.BLANK" instead.');
                    if (PDFJS.externalLinkTarget === LinkTarget.NONE) {
                        PDFJS.externalLinkTarget = LinkTarget.BLANK;
                    }
                    PDFJS.openExternalLinksInNewWindow = false;
                }
                switch (PDFJS.externalLinkTarget) {
                    case LinkTarget.NONE:
                        return false;
                    case LinkTarget.SELF:
                    case LinkTarget.BLANK:
                    case LinkTarget.PARENT:
                    case LinkTarget.TOP:
                        return true;
                }
                warn('PDFJS.externalLinkTarget is invalid: ' + PDFJS.externalLinkTarget);
                PDFJS.externalLinkTarget = LinkTarget.NONE;
                return false;
            }
            PDFJS.isExternalLinkTargetSet = isExternalLinkTargetSet;
            var PasswordResponses = PDFJS.PasswordResponses = {
                NEED_PASSWORD: 1,
                INCORRECT_PASSWORD: 2
            };
            var PasswordException = (function PasswordExceptionClosure() {
                function PasswordException(msg, code) {
                    this.name = 'PasswordException';
                    this.message = msg;
                    this.code = code;
                }
                PasswordException.prototype = new Error();
                PasswordException.constructor = PasswordException;
                return PasswordException;
            })();
            PDFJS.PasswordException = PasswordException;
            var UnknownErrorException = (function UnknownErrorExceptionClosure() {
                function UnknownErrorException(msg, details) {
                    this.name = 'UnknownErrorException';
                    this.message = msg;
                    this.details = details;
                }
                UnknownErrorException.prototype = new Error();
                UnknownErrorException.constructor = UnknownErrorException;
                return UnknownErrorException;
            })();
            PDFJS.UnknownErrorException = UnknownErrorException;
            var InvalidPDFException = (function InvalidPDFExceptionClosure() {
                function InvalidPDFException(msg) {
                    this.name = 'InvalidPDFException';
                    this.message = msg;
                }
                InvalidPDFException.prototype = new Error();
                InvalidPDFException.constructor = InvalidPDFException;
                return InvalidPDFException;
            })();
            PDFJS.InvalidPDFException = InvalidPDFException;
            var MissingPDFException = (function MissingPDFExceptionClosure() {
                function MissingPDFException(msg) {
                    this.name = 'MissingPDFException';
                    this.message = msg;
                }
                MissingPDFException.prototype = new Error();
                MissingPDFException.constructor = MissingPDFException;
                return MissingPDFException;
            })();
            PDFJS.MissingPDFException = MissingPDFException;
            var UnexpectedResponseException = (function UnexpectedResponseExceptionClosure() {
                function UnexpectedResponseException(msg, status) {
                    this.name = 'UnexpectedResponseException';
                    this.message = msg;
                    this.status = status;
                }
                UnexpectedResponseException.prototype = new Error();
                UnexpectedResponseException.constructor = UnexpectedResponseException;
                return UnexpectedResponseException;
            })();
            PDFJS.UnexpectedResponseException = UnexpectedResponseException;
            var NotImplementedException = (function NotImplementedExceptionClosure() {
                function NotImplementedException(msg) {
                    this.message = msg;
                }
                NotImplementedException.prototype = new Error();
                NotImplementedException.prototype.name = 'NotImplementedException';
                NotImplementedException.constructor = NotImplementedException;
                return NotImplementedException;
            })();
            var MissingDataException = (function MissingDataExceptionClosure() {
                function MissingDataException(begin, end) {
                    this.begin = begin;
                    this.end = end;
                    this.message = 'Missing data [' + begin + ', ' + end + ')';
                }
                MissingDataException.prototype = new Error();
                MissingDataException.prototype.name = 'MissingDataException';
                MissingDataException.constructor = MissingDataException;
                return MissingDataException;
            })();
            var XRefParseException = (function XRefParseExceptionClosure() {
                function XRefParseException(msg) {
                    this.message = msg;
                }
                XRefParseException.prototype = new Error();
                XRefParseException.prototype.name = 'XRefParseException';
                XRefParseException.constructor = XRefParseException;
                return XRefParseException;
            })();
            var NullCharactersRegExp = /\x00/g;

            function removeNullCharacters(str) {
                if (typeof str !== 'string') {
                    warn('The argument for removeNullCharacters must be a string.');
                    return str;
                }
                return str.replace(NullCharactersRegExp, '');
            }
            PDFJS.removeNullCharacters = removeNullCharacters;

            function bytesToString(bytes) {
                assert(bytes !== null && typeof bytes === 'object' && bytes.length !== undefined, 'Invalid argument for bytesToString');
                var length = bytes.length;
                var MAX_ARGUMENT_COUNT = 8192;
                if (length < MAX_ARGUMENT_COUNT) {
                    return String.fromCharCode.apply(null, bytes);
                }
                var strBuf = [];
                for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
                    var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
                    var chunk = bytes.subarray(i, chunkEnd);
                    strBuf.push(String.fromCharCode.apply(null, chunk));
                }
                return strBuf.join('');
            }

            function stringToBytes(str) {
                assert(typeof str === 'string', 'Invalid argument for stringToBytes');
                var length = str.length;
                var bytes = new Uint8Array(length);
                for (var i = 0; i < length; ++i) {
                    bytes[i] = str.charCodeAt(i) & 0xFF;
                }
                return bytes;
            }

            function string32(value) {
                return String.fromCharCode((value >> 24) & 0xff, (value >> 16) & 0xff, (value >> 8) & 0xff, value & 0xff);
            }

            function log2(x) {
                var n = 1,
                    i = 0;
                while (x > n) {
                    n <<= 1;
                    i++;
                }
                return i;
            }

            function readInt8(data, start) {
                return (data[start] << 24) >> 24;
            }

            function readUint16(data, offset) {
                return (data[offset] << 8) | data[offset + 1];
            }

            function readUint32(data, offset) {
                return ((data[offset] << 24) | (data[offset + 1] << 16) | (data[offset + 2] << 8) | data[offset + 3]) >>> 0;
            }

            function isLittleEndian() {
                var buffer8 = new Uint8Array(2);
                buffer8[0] = 1;
                var buffer16 = new Uint16Array(buffer8.buffer);
                return (buffer16[0] === 1);
            }
            Object.defineProperty(PDFJS, 'isLittleEndian', {
                configurable: true,
                get: function PDFJS_isLittleEndian() {
                    return shadow(PDFJS, 'isLittleEndian', isLittleEndian());
                }
            });

            function hasCanvasTypedArrays() {
                var canvas = document.createElement('canvas');
                canvas.width = canvas.height = 1;
                var ctx = canvas.getContext('2d');
                var imageData = ctx.createImageData(1, 1);
                return (typeof imageData.data.buffer !== 'undefined');
            }
            Object.defineProperty(PDFJS, 'hasCanvasTypedArrays', {
                configurable: true,
                get: function PDFJS_hasCanvasTypedArrays() {
                    return shadow(PDFJS, 'hasCanvasTypedArrays', hasCanvasTypedArrays());
                }
            });
            var Uint32ArrayView = (function Uint32ArrayViewClosure() {
                function Uint32ArrayView(buffer, length) {
                    this.buffer = buffer;
                    this.byteLength = buffer.length;
                    this.length = length === undefined ? (this.byteLength >> 2) : length;
                    ensureUint32ArrayViewProps(this.length);
                }
                Uint32ArrayView.prototype = Object.create(null);
                var uint32ArrayViewSetters = 0;

                function createUint32ArrayProp(index) {
                    return {
                        get: function() {
                            var buffer = this.buffer,
                                offset = index << 2;
                            return (buffer[offset] | (buffer[offset + 1] << 8) | (buffer[offset + 2] << 16) | (buffer[offset + 3] << 24)) >>> 0;
                        },
                        set: function(value) {
                            var buffer = this.buffer,
                                offset = index << 2;
                            buffer[offset] = value & 255;
                            buffer[offset + 1] = (value >> 8) & 255;
                            buffer[offset + 2] = (value >> 16) & 255;
                            buffer[offset + 3] = (value >>> 24) & 255;
                        }
                    };
                }

                function ensureUint32ArrayViewProps(length) {
                    while (uint32ArrayViewSetters < length) {
                        Object.defineProperty(Uint32ArrayView.prototype, uint32ArrayViewSetters, createUint32ArrayProp(uint32ArrayViewSetters));
                        uint32ArrayViewSetters++;
                    }
                }
                return Uint32ArrayView;
            })();
            exports.Uint32ArrayView = Uint32ArrayView;
            var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
            var Util = PDFJS.Util = (function UtilClosure() {
                function Util() {}
                var rgbBuf = ['rgb(', 0, ',', 0, ',', 0, ')'];
                Util.makeCssRgb = function Util_makeCssRgb(r, g, b) {
                    rgbBuf[1] = r;
                    rgbBuf[3] = g;
                    rgbBuf[5] = b;
                    return rgbBuf.join('');
                };
                Util.transform = function Util_transform(m1, m2) {
                    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
                };
                Util.applyTransform = function Util_applyTransform(p, m) {
                    var xt = p[0] * m[0] + p[1] * m[2] + m[4];
                    var yt = p[0] * m[1] + p[1] * m[3] + m[5];
                    return [xt, yt];
                };
                Util.applyInverseTransform = function Util_applyInverseTransform(p, m) {
                    var d = m[0] * m[3] - m[1] * m[2];
                    var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
                    var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
                    return [xt, yt];
                };
                Util.getAxialAlignedBoundingBox = function Util_getAxialAlignedBoundingBox(r, m) {
                    var p1 = Util.applyTransform(r, m);
                    var p2 = Util.applyTransform(r.slice(2, 4), m);
                    var p3 = Util.applyTransform([r[0], r[3]], m);
                    var p4 = Util.applyTransform([r[2], r[1]], m);
                    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
                };
                Util.inverseTransform = function Util_inverseTransform(m) {
                    var d = m[0] * m[3] - m[1] * m[2];
                    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
                };
                Util.apply3dTransform = function Util_apply3dTransform(m, v) {
                    return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
                };
                Util.singularValueDecompose2dScale = function Util_singularValueDecompose2dScale(m) {
                    var transpose = [m[0], m[2], m[1], m[3]];
                    var a = m[0] * transpose[0] + m[1] * transpose[2];
                    var b = m[0] * transpose[1] + m[1] * transpose[3];
                    var c = m[2] * transpose[0] + m[3] * transpose[2];
                    var d = m[2] * transpose[1] + m[3] * transpose[3];
                    var first = (a + d) / 2;
                    var second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;
                    var sx = first + second || 1;
                    var sy = first - second || 1;
                    return [Math.sqrt(sx), Math.sqrt(sy)];
                };
                Util.normalizeRect = function Util_normalizeRect(rect) {
                    var r = rect.slice(0);
                    if (rect[0] > rect[2]) {
                        r[0] = rect[2];
                        r[2] = rect[0];
                    }
                    if (rect[1] > rect[3]) {
                        r[1] = rect[3];
                        r[3] = rect[1];
                    }
                    return r;
                };
                Util.intersect = function Util_intersect(rect1, rect2) {
                    function compare(a, b) {
                        return a - b;
                    }
                    var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare),
                        orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare),
                        result = [];
                    rect1 = Util.normalizeRect(rect1);
                    rect2 = Util.normalizeRect(rect2);
                    if ((orderedX[0] === rect1[0] && orderedX[1] === rect2[0]) || (orderedX[0] === rect2[0] && orderedX[1] === rect1[0])) {
                        result[0] = orderedX[1];
                        result[2] = orderedX[2];
                    } else {
                        return false;
                    }
                    if ((orderedY[0] === rect1[1] && orderedY[1] === rect2[1]) || (orderedY[0] === rect2[1] && orderedY[1] === rect1[1])) {
                        result[1] = orderedY[1];
                        result[3] = orderedY[2];
                    } else {
                        return false;
                    }
                    return result;
                };
                Util.sign = function Util_sign(num) {
                    return num < 0 ? -1 : 1;
                };
                var ROMAN_NUMBER_MAP = ['', 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM', '', 'X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC', '', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX'];
                Util.toRoman = function Util_toRoman(number, lowerCase) {
                    assert(isInt(number) && number > 0, 'The number should be a positive integer.');
                    var pos, romanBuf = [];
                    while (number >= 1000) {
                        number -= 1000;
                        romanBuf.push('M');
                    }
                    pos = (number / 100) | 0;
                    number %= 100;
                    romanBuf.push(ROMAN_NUMBER_MAP[pos]);
                    pos = (number / 10) | 0;
                    number %= 10;
                    romanBuf.push(ROMAN_NUMBER_MAP[10 + pos]);
                    romanBuf.push(ROMAN_NUMBER_MAP[20 + number]);
                    var romanStr = romanBuf.join('');
                    return (lowerCase ? romanStr.toLowerCase() : romanStr);
                };
                Util.appendToArray = function Util_appendToArray(arr1, arr2) {
                    Array.prototype.push.apply(arr1, arr2);
                };
                Util.prependToArray = function Util_prependToArray(arr1, arr2) {
                    Array.prototype.unshift.apply(arr1, arr2);
                };
                Util.extendObj = function extendObj(obj1, obj2) {
                    for (var key in obj2) {
                        obj1[key] = obj2[key];
                    }
                };
                Util.getInheritableProperty = function Util_getInheritableProperty(dict, name) {
                    while (dict && !dict.has(name)) {
                        dict = dict.get('Parent');
                    }
                    if (!dict) {
                        return null;
                    }
                    return dict.get(name);
                };
                Util.inherit = function Util_inherit(sub, base, prototype) {
                    sub.prototype = Object.create(base.prototype);
                    sub.prototype.constructor = sub;
                    for (var prop in prototype) {
                        sub.prototype[prop] = prototype[prop];
                    }
                };
                Util.loadScript = function Util_loadScript(src, callback) {
                    var script = document.createElement('script');
                    var loaded = false;
                    script.setAttribute('src', src);
                    if (callback) {
                        script.onload = function() {
                            if (!loaded) {
                                callback();
                            }
                            loaded = true;
                        };
                    }
                    document.getElementsByTagName('head')[0].appendChild(script);
                };
                return Util;
            })();
            var PageViewport = PDFJS.PageViewport = (function PageViewportClosure() {
                function PageViewport(viewBox, scale, rotation, offsetX, offsetY, dontFlip) {
                    this.viewBox = viewBox;
                    this.scale = scale;
                    this.rotation = rotation;
                    this.offsetX = offsetX;
                    this.offsetY = offsetY;
                    var centerX = (viewBox[2] + viewBox[0]) / 2;
                    var centerY = (viewBox[3] + viewBox[1]) / 2;
                    var rotateA, rotateB, rotateC, rotateD;
                    rotation = rotation % 360;
                    rotation = rotation < 0 ? rotation + 360 : rotation;
                    switch (rotation) {
                        case 180:
                            rotateA = -1;
                            rotateB = 0;
                            rotateC = 0;
                            rotateD = 1;
                            break;
                        case 90:
                            rotateA = 0;
                            rotateB = 1;
                            rotateC = 1;
                            rotateD = 0;
                            break;
                        case 270:
                            rotateA = 0;
                            rotateB = -1;
                            rotateC = -1;
                            rotateD = 0;
                            break;
                        default:
                            rotateA = 1;
                            rotateB = 0;
                            rotateC = 0;
                            rotateD = -1;
                            break;
                    }
                    if (dontFlip) {
                        rotateC = -rotateC;
                        rotateD = -rotateD;
                    }
                    var offsetCanvasX, offsetCanvasY;
                    var width, height;
                    if (rotateA === 0) {
                        offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
                        offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
                        width = Math.abs(viewBox[3] - viewBox[1]) * scale;
                        height = Math.abs(viewBox[2] - viewBox[0]) * scale;
                    } else {
                        offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
                        offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
                        width = Math.abs(viewBox[2] - viewBox[0]) * scale;
                        height = Math.abs(viewBox[3] - viewBox[1]) * scale;
                    }
                    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
                    this.width = width;
                    this.height = height;
                    this.fontScale = scale;
                }
                PageViewport.prototype = {
                    clone: function PageViewPort_clone(args) {
                        args = args || {};
                        var scale = 'scale' in args ? args.scale : this.scale;
                        var rotation = 'rotation' in args ? args.rotation : this.rotation;
                        return new PageViewport(this.viewBox.slice(), scale, rotation, this.offsetX, this.offsetY, args.dontFlip);
                    },
                    convertToViewportPoint: function PageViewport_convertToViewportPoint(x, y) {
                        return Util.applyTransform([x, y], this.transform);
                    },
                    convertToViewportRectangle: function PageViewport_convertToViewportRectangle(rect) {
                        var tl = Util.applyTransform([rect[0], rect[1]], this.transform);
                        var br = Util.applyTransform([rect[2], rect[3]], this.transform);
                        return [tl[0], tl[1], br[0], br[1]];
                    },
                    convertToPdfPoint: function PageViewport_convertToPdfPoint(x, y) {
                        return Util.applyInverseTransform([x, y], this.transform);
                    }
                };
                return PageViewport;
            })();
            var PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2D8, 0x2C7, 0x2C6, 0x2D9, 0x2DD, 0x2DB, 0x2DA, 0x2DC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203A, 0x2212, 0x2030, 0x201E, 0x201C, 0x201D, 0x2018, 0x2019, 0x201A, 0x2122, 0xFB01, 0xFB02, 0x141, 0x152, 0x160, 0x178, 0x17D, 0x131, 0x142, 0x153, 0x161, 0x17E, 0, 0x20AC];

            function stringToPDFString(str) {
                var i, n = str.length,
                    strBuf = [];
                if (str[0] === '\xFE' && str[1] === '\xFF') {
                    for (i = 2; i < n; i += 2) {
                        strBuf.push(String.fromCharCode((str.charCodeAt(i) << 8) | str.charCodeAt(i + 1)));
                    }
                } else {
                    for (i = 0; i < n; ++i) {
                        var code = PDFStringTranslateTable[str.charCodeAt(i)];
                        strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
                    }
                }
                return strBuf.join('');
            }

            function stringToUTF8String(str) {
                return decodeURIComponent(escape(str));
            }

            function utf8StringToString(str) {
                return unescape(encodeURIComponent(str));
            }

            function isEmptyObj(obj) {
                for (var key in obj) {
                    return false;
                }
                return true;
            }

            function isBool(v) {
                return typeof v === 'boolean';
            }

            function isInt(v) {
                return typeof v === 'number' && ((v | 0) === v);
            }

            function isNum(v) {
                return typeof v === 'number';
            }

            function isString(v) {
                return typeof v === 'string';
            }

            function isArray(v) {
                return v instanceof Array;
            }

            function isArrayBuffer(v) {
                return typeof v === 'object' && v !== null && v.byteLength !== undefined;
            }

            function createPromiseCapability() {
                var capability = {};
                capability.promise = new Promise(function(resolve, reject) {
                    capability.resolve = resolve;
                    capability.reject = reject;
                });
                return capability;
            }
            PDFJS.createPromiseCapability = createPromiseCapability;
            (function PromiseClosure() {
                if (globalScope.Promise) {
                    if (typeof globalScope.Promise.all !== 'function') {
                        globalScope.Promise.all = function(iterable) {
                            var count = 0,
                                results = [],
                                resolve, reject;
                            var promise = new globalScope.Promise(function(resolve_, reject_) {
                                resolve = resolve_;
                                reject = reject_;
                            });
                            iterable.forEach(function(p, i) {
                                count++;
                                p.then(function(result) {
                                    results[i] = result;
                                    count--;
                                    if (count === 0) {
                                        resolve(results);
                                    }
                                }, reject);
                            });
                            if (count === 0) {
                                resolve(results);
                            }
                            return promise;
                        };
                    }
                    if (typeof globalScope.Promise.resolve !== 'function') {
                        globalScope.Promise.resolve = function(value) {
                            return new globalScope.Promise(function(resolve) {
                                resolve(value);
                            });
                        };
                    }
                    if (typeof globalScope.Promise.reject !== 'function') {
                        globalScope.Promise.reject = function(reason) {
                            return new globalScope.Promise(function(resolve, reject) {
                                reject(reason);
                            });
                        };
                    }
                    if (typeof globalScope.Promise.prototype.catch !== 'function') {
                        globalScope.Promise.prototype.catch = function(onReject) {
                            return globalScope.Promise.prototype.then(undefined, onReject);
                        };
                    }
                    return;
                }
                var STATUS_PENDING = 0;
                var STATUS_RESOLVED = 1;
                var STATUS_REJECTED = 2;
                var REJECTION_TIMEOUT = 500;
                var HandlerManager = {
                    handlers: [],
                    running: false,
                    unhandledRejections: [],
                    pendingRejectionCheck: false,
                    scheduleHandlers: function scheduleHandlers(promise) {
                        if (promise._status === STATUS_PENDING) {
                            return;
                        }
                        this.handlers = this.handlers.concat(promise._handlers);
                        promise._handlers = [];
                        if (this.running) {
                            return;
                        }
                        this.running = true;
                        setTimeout(this.runHandlers.bind(this), 0);
                    },
                    runHandlers: function runHandlers() {
                        var RUN_TIMEOUT = 1;
                        var timeoutAt = Date.now() + RUN_TIMEOUT;
                        while (this.handlers.length > 0) {
                            var handler = this.handlers.shift();
                            var nextStatus = handler.thisPromise._status;
                            var nextValue = handler.thisPromise._value;
                            try {
                                if (nextStatus === STATUS_RESOLVED) {
                                    if (typeof handler.onResolve === 'function') {
                                        nextValue = handler.onResolve(nextValue);
                                    }
                                } else if (typeof handler.onReject === 'function') {
                                    nextValue = handler.onReject(nextValue);
                                    nextStatus = STATUS_RESOLVED;
                                    if (handler.thisPromise._unhandledRejection) {
                                        this.removeUnhandeledRejection(handler.thisPromise);
                                    }
                                }
                            } catch (ex) {
                                nextStatus = STATUS_REJECTED;
                                nextValue = ex;
                            }
                            handler.nextPromise._updateStatus(nextStatus, nextValue);
                            if (Date.now() >= timeoutAt) {
                                break;
                            }
                        }
                        if (this.handlers.length > 0) {
                            setTimeout(this.runHandlers.bind(this), 0);
                            return;
                        }
                        this.running = false;
                    },
                    addUnhandledRejection: function addUnhandledRejection(promise) {
                        this.unhandledRejections.push({
                            promise: promise,
                            time: Date.now()
                        });
                        this.scheduleRejectionCheck();
                    },
                    removeUnhandeledRejection: function removeUnhandeledRejection(promise) {
                        promise._unhandledRejection = false;
                        for (var i = 0; i < this.unhandledRejections.length; i++) {
                            if (this.unhandledRejections[i].promise === promise) {
                                this.unhandledRejections.splice(i);
                                i--;
                            }
                        }
                    },
                    scheduleRejectionCheck: function scheduleRejectionCheck() {
                        if (this.pendingRejectionCheck) {
                            return;
                        }
                        this.pendingRejectionCheck = true;
                        setTimeout(function rejectionCheck() {
                            this.pendingRejectionCheck = false;
                            var now = Date.now();
                            for (var i = 0; i < this.unhandledRejections.length; i++) {
                                if (now - this.unhandledRejections[i].time > REJECTION_TIMEOUT) {
                                    var unhandled = this.unhandledRejections[i].promise._value;
                                    var msg = 'Unhandled rejection: ' + unhandled;
                                    if (unhandled.stack) {
                                        msg += '\n' + unhandled.stack;
                                    }
                                    warn(msg);
                                    this.unhandledRejections.splice(i);
                                    i--;
                                }
                            }
                            if (this.unhandledRejections.length) {
                                this.scheduleRejectionCheck();
                            }
                        }.bind(this), REJECTION_TIMEOUT);
                    }
                };

                function Promise(resolver) {
                    this._status = STATUS_PENDING;
                    this._handlers = [];
                    try {
                        resolver.call(this, this._resolve.bind(this), this._reject.bind(this));
                    } catch (e) {
                        this._reject(e);
                    }
                }
                Promise.all = function Promise_all(promises) {
                    var resolveAll, rejectAll;
                    var deferred = new Promise(function(resolve, reject) {
                        resolveAll = resolve;
                        rejectAll = reject;
                    });
                    var unresolved = promises.length;
                    var results = [];
                    if (unresolved === 0) {
                        resolveAll(results);
                        return deferred;
                    }

                    function reject(reason) {
                        if (deferred._status === STATUS_REJECTED) {
                            return;
                        }
                        results = [];
                        rejectAll(reason);
                    }
                    for (var i = 0, ii = promises.length; i < ii; ++i) {
                        var promise = promises[i];
                        var resolve = (function(i) {
                            return function(value) {
                                if (deferred._status === STATUS_REJECTED) {
                                    return;
                                }
                                results[i] = value;
                                unresolved--;
                                if (unresolved === 0) {
                                    resolveAll(results);
                                }
                            };
                        })(i);
                        if (Promise.isPromise(promise)) {
                            promise.then(resolve, reject);
                        } else {
                            resolve(promise);
                        }
                    }
                    return deferred;
                };
                Promise.isPromise = function Promise_isPromise(value) {
                    return value && typeof value.then === 'function';
                };
                Promise.resolve = function Promise_resolve(value) {
                    return new Promise(function(resolve) {
                        resolve(value);
                    });
                };
                Promise.reject = function Promise_reject(reason) {
                    return new Promise(function(resolve, reject) {
                        reject(reason);
                    });
                };
                Promise.prototype = {
                    _status: null,
                    _value: null,
                    _handlers: null,
                    _unhandledRejection: null,
                    _updateStatus: function Promise__updateStatus(status, value) {
                        if (this._status === STATUS_RESOLVED || this._status === STATUS_REJECTED) {
                            return;
                        }
                        if (status === STATUS_RESOLVED && Promise.isPromise(value)) {
                            value.then(this._updateStatus.bind(this, STATUS_RESOLVED), this._updateStatus.bind(this, STATUS_REJECTED));
                            return;
                        }
                        this._status = status;
                        this._value = value;
                        if (status === STATUS_REJECTED && this._handlers.length === 0) {
                            this._unhandledRejection = true;
                            HandlerManager.addUnhandledRejection(this);
                        }
                        HandlerManager.scheduleHandlers(this);
                    },
                    _resolve: function Promise_resolve(value) {
                        this._updateStatus(STATUS_RESOLVED, value);
                    },
                    _reject: function Promise_reject(reason) {
                        this._updateStatus(STATUS_REJECTED, reason);
                    },
                    then: function Promise_then(onResolve, onReject) {
                        var nextPromise = new Promise(function(resolve, reject) {
                            this.resolve = resolve;
                            this.reject = reject;
                        });
                        this._handlers.push({
                            thisPromise: this,
                            onResolve: onResolve,
                            onReject: onReject,
                            nextPromise: nextPromise
                        });
                        HandlerManager.scheduleHandlers(this);
                        return nextPromise;
                    },
                    catch: function Promise_catch(onReject) {
                        return this.then(undefined, onReject);
                    }
                };
                globalScope.Promise = Promise;
            })();
            var StatTimer = (function StatTimerClosure() {
                function rpad(str, pad, length) {
                    while (str.length < length) {
                        str += pad;
                    }
                    return str;
                }

                function StatTimer() {
                    this.started = {};
                    this.times = [];
                    this.enabled = true;
                }
                StatTimer.prototype = {
                    time: function StatTimer_time(name) {
                        if (!this.enabled) {
                            return;
                        }
                        if (name in this.started) {
                            warn('Timer is already running for ' + name);
                        }
                        this.started[name] = Date.now();
                    },
                    timeEnd: function StatTimer_timeEnd(name) {
                        if (!this.enabled) {
                            return;
                        }
                        if (!(name in this.started)) {
                            warn('Timer has not been started for ' + name);
                        }
                        this.times.push({
                            'name': name,
                            'start': this.started[name],
                            'end': Date.now()
                        });
                        delete this.started[name];
                    },
                    toString: function StatTimer_toString() {
                        var i, ii;
                        var times = this.times;
                        var out = '';
                        var longest = 0;
                        for (i = 0, ii = times.length; i < ii; ++i) {
                            var name = times[i]['name'];
                            if (name.length > longest) {
                                longest = name.length;
                            }
                        }
                        for (i = 0, ii = times.length; i < ii; ++i) {
                            var span = times[i];
                            var duration = span.end - span.start;
                            out += rpad(span['name'], ' ', longest) + ' ' + duration + 'ms\n';
                        }
                        return out;
                    }
                };
                return StatTimer;
            })();
            PDFJS.createBlob = function createBlob(data, contentType) {
                if (typeof Blob !== 'undefined') {
                    return new Blob([data], {
                        type: contentType
                    });
                }
                var bb = new MozBlobBuilder();
                bb.append(data);
                return bb.getBlob(contentType);
            };
            PDFJS.createObjectURL = (function createObjectURLClosure() {
                var digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
                return function createObjectURL(data, contentType) {
                    if (!PDFJS.disableCreateObjectURL && typeof URL !== 'undefined' && URL.createObjectURL) {
                        var blob = PDFJS.createBlob(data, contentType);
                        return URL.createObjectURL(blob);
                    }
                    var buffer = 'data:' + contentType + ';base64,';
                    for (var i = 0, ii = data.length; i < ii; i += 3) {
                        var b1 = data[i] & 0xFF;
                        var b2 = data[i + 1] & 0xFF;
                        var b3 = data[i + 2] & 0xFF;
                        var d1 = b1 >> 2,
                            d2 = ((b1 & 3) << 4) | (b2 >> 4);
                        var d3 = i + 1 < ii ? ((b2 & 0xF) << 2) | (b3 >> 6) : 64;
                        var d4 = i + 2 < ii ? (b3 & 0x3F) : 64;
                        buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
                    }
                    return buffer;
                };
            })();

            function MessageHandler(sourceName, targetName, comObj) {
                this.sourceName = sourceName;
                this.targetName = targetName;
                this.comObj = comObj;
                this.callbackIndex = 1;
                this.postMessageTransfers = true;
                var callbacksCapabilities = this.callbacksCapabilities = {};
                var ah = this.actionHandler = {};
                this._onComObjOnMessage = function messageHandlerComObjOnMessage(event) {
                    var data = event.data;
                    if (data.targetName !== this.sourceName) {
                        return;
                    }
                    if (data.isReply) {
                        var callbackId = data.callbackId;
                        if (data.callbackId in callbacksCapabilities) {
                            var callback = callbacksCapabilities[callbackId];
                            delete callbacksCapabilities[callbackId];
                            if ('error' in data) {
                                callback.reject(data.error);
                            } else {
                                callback.resolve(data.data);
                            }
                        } else {
                            error('Cannot resolve callback ' + callbackId);
                        }
                    } else if (data.action in ah) {
                        var action = ah[data.action];
                        if (data.callbackId) {
                            var sourceName = this.sourceName;
                            var targetName = data.sourceName;
                            Promise.resolve().then(function() {
                                return action[0].call(action[1], data.data);
                            }).then(function(result) {
                                comObj.postMessage({
                                    sourceName: sourceName,
                                    targetName: targetName,
                                    isReply: true,
                                    callbackId: data.callbackId,
                                    data: result
                                });
                            }, function(reason) {
                                if (reason instanceof Error) {
                                    reason = reason + '';
                                }
                                comObj.postMessage({
                                    sourceName: sourceName,
                                    targetName: targetName,
                                    isReply: true,
                                    callbackId: data.callbackId,
                                    error: reason
                                });
                            });
                        } else {
                            action[0].call(action[1], data.data);
                        }
                    } else {
                        error('Unknown action from worker: ' + data.action);
                    }
                }.bind(this);
                comObj.addEventListener('message', this._onComObjOnMessage);
            }
            MessageHandler.prototype = {
                on: function messageHandlerOn(actionName, handler, scope) {
                    var ah = this.actionHandler;
                    if (ah[actionName]) {
                        error('There is already an actionName called "' + actionName + '"');
                    }
                    ah[actionName] = [handler, scope];
                },
                send: function messageHandlerSend(actionName, data, transfers) {
                    var message = {
                        sourceName: this.sourceName,
                        targetName: this.targetName,
                        action: actionName,
                        data: data
                    };
                    this.postMessage(message, transfers);
                },
                sendWithPromise: function messageHandlerSendWithPromise(actionName, data, transfers) {
                    var callbackId = this.callbackIndex++;
                    var message = {
                        sourceName: this.sourceName,
                        targetName: this.targetName,
                        action: actionName,
                        data: data,
                        callbackId: callbackId
                    };
                    var capability = createPromiseCapability();
                    this.callbacksCapabilities[callbackId] = capability;
                    try {
                        this.postMessage(message, transfers);
                    } catch (e) {
                        capability.reject(e);
                    }
                    return capability.promise;
                },
                postMessage: function(message, transfers) {
                    if (transfers && this.postMessageTransfers) {
                        this.comObj.postMessage(message, transfers);
                    } else {
                        this.comObj.postMessage(message);
                    }
                },
                destroy: function() {
                    this.comObj.removeEventListener('message', this._onComObjOnMessage);
                }
            };

            function loadJpegStream(id, imageUrl, objs) {
                var img = new Image();
                img.onload = (function loadJpegStream_onloadClosure() {
                    objs.resolve(id, img);
                });
                img.onerror = (function loadJpegStream_onerrorClosure() {
                    objs.resolve(id, null);
                    warn('Error during JPEG image loading');
                });
                img.src = imageUrl;
            }
            (function checkURLConstructor(scope) {
                var hasWorkingUrl = false;
                try {
                    if (typeof URL === 'function' && typeof URL.prototype === 'object' && ('origin' in URL.prototype)) {
                        var u = new URL('b', 'http://a');
                        u.pathname = 'c%20d';
                        hasWorkingUrl = u.href === 'http://a/c%20d';
                    }
                } catch (e) {}
                if (hasWorkingUrl)
                    return;
                var relative = Object.create(null);
                relative['ftp'] = 21;
                relative['file'] = 0;
                relative['gopher'] = 70;
                relative['http'] = 80;
                relative['https'] = 443;
                relative['ws'] = 80;
                relative['wss'] = 443;
                var relativePathDotMapping = Object.create(null);
                relativePathDotMapping['%2e'] = '.';
                relativePathDotMapping['.%2e'] = '..';
                relativePathDotMapping['%2e.'] = '..';
                relativePathDotMapping['%2e%2e'] = '..';

                function isRelativeScheme(scheme) {
                    return relative[scheme] !== undefined;
                }

                function invalid() {
                    clear.call(this);
                    this._isInvalid = true;
                }

                function IDNAToASCII(h) {
                    if ('' == h) {
                        invalid.call(this)
                    }
                    return h.toLowerCase()
                }

                function percentEscape(c) {
                    var unicode = c.charCodeAt(0);
                    if (unicode > 0x20 && unicode < 0x7F && [0x22, 0x23, 0x3C, 0x3E, 0x3F, 0x60].indexOf(unicode) == -1) {
                        return c;
                    }
                    return encodeURIComponent(c);
                }

                function percentEscapeQuery(c) {
                    var unicode = c.charCodeAt(0);
                    if (unicode > 0x20 && unicode < 0x7F && [0x22, 0x23, 0x3C, 0x3E, 0x60].indexOf(unicode) == -1) {
                        return c;
                    }
                    return encodeURIComponent(c);
                }
                var EOF = undefined,
                    ALPHA = /[a-zA-Z]/,
                    ALPHANUMERIC = /[a-zA-Z0-9\+\-\.]/;

                function parse(input, stateOverride, base) {
                    function err(message) {
                        errors.push(message)
                    }
                    var state = stateOverride || 'scheme start',
                        cursor = 0,
                        buffer = '',
                        seenAt = false,
                        seenBracket = false,
                        errors = [];
                    loop: while ((input[cursor - 1] != EOF || cursor == 0) && !this._isInvalid) {
                        var c = input[cursor];
                        switch (state) {
                            case 'scheme start':
                                if (c && ALPHA.test(c)) {
                                    buffer += c.toLowerCase();
                                    state = 'scheme';
                                } else if (!stateOverride) {
                                    buffer = '';
                                    state = 'no scheme';
                                    continue;
                                } else {
                                    err('Invalid scheme.');
                                    break loop;
                                }
                                break;
                            case 'scheme':
                                if (c && ALPHANUMERIC.test(c)) {
                                    buffer += c.toLowerCase();
                                } else if (':' == c) {
                                    this._scheme = buffer;
                                    buffer = '';
                                    if (stateOverride) {
                                        break loop;
                                    }
                                    if (isRelativeScheme(this._scheme)) {
                                        this._isRelative = true;
                                    }
                                    if ('file' == this._scheme) {
                                        state = 'relative';
                                    } else if (this._isRelative && base && base._scheme == this._scheme) {
                                        state = 'relative or authority';
                                    } else if (this._isRelative) {
                                        state = 'authority first slash';
                                    } else {
                                        state = 'scheme data';
                                    }
                                } else if (!stateOverride) {
                                    buffer = '';
                                    cursor = 0;
                                    state = 'no scheme';
                                    continue;
                                } else if (EOF == c) {
                                    break loop;
                                } else {
                                    err('Code point not allowed in scheme: ' + c)
                                    break loop;
                                }
                                break;
                            case 'scheme data':
                                if ('?' == c) {
                                    this._query = '?';
                                    state = 'query';
                                } else if ('#' == c) {
                                    this._fragment = '#';
                                    state = 'fragment';
                                } else {
                                    if (EOF != c && '\t' != c && '\n' != c && '\r' != c) {
                                        this._schemeData += percentEscape(c);
                                    }
                                }
                                break;
                            case 'no scheme':
                                if (!base || !(isRelativeScheme(base._scheme))) {
                                    err('Missing scheme.');
                                    invalid.call(this);
                                } else {
                                    state = 'relative';
                                    continue;
                                }
                                break;
                            case 'relative or authority':
                                if ('/' == c && '/' == input[cursor + 1]) {
                                    state = 'authority ignore slashes';
                                } else {
                                    err('Expected /, got: ' + c);
                                    state = 'relative';
                                    continue
                                }
                                break;
                            case 'relative':
                                this._isRelative = true;
                                if ('file' != this._scheme)
                                    this._scheme = base._scheme;
                                if (EOF == c) {
                                    this._host = base._host;
                                    this._port = base._port;
                                    this._path = base._path.slice();
                                    this._query = base._query;
                                    this._username = base._username;
                                    this._password = base._password;
                                    break loop;
                                } else if ('/' == c || '\\' == c) {
                                    if ('\\' == c)
                                        err('\\ is an invalid code point.');
                                    state = 'relative slash';
                                } else if ('?' == c) {
                                    this._host = base._host;
                                    this._port = base._port;
                                    this._path = base._path.slice();
                                    this._query = '?';
                                    this._username = base._username;
                                    this._password = base._password;
                                    state = 'query';
                                } else if ('#' == c) {
                                    this._host = base._host;
                                    this._port = base._port;
                                    this._path = base._path.slice();
                                    this._query = base._query;
                                    this._fragment = '#';
                                    this._username = base._username;
                                    this._password = base._password;
                                    state = 'fragment';
                                } else {
                                    var nextC = input[cursor + 1]
                                    var nextNextC = input[cursor + 2]
                                    if ('file' != this._scheme || !ALPHA.test(c) || (nextC != ':' && nextC != '|') || (EOF != nextNextC && '/' != nextNextC && '\\' != nextNextC && '?' != nextNextC && '#' != nextNextC)) {
                                        this._host = base._host;
                                        this._port = base._port;
                                        this._username = base._username;
                                        this._password = base._password;
                                        this._path = base._path.slice();
                                        this._path.pop();
                                    }
                                    state = 'relative path';
                                    continue;
                                }
                                break;
                            case 'relative slash':
                                if ('/' == c || '\\' == c) {
                                    if ('\\' == c) {
                                        err('\\ is an invalid code point.');
                                    }
                                    if ('file' == this._scheme) {
                                        state = 'file host';
                                    } else {
                                        state = 'authority ignore slashes';
                                    }
                                } else {
                                    if ('file' != this._scheme) {
                                        this._host = base._host;
                                        this._port = base._port;
                                        this._username = base._username;
                                        this._password = base._password;
                                    }
                                    state = 'relative path';
                                    continue;
                                }
                                break;
                            case 'authority first slash':
                                if ('/' == c) {
                                    state = 'authority second slash';
                                } else {
                                    err("Expected '/', got: " + c);
                                    state = 'authority ignore slashes';
                                    continue;
                                }
                                break;
                            case 'authority second slash':
                                state = 'authority ignore slashes';
                                if ('/' != c) {
                                    err("Expected '/', got: " + c);
                                    continue;
                                }
                                break;
                            case 'authority ignore slashes':
                                if ('/' != c && '\\' != c) {
                                    state = 'authority';
                                    continue;
                                } else {
                                    err('Expected authority, got: ' + c);
                                }
                                break;
                            case 'authority':
                                if ('@' == c) {
                                    if (seenAt) {
                                        err('@ already seen.');
                                        buffer += '%40';
                                    }
                                    seenAt = true;
                                    for (var i = 0; i < buffer.length; i++) {
                                        var cp = buffer[i];
                                        if ('\t' == cp || '\n' == cp || '\r' == cp) {
                                            err('Invalid whitespace in authority.');
                                            continue;
                                        }
                                        if (':' == cp && null === this._password) {
                                            this._password = '';
                                            continue;
                                        }
                                        var tempC = percentEscape(cp);
                                        (null !== this._password) ? this._password += tempC: this._username += tempC;
                                    }
                                    buffer = '';
                                } else if (EOF == c || '/' == c || '\\' == c || '?' == c || '#' == c) {
                                    cursor -= buffer.length;
                                    buffer = '';
                                    state = 'host';
                                    continue;
                                } else {
                                    buffer += c;
                                }
                                break;
                            case 'file host':
                                if (EOF == c || '/' == c || '\\' == c || '?' == c || '#' == c) {
                                    if (buffer.length == 2 && ALPHA.test(buffer[0]) && (buffer[1] == ':' || buffer[1] == '|')) {
                                        state = 'relative path';
                                    } else if (buffer.length == 0) {
                                        state = 'relative path start';
                                    } else {
                                        this._host = IDNAToASCII.call(this, buffer);
                                        buffer = '';
                                        state = 'relative path start';
                                    }
                                    continue;
                                } else if ('\t' == c || '\n' == c || '\r' == c) {
                                    err('Invalid whitespace in file host.');
                                } else {
                                    buffer += c;
                                }
                                break;
                            case 'host':
                            case 'hostname':
                                if (':' == c && !seenBracket) {
                                    this._host = IDNAToASCII.call(this, buffer);
                                    buffer = '';
                                    state = 'port';
                                    if ('hostname' == stateOverride) {
                                        break loop;
                                    }
                                } else if (EOF == c || '/' == c || '\\' == c || '?' == c || '#' == c) {
                                    this._host = IDNAToASCII.call(this, buffer);
                                    buffer = '';
                                    state = 'relative path start';
                                    if (stateOverride) {
                                        break loop;
                                    }
                                    continue;
                                } else if ('\t' != c && '\n' != c && '\r' != c) {
                                    if ('[' == c) {
                                        seenBracket = true;
                                    } else if (']' == c) {
                                        seenBracket = false;
                                    }
                                    buffer += c;
                                } else {
                                    err('Invalid code point in host/hostname: ' + c);
                                }
                                break;
                            case 'port':
                                if (/[0-9]/.test(c)) {
                                    buffer += c;
                                } else if (EOF == c || '/' == c || '\\' == c || '?' == c || '#' == c || stateOverride) {
                                    if ('' != buffer) {
                                        var temp = parseInt(buffer, 10);
                                        if (temp != relative[this._scheme]) {
                                            this._port = temp + '';
                                        }
                                        buffer = '';
                                    }
                                    if (stateOverride) {
                                        break loop;
                                    }
                                    state = 'relative path start';
                                    continue;
                                } else if ('\t' == c || '\n' == c || '\r' == c) {
                                    err('Invalid code point in port: ' + c);
                                } else {
                                    invalid.call(this);
                                }
                                break;
                            case 'relative path start':
                                if ('\\' == c)
                                    err("'\\' not allowed in path.");
                                state = 'relative path';
                                if ('/' != c && '\\' != c) {
                                    continue;
                                }
                                break;
                            case 'relative path':
                                if (EOF == c || '/' == c || '\\' == c || (!stateOverride && ('?' == c || '#' == c))) {
                                    if ('\\' == c) {
                                        err('\\ not allowed in relative path.');
                                    }
                                    var tmp;
                                    if (tmp = relativePathDotMapping[buffer.toLowerCase()]) {
                                        buffer = tmp;
                                    }
                                    if ('..' == buffer) {
                                        this._path.pop();
                                        if ('/' != c && '\\' != c) {
                                            this._path.push('');
                                        }
                                    } else if ('.' == buffer && '/' != c && '\\' != c) {
                                        this._path.push('');
                                    } else if ('.' != buffer) {
                                        if ('file' == this._scheme && this._path.length == 0 && buffer.length == 2 && ALPHA.test(buffer[0]) && buffer[1] == '|') {
                                            buffer = buffer[0] + ':';
                                        }
                                        this._path.push(buffer);
                                    }
                                    buffer = '';
                                    if ('?' == c) {
                                        this._query = '?';
                                        state = 'query';
                                    } else if ('#' == c) {
                                        this._fragment = '#';
                                        state = 'fragment';
                                    }
                                } else if ('\t' != c && '\n' != c && '\r' != c) {
                                    buffer += percentEscape(c);
                                }
                                break;
                            case 'query':
                                if (!stateOverride && '#' == c) {
                                    this._fragment = '#';
                                    state = 'fragment';
                                } else if (EOF != c && '\t' != c && '\n' != c && '\r' != c) {
                                    this._query += percentEscapeQuery(c);
                                }
                                break;
                            case 'fragment':
                                if (EOF != c && '\t' != c && '\n' != c && '\r' != c) {
                                    this._fragment += c;
                                }
                                break;
                        }
                        cursor++;
                    }
                }

                function clear() {
                    this._scheme = '';
                    this._schemeData = '';
                    this._username = '';
                    this._password = null;
                    this._host = '';
                    this._port = '';
                    this._path = [];
                    this._query = '';
                    this._fragment = '';
                    this._isInvalid = false;
                    this._isRelative = false;
                }

                function jURL(url, base) {
                    if (base !== undefined && !(base instanceof jURL))
                        base = new jURL(String(base));
                    this._url = url;
                    clear.call(this);
                    var input = url.replace(/^[ \t\r\n\f]+|[ \t\r\n\f]+$/g, '');
                    parse.call(this, input, null, base);
                }
                jURL.prototype = {
                    toString: function() {
                        return this.href;
                    },
                    get href() {
                        if (this._isInvalid)
                            return this._url;
                        var authority = '';
                        if ('' != this._username || null != this._password) {
                            authority = this._username +
                                (null != this._password ? ':' + this._password : '') + '@';
                        }
                        return this.protocol +
                            (this._isRelative ? '//' + authority + this.host : '') +
                            this.pathname + this._query + this._fragment;
                    },
                    set href(href) {
                        clear.call(this);
                        parse.call(this, href);
                    },
                    get protocol() {
                        return this._scheme + ':';
                    },
                    set protocol(protocol) {
                        if (this._isInvalid)
                            return;
                        parse.call(this, protocol + ':', 'scheme start');
                    },
                    get host() {
                        return this._isInvalid ? '' : this._port ? this._host + ':' + this._port : this._host;
                    },
                    set host(host) {
                        if (this._isInvalid || !this._isRelative)
                            return;
                        parse.call(this, host, 'host');
                    },
                    get hostname() {
                        return this._host;
                    },
                    set hostname(hostname) {
                        if (this._isInvalid || !this._isRelative)
                            return;
                        parse.call(this, hostname, 'hostname');
                    },
                    get port() {
                        return this._port;
                    },
                    set port(port) {
                        if (this._isInvalid || !this._isRelative)
                            return;
                        parse.call(this, port, 'port');
                    },
                    get pathname() {
                        return this._isInvalid ? '' : this._isRelative ? '/' + this._path.join('/') : this._schemeData;
                    },
                    set pathname(pathname) {
                        if (this._isInvalid || !this._isRelative)
                            return;
                        this._path = [];
                        parse.call(this, pathname, 'relative path start');
                    },
                    get search() {
                        return this._isInvalid || !this._query || '?' == this._query ? '' : this._query;
                    },
                    set search(search) {
                        if (this._isInvalid || !this._isRelative)
                            return;
                        this._query = '?';
                        if ('?' == search[0])
                            search = search.slice(1);
                        parse.call(this, search, 'query');
                    },
                    get hash() {
                        return this._isInvalid || !this._fragment || '#' == this._fragment ? '' : this._fragment;
                    },
                    set hash(hash) {
                        if (this._isInvalid)
                            return;
                        this._fragment = '#';
                        if ('#' == hash[0])
                            hash = hash.slice(1);
                        parse.call(this, hash, 'fragment');
                    },
                    get origin() {
                        var host;
                        if (this._isInvalid || !this._scheme) {
                            return '';
                        }
                        switch (this._scheme) {
                            case 'data':
                            case 'file':
                            case 'javascript':
                            case 'mailto':
                                return 'null';
                        }
                        host = this.host;
                        if (!host) {
                            return '';
                        }
                        return this._scheme + '://' + host;
                    }
                };
                var OriginalURL = scope.URL;
                if (OriginalURL) {
                    jURL.createObjectURL = function(blob) {
                        return OriginalURL.createObjectURL.apply(OriginalURL, arguments);
                    };
                    jURL.revokeObjectURL = function(url) {
                        OriginalURL.revokeObjectURL(url);
                    };
                }
                scope.URL = jURL;
            })(globalScope);
            exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
            exports.IDENTITY_MATRIX = IDENTITY_MATRIX;
            exports.OPS = OPS;
            exports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
            exports.AnnotationBorderStyleType = AnnotationBorderStyleType;
            exports.AnnotationFlag = AnnotationFlag;
            exports.AnnotationType = AnnotationType;
            exports.FontType = FontType;
            exports.ImageKind = ImageKind;
            exports.InvalidPDFException = InvalidPDFException;
            exports.LinkTarget = LinkTarget;
            exports.LinkTargetStringMap = LinkTargetStringMap;
            exports.MessageHandler = MessageHandler;
            exports.MissingDataException = MissingDataException;
            exports.MissingPDFException = MissingPDFException;
            exports.NotImplementedException = NotImplementedException;
            exports.PasswordException = PasswordException;
            exports.PasswordResponses = PasswordResponses;
            exports.StatTimer = StatTimer;
            exports.StreamType = StreamType;
            exports.TextRenderingMode = TextRenderingMode;
            exports.UnexpectedResponseException = UnexpectedResponseException;
            exports.UnknownErrorException = UnknownErrorException;
            exports.Util = Util;
            exports.XRefParseException = XRefParseException;
            exports.assert = assert;
            exports.bytesToString = bytesToString;
            exports.combineUrl = combineUrl;
            exports.createPromiseCapability = createPromiseCapability;
            exports.deprecated = deprecated;
            exports.error = error;
            exports.info = info;
            exports.isArray = isArray;
            exports.isArrayBuffer = isArrayBuffer;
            exports.isBool = isBool;
            exports.isEmptyObj = isEmptyObj;
            exports.isExternalLinkTargetSet = isExternalLinkTargetSet;
            exports.isInt = isInt;
            exports.isNum = isNum;
            exports.isString = isString;
            exports.isValidUrl = isValidUrl;
            exports.addLinkAttributes = addLinkAttributes;
            exports.loadJpegStream = loadJpegStream;
            exports.log2 = log2;
            exports.readInt8 = readInt8;
            exports.readUint16 = readUint16;
            exports.readUint32 = readUint32;
            exports.removeNullCharacters = removeNullCharacters;
            exports.shadow = shadow;
            exports.string32 = string32;
            exports.stringToBytes = stringToBytes;
            exports.stringToPDFString = stringToPDFString;
            exports.stringToUTF8String = stringToUTF8String;
            exports.utf8StringToString = utf8StringToString;
            exports.warn = warn;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsCoreChunkedStream = {}), root.pdfjsSharedUtil);
            }
        }(this, function(exports, sharedUtil) {
            var MissingDataException = sharedUtil.MissingDataException;
            var assert = sharedUtil.assert;
            var createPromiseCapability = sharedUtil.createPromiseCapability;
            var isInt = sharedUtil.isInt;
            var isEmptyObj = sharedUtil.isEmptyObj;
            var ChunkedStream = (function ChunkedStreamClosure() {
                function ChunkedStream(length, chunkSize, manager) {
                    this.bytes = new Uint8Array(length);
                    this.start = 0;
                    this.pos = 0;
                    this.end = length;
                    this.chunkSize = chunkSize;
                    this.loadedChunks = [];
                    this.numChunksLoaded = 0;
                    this.numChunks = Math.ceil(length / chunkSize);
                    this.manager = manager;
                    this.progressiveDataLength = 0;
                    this.lastSuccessfulEnsureByteChunk = -1;
                }
                ChunkedStream.prototype = {
                    getMissingChunks: function ChunkedStream_getMissingChunks() {
                        var chunks = [];
                        for (var chunk = 0, n = this.numChunks; chunk < n; ++chunk) {
                            if (!this.loadedChunks[chunk]) {
                                chunks.push(chunk);
                            }
                        }
                        return chunks;
                    },
                    getBaseStreams: function ChunkedStream_getBaseStreams() {
                        return [this];
                    },
                    allChunksLoaded: function ChunkedStream_allChunksLoaded() {
                        return this.numChunksLoaded === this.numChunks;
                    },
                    onReceiveData: function ChunkedStream_onReceiveData(begin, chunk) {
                        var end = begin + chunk.byteLength;
                        assert(begin % this.chunkSize === 0, 'Bad begin offset: ' + begin);
                        var length = this.bytes.length;
                        assert(end % this.chunkSize === 0 || end === length, 'Bad end offset: ' + end);
                        this.bytes.set(new Uint8Array(chunk), begin);
                        var chunkSize = this.chunkSize;
                        var beginChunk = Math.floor(begin / chunkSize);
                        var endChunk = Math.floor((end - 1) / chunkSize) + 1;
                        var curChunk;
                        for (curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
                            if (!this.loadedChunks[curChunk]) {
                                this.loadedChunks[curChunk] = true;
                                ++this.numChunksLoaded;
                            }
                        }
                    },
                    onReceiveProgressiveData: function ChunkedStream_onReceiveProgressiveData(data) {
                        var position = this.progressiveDataLength;
                        var beginChunk = Math.floor(position / this.chunkSize);
                        this.bytes.set(new Uint8Array(data), position);
                        position += data.byteLength;
                        this.progressiveDataLength = position;
                        var endChunk = position >= this.end ? this.numChunks : Math.floor(position / this.chunkSize);
                        var curChunk;
                        for (curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
                            if (!this.loadedChunks[curChunk]) {
                                this.loadedChunks[curChunk] = true;
                                ++this.numChunksLoaded;
                            }
                        }
                    },
                    ensureByte: function ChunkedStream_ensureByte(pos) {
                        var chunk = Math.floor(pos / this.chunkSize);
                        if (chunk === this.lastSuccessfulEnsureByteChunk) {
                            return;
                        }
                        if (!this.loadedChunks[chunk]) {
                            throw new MissingDataException(pos, pos + 1);
                        }
                        this.lastSuccessfulEnsureByteChunk = chunk;
                    },
                    ensureRange: function ChunkedStream_ensureRange(begin, end) {
                        if (begin >= end) {
                            return;
                        }
                        if (end <= this.progressiveDataLength) {
                            return;
                        }
                        var chunkSize = this.chunkSize;
                        var beginChunk = Math.floor(begin / chunkSize);
                        var endChunk = Math.floor((end - 1) / chunkSize) + 1;
                        for (var chunk = beginChunk; chunk < endChunk; ++chunk) {
                            if (!this.loadedChunks[chunk]) {
                                throw new MissingDataException(begin, end);
                            }
                        }
                    },
                    nextEmptyChunk: function ChunkedStream_nextEmptyChunk(beginChunk) {
                        var chunk, numChunks = this.numChunks;
                        for (var i = 0; i < numChunks; ++i) {
                            chunk = (beginChunk + i) % numChunks;
                            if (!this.loadedChunks[chunk]) {
                                return chunk;
                            }
                        }
                        return null;
                    },
                    hasChunk: function ChunkedStream_hasChunk(chunk) {
                        return !!this.loadedChunks[chunk];
                    },
                    get length() {
                        return this.end - this.start;
                    },
                    get isEmpty() {
                        return this.length === 0;
                    },
                    getByte: function ChunkedStream_getByte() {
                        var pos = this.pos;
                        if (pos >= this.end) {
                            return -1;
                        }
                        this.ensureByte(pos);
                        return this.bytes[this.pos++];
                    },
                    getUint16: function ChunkedStream_getUint16() {
                        var b0 = this.getByte();
                        var b1 = this.getByte();
                        if (b0 === -1 || b1 === -1) {
                            return -1;
                        }
                        return (b0 << 8) + b1;
                    },
                    getInt32: function ChunkedStream_getInt32() {
                        var b0 = this.getByte();
                        var b1 = this.getByte();
                        var b2 = this.getByte();
                        var b3 = this.getByte();
                        return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
                    },
                    getBytes: function ChunkedStream_getBytes(length) {
                        var bytes = this.bytes;
                        var pos = this.pos;
                        var strEnd = this.end;
                        if (!length) {
                            this.ensureRange(pos, strEnd);
                            return bytes.subarray(pos, strEnd);
                        }
                        var end = pos + length;
                        if (end > strEnd) {
                            end = strEnd;
                        }
                        this.ensureRange(pos, end);
                        this.pos = end;
                        return bytes.subarray(pos, end);
                    },
                    peekByte: function ChunkedStream_peekByte() {
                        var peekedByte = this.getByte();
                        this.pos--;
                        return peekedByte;
                    },
                    peekBytes: function ChunkedStream_peekBytes(length) {
                        var bytes = this.getBytes(length);
                        this.pos -= bytes.length;
                        return bytes;
                    },
                    getByteRange: function ChunkedStream_getBytes(begin, end) {
                        this.ensureRange(begin, end);
                        return this.bytes.subarray(begin, end);
                    },
                    skip: function ChunkedStream_skip(n) {
                        if (!n) {
                            n = 1;
                        }
                        this.pos += n;
                    },
                    reset: function ChunkedStream_reset() {
                        this.pos = this.start;
                    },
                    moveStart: function ChunkedStream_moveStart() {
                        this.start = this.pos;
                    },
                    makeSubStream: function ChunkedStream_makeSubStream(start, length, dict) {
                        this.ensureRange(start, start + length);

                        function ChunkedStreamSubstream() {}
                        ChunkedStreamSubstream.prototype = Object.create(this);
                        ChunkedStreamSubstream.prototype.getMissingChunks = function() {
                            var chunkSize = this.chunkSize;
                            var beginChunk = Math.floor(this.start / chunkSize);
                            var endChunk = Math.floor((this.end - 1) / chunkSize) + 1;
                            var missingChunks = [];
                            for (var chunk = beginChunk; chunk < endChunk; ++chunk) {
                                if (!this.loadedChunks[chunk]) {
                                    missingChunks.push(chunk);
                                }
                            }
                            return missingChunks;
                        };
                        var subStream = new ChunkedStreamSubstream();
                        subStream.pos = subStream.start = start;
                        subStream.end = start + length || this.end;
                        subStream.dict = dict;
                        return subStream;
                    },
                    isStream: true
                };
                return ChunkedStream;
            })();
            var ChunkedStreamManager = (function ChunkedStreamManagerClosure() {
                function ChunkedStreamManager(length, chunkSize, url, args) {
                    this.stream = new ChunkedStream(length, chunkSize, this);
                    this.length = length;
                    this.chunkSize = chunkSize;
                    this.url = url;
                    this.disableAutoFetch = args.disableAutoFetch;
                    var msgHandler = this.msgHandler = args.msgHandler;
                    if (args.chunkedViewerLoading) {
                        msgHandler.on('OnDataRange', this.onReceiveData.bind(this));
                        msgHandler.on('OnDataProgress', this.onProgress.bind(this));
                        this.sendRequest = function ChunkedStreamManager_sendRequest(begin, end) {
                            msgHandler.send('RequestDataRange', {
                                begin: begin,
                                end: end
                            });
                        };
                    } else {
                        var getXhr = function getXhr() {
                            return new XMLHttpRequest();
                        };
                        this.networkManager = new NetworkManager(this.url, {
                            getXhr: getXhr,
                            httpHeaders: args.httpHeaders,
                            withCredentials: args.withCredentials
                        });
                        this.sendRequest = function ChunkedStreamManager_sendRequest(begin, end) {
                            this.networkManager.requestRange(begin, end, {
                                onDone: this.onReceiveData.bind(this),
                                onProgress: this.onProgress.bind(this)
                            });
                        };
                    }
                    this.currRequestId = 0;
                    this.chunksNeededByRequest = {};
                    this.requestsByChunk = {};
                    this.promisesByRequest = {};
                    this.progressiveDataLength = 0;
                    this._loadedStreamCapability = createPromiseCapability();
                    if (args.initialData) {
                        this.onReceiveData({
                            chunk: args.initialData
                        });
                    }
                }
                ChunkedStreamManager.prototype = {
                    onLoadedStream: function ChunkedStreamManager_getLoadedStream() {
                        return this._loadedStreamCapability.promise;
                    },
                    requestAllChunks: function ChunkedStreamManager_requestAllChunks() {
                        var missingChunks = this.stream.getMissingChunks();
                        this._requestChunks(missingChunks);
                        return this._loadedStreamCapability.promise;
                    },
                    _requestChunks: function ChunkedStreamManager_requestChunks(chunks) {
                        var requestId = this.currRequestId++;
                        var chunksNeeded;
                        var i, ii;
                        this.chunksNeededByRequest[requestId] = chunksNeeded = {};
                        for (i = 0, ii = chunks.length; i < ii; i++) {
                            if (!this.stream.hasChunk(chunks[i])) {
                                chunksNeeded[chunks[i]] = true;
                            }
                        }
                        if (isEmptyObj(chunksNeeded)) {
                            return Promise.resolve();
                        }
                        var capability = createPromiseCapability();
                        this.promisesByRequest[requestId] = capability;
                        var chunksToRequest = [];
                        for (var chunk in chunksNeeded) {
                            chunk = chunk | 0;
                            if (!(chunk in this.requestsByChunk)) {
                                this.requestsByChunk[chunk] = [];
                                chunksToRequest.push(chunk);
                            }
                            this.requestsByChunk[chunk].push(requestId);
                        }
                        if (!chunksToRequest.length) {
                            return capability.promise;
                        }
                        var groupedChunksToRequest = this.groupChunks(chunksToRequest);
                        for (i = 0; i < groupedChunksToRequest.length; ++i) {
                            var groupedChunk = groupedChunksToRequest[i];
                            var begin = groupedChunk.beginChunk * this.chunkSize;
                            var end = Math.min(groupedChunk.endChunk * this.chunkSize, this.length);
                            this.sendRequest(begin, end);
                        }
                        return capability.promise;
                    },
                    getStream: function ChunkedStreamManager_getStream() {
                        return this.stream;
                    },
                    requestRange: function ChunkedStreamManager_requestRange(begin, end) {
                        end = Math.min(end, this.length);
                        var beginChunk = this.getBeginChunk(begin);
                        var endChunk = this.getEndChunk(end);
                        var chunks = [];
                        for (var chunk = beginChunk; chunk < endChunk; ++chunk) {
                            chunks.push(chunk);
                        }
                        return this._requestChunks(chunks);
                    },
                    requestRanges: function ChunkedStreamManager_requestRanges(ranges) {
                        ranges = ranges || [];
                        var chunksToRequest = [];
                        for (var i = 0; i < ranges.length; i++) {
                            var beginChunk = this.getBeginChunk(ranges[i].begin);
                            var endChunk = this.getEndChunk(ranges[i].end);
                            for (var chunk = beginChunk; chunk < endChunk; ++chunk) {
                                if (chunksToRequest.indexOf(chunk) < 0) {
                                    chunksToRequest.push(chunk);
                                }
                            }
                        }
                        chunksToRequest.sort(function(a, b) {
                            return a - b;
                        });
                        return this._requestChunks(chunksToRequest);
                    },
                    groupChunks: function ChunkedStreamManager_groupChunks(chunks) {
                        var groupedChunks = [];
                        var beginChunk = -1;
                        var prevChunk = -1;
                        for (var i = 0; i < chunks.length; ++i) {
                            var chunk = chunks[i];
                            if (beginChunk < 0) {
                                beginChunk = chunk;
                            }
                            if (prevChunk >= 0 && prevChunk + 1 !== chunk) {
                                groupedChunks.push({
                                    beginChunk: beginChunk,
                                    endChunk: prevChunk + 1
                                });
                                beginChunk = chunk;
                            }
                            if (i + 1 === chunks.length) {
                                groupedChunks.push({
                                    beginChunk: beginChunk,
                                    endChunk: chunk + 1
                                });
                            }
                            prevChunk = chunk;
                        }
                        return groupedChunks;
                    },
                    onProgress: function ChunkedStreamManager_onProgress(args) {
                        var bytesLoaded = (this.stream.numChunksLoaded * this.chunkSize +
                            args.loaded);
                        this.msgHandler.send('DocProgress', {
                            loaded: bytesLoaded,
                            total: this.length
                        });
                    },
                    onReceiveData: function ChunkedStreamManager_onReceiveData(args) {
                        var chunk = args.chunk;
                        var isProgressive = args.begin === undefined;
                        var begin = isProgressive ? this.progressiveDataLength : args.begin;
                        var end = begin + chunk.byteLength;
                        var beginChunk = Math.floor(begin / this.chunkSize);
                        var endChunk = end < this.length ? Math.floor(end / this.chunkSize) : Math.ceil(end / this.chunkSize);
                        if (isProgressive) {
                            this.stream.onReceiveProgressiveData(chunk);
                            this.progressiveDataLength = end;
                        } else {
                            this.stream.onReceiveData(begin, chunk);
                        }
                        if (this.stream.allChunksLoaded()) {
                            this._loadedStreamCapability.resolve(this.stream);
                        }
                        var loadedRequests = [];
                        var i, requestId;
                        for (chunk = beginChunk; chunk < endChunk; ++chunk) {
                            var requestIds = this.requestsByChunk[chunk] || [];
                            delete this.requestsByChunk[chunk];
                            for (i = 0; i < requestIds.length; ++i) {
                                requestId = requestIds[i];
                                var chunksNeeded = this.chunksNeededByRequest[requestId];
                                if (chunk in chunksNeeded) {
                                    delete chunksNeeded[chunk];
                                }
                                if (!isEmptyObj(chunksNeeded)) {
                                    continue;
                                }
                                loadedRequests.push(requestId);
                            }
                        }
                        if (!this.disableAutoFetch && isEmptyObj(this.requestsByChunk)) {
                            var nextEmptyChunk;
                            if (this.stream.numChunksLoaded === 1) {
                                var lastChunk = this.stream.numChunks - 1;
                                if (!this.stream.hasChunk(lastChunk)) {
                                    nextEmptyChunk = lastChunk;
                                }
                            } else {
                                nextEmptyChunk = this.stream.nextEmptyChunk(endChunk);
                            }
                            if (isInt(nextEmptyChunk)) {
                                this._requestChunks([nextEmptyChunk]);
                            }
                        }
                        for (i = 0; i < loadedRequests.length; ++i) {
                            requestId = loadedRequests[i];
                            var capability = this.promisesByRequest[requestId];
                            delete this.promisesByRequest[requestId];
                            capability.resolve();
                        }
                        this.msgHandler.send('DocProgress', {
                            loaded: this.stream.numChunksLoaded * this.chunkSize,
                            total: this.length
                        });
                    },
                    onError: function ChunkedStreamManager_onError(err) {
                        this._loadedStreamCapability.reject(err);
                    },
                    getBeginChunk: function ChunkedStreamManager_getBeginChunk(begin) {
                        var chunk = Math.floor(begin / this.chunkSize);
                        return chunk;
                    },
                    getEndChunk: function ChunkedStreamManager_getEndChunk(end) {
                        var chunk = Math.floor((end - 1) / this.chunkSize) + 1;
                        return chunk;
                    },
                    abort: function ChunkedStreamManager_abort() {
                        if (this.networkManager) {
                            this.networkManager.abortAllRequests();
                        }
                        for (var requestId in this.promisesByRequest) {
                            var capability = this.promisesByRequest[requestId];
                            capability.reject(new Error('Request was aborted'));
                        }
                    }
                };
                return ChunkedStreamManager;
            })();
            exports.ChunkedStream = ChunkedStream;
            exports.ChunkedStreamManager = ChunkedStreamManager;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsCoreJbig2 = {}), root.pdfjsSharedUtil, root.pdfjsCoreArithmeticDecoder);
            }
        }(this, function(exports, sharedUtil, coreArithmeticDecoder) {
            var error = sharedUtil.error;
            var log2 = sharedUtil.log2;
            var readInt8 = sharedUtil.readInt8;
            var readUint16 = sharedUtil.readUint16;
            var readUint32 = sharedUtil.readUint32;
            var shadow = sharedUtil.shadow;
            var ArithmeticDecoder = coreArithmeticDecoder.ArithmeticDecoder;
            var Jbig2Image = (function Jbig2ImageClosure() {
                function ContextCache() {}
                ContextCache.prototype = {
                    getContexts: function(id) {
                        if (id in this) {
                            return this[id];
                        }
                        return (this[id] = new Int8Array(1 << 16));
                    }
                };

                function DecodingContext(data, start, end) {
                    this.data = data;
                    this.start = start;
                    this.end = end;
                }
                DecodingContext.prototype = {
                    get decoder() {
                        var decoder = new ArithmeticDecoder(this.data, this.start, this.end);
                        return shadow(this, 'decoder', decoder);
                    },
                    get contextCache() {
                        var cache = new ContextCache();
                        return shadow(this, 'contextCache', cache);
                    }
                };

                function decodeInteger(contextCache, procedure, decoder) {
                    var contexts = contextCache.getContexts(procedure);
                    var prev = 1;

                    function readBits(length) {
                        var v = 0;
                        for (var i = 0; i < length; i++) {
                            var bit = decoder.readBit(contexts, prev);
                            prev = (prev < 256 ? (prev << 1) | bit : (((prev << 1) | bit) & 511) | 256);
                            v = (v << 1) | bit;
                        }
                        return v >>> 0;
                    }
                    var sign = readBits(1);
                    var value = readBits(1) ? (readBits(1) ? (readBits(1) ? (readBits(1) ? (readBits(1) ? (readBits(32) + 4436) : readBits(12) + 340) : readBits(8) + 84) : readBits(6) + 20) : readBits(4) + 4) : readBits(2);
                    return (sign === 0 ? value : (value > 0 ? -value : null));
                }

                function decodeIAID(contextCache, decoder, codeLength) {
                    var contexts = contextCache.getContexts('IAID');
                    var prev = 1;
                    for (var i = 0; i < codeLength; i++) {
                        var bit = decoder.readBit(contexts, prev);
                        prev = (prev << 1) | bit;
                    }
                    if (codeLength < 31) {
                        return prev & ((1 << codeLength) - 1);
                    }
                    return prev & 0x7FFFFFFF;
                }
                var SegmentTypes = ['SymbolDictionary', null, null, null, 'IntermediateTextRegion', null, 'ImmediateTextRegion', 'ImmediateLosslessTextRegion', null, null, null, null, null, null, null, null, 'patternDictionary', null, null, null, 'IntermediateHalftoneRegion', null, 'ImmediateHalftoneRegion', 'ImmediateLosslessHalftoneRegion', null, null, null, null, null, null, null, null, null, null, null, null, 'IntermediateGenericRegion', null, 'ImmediateGenericRegion', 'ImmediateLosslessGenericRegion', 'IntermediateGenericRefinementRegion', null, 'ImmediateGenericRefinementRegion', 'ImmediateLosslessGenericRefinementRegion', null, null, null, null, 'PageInformation', 'EndOfPage', 'EndOfStripe', 'EndOfFile', 'Profiles', 'Tables', null, null, null, null, null, null, null, null, 'Extension'];
                var CodingTemplates = [
                    [{
                        x: -1,
                        y: -2
                    }, {
                        x: 0,
                        y: -2
                    }, {
                        x: 1,
                        y: -2
                    }, {
                        x: -2,
                        y: -1
                    }, {
                        x: -1,
                        y: -1
                    }, {
                        x: 0,
                        y: -1
                    }, {
                        x: 1,
                        y: -1
                    }, {
                        x: 2,
                        y: -1
                    }, {
                        x: -4,
                        y: 0
                    }, {
                        x: -3,
                        y: 0
                    }, {
                        x: -2,
                        y: 0
                    }, {
                        x: -1,
                        y: 0
                    }],
                    [{
                        x: -1,
                        y: -2
                    }, {
                        x: 0,
                        y: -2
                    }, {
                        x: 1,
                        y: -2
                    }, {
                        x: 2,
                        y: -2
                    }, {
                        x: -2,
                        y: -1
                    }, {
                        x: -1,
                        y: -1
                    }, {
                        x: 0,
                        y: -1
                    }, {
                        x: 1,
                        y: -1
                    }, {
                        x: 2,
                        y: -1
                    }, {
                        x: -3,
                        y: 0
                    }, {
                        x: -2,
                        y: 0
                    }, {
                        x: -1,
                        y: 0
                    }],
                    [{
                        x: -1,
                        y: -2
                    }, {
                        x: 0,
                        y: -2
                    }, {
                        x: 1,
                        y: -2
                    }, {
                        x: -2,
                        y: -1
                    }, {
                        x: -1,
                        y: -1
                    }, {
                        x: 0,
                        y: -1
                    }, {
                        x: 1,
                        y: -1
                    }, {
                        x: -2,
                        y: 0
                    }, {
                        x: -1,
                        y: 0
                    }],
                    [{
                        x: -3,
                        y: -1
                    }, {
                        x: -2,
                        y: -1
                    }, {
                        x: -1,
                        y: -1
                    }, {
                        x: 0,
                        y: -1
                    }, {
                        x: 1,
                        y: -1
                    }, {
                        x: -4,
                        y: 0
                    }, {
                        x: -3,
                        y: 0
                    }, {
                        x: -2,
                        y: 0
                    }, {
                        x: -1,
                        y: 0
                    }]
                ];
                var RefinementTemplates = [{
                    coding: [{
                        x: 0,
                        y: -1
                    }, {
                        x: 1,
                        y: -1
                    }, {
                        x: -1,
                        y: 0
                    }],
                    reference: [{
                        x: 0,
                        y: -1
                    }, {
                        x: 1,
                        y: -1
                    }, {
                        x: -1,
                        y: 0
                    }, {
                        x: 0,
                        y: 0
                    }, {
                        x: 1,
                        y: 0
                    }, {
                        x: -1,
                        y: 1
                    }, {
                        x: 0,
                        y: 1
                    }, {
                        x: 1,
                        y: 1
                    }]
                }, {
                    coding: [{
                        x: -1,
                        y: -1
                    }, {
                        x: 0,
                        y: -1
                    }, {
                        x: 1,
                        y: -1
                    }, {
                        x: -1,
                        y: 0
                    }],
                    reference: [{
                        x: 0,
                        y: -1
                    }, {
                        x: -1,
                        y: 0
                    }, {
                        x: 0,
                        y: 0
                    }, {
                        x: 1,
                        y: 0
                    }, {
                        x: 0,
                        y: 1
                    }, {
                        x: 1,
                        y: 1
                    }]
                }];
                var ReusedContexts = [0x9B25, 0x0795, 0x00E5, 0x0195];
                var RefinementReusedContexts = [0x0020, 0x0008];

                function decodeBitmapTemplate0(width, height, decodingContext) {
                    var decoder = decodingContext.decoder;
                    var contexts = decodingContext.contextCache.getContexts('GB');
                    var contextLabel, i, j, pixel, row, row1, row2, bitmap = [];
                    var OLD_PIXEL_MASK = 0x7BF7;
                    for (i = 0; i < height; i++) {
                        row = bitmap[i] = new Uint8Array(width);
                        row1 = (i < 1) ? row : bitmap[i - 1];
                        row2 = (i < 2) ? row : bitmap[i - 2];
                        contextLabel = (row2[0] << 13) | (row2[1] << 12) | (row2[2] << 11) | (row1[0] << 7) | (row1[1] << 6) | (row1[2] << 5) | (row1[3] << 4);
                        for (j = 0; j < width; j++) {
                            row[j] = pixel = decoder.readBit(contexts, contextLabel);
                            contextLabel = ((contextLabel & OLD_PIXEL_MASK) << 1) | (j + 3 < width ? row2[j + 3] << 11 : 0) | (j + 4 < width ? row1[j + 4] << 4 : 0) | pixel;
                        }
                    }
                    return bitmap;
                }

                function decodeBitmap(mmr, width, height, templateIndex, prediction, skip, at, decodingContext) {
                    if (mmr) {
                        error('JBIG2 error: MMR encoding is not supported');
                    }
                    if (templateIndex === 0 && !skip && !prediction && at.length === 4 && at[0].x === 3 && at[0].y === -1 && at[1].x === -3 && at[1].y === -1 && at[2].x === 2 && at[2].y === -2 && at[3].x === -2 && at[3].y === -2) {
                        return decodeBitmapTemplate0(width, height, decodingContext);
                    }
                    var useskip = !!skip;
                    var template = CodingTemplates[templateIndex].concat(at);
                    template.sort(function(a, b) {
                        return (a.y - b.y) || (a.x - b.x);
                    });
                    var templateLength = template.length;
                    var templateX = new Int8Array(templateLength);
                    var templateY = new Int8Array(templateLength);
                    var changingTemplateEntries = [];
                    var reuseMask = 0,
                        minX = 0,
                        maxX = 0,
                        minY = 0;
                    var c, k;
                    for (k = 0; k < templateLength; k++) {
                        templateX[k] = template[k].x;
                        templateY[k] = template[k].y;
                        minX = Math.min(minX, template[k].x);
                        maxX = Math.max(maxX, template[k].x);
                        minY = Math.min(minY, template[k].y);
                        if (k < templateLength - 1 && template[k].y === template[k + 1].y && template[k].x === template[k + 1].x - 1) {
                            reuseMask |= 1 << (templateLength - 1 - k);
                        } else {
                            changingTemplateEntries.push(k);
                        }
                    }
                    var changingEntriesLength = changingTemplateEntries.length;
                    var changingTemplateX = new Int8Array(changingEntriesLength);
                    var changingTemplateY = new Int8Array(changingEntriesLength);
                    var changingTemplateBit = new Uint16Array(changingEntriesLength);
                    for (c = 0; c < changingEntriesLength; c++) {
                        k = changingTemplateEntries[c];
                        changingTemplateX[c] = template[k].x;
                        changingTemplateY[c] = template[k].y;
                        changingTemplateBit[c] = 1 << (templateLength - 1 - k);
                    }
                    var sbb_left = -minX;
                    var sbb_top = -minY;
                    var sbb_right = width - maxX;
                    var pseudoPixelContext = ReusedContexts[templateIndex];
                    var row = new Uint8Array(width);
                    var bitmap = [];
                    var decoder = decodingContext.decoder;
                    var contexts = decodingContext.contextCache.getContexts('GB');
                    var ltp = 0,
                        j, i0, j0, contextLabel = 0,
                        bit, shift;
                    for (var i = 0; i < height; i++) {
                        if (prediction) {
                            var sltp = decoder.readBit(contexts, pseudoPixelContext);
                            ltp ^= sltp;
                            if (ltp) {
                                bitmap.push(row);
                                continue;
                            }
                        }
                        row = new Uint8Array(row);
                        bitmap.push(row);
                        for (j = 0; j < width; j++) {
                            if (useskip && skip[i][j]) {
                                row[j] = 0;
                                continue;
                            }
                            if (j >= sbb_left && j < sbb_right && i >= sbb_top) {
                                contextLabel = (contextLabel << 1) & reuseMask;
                                for (k = 0; k < changingEntriesLength; k++) {
                                    i0 = i + changingTemplateY[k];
                                    j0 = j + changingTemplateX[k];
                                    bit = bitmap[i0][j0];
                                    if (bit) {
                                        bit = changingTemplateBit[k];
                                        contextLabel |= bit;
                                    }
                                }
                            } else {
                                contextLabel = 0;
                                shift = templateLength - 1;
                                for (k = 0; k < templateLength; k++, shift--) {
                                    j0 = j + templateX[k];
                                    if (j0 >= 0 && j0 < width) {
                                        i0 = i + templateY[k];
                                        if (i0 >= 0) {
                                            bit = bitmap[i0][j0];
                                            if (bit) {
                                                contextLabel |= bit << shift;
                                            }
                                        }
                                    }
                                }
                            }
                            var pixel = decoder.readBit(contexts, contextLabel);
                            row[j] = pixel;
                        }
                    }
                    return bitmap;
                }

                function decodeRefinement(width, height, templateIndex, referenceBitmap, offsetX, offsetY, prediction, at, decodingContext) {
                    var codingTemplate = RefinementTemplates[templateIndex].coding;
                    if (templateIndex === 0) {
                        codingTemplate = codingTemplate.concat([at[0]]);
                    }
                    var codingTemplateLength = codingTemplate.length;
                    var codingTemplateX = new Int32Array(codingTemplateLength);
                    var codingTemplateY = new Int32Array(codingTemplateLength);
                    var k;
                    for (k = 0; k < codingTemplateLength; k++) {
                        codingTemplateX[k] = codingTemplate[k].x;
                        codingTemplateY[k] = codingTemplate[k].y;
                    }
                    var referenceTemplate = RefinementTemplates[templateIndex].reference;
                    if (templateIndex === 0) {
                        referenceTemplate = referenceTemplate.concat([at[1]]);
                    }
                    var referenceTemplateLength = referenceTemplate.length;
                    var referenceTemplateX = new Int32Array(referenceTemplateLength);
                    var referenceTemplateY = new Int32Array(referenceTemplateLength);
                    for (k = 0; k < referenceTemplateLength; k++) {
                        referenceTemplateX[k] = referenceTemplate[k].x;
                        referenceTemplateY[k] = referenceTemplate[k].y;
                    }
                    var referenceWidth = referenceBitmap[0].length;
                    var referenceHeight = referenceBitmap.length;
                    var pseudoPixelContext = RefinementReusedContexts[templateIndex];
                    var bitmap = [];
                    var decoder = decodingContext.decoder;
                    var contexts = decodingContext.contextCache.getContexts('GR');
                    var ltp = 0;
                    for (var i = 0; i < height; i++) {
                        if (prediction) {
                            var sltp = decoder.readBit(contexts, pseudoPixelContext);
                            ltp ^= sltp;
                            if (ltp) {
                                error('JBIG2 error: prediction is not supported');
                            }
                        }
                        var row = new Uint8Array(width);
                        bitmap.push(row);
                        for (var j = 0; j < width; j++) {
                            var i0, j0;
                            var contextLabel = 0;
                            for (k = 0; k < codingTemplateLength; k++) {
                                i0 = i + codingTemplateY[k];
                                j0 = j + codingTemplateX[k];
                                if (i0 < 0 || j0 < 0 || j0 >= width) {
                                    contextLabel <<= 1;
                                } else {
                                    contextLabel = (contextLabel << 1) | bitmap[i0][j0];
                                }
                            }
                            for (k = 0; k < referenceTemplateLength; k++) {
                                i0 = i + referenceTemplateY[k] + offsetY;
                                j0 = j + referenceTemplateX[k] + offsetX;
                                if (i0 < 0 || i0 >= referenceHeight || j0 < 0 || j0 >= referenceWidth) {
                                    contextLabel <<= 1;
                                } else {
                                    contextLabel = (contextLabel << 1) | referenceBitmap[i0][j0];
                                }
                            }
                            var pixel = decoder.readBit(contexts, contextLabel);
                            row[j] = pixel;
                        }
                    }
                    return bitmap;
                }

                function decodeSymbolDictionary(huffman, refinement, symbols, numberOfNewSymbols, numberOfExportedSymbols, huffmanTables, templateIndex, at, refinementTemplateIndex, refinementAt, decodingContext) {
                    if (huffman) {
                        error('JBIG2 error: huffman is not supported');
                    }
                    var newSymbols = [];
                    var currentHeight = 0;
                    var symbolCodeLength = log2(symbols.length + numberOfNewSymbols);
                    var decoder = decodingContext.decoder;
                    var contextCache = decodingContext.contextCache;
                    while (newSymbols.length < numberOfNewSymbols) {
                        var deltaHeight = decodeInteger(contextCache, 'IADH', decoder);
                        currentHeight += deltaHeight;
                        var currentWidth = 0;
                        var totalWidth = 0;
                        while (true) {
                            var deltaWidth = decodeInteger(contextCache, 'IADW', decoder);
                            if (deltaWidth === null) {
                                break;
                            }
                            currentWidth += deltaWidth;
                            totalWidth += currentWidth;
                            var bitmap;
                            if (refinement) {
                                var numberOfInstances = decodeInteger(contextCache, 'IAAI', decoder);
                                if (numberOfInstances > 1) {
                                    bitmap = decodeTextRegion(huffman, refinement, currentWidth, currentHeight, 0, numberOfInstances, 1, symbols.concat(newSymbols), symbolCodeLength, 0, 0, 1, 0, huffmanTables, refinementTemplateIndex, refinementAt, decodingContext);
                                } else {
                                    var symbolId = decodeIAID(contextCache, decoder, symbolCodeLength);
                                    var rdx = decodeInteger(contextCache, 'IARDX', decoder);
                                    var rdy = decodeInteger(contextCache, 'IARDY', decoder);
                                    var symbol = (symbolId < symbols.length ? symbols[symbolId] : newSymbols[symbolId - symbols.length]);
                                    bitmap = decodeRefinement(currentWidth, currentHeight, refinementTemplateIndex, symbol, rdx, rdy, false, refinementAt, decodingContext);
                                }
                            } else {
                                bitmap = decodeBitmap(false, currentWidth, currentHeight, templateIndex, false, null, at, decodingContext);
                            }
                            newSymbols.push(bitmap);
                        }
                    }
                    var exportedSymbols = [];
                    var flags = [],
                        currentFlag = false;
                    var totalSymbolsLength = symbols.length + numberOfNewSymbols;
                    while (flags.length < totalSymbolsLength) {
                        var runLength = decodeInteger(contextCache, 'IAEX', decoder);
                        while (runLength--) {
                            flags.push(currentFlag);
                        }
                        currentFlag = !currentFlag;
                    }
                    for (var i = 0, ii = symbols.length; i < ii; i++) {
                        if (flags[i]) {
                            exportedSymbols.push(symbols[i]);
                        }
                    }
                    for (var j = 0; j < numberOfNewSymbols; i++, j++) {
                        if (flags[i]) {
                            exportedSymbols.push(newSymbols[j]);
                        }
                    }
                    return exportedSymbols;
                }

                function decodeTextRegion(huffman, refinement, width, height, defaultPixelValue, numberOfSymbolInstances, stripSize, inputSymbols, symbolCodeLength, transposed, dsOffset, referenceCorner, combinationOperator, huffmanTables, refinementTemplateIndex, refinementAt, decodingContext) {
                    if (huffman) {
                        error('JBIG2 error: huffman is not supported');
                    }
                    var bitmap = [];
                    var i, row;
                    for (i = 0; i < height; i++) {
                        row = new Uint8Array(width);
                        if (defaultPixelValue) {
                            for (var j = 0; j < width; j++) {
                                row[j] = defaultPixelValue;
                            }
                        }
                        bitmap.push(row);
                    }
                    var decoder = decodingContext.decoder;
                    var contextCache = decodingContext.contextCache;
                    var stripT = -decodeInteger(contextCache, 'IADT', decoder);
                    var firstS = 0;
                    i = 0;
                    while (i < numberOfSymbolInstances) {
                        var deltaT = decodeInteger(contextCache, 'IADT', decoder);
                        stripT += deltaT;
                        var deltaFirstS = decodeInteger(contextCache, 'IAFS', decoder);
                        firstS += deltaFirstS;
                        var currentS = firstS;
                        do {
                            var currentT = (stripSize === 1 ? 0 : decodeInteger(contextCache, 'IAIT', decoder));
                            var t = stripSize * stripT + currentT;
                            var symbolId = decodeIAID(contextCache, decoder, symbolCodeLength);
                            var applyRefinement = (refinement && decodeInteger(contextCache, 'IARI', decoder));
                            var symbolBitmap = inputSymbols[symbolId];
                            var symbolWidth = symbolBitmap[0].length;
                            var symbolHeight = symbolBitmap.length;
                            if (applyRefinement) {
                                var rdw = decodeInteger(contextCache, 'IARDW', decoder);
                                var rdh = decodeInteger(contextCache, 'IARDH', decoder);
                                var rdx = decodeInteger(contextCache, 'IARDX', decoder);
                                var rdy = decodeInteger(contextCache, 'IARDY', decoder);
                                symbolWidth += rdw;
                                symbolHeight += rdh;
                                symbolBitmap = decodeRefinement(symbolWidth, symbolHeight, refinementTemplateIndex, symbolBitmap, (rdw >> 1) + rdx, (rdh >> 1) + rdy, false, refinementAt, decodingContext);
                            }
                            var offsetT = t - ((referenceCorner & 1) ? 0 : symbolHeight);
                            var offsetS = currentS - ((referenceCorner & 2) ? symbolWidth : 0);
                            var s2, t2, symbolRow;
                            if (transposed) {
                                for (s2 = 0; s2 < symbolHeight; s2++) {
                                    row = bitmap[offsetS + s2];
                                    if (!row) {
                                        continue;
                                    }
                                    symbolRow = symbolBitmap[s2];
                                    var maxWidth = Math.min(width - offsetT, symbolWidth);
                                    switch (combinationOperator) {
                                        case 0:
                                            for (t2 = 0; t2 < maxWidth; t2++) {
                                                row[offsetT + t2] |= symbolRow[t2];
                                            }
                                            break;
                                        case 2:
                                            for (t2 = 0; t2 < maxWidth; t2++) {
                                                row[offsetT + t2] ^= symbolRow[t2];
                                            }
                                            break;
                                        default:
                                            error('JBIG2 error: operator ' + combinationOperator + ' is not supported');
                                    }
                                }
                                currentS += symbolHeight - 1;
                            } else {
                                for (t2 = 0; t2 < symbolHeight; t2++) {
                                    row = bitmap[offsetT + t2];
                                    if (!row) {
                                        continue;
                                    }
                                    symbolRow = symbolBitmap[t2];
                                    switch (combinationOperator) {
                                        case 0:
                                            for (s2 = 0; s2 < symbolWidth; s2++) {
                                                row[offsetS + s2] |= symbolRow[s2];
                                            }
                                            break;
                                        case 2:
                                            for (s2 = 0; s2 < symbolWidth; s2++) {
                                                row[offsetS + s2] ^= symbolRow[s2];
                                            }
                                            break;
                                        default:
                                            error('JBIG2 error: operator ' + combinationOperator + ' is not supported');
                                    }
                                }
                                currentS += symbolWidth - 1;
                            }
                            i++;
                            var deltaS = decodeInteger(contextCache, 'IADS', decoder);
                            if (deltaS === null) {
                                break;
                            }
                            currentS += deltaS + dsOffset;
                        } while (true);
                    }
                    return bitmap;
                }

                function readSegmentHeader(data, start) {
                    var segmentHeader = {};
                    segmentHeader.number = readUint32(data, start);
                    var flags = data[start + 4];
                    var segmentType = flags & 0x3F;
                    if (!SegmentTypes[segmentType]) {
                        error('JBIG2 error: invalid segment type: ' + segmentType);
                    }
                    segmentHeader.type = segmentType;
                    segmentHeader.typeName = SegmentTypes[segmentType];
                    segmentHeader.deferredNonRetain = !!(flags & 0x80);
                    var pageAssociationFieldSize = !!(flags & 0x40);
                    var referredFlags = data[start + 5];
                    var referredToCount = (referredFlags >> 5) & 7;
                    var retainBits = [referredFlags & 31];
                    var position = start + 6;
                    if (referredFlags === 7) {
                        referredToCount = readUint32(data, position - 1) & 0x1FFFFFFF;
                        position += 3;
                        var bytes = (referredToCount + 7) >> 3;
                        retainBits[0] = data[position++];
                        while (--bytes > 0) {
                            retainBits.push(data[position++]);
                        }
                    } else if (referredFlags === 5 || referredFlags === 6) {
                        error('JBIG2 error: invalid referred-to flags');
                    }
                    segmentHeader.retainBits = retainBits;
                    var referredToSegmentNumberSize = (segmentHeader.number <= 256 ? 1 : (segmentHeader.number <= 65536 ? 2 : 4));
                    var referredTo = [];
                    var i, ii;
                    for (i = 0; i < referredToCount; i++) {
                        var number = (referredToSegmentNumberSize === 1 ? data[position] : (referredToSegmentNumberSize === 2 ? readUint16(data, position) : readUint32(data, position)));
                        referredTo.push(number);
                        position += referredToSegmentNumberSize;
                    }
                    segmentHeader.referredTo = referredTo;
                    if (!pageAssociationFieldSize) {
                        segmentHeader.pageAssociation = data[position++];
                    } else {
                        segmentHeader.pageAssociation = readUint32(data, position);
                        position += 4;
                    }
                    segmentHeader.length = readUint32(data, position);
                    position += 4;
                    if (segmentHeader.length === 0xFFFFFFFF) {
                        if (segmentType === 38) {
                            var genericRegionInfo = readRegionSegmentInformation(data, position);
                            var genericRegionSegmentFlags = data[position +
                                RegionSegmentInformationFieldLength];
                            var genericRegionMmr = !!(genericRegionSegmentFlags & 1);
                            var searchPatternLength = 6;
                            var searchPattern = new Uint8Array(searchPatternLength);
                            if (!genericRegionMmr) {
                                searchPattern[0] = 0xFF;
                                searchPattern[1] = 0xAC;
                            }
                            searchPattern[2] = (genericRegionInfo.height >>> 24) & 0xFF;
                            searchPattern[3] = (genericRegionInfo.height >> 16) & 0xFF;
                            searchPattern[4] = (genericRegionInfo.height >> 8) & 0xFF;
                            searchPattern[5] = genericRegionInfo.height & 0xFF;
                            for (i = position, ii = data.length; i < ii; i++) {
                                var j = 0;
                                while (j < searchPatternLength && searchPattern[j] === data[i + j]) {
                                    j++;
                                }
                                if (j === searchPatternLength) {
                                    segmentHeader.length = i + searchPatternLength;
                                    break;
                                }
                            }
                            if (segmentHeader.length === 0xFFFFFFFF) {
                                error('JBIG2 error: segment end was not found');
                            }
                        } else {
                            error('JBIG2 error: invalid unknown segment length');
                        }
                    }
                    segmentHeader.headerEnd = position;
                    return segmentHeader;
                }

                function readSegments(header, data, start, end) {
                    var segments = [];
                    var position = start;
                    while (position < end) {
                        var segmentHeader = readSegmentHeader(data, position);
                        position = segmentHeader.headerEnd;
                        var segment = {
                            header: segmentHeader,
                            data: data
                        };
                        if (!header.randomAccess) {
                            segment.start = position;
                            position += segmentHeader.length;
                            segment.end = position;
                        }
                        segments.push(segment);
                        if (segmentHeader.type === 51) {
                            break;
                        }
                    }
                    if (header.randomAccess) {
                        for (var i = 0, ii = segments.length; i < ii; i++) {
                            segments[i].start = position;
                            position += segments[i].header.length;
                            segments[i].end = position;
                        }
                    }
                    return segments;
                }

                function readRegionSegmentInformation(data, start) {
                    return {
                        width: readUint32(data, start),
                        height: readUint32(data, start + 4),
                        x: readUint32(data, start + 8),
                        y: readUint32(data, start + 12),
                        combinationOperator: data[start + 16] & 7
                    };
                }
                var RegionSegmentInformationFieldLength = 17;

                function processSegment(segment, visitor) {
                    var header = segment.header;
                    var data = segment.data,
                        position = segment.start,
                        end = segment.end;
                    var args, at, i, atLength;
                    switch (header.type) {
                        case 0:
                            var dictionary = {};
                            var dictionaryFlags = readUint16(data, position);
                            dictionary.huffman = !!(dictionaryFlags & 1);
                            dictionary.refinement = !!(dictionaryFlags & 2);
                            dictionary.huffmanDHSelector = (dictionaryFlags >> 2) & 3;
                            dictionary.huffmanDWSelector = (dictionaryFlags >> 4) & 3;
                            dictionary.bitmapSizeSelector = (dictionaryFlags >> 6) & 1;
                            dictionary.aggregationInstancesSelector = (dictionaryFlags >> 7) & 1;
                            dictionary.bitmapCodingContextUsed = !!(dictionaryFlags & 256);
                            dictionary.bitmapCodingContextRetained = !!(dictionaryFlags & 512);
                            dictionary.template = (dictionaryFlags >> 10) & 3;
                            dictionary.refinementTemplate = (dictionaryFlags >> 12) & 1;
                            position += 2;
                            if (!dictionary.huffman) {
                                atLength = dictionary.template === 0 ? 4 : 1;
                                at = [];
                                for (i = 0; i < atLength; i++) {
                                    at.push({
                                        x: readInt8(data, position),
                                        y: readInt8(data, position + 1)
                                    });
                                    position += 2;
                                }
                                dictionary.at = at;
                            }
                            if (dictionary.refinement && !dictionary.refinementTemplate) {
                                at = [];
                                for (i = 0; i < 2; i++) {
                                    at.push({
                                        x: readInt8(data, position),
                                        y: readInt8(data, position + 1)
                                    });
                                    position += 2;
                                }
                                dictionary.refinementAt = at;
                            }
                            dictionary.numberOfExportedSymbols = readUint32(data, position);
                            position += 4;
                            dictionary.numberOfNewSymbols = readUint32(data, position);
                            position += 4;
                            args = [dictionary, header.number, header.referredTo, data, position, end];
                            break;
                        case 6:
                        case 7:
                            var textRegion = {};
                            textRegion.info = readRegionSegmentInformation(data, position);
                            position += RegionSegmentInformationFieldLength;
                            var textRegionSegmentFlags = readUint16(data, position);
                            position += 2;
                            textRegion.huffman = !!(textRegionSegmentFlags & 1);
                            textRegion.refinement = !!(textRegionSegmentFlags & 2);
                            textRegion.stripSize = 1 << ((textRegionSegmentFlags >> 2) & 3);
                            textRegion.referenceCorner = (textRegionSegmentFlags >> 4) & 3;
                            textRegion.transposed = !!(textRegionSegmentFlags & 64);
                            textRegion.combinationOperator = (textRegionSegmentFlags >> 7) & 3;
                            textRegion.defaultPixelValue = (textRegionSegmentFlags >> 9) & 1;
                            textRegion.dsOffset = (textRegionSegmentFlags << 17) >> 27;
                            textRegion.refinementTemplate = (textRegionSegmentFlags >> 15) & 1;
                            if (textRegion.huffman) {
                                var textRegionHuffmanFlags = readUint16(data, position);
                                position += 2;
                                textRegion.huffmanFS = (textRegionHuffmanFlags) & 3;
                                textRegion.huffmanDS = (textRegionHuffmanFlags >> 2) & 3;
                                textRegion.huffmanDT = (textRegionHuffmanFlags >> 4) & 3;
                                textRegion.huffmanRefinementDW = (textRegionHuffmanFlags >> 6) & 3;
                                textRegion.huffmanRefinementDH = (textRegionHuffmanFlags >> 8) & 3;
                                textRegion.huffmanRefinementDX = (textRegionHuffmanFlags >> 10) & 3;
                                textRegion.huffmanRefinementDY = (textRegionHuffmanFlags >> 12) & 3;
                                textRegion.huffmanRefinementSizeSelector = !!(textRegionHuffmanFlags & 14);
                            }
                            if (textRegion.refinement && !textRegion.refinementTemplate) {
                                at = [];
                                for (i = 0; i < 2; i++) {
                                    at.push({
                                        x: readInt8(data, position),
                                        y: readInt8(data, position + 1)
                                    });
                                    position += 2;
                                }
                                textRegion.refinementAt = at;
                            }
                            textRegion.numberOfSymbolInstances = readUint32(data, position);
                            position += 4;
                            if (textRegion.huffman) {
                                error('JBIG2 error: huffman is not supported');
                            }
                            args = [textRegion, header.referredTo, data, position, end];
                            break;
                        case 38:
                        case 39:
                            var genericRegion = {};
                            genericRegion.info = readRegionSegmentInformation(data, position);
                            position += RegionSegmentInformationFieldLength;
                            var genericRegionSegmentFlags = data[position++];
                            genericRegion.mmr = !!(genericRegionSegmentFlags & 1);
                            genericRegion.template = (genericRegionSegmentFlags >> 1) & 3;
                            genericRegion.prediction = !!(genericRegionSegmentFlags & 8);
                            if (!genericRegion.mmr) {
                                atLength = genericRegion.template === 0 ? 4 : 1;
                                at = [];
                                for (i = 0; i < atLength; i++) {
                                    at.push({
                                        x: readInt8(data, position),
                                        y: readInt8(data, position + 1)
                                    });
                                    position += 2;
                                }
                                genericRegion.at = at;
                            }
                            args = [genericRegion, data, position, end];
                            break;
                        case 48:
                            var pageInfo = {
                                width: readUint32(data, position),
                                height: readUint32(data, position + 4),
                                resolutionX: readUint32(data, position + 8),
                                resolutionY: readUint32(data, position + 12)
                            };
                            if (pageInfo.height === 0xFFFFFFFF) {
                                delete pageInfo.height;
                            }
                            var pageSegmentFlags = data[position + 16];
                            var pageStripingInformation = readUint16(data, position + 17);
                            pageInfo.lossless = !!(pageSegmentFlags & 1);
                            pageInfo.refinement = !!(pageSegmentFlags & 2);
                            pageInfo.defaultPixelValue = (pageSegmentFlags >> 2) & 1;
                            pageInfo.combinationOperator = (pageSegmentFlags >> 3) & 3;
                            pageInfo.requiresBuffer = !!(pageSegmentFlags & 32);
                            pageInfo.combinationOperatorOverride = !!(pageSegmentFlags & 64);
                            args = [pageInfo];
                            break;
                        case 49:
                            break;
                        case 50:
                            break;
                        case 51:
                            break;
                        case 62:
                            break;
                        default:
                            error('JBIG2 error: segment type ' + header.typeName + '(' +
                                header.type + ') is not implemented');
                    }
                    var callbackName = 'on' + header.typeName;
                    if (callbackName in visitor) {
                        visitor[callbackName].apply(visitor, args);
                    }
                }

                function processSegments(segments, visitor) {
                    for (var i = 0, ii = segments.length; i < ii; i++) {
                        processSegment(segments[i], visitor);
                    }
                }

                function parseJbig2(data, start, end) {
                    var position = start;
                    if (data[position] !== 0x97 || data[position + 1] !== 0x4A || data[position + 2] !== 0x42 || data[position + 3] !== 0x32 || data[position + 4] !== 0x0D || data[position + 5] !== 0x0A || data[position + 6] !== 0x1A || data[position + 7] !== 0x0A) {
                        error('JBIG2 error: invalid header');
                    }
                    var header = {};
                    position += 8;
                    var flags = data[position++];
                    header.randomAccess = !(flags & 1);
                    if (!(flags & 2)) {
                        header.numberOfPages = readUint32(data, position);
                        position += 4;
                    }
                    var segments = readSegments(header, data, position, end);
                    error('Not implemented');
                }

                function parseJbig2Chunks(chunks) {
                    var visitor = new SimpleSegmentVisitor();
                    for (var i = 0, ii = chunks.length; i < ii; i++) {
                        var chunk = chunks[i];
                        var segments = readSegments({}, chunk.data, chunk.start, chunk.end);
                        processSegments(segments, visitor);
                    }
                    return visitor.buffer;
                }

                function SimpleSegmentVisitor() {}
                SimpleSegmentVisitor.prototype = {
                    onPageInformation: function SimpleSegmentVisitor_onPageInformation(info) {
                        this.currentPageInfo = info;
                        var rowSize = (info.width + 7) >> 3;
                        var buffer = new Uint8Array(rowSize * info.height);
                        if (info.defaultPixelValue) {
                            for (var i = 0, ii = buffer.length; i < ii; i++) {
                                buffer[i] = 0xFF;
                            }
                        }
                        this.buffer = buffer;
                    },
                    drawBitmap: function SimpleSegmentVisitor_drawBitmap(regionInfo, bitmap) {
                        var pageInfo = this.currentPageInfo;
                        var width = regionInfo.width,
                            height = regionInfo.height;
                        var rowSize = (pageInfo.width + 7) >> 3;
                        var combinationOperator = pageInfo.combinationOperatorOverride ? regionInfo.combinationOperator : pageInfo.combinationOperator;
                        var buffer = this.buffer;
                        var mask0 = 128 >> (regionInfo.x & 7);
                        var offset0 = regionInfo.y * rowSize + (regionInfo.x >> 3);
                        var i, j, mask, offset;
                        switch (combinationOperator) {
                            case 0:
                                for (i = 0; i < height; i++) {
                                    mask = mask0;
                                    offset = offset0;
                                    for (j = 0; j < width; j++) {
                                        if (bitmap[i][j]) {
                                            buffer[offset] |= mask;
                                        }
                                        mask >>= 1;
                                        if (!mask) {
                                            mask = 128;
                                            offset++;
                                        }
                                    }
                                    offset0 += rowSize;
                                }
                                break;
                            case 2:
                                for (i = 0; i < height; i++) {
                                    mask = mask0;
                                    offset = offset0;
                                    for (j = 0; j < width; j++) {
                                        if (bitmap[i][j]) {
                                            buffer[offset] ^= mask;
                                        }
                                        mask >>= 1;
                                        if (!mask) {
                                            mask = 128;
                                            offset++;
                                        }
                                    }
                                    offset0 += rowSize;
                                }
                                break;
                            default:
                                error('JBIG2 error: operator ' + combinationOperator + ' is not supported');
                        }
                    },
                    onImmediateGenericRegion: function SimpleSegmentVisitor_onImmediateGenericRegion(region, data, start, end) {
                        var regionInfo = region.info;
                        var decodingContext = new DecodingContext(data, start, end);
                        var bitmap = decodeBitmap(region.mmr, regionInfo.width, regionInfo.height, region.template, region.prediction, null, region.at, decodingContext);
                        this.drawBitmap(regionInfo, bitmap);
                    },
                    onImmediateLosslessGenericRegion: function SimpleSegmentVisitor_onImmediateLosslessGenericRegion() {
                        this.onImmediateGenericRegion.apply(this, arguments);
                    },
                    onSymbolDictionary: function SimpleSegmentVisitor_onSymbolDictionary(dictionary, currentSegment, referredSegments, data, start, end) {
                        var huffmanTables;
                        if (dictionary.huffman) {
                            error('JBIG2 error: huffman is not supported');
                        }
                        var symbols = this.symbols;
                        if (!symbols) {
                            this.symbols = symbols = {};
                        }
                        var inputSymbols = [];
                        for (var i = 0, ii = referredSegments.length; i < ii; i++) {
                            inputSymbols = inputSymbols.concat(symbols[referredSegments[i]]);
                        }
                        var decodingContext = new DecodingContext(data, start, end);
                        symbols[currentSegment] = decodeSymbolDictionary(dictionary.huffman, dictionary.refinement, inputSymbols, dictionary.numberOfNewSymbols, dictionary.numberOfExportedSymbols, huffmanTables, dictionary.template, dictionary.at, dictionary.refinementTemplate, dictionary.refinementAt, decodingContext);
                    },
                    onImmediateTextRegion: function SimpleSegmentVisitor_onImmediateTextRegion(region, referredSegments, data, start, end) {
                        var regionInfo = region.info;
                        var huffmanTables;
                        var symbols = this.symbols;
                        var inputSymbols = [];
                        for (var i = 0, ii = referredSegments.length; i < ii; i++) {
                            inputSymbols = inputSymbols.concat(symbols[referredSegments[i]]);
                        }
                        var symbolCodeLength = log2(inputSymbols.length);
                        var decodingContext = new DecodingContext(data, start, end);
                        var bitmap = decodeTextRegion(region.huffman, region.refinement, regionInfo.width, regionInfo.height, region.defaultPixelValue, region.numberOfSymbolInstances, region.stripSize, inputSymbols, symbolCodeLength, region.transposed, region.dsOffset, region.referenceCorner, region.combinationOperator, huffmanTables, region.refinementTemplate, region.refinementAt, decodingContext);
                        this.drawBitmap(regionInfo, bitmap);
                    },
                    onImmediateLosslessTextRegion: function SimpleSegmentVisitor_onImmediateLosslessTextRegion() {
                        this.onImmediateTextRegion.apply(this, arguments);
                    }
                };

                function Jbig2Image() {}
                Jbig2Image.prototype = {
                    parseChunks: function Jbig2Image_parseChunks(chunks) {
                        return parseJbig2Chunks(chunks);
                    }
                };
                return Jbig2Image;
            })();
            exports.Jbig2Image = Jbig2Image;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsCoreJpx = {}), root.pdfjsSharedUtil, root.pdfjsCoreArithmeticDecoder);
            }
        }(this, function(exports, sharedUtil, coreArithmeticDecoder) {
            var info = sharedUtil.info;
            var log2 = sharedUtil.log2;
            var readUint16 = sharedUtil.readUint16;
            var readUint32 = sharedUtil.readUint32;
            var warn = sharedUtil.warn;
            var ArithmeticDecoder = coreArithmeticDecoder.ArithmeticDecoder;
            var JpxImage = (function JpxImageClosure() {
                var SubbandsGainLog2 = {
                    'LL': 0,
                    'LH': 1,
                    'HL': 1,
                    'HH': 2
                };

                function JpxImage() {
                    this.failOnCorruptedImage = false;
                }
                JpxImage.prototype = {
                    parse: function JpxImage_parse(data) {
                        var head = readUint16(data, 0);
                        if (head === 0xFF4F) {
                            this.parseCodestream(data, 0, data.length);
                            return;
                        }
                        var position = 0,
                            length = data.length;
                        while (position < length) {
                            var headerSize = 8;
                            var lbox = readUint32(data, position);
                            var tbox = readUint32(data, position + 4);
                            position += headerSize;
                            if (lbox === 1) {
                                lbox = readUint32(data, position) * 4294967296 +
                                    readUint32(data, position + 4);
                                position += 8;
                                headerSize += 8;
                            }
                            if (lbox === 0) {
                                lbox = length - position + headerSize;
                            }
                            if (lbox < headerSize) {
                                throw new Error('JPX Error: Invalid box field size');
                            }
                            var dataLength = lbox - headerSize;
                            var jumpDataLength = true;
                            switch (tbox) {
                                case 0x6A703268:
                                    jumpDataLength = false;
                                    break;
                                case 0x636F6C72:
                                    var method = data[position];
                                    if (method === 1) {
                                        var colorspace = readUint32(data, position + 3);
                                        switch (colorspace) {
                                            case 16:
                                            case 17:
                                            case 18:
                                                break;
                                            default:
                                                warn('Unknown colorspace ' + colorspace);
                                                break;
                                        }
                                    } else if (method === 2) {
                                        info('ICC profile not supported');
                                    }
                                    break;
                                case 0x6A703263:
                                    this.parseCodestream(data, position, position + dataLength);
                                    break;
                                case 0x6A502020:
                                    if (0x0d0a870a !== readUint32(data, position)) {
                                        warn('Invalid JP2 signature');
                                    }
                                    break;
                                case 0x6A501A1A:
                                case 0x66747970:
                                case 0x72726571:
                                case 0x72657320:
                                case 0x69686472:
                                    break;
                                default:
                                    var headerType = String.fromCharCode((tbox >> 24) & 0xFF, (tbox >> 16) & 0xFF, (tbox >> 8) & 0xFF, tbox & 0xFF);
                                    warn('Unsupported header type ' + tbox + ' (' + headerType + ')');
                                    break;
                            }
                            if (jumpDataLength) {
                                position += dataLength;
                            }
                        }
                    },
                    parseImageProperties: function JpxImage_parseImageProperties(stream) {
                        var newByte = stream.getByte();
                        while (newByte >= 0) {
                            var oldByte = newByte;
                            newByte = stream.getByte();
                            var code = (oldByte << 8) | newByte;
                            if (code === 0xFF51) {
                                stream.skip(4);
                                var Xsiz = stream.getInt32() >>> 0;
                                var Ysiz = stream.getInt32() >>> 0;
                                var XOsiz = stream.getInt32() >>> 0;
                                var YOsiz = stream.getInt32() >>> 0;
                                stream.skip(16);
                                var Csiz = stream.getUint16();
                                this.width = Xsiz - XOsiz;
                                this.height = Ysiz - YOsiz;
                                this.componentsCount = Csiz;
                                this.bitsPerComponent = 8;
                                return;
                            }
                        }
                        throw new Error('JPX Error: No size marker found in JPX stream');
                    },
                    parseCodestream: function JpxImage_parseCodestream(data, start, end) {
                        var context = {};
                        try {
                            var doNotRecover = false;
                            var position = start;
                            while (position + 1 < end) {
                                var code = readUint16(data, position);
                                position += 2;
                                var length = 0,
                                    j, sqcd, spqcds, spqcdSize, scalarExpounded, tile;
                                switch (code) {
                                    case 0xFF4F:
                                        context.mainHeader = true;
                                        break;
                                    case 0xFFD9:
                                        break;
                                    case 0xFF51:
                                        length = readUint16(data, position);
                                        var siz = {};
                                        siz.Xsiz = readUint32(data, position + 4);
                                        siz.Ysiz = readUint32(data, position + 8);
                                        siz.XOsiz = readUint32(data, position + 12);
                                        siz.YOsiz = readUint32(data, position + 16);
                                        siz.XTsiz = readUint32(data, position + 20);
                                        siz.YTsiz = readUint32(data, position + 24);
                                        siz.XTOsiz = readUint32(data, position + 28);
                                        siz.YTOsiz = readUint32(data, position + 32);
                                        var componentsCount = readUint16(data, position + 36);
                                        siz.Csiz = componentsCount;
                                        var components = [];
                                        j = position + 38;
                                        for (var i = 0; i < componentsCount; i++) {
                                            var component = {
                                                precision: (data[j] & 0x7F) + 1,
                                                isSigned: !!(data[j] & 0x80),
                                                XRsiz: data[j + 1],
                                                YRsiz: data[j + 1]
                                            };
                                            calculateComponentDimensions(component, siz);
                                            components.push(component);
                                        }
                                        context.SIZ = siz;
                                        context.components = components;
                                        calculateTileGrids(context, components);
                                        context.QCC = [];
                                        context.COC = [];
                                        break;
                                    case 0xFF5C:
                                        length = readUint16(data, position);
                                        var qcd = {};
                                        j = position + 2;
                                        sqcd = data[j++];
                                        switch (sqcd & 0x1F) {
                                            case 0:
                                                spqcdSize = 8;
                                                scalarExpounded = true;
                                                break;
                                            case 1:
                                                spqcdSize = 16;
                                                scalarExpounded = false;
                                                break;
                                            case 2:
                                                spqcdSize = 16;
                                                scalarExpounded = true;
                                                break;
                                            default:
                                                throw new Error('JPX Error: Invalid SQcd value ' + sqcd);
                                        }
                                        qcd.noQuantization = (spqcdSize === 8);
                                        qcd.scalarExpounded = scalarExpounded;
                                        qcd.guardBits = sqcd >> 5;
                                        spqcds = [];
                                        while (j < length + position) {
                                            var spqcd = {};
                                            if (spqcdSize === 8) {
                                                spqcd.epsilon = data[j++] >> 3;
                                                spqcd.mu = 0;
                                            } else {
                                                spqcd.epsilon = data[j] >> 3;
                                                spqcd.mu = ((data[j] & 0x7) << 8) | data[j + 1];
                                                j += 2;
                                            }
                                            spqcds.push(spqcd);
                                        }
                                        qcd.SPqcds = spqcds;
                                        if (context.mainHeader) {
                                            context.QCD = qcd;
                                        } else {
                                            context.currentTile.QCD = qcd;
                                            context.currentTile.QCC = [];
                                        }
                                        break;
                                    case 0xFF5D:
                                        length = readUint16(data, position);
                                        var qcc = {};
                                        j = position + 2;
                                        var cqcc;
                                        if (context.SIZ.Csiz < 257) {
                                            cqcc = data[j++];
                                        } else {
                                            cqcc = readUint16(data, j);
                                            j += 2;
                                        }
                                        sqcd = data[j++];
                                        switch (sqcd & 0x1F) {
                                            case 0:
                                                spqcdSize = 8;
                                                scalarExpounded = true;
                                                break;
                                            case 1:
                                                spqcdSize = 16;
                                                scalarExpounded = false;
                                                break;
                                            case 2:
                                                spqcdSize = 16;
                                                scalarExpounded = true;
                                                break;
                                            default:
                                                throw new Error('JPX Error: Invalid SQcd value ' + sqcd);
                                        }
                                        qcc.noQuantization = (spqcdSize === 8);
                                        qcc.scalarExpounded = scalarExpounded;
                                        qcc.guardBits = sqcd >> 5;
                                        spqcds = [];
                                        while (j < (length + position)) {
                                            spqcd = {};
                                            if (spqcdSize === 8) {
                                                spqcd.epsilon = data[j++] >> 3;
                                                spqcd.mu = 0;
                                            } else {
                                                spqcd.epsilon = data[j] >> 3;
                                                spqcd.mu = ((data[j] & 0x7) << 8) | data[j + 1];
                                                j += 2;
                                            }
                                            spqcds.push(spqcd);
                                        }
                                        qcc.SPqcds = spqcds;
                                        if (context.mainHeader) {
                                            context.QCC[cqcc] = qcc;
                                        } else {
                                            context.currentTile.QCC[cqcc] = qcc;
                                        }
                                        break;
                                    case 0xFF52:
                                        length = readUint16(data, position);
                                        var cod = {};
                                        j = position + 2;
                                        var scod = data[j++];
                                        cod.entropyCoderWithCustomPrecincts = !!(scod & 1);
                                        cod.sopMarkerUsed = !!(scod & 2);
                                        cod.ephMarkerUsed = !!(scod & 4);
                                        cod.progressionOrder = data[j++];
                                        cod.layersCount = readUint16(data, j);
                                        j += 2;
                                        cod.multipleComponentTransform = data[j++];
                                        cod.decompositionLevelsCount = data[j++];
                                        cod.xcb = (data[j++] & 0xF) + 2;
                                        cod.ycb = (data[j++] & 0xF) + 2;
                                        var blockStyle = data[j++];
                                        cod.selectiveArithmeticCodingBypass = !!(blockStyle & 1);
                                        cod.resetContextProbabilities = !!(blockStyle & 2);
                                        cod.terminationOnEachCodingPass = !!(blockStyle & 4);
                                        cod.verticalyStripe = !!(blockStyle & 8);
                                        cod.predictableTermination = !!(blockStyle & 16);
                                        cod.segmentationSymbolUsed = !!(blockStyle & 32);
                                        cod.reversibleTransformation = data[j++];
                                        if (cod.entropyCoderWithCustomPrecincts) {
                                            var precinctsSizes = [];
                                            while (j < length + position) {
                                                var precinctsSize = data[j++];
                                                precinctsSizes.push({
                                                    PPx: precinctsSize & 0xF,
                                                    PPy: precinctsSize >> 4
                                                });
                                            }
                                            cod.precinctsSizes = precinctsSizes;
                                        }
                                        var unsupported = [];
                                        if (cod.selectiveArithmeticCodingBypass) {
                                            unsupported.push('selectiveArithmeticCodingBypass');
                                        }
                                        if (cod.resetContextProbabilities) {
                                            unsupported.push('resetContextProbabilities');
                                        }
                                        if (cod.terminationOnEachCodingPass) {
                                            unsupported.push('terminationOnEachCodingPass');
                                        }
                                        if (cod.verticalyStripe) {
                                            unsupported.push('verticalyStripe');
                                        }
                                        if (cod.predictableTermination) {
                                            unsupported.push('predictableTermination');
                                        }
                                        if (unsupported.length > 0) {
                                            doNotRecover = true;
                                            throw new Error('JPX Error: Unsupported COD options (' +
                                                unsupported.join(', ') + ')');
                                        }
                                        if (context.mainHeader) {
                                            context.COD = cod;
                                        } else {
                                            context.currentTile.COD = cod;
                                            context.currentTile.COC = [];
                                        }
                                        break;
                                    case 0xFF90:
                                        length = readUint16(data, position);
                                        tile = {};
                                        tile.index = readUint16(data, position + 2);
                                        tile.length = readUint32(data, position + 4);
                                        tile.dataEnd = tile.length + position - 2;
                                        tile.partIndex = data[position + 8];
                                        tile.partsCount = data[position + 9];
                                        context.mainHeader = false;
                                        if (tile.partIndex === 0) {
                                            tile.COD = context.COD;
                                            tile.COC = context.COC.slice(0);
                                            tile.QCD = context.QCD;
                                            tile.QCC = context.QCC.slice(0);
                                        }
                                        context.currentTile = tile;
                                        break;
                                    case 0xFF93:
                                        tile = context.currentTile;
                                        if (tile.partIndex === 0) {
                                            initializeTile(context, tile.index);
                                            buildPackets(context);
                                        }
                                        length = tile.dataEnd - position;
                                        parseTilePackets(context, data, position, length);
                                        break;
                                    case 0xFF55:
                                    case 0xFF57:
                                    case 0xFF58:
                                    case 0xFF64:
                                        length = readUint16(data, position);
                                        break;
                                    case 0xFF53:
                                        throw new Error('JPX Error: Codestream code 0xFF53 (COC) is ' + 'not implemented');
                                    default:
                                        throw new Error('JPX Error: Unknown codestream code: ' +
                                            code.toString(16));
                                }
                                position += length;
                            }
                        } catch (e) {
                            if (doNotRecover || this.failOnCorruptedImage) {
                                throw e;
                            } else {
                                warn('Trying to recover from ' + e.message);
                            }
                        }
                        this.tiles = transformComponents(context);
                        this.width = context.SIZ.Xsiz - context.SIZ.XOsiz;
                        this.height = context.SIZ.Ysiz - context.SIZ.YOsiz;
                        this.componentsCount = context.SIZ.Csiz;
                    }
                };

                function calculateComponentDimensions(component, siz) {
                    component.x0 = Math.ceil(siz.XOsiz / component.XRsiz);
                    component.x1 = Math.ceil(siz.Xsiz / component.XRsiz);
                    component.y0 = Math.ceil(siz.YOsiz / component.YRsiz);
                    component.y1 = Math.ceil(siz.Ysiz / component.YRsiz);
                    component.width = component.x1 - component.x0;
                    component.height = component.y1 - component.y0;
                }

                function calculateTileGrids(context, components) {
                    var siz = context.SIZ;
                    var tile, tiles = [];
                    var numXtiles = Math.ceil((siz.Xsiz - siz.XTOsiz) / siz.XTsiz);
                    var numYtiles = Math.ceil((siz.Ysiz - siz.YTOsiz) / siz.YTsiz);
                    for (var q = 0; q < numYtiles; q++) {
                        for (var p = 0; p < numXtiles; p++) {
                            tile = {};
                            tile.tx0 = Math.max(siz.XTOsiz + p * siz.XTsiz, siz.XOsiz);
                            tile.ty0 = Math.max(siz.YTOsiz + q * siz.YTsiz, siz.YOsiz);
                            tile.tx1 = Math.min(siz.XTOsiz + (p + 1) * siz.XTsiz, siz.Xsiz);
                            tile.ty1 = Math.min(siz.YTOsiz + (q + 1) * siz.YTsiz, siz.Ysiz);
                            tile.width = tile.tx1 - tile.tx0;
                            tile.height = tile.ty1 - tile.ty0;
                            tile.components = [];
                            tiles.push(tile);
                        }
                    }
                    context.tiles = tiles;
                    var componentsCount = siz.Csiz;
                    for (var i = 0, ii = componentsCount; i < ii; i++) {
                        var component = components[i];
                        for (var j = 0, jj = tiles.length; j < jj; j++) {
                            var tileComponent = {};
                            tile = tiles[j];
                            tileComponent.tcx0 = Math.ceil(tile.tx0 / component.XRsiz);
                            tileComponent.tcy0 = Math.ceil(tile.ty0 / component.YRsiz);
                            tileComponent.tcx1 = Math.ceil(tile.tx1 / component.XRsiz);
                            tileComponent.tcy1 = Math.ceil(tile.ty1 / component.YRsiz);
                            tileComponent.width = tileComponent.tcx1 - tileComponent.tcx0;
                            tileComponent.height = tileComponent.tcy1 - tileComponent.tcy0;
                            tile.components[i] = tileComponent;
                        }
                    }
                }

                function getBlocksDimensions(context, component, r) {
                    var codOrCoc = component.codingStyleParameters;
                    var result = {};
                    if (!codOrCoc.entropyCoderWithCustomPrecincts) {
                        result.PPx = 15;
                        result.PPy = 15;
                    } else {
                        result.PPx = codOrCoc.precinctsSizes[r].PPx;
                        result.PPy = codOrCoc.precinctsSizes[r].PPy;
                    }
                    result.xcb_ = (r > 0 ? Math.min(codOrCoc.xcb, result.PPx - 1) : Math.min(codOrCoc.xcb, result.PPx));
                    result.ycb_ = (r > 0 ? Math.min(codOrCoc.ycb, result.PPy - 1) : Math.min(codOrCoc.ycb, result.PPy));
                    return result;
                }

                function buildPrecincts(context, resolution, dimensions) {
                    var precinctWidth = 1 << dimensions.PPx;
                    var precinctHeight = 1 << dimensions.PPy;
                    var isZeroRes = resolution.resLevel === 0;
                    var precinctWidthInSubband = 1 << (dimensions.PPx + (isZeroRes ? 0 : -1));
                    var precinctHeightInSubband = 1 << (dimensions.PPy + (isZeroRes ? 0 : -1));
                    var numprecinctswide = (resolution.trx1 > resolution.trx0 ? Math.ceil(resolution.trx1 / precinctWidth) -
                        Math.floor(resolution.trx0 / precinctWidth) : 0);
                    var numprecinctshigh = (resolution.try1 > resolution.try0 ? Math.ceil(resolution.try1 / precinctHeight) -
                        Math.floor(resolution.try0 / precinctHeight) : 0);
                    var numprecincts = numprecinctswide * numprecinctshigh;
                    resolution.precinctParameters = {
                        precinctWidth: precinctWidth,
                        precinctHeight: precinctHeight,
                        numprecinctswide: numprecinctswide,
                        numprecinctshigh: numprecinctshigh,
                        numprecincts: numprecincts,
                        precinctWidthInSubband: precinctWidthInSubband,
                        precinctHeightInSubband: precinctHeightInSubband
                    };
                }

                function buildCodeblocks(context, subband, dimensions) {
                    var xcb_ = dimensions.xcb_;
                    var ycb_ = dimensions.ycb_;
                    var codeblockWidth = 1 << xcb_;
                    var codeblockHeight = 1 << ycb_;
                    var cbx0 = subband.tbx0 >> xcb_;
                    var cby0 = subband.tby0 >> ycb_;
                    var cbx1 = (subband.tbx1 + codeblockWidth - 1) >> xcb_;
                    var cby1 = (subband.tby1 + codeblockHeight - 1) >> ycb_;
                    var precinctParameters = subband.resolution.precinctParameters;
                    var codeblocks = [];
                    var precincts = [];
                    var i, j, codeblock, precinctNumber;
                    for (j = cby0; j < cby1; j++) {
                        for (i = cbx0; i < cbx1; i++) {
                            codeblock = {
                                cbx: i,
                                cby: j,
                                tbx0: codeblockWidth * i,
                                tby0: codeblockHeight * j,
                                tbx1: codeblockWidth * (i + 1),
                                tby1: codeblockHeight * (j + 1)
                            };
                            codeblock.tbx0_ = Math.max(subband.tbx0, codeblock.tbx0);
                            codeblock.tby0_ = Math.max(subband.tby0, codeblock.tby0);
                            codeblock.tbx1_ = Math.min(subband.tbx1, codeblock.tbx1);
                            codeblock.tby1_ = Math.min(subband.tby1, codeblock.tby1);
                            var pi = Math.floor((codeblock.tbx0_ - subband.tbx0) / precinctParameters.precinctWidthInSubband);
                            var pj = Math.floor((codeblock.tby0_ - subband.tby0) / precinctParameters.precinctHeightInSubband);
                            precinctNumber = pi + (pj * precinctParameters.numprecinctswide);
                            codeblock.precinctNumber = precinctNumber;
                            codeblock.subbandType = subband.type;
                            codeblock.Lblock = 3;
                            if (codeblock.tbx1_ <= codeblock.tbx0_ || codeblock.tby1_ <= codeblock.tby0_) {
                                continue;
                            }
                            codeblocks.push(codeblock);
                            var precinct = precincts[precinctNumber];
                            if (precinct !== undefined) {
                                if (i < precinct.cbxMin) {
                                    precinct.cbxMin = i;
                                } else if (i > precinct.cbxMax) {
                                    precinct.cbxMax = i;
                                }
                                if (j < precinct.cbyMin) {
                                    precinct.cbxMin = j;
                                } else if (j > precinct.cbyMax) {
                                    precinct.cbyMax = j;
                                }
                            } else {
                                precincts[precinctNumber] = precinct = {
                                    cbxMin: i,
                                    cbyMin: j,
                                    cbxMax: i,
                                    cbyMax: j
                                };
                            }
                            codeblock.precinct = precinct;
                        }
                    }
                    subband.codeblockParameters = {
                        codeblockWidth: xcb_,
                        codeblockHeight: ycb_,
                        numcodeblockwide: cbx1 - cbx0 + 1,
                        numcodeblockhigh: cby1 - cby0 + 1
                    };
                    subband.codeblocks = codeblocks;
                    subband.precincts = precincts;
                }

                function createPacket(resolution, precinctNumber, layerNumber) {
                    var precinctCodeblocks = [];
                    var subbands = resolution.subbands;
                    for (var i = 0, ii = subbands.length; i < ii; i++) {
                        var subband = subbands[i];
                        var codeblocks = subband.codeblocks;
                        for (var j = 0, jj = codeblocks.length; j < jj; j++) {
                            var codeblock = codeblocks[j];
                            if (codeblock.precinctNumber !== precinctNumber) {
                                continue;
                            }
                            precinctCodeblocks.push(codeblock);
                        }
                    }
                    return {
                        layerNumber: layerNumber,
                        codeblocks: precinctCodeblocks
                    };
                }

                function LayerResolutionComponentPositionIterator(context) {
                    var siz = context.SIZ;
                    var tileIndex = context.currentTile.index;
                    var tile = context.tiles[tileIndex];
                    var layersCount = tile.codingStyleDefaultParameters.layersCount;
                    var componentsCount = siz.Csiz;
                    var maxDecompositionLevelsCount = 0;
                    for (var q = 0; q < componentsCount; q++) {
                        maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q].codingStyleParameters.decompositionLevelsCount);
                    }
                    var l = 0,
                        r = 0,
                        i = 0,
                        k = 0;
                    this.nextPacket = function JpxImage_nextPacket() {
                        for (; l < layersCount; l++) {
                            for (; r <= maxDecompositionLevelsCount; r++) {
                                for (; i < componentsCount; i++) {
                                    var component = tile.components[i];
                                    if (r > component.codingStyleParameters.decompositionLevelsCount) {
                                        continue;
                                    }
                                    var resolution = component.resolutions[r];
                                    var numprecincts = resolution.precinctParameters.numprecincts;
                                    for (; k < numprecincts;) {
                                        var packet = createPacket(resolution, k, l);
                                        k++;
                                        return packet;
                                    }
                                    k = 0;
                                }
                                i = 0;
                            }
                            r = 0;
                        }
                        throw new Error('JPX Error: Out of packets');
                    };
                }

                function ResolutionLayerComponentPositionIterator(context) {
                    var siz = context.SIZ;
                    var tileIndex = context.currentTile.index;
                    var tile = context.tiles[tileIndex];
                    var layersCount = tile.codingStyleDefaultParameters.layersCount;
                    var componentsCount = siz.Csiz;
                    var maxDecompositionLevelsCount = 0;
                    for (var q = 0; q < componentsCount; q++) {
                        maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q].codingStyleParameters.decompositionLevelsCount);
                    }
                    var r = 0,
                        l = 0,
                        i = 0,
                        k = 0;
                    this.nextPacket = function JpxImage_nextPacket() {
                        for (; r <= maxDecompositionLevelsCount; r++) {
                            for (; l < layersCount; l++) {
                                for (; i < componentsCount; i++) {
                                    var component = tile.components[i];
                                    if (r > component.codingStyleParameters.decompositionLevelsCount) {
                                        continue;
                                    }
                                    var resolution = component.resolutions[r];
                                    var numprecincts = resolution.precinctParameters.numprecincts;
                                    for (; k < numprecincts;) {
                                        var packet = createPacket(resolution, k, l);
                                        k++;
                                        return packet;
                                    }
                                    k = 0;
                                }
                                i = 0;
                            }
                            l = 0;
                        }
                        throw new Error('JPX Error: Out of packets');
                    };
                }

                function ResolutionPositionComponentLayerIterator(context) {
                    var siz = context.SIZ;
                    var tileIndex = context.currentTile.index;
                    var tile = context.tiles[tileIndex];
                    var layersCount = tile.codingStyleDefaultParameters.layersCount;
                    var componentsCount = siz.Csiz;
                    var l, r, c, p;
                    var maxDecompositionLevelsCount = 0;
                    for (c = 0; c < componentsCount; c++) {
                        var component = tile.components[c];
                        maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, component.codingStyleParameters.decompositionLevelsCount);
                    }
                    var maxNumPrecinctsInLevel = new Int32Array(maxDecompositionLevelsCount + 1);
                    for (r = 0; r <= maxDecompositionLevelsCount; ++r) {
                        var maxNumPrecincts = 0;
                        for (c = 0; c < componentsCount; ++c) {
                            var resolutions = tile.components[c].resolutions;
                            if (r < resolutions.length) {
                                maxNumPrecincts = Math.max(maxNumPrecincts, resolutions[r].precinctParameters.numprecincts);
                            }
                        }
                        maxNumPrecinctsInLevel[r] = maxNumPrecincts;
                    }
                    l = 0;
                    r = 0;
                    c = 0;
                    p = 0;
                    this.nextPacket = function JpxImage_nextPacket() {
                        for (; r <= maxDecompositionLevelsCount; r++) {
                            for (; p < maxNumPrecinctsInLevel[r]; p++) {
                                for (; c < componentsCount; c++) {
                                    var component = tile.components[c];
                                    if (r > component.codingStyleParameters.decompositionLevelsCount) {
                                        continue;
                                    }
                                    var resolution = component.resolutions[r];
                                    var numprecincts = resolution.precinctParameters.numprecincts;
                                    if (p >= numprecincts) {
                                        continue;
                                    }
                                    for (; l < layersCount;) {
                                        var packet = createPacket(resolution, p, l);
                                        l++;
                                        return packet;
                                    }
                                    l = 0;
                                }
                                c = 0;
                            }
                            p = 0;
                        }
                        throw new Error('JPX Error: Out of packets');
                    };
                }

                function PositionComponentResolutionLayerIterator(context) {
                    var siz = context.SIZ;
                    var tileIndex = context.currentTile.index;
                    var tile = context.tiles[tileIndex];
                    var layersCount = tile.codingStyleDefaultParameters.layersCount;
                    var componentsCount = siz.Csiz;
                    var precinctsSizes = getPrecinctSizesInImageScale(tile);
                    var precinctsIterationSizes = precinctsSizes;
                    var l = 0,
                        r = 0,
                        c = 0,
                        px = 0,
                        py = 0;
                    this.nextPacket = function JpxImage_nextPacket() {
                        for (; py < precinctsIterationSizes.maxNumHigh; py++) {
                            for (; px < precinctsIterationSizes.maxNumWide; px++) {
                                for (; c < componentsCount; c++) {
                                    var component = tile.components[c];
                                    var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
                                    for (; r <= decompositionLevelsCount; r++) {
                                        var resolution = component.resolutions[r];
                                        var sizeInImageScale = precinctsSizes.components[c].resolutions[r];
                                        var k = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution);
                                        if (k === null) {
                                            continue;
                                        }
                                        for (; l < layersCount;) {
                                            var packet = createPacket(resolution, k, l);
                                            l++;
                                            return packet;
                                        }
                                        l = 0;
                                    }
                                    r = 0;
                                }
                                c = 0;
                            }
                            px = 0;
                        }
                        throw new Error('JPX Error: Out of packets');
                    };
                }

                function ComponentPositionResolutionLayerIterator(context) {
                    var siz = context.SIZ;
                    var tileIndex = context.currentTile.index;
                    var tile = context.tiles[tileIndex];
                    var layersCount = tile.codingStyleDefaultParameters.layersCount;
                    var componentsCount = siz.Csiz;
                    var precinctsSizes = getPrecinctSizesInImageScale(tile);
                    var l = 0,
                        r = 0,
                        c = 0,
                        px = 0,
                        py = 0;
                    this.nextPacket = function JpxImage_nextPacket() {
                        for (; c < componentsCount; ++c) {
                            var component = tile.components[c];
                            var precinctsIterationSizes = precinctsSizes.components[c];
                            var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
                            for (; py < precinctsIterationSizes.maxNumHigh; py++) {
                                for (; px < precinctsIterationSizes.maxNumWide; px++) {
                                    for (; r <= decompositionLevelsCount; r++) {
                                        var resolution = component.resolutions[r];
                                        var sizeInImageScale = precinctsIterationSizes.resolutions[r];
                                        var k = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution);
                                        if (k === null) {
                                            continue;
                                        }
                                        for (; l < layersCount;) {
                                            var packet = createPacket(resolution, k, l);
                                            l++;
                                            return packet;
                                        }
                                        l = 0;
                                    }
                                    r = 0;
                                }
                                px = 0;
                            }
                            py = 0;
                        }
                        throw new Error('JPX Error: Out of packets');
                    };
                }

                function getPrecinctIndexIfExist(pxIndex, pyIndex, sizeInImageScale, precinctIterationSizes, resolution) {
                    var posX = pxIndex * precinctIterationSizes.minWidth;
                    var posY = pyIndex * precinctIterationSizes.minHeight;
                    if (posX % sizeInImageScale.width !== 0 || posY % sizeInImageScale.height !== 0) {
                        return null;
                    }
                    var startPrecinctRowIndex = (posY / sizeInImageScale.width) * resolution.precinctParameters.numprecinctswide;
                    return (posX / sizeInImageScale.height) + startPrecinctRowIndex;
                }

                function getPrecinctSizesInImageScale(tile) {
                    var componentsCount = tile.components.length;
                    var minWidth = Number.MAX_VALUE;
                    var minHeight = Number.MAX_VALUE;
                    var maxNumWide = 0;
                    var maxNumHigh = 0;
                    var sizePerComponent = new Array(componentsCount);
                    for (var c = 0; c < componentsCount; c++) {
                        var component = tile.components[c];
                        var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
                        var sizePerResolution = new Array(decompositionLevelsCount + 1);
                        var minWidthCurrentComponent = Number.MAX_VALUE;
                        var minHeightCurrentComponent = Number.MAX_VALUE;
                        var maxNumWideCurrentComponent = 0;
                        var maxNumHighCurrentComponent = 0;
                        var scale = 1;
                        for (var r = decompositionLevelsCount; r >= 0; --r) {
                            var resolution = component.resolutions[r];
                            var widthCurrentResolution = scale * resolution.precinctParameters.precinctWidth;
                            var heightCurrentResolution = scale * resolution.precinctParameters.precinctHeight;
                            minWidthCurrentComponent = Math.min(minWidthCurrentComponent, widthCurrentResolution);
                            minHeightCurrentComponent = Math.min(minHeightCurrentComponent, heightCurrentResolution);
                            maxNumWideCurrentComponent = Math.max(maxNumWideCurrentComponent, resolution.precinctParameters.numprecinctswide);
                            maxNumHighCurrentComponent = Math.max(maxNumHighCurrentComponent, resolution.precinctParameters.numprecinctshigh);
                            sizePerResolution[r] = {
                                width: widthCurrentResolution,
                                height: heightCurrentResolution
                            };
                            scale <<= 1;
                        }
                        minWidth = Math.min(minWidth, minWidthCurrentComponent);
                        minHeight = Math.min(minHeight, minHeightCurrentComponent);
                        maxNumWide = Math.max(maxNumWide, maxNumWideCurrentComponent);
                        maxNumHigh = Math.max(maxNumHigh, maxNumHighCurrentComponent);
                        sizePerComponent[c] = {
                            resolutions: sizePerResolution,
                            minWidth: minWidthCurrentComponent,
                            minHeight: minHeightCurrentComponent,
                            maxNumWide: maxNumWideCurrentComponent,
                            maxNumHigh: maxNumHighCurrentComponent
                        };
                    }
                    return {
                        components: sizePerComponent,
                        minWidth: minWidth,
                        minHeight: minHeight,
                        maxNumWide: maxNumWide,
                        maxNumHigh: maxNumHigh
                    };
                }

                function buildPackets(context) {
                    var siz = context.SIZ;
                    var tileIndex = context.currentTile.index;
                    var tile = context.tiles[tileIndex];
                    var componentsCount = siz.Csiz;
                    for (var c = 0; c < componentsCount; c++) {
                        var component = tile.components[c];
                        var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
                        var resolutions = [];
                        var subbands = [];
                        for (var r = 0; r <= decompositionLevelsCount; r++) {
                            var blocksDimensions = getBlocksDimensions(context, component, r);
                            var resolution = {};
                            var scale = 1 << (decompositionLevelsCount - r);
                            resolution.trx0 = Math.ceil(component.tcx0 / scale);
                            resolution.try0 = Math.ceil(component.tcy0 / scale);
                            resolution.trx1 = Math.ceil(component.tcx1 / scale);
                            resolution.try1 = Math.ceil(component.tcy1 / scale);
                            resolution.resLevel = r;
                            buildPrecincts(context, resolution, blocksDimensions);
                            resolutions.push(resolution);
                            var subband;
                            if (r === 0) {
                                subband = {};
                                subband.type = 'LL';
                                subband.tbx0 = Math.ceil(component.tcx0 / scale);
                                subband.tby0 = Math.ceil(component.tcy0 / scale);
                                subband.tbx1 = Math.ceil(component.tcx1 / scale);
                                subband.tby1 = Math.ceil(component.tcy1 / scale);
                                subband.resolution = resolution;
                                buildCodeblocks(context, subband, blocksDimensions);
                                subbands.push(subband);
                                resolution.subbands = [subband];
                            } else {
                                var bscale = 1 << (decompositionLevelsCount - r + 1);
                                var resolutionSubbands = [];
                                subband = {};
                                subband.type = 'HL';
                                subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
                                subband.tby0 = Math.ceil(component.tcy0 / bscale);
                                subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
                                subband.tby1 = Math.ceil(component.tcy1 / bscale);
                                subband.resolution = resolution;
                                buildCodeblocks(context, subband, blocksDimensions);
                                subbands.push(subband);
                                resolutionSubbands.push(subband);
                                subband = {};
                                subband.type = 'LH';
                                subband.tbx0 = Math.ceil(component.tcx0 / bscale);
                                subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
                                subband.tbx1 = Math.ceil(component.tcx1 / bscale);
                                subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
                                subband.resolution = resolution;
                                buildCodeblocks(context, subband, blocksDimensions);
                                subbands.push(subband);
                                resolutionSubbands.push(subband);
                                subband = {};
                                subband.type = 'HH';
                                subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
                                subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
                                subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
                                subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
                                subband.resolution = resolution;
                                buildCodeblocks(context, subband, blocksDimensions);
                                subbands.push(subband);
                                resolutionSubbands.push(subband);
                                resolution.subbands = resolutionSubbands;
                            }
                        }
                        component.resolutions = resolutions;
                        component.subbands = subbands;
                    }
                    var progressionOrder = tile.codingStyleDefaultParameters.progressionOrder;
                    switch (progressionOrder) {
                        case 0:
                            tile.packetsIterator = new LayerResolutionComponentPositionIterator(context);
                            break;
                        case 1:
                            tile.packetsIterator = new ResolutionLayerComponentPositionIterator(context);
                            break;
                        case 2:
                            tile.packetsIterator = new ResolutionPositionComponentLayerIterator(context);
                            break;
                        case 3:
                            tile.packetsIterator = new PositionComponentResolutionLayerIterator(context);
                            break;
                        case 4:
                            tile.packetsIterator = new ComponentPositionResolutionLayerIterator(context);
                            break;
                        default:
                            throw new Error('JPX Error: Unsupported progression order ' +
                                progressionOrder);
                    }
                }

                function parseTilePackets(context, data, offset, dataLength) {
                    var position = 0;
                    var buffer, bufferSize = 0,
                        skipNextBit = false;

                    function readBits(count) {
                        while (bufferSize < count) {
                            var b = data[offset + position];
                            position++;
                            if (skipNextBit) {
                                buffer = (buffer << 7) | b;
                                bufferSize += 7;
                                skipNextBit = false;
                            } else {
                                buffer = (buffer << 8) | b;
                                bufferSize += 8;
                            }
                            if (b === 0xFF) {
                                skipNextBit = true;
                            }
                        }
                        bufferSize -= count;
                        return (buffer >>> bufferSize) & ((1 << count) - 1);
                    }

                    function skipMarkerIfEqual(value) {
                        if (data[offset + position - 1] === 0xFF && data[offset + position] === value) {
                            skipBytes(1);
                            return true;
                        } else if (data[offset + position] === 0xFF && data[offset + position + 1] === value) {
                            skipBytes(2);
                            return true;
                        }
                        return false;
                    }

                    function skipBytes(count) {
                        position += count;
                    }

                    function alignToByte() {
                        bufferSize = 0;
                        if (skipNextBit) {
                            position++;
                            skipNextBit = false;
                        }
                    }

                    function readCodingpasses() {
                        if (readBits(1) === 0) {
                            return 1;
                        }
                        if (readBits(1) === 0) {
                            return 2;
                        }
                        var value = readBits(2);
                        if (value < 3) {
                            return value + 3;
                        }
                        value = readBits(5);
                        if (value < 31) {
                            return value + 6;
                        }
                        value = readBits(7);
                        return value + 37;
                    }
                    var tileIndex = context.currentTile.index;
                    var tile = context.tiles[tileIndex];
                    var sopMarkerUsed = context.COD.sopMarkerUsed;
                    var ephMarkerUsed = context.COD.ephMarkerUsed;
                    var packetsIterator = tile.packetsIterator;
                    while (position < dataLength) {
                        alignToByte();
                        if (sopMarkerUsed && skipMarkerIfEqual(0x91)) {
                            skipBytes(4);
                        }
                        var packet = packetsIterator.nextPacket();
                        if (!readBits(1)) {
                            continue;
                        }
                        var layerNumber = packet.layerNumber;
                        var queue = [],
                            codeblock;
                        for (var i = 0, ii = packet.codeblocks.length; i < ii; i++) {
                            codeblock = packet.codeblocks[i];
                            var precinct = codeblock.precinct;
                            var codeblockColumn = codeblock.cbx - precinct.cbxMin;
                            var codeblockRow = codeblock.cby - precinct.cbyMin;
                            var codeblockIncluded = false;
                            var firstTimeInclusion = false;
                            var valueReady;
                            if (codeblock['included'] !== undefined) {
                                codeblockIncluded = !!readBits(1);
                            } else {
                                precinct = codeblock.precinct;
                                var inclusionTree, zeroBitPlanesTree;
                                if (precinct['inclusionTree'] !== undefined) {
                                    inclusionTree = precinct.inclusionTree;
                                } else {
                                    var width = precinct.cbxMax - precinct.cbxMin + 1;
                                    var height = precinct.cbyMax - precinct.cbyMin + 1;
                                    inclusionTree = new InclusionTree(width, height, layerNumber);
                                    zeroBitPlanesTree = new TagTree(width, height);
                                    precinct.inclusionTree = inclusionTree;
                                    precinct.zeroBitPlanesTree = zeroBitPlanesTree;
                                }
                                if (inclusionTree.reset(codeblockColumn, codeblockRow, layerNumber)) {
                                    while (true) {
                                        if (readBits(1)) {
                                            valueReady = !inclusionTree.nextLevel();
                                            if (valueReady) {
                                                codeblock.included = true;
                                                codeblockIncluded = firstTimeInclusion = true;
                                                break;
                                            }
                                        } else {
                                            inclusionTree.incrementValue(layerNumber);
                                            break;
                                        }
                                    }
                                }
                            }
                            if (!codeblockIncluded) {
                                continue;
                            }
                            if (firstTimeInclusion) {
                                zeroBitPlanesTree = precinct.zeroBitPlanesTree;
                                zeroBitPlanesTree.reset(codeblockColumn, codeblockRow);
                                while (true) {
                                    if (readBits(1)) {
                                        valueReady = !zeroBitPlanesTree.nextLevel();
                                        if (valueReady) {
                                            break;
                                        }
                                    } else {
                                        zeroBitPlanesTree.incrementValue();
                                    }
                                }
                                codeblock.zeroBitPlanes = zeroBitPlanesTree.value;
                            }
                            var codingpasses = readCodingpasses();
                            while (readBits(1)) {
                                codeblock.Lblock++;
                            }
                            var codingpassesLog2 = log2(codingpasses);
                            var bits = ((codingpasses < (1 << codingpassesLog2)) ? codingpassesLog2 - 1 : codingpassesLog2) + codeblock.Lblock;
                            var codedDataLength = readBits(bits);
                            queue.push({
                                codeblock: codeblock,
                                codingpasses: codingpasses,
                                dataLength: codedDataLength
                            });
                        }
                        alignToByte();
                        if (ephMarkerUsed) {
                            skipMarkerIfEqual(0x92);
                        }
                        while (queue.length > 0) {
                            var packetItem = queue.shift();
                            codeblock = packetItem.codeblock;
                            if (codeblock['data'] === undefined) {
                                codeblock.data = [];
                            }
                            codeblock.data.push({
                                data: data,
                                start: offset + position,
                                end: offset + position + packetItem.dataLength,
                                codingpasses: packetItem.codingpasses
                            });
                            position += packetItem.dataLength;
                        }
                    }
                    return position;
                }

                function copyCoefficients(coefficients, levelWidth, levelHeight, subband, delta, mb, reversible, segmentationSymbolUsed) {
                    var x0 = subband.tbx0;
                    var y0 = subband.tby0;
                    var width = subband.tbx1 - subband.tbx0;
                    var codeblocks = subband.codeblocks;
                    var right = subband.type.charAt(0) === 'H' ? 1 : 0;
                    var bottom = subband.type.charAt(1) === 'H' ? levelWidth : 0;
                    for (var i = 0, ii = codeblocks.length; i < ii; ++i) {
                        var codeblock = codeblocks[i];
                        var blockWidth = codeblock.tbx1_ - codeblock.tbx0_;
                        var blockHeight = codeblock.tby1_ - codeblock.tby0_;
                        if (blockWidth === 0 || blockHeight === 0) {
                            continue;
                        }
                        if (codeblock['data'] === undefined) {
                            continue;
                        }
                        var bitModel, currentCodingpassType;
                        bitModel = new BitModel(blockWidth, blockHeight, codeblock.subbandType, codeblock.zeroBitPlanes, mb);
                        currentCodingpassType = 2;
                        var data = codeblock.data,
                            totalLength = 0,
                            codingpasses = 0;
                        var j, jj, dataItem;
                        for (j = 0, jj = data.length; j < jj; j++) {
                            dataItem = data[j];
                            totalLength += dataItem.end - dataItem.start;
                            codingpasses += dataItem.codingpasses;
                        }
                        var encodedData = new Uint8Array(totalLength);
                        var position = 0;
                        for (j = 0, jj = data.length; j < jj; j++) {
                            dataItem = data[j];
                            var chunk = dataItem.data.subarray(dataItem.start, dataItem.end);
                            encodedData.set(chunk, position);
                            position += chunk.length;
                        }
                        var decoder = new ArithmeticDecoder(encodedData, 0, totalLength);
                        bitModel.setDecoder(decoder);
                        for (j = 0; j < codingpasses; j++) {
                            switch (currentCodingpassType) {
                                case 0:
                                    bitModel.runSignificancePropogationPass();
                                    break;
                                case 1:
                                    bitModel.runMagnitudeRefinementPass();
                                    break;
                                case 2:
                                    bitModel.runCleanupPass();
                                    if (segmentationSymbolUsed) {
                                        bitModel.checkSegmentationSymbol();
                                    }
                                    break;
                            }
                            currentCodingpassType = (currentCodingpassType + 1) % 3;
                        }
                        var offset = (codeblock.tbx0_ - x0) + (codeblock.tby0_ - y0) * width;
                        var sign = bitModel.coefficentsSign;
                        var magnitude = bitModel.coefficentsMagnitude;
                        var bitsDecoded = bitModel.bitsDecoded;
                        var magnitudeCorrection = reversible ? 0 : 0.5;
                        var k, n, nb;
                        position = 0;
                        var interleave = (subband.type !== 'LL');
                        for (j = 0; j < blockHeight; j++) {
                            var row = (offset / width) | 0;
                            var levelOffset = 2 * row * (levelWidth - width) + right + bottom;
                            for (k = 0; k < blockWidth; k++) {
                                n = magnitude[position];
                                if (n !== 0) {
                                    n = (n + magnitudeCorrection) * delta;
                                    if (sign[position] !== 0) {
                                        n = -n;
                                    }
                                    nb = bitsDecoded[position];
                                    var pos = interleave ? (levelOffset + (offset << 1)) : offset;
                                    if (reversible && (nb >= mb)) {
                                        coefficients[pos] = n;
                                    } else {
                                        coefficients[pos] = n * (1 << (mb - nb));
                                    }
                                }
                                offset++;
                                position++;
                            }
                            offset += width - blockWidth;
                        }
                    }
                }

                function transformTile(context, tile, c) {
                    var component = tile.components[c];
                    var codingStyleParameters = component.codingStyleParameters;
                    var quantizationParameters = component.quantizationParameters;
                    var decompositionLevelsCount = codingStyleParameters.decompositionLevelsCount;
                    var spqcds = quantizationParameters.SPqcds;
                    var scalarExpounded = quantizationParameters.scalarExpounded;
                    var guardBits = quantizationParameters.guardBits;
                    var segmentationSymbolUsed = codingStyleParameters.segmentationSymbolUsed;
                    var precision = context.components[c].precision;
                    var reversible = codingStyleParameters.reversibleTransformation;
                    var transform = (reversible ? new ReversibleTransform() : new IrreversibleTransform());
                    var subbandCoefficients = [];
                    var b = 0;
                    for (var i = 0; i <= decompositionLevelsCount; i++) {
                        var resolution = component.resolutions[i];
                        var width = resolution.trx1 - resolution.trx0;
                        var height = resolution.try1 - resolution.try0;
                        var coefficients = new Float32Array(width * height);
                        for (var j = 0, jj = resolution.subbands.length; j < jj; j++) {
                            var mu, epsilon;
                            if (!scalarExpounded) {
                                mu = spqcds[0].mu;
                                epsilon = spqcds[0].epsilon + (i > 0 ? 1 - i : 0);
                            } else {
                                mu = spqcds[b].mu;
                                epsilon = spqcds[b].epsilon;
                                b++;
                            }
                            var subband = resolution.subbands[j];
                            var gainLog2 = SubbandsGainLog2[subband.type];
                            var delta = (reversible ? 1 : Math.pow(2, precision + gainLog2 - epsilon) * (1 + mu / 2048));
                            var mb = (guardBits + epsilon - 1);
                            copyCoefficients(coefficients, width, height, subband, delta, mb, reversible, segmentationSymbolUsed);
                        }
                        subbandCoefficients.push({
                            width: width,
                            height: height,
                            items: coefficients
                        });
                    }
                    var result = transform.calculate(subbandCoefficients, component.tcx0, component.tcy0);
                    return {
                        left: component.tcx0,
                        top: component.tcy0,
                        width: result.width,
                        height: result.height,
                        items: result.items
                    };
                }

                function transformComponents(context) {
                    var siz = context.SIZ;
                    var components = context.components;
                    var componentsCount = siz.Csiz;
                    var resultImages = [];
                    for (var i = 0, ii = context.tiles.length; i < ii; i++) {
                        var tile = context.tiles[i];
                        var transformedTiles = [];
                        var c;
                        for (c = 0; c < componentsCount; c++) {
                            transformedTiles[c] = transformTile(context, tile, c);
                        }
                        var tile0 = transformedTiles[0];
                        var out = new Uint8Array(tile0.items.length * componentsCount);
                        var result = {
                            left: tile0.left,
                            top: tile0.top,
                            width: tile0.width,
                            height: tile0.height,
                            items: out
                        };
                        var shift, offset, max, min, maxK;
                        var pos = 0,
                            j, jj, y0, y1, y2, r, g, b, k, val;
                        if (tile.codingStyleDefaultParameters.multipleComponentTransform) {
                            var fourComponents = componentsCount === 4;
                            var y0items = transformedTiles[0].items;
                            var y1items = transformedTiles[1].items;
                            var y2items = transformedTiles[2].items;
                            var y3items = fourComponents ? transformedTiles[3].items : null;
                            shift = components[0].precision - 8;
                            offset = (128 << shift) + 0.5;
                            max = 255 * (1 << shift);
                            maxK = max * 0.5;
                            min = -maxK;
                            var component0 = tile.components[0];
                            var alpha01 = componentsCount - 3;
                            jj = y0items.length;
                            if (!component0.codingStyleParameters.reversibleTransformation) {
                                for (j = 0; j < jj; j++, pos += alpha01) {
                                    y0 = y0items[j] + offset;
                                    y1 = y1items[j];
                                    y2 = y2items[j];
                                    r = y0 + 1.402 * y2;
                                    g = y0 - 0.34413 * y1 - 0.71414 * y2;
                                    b = y0 + 1.772 * y1;
                                    out[pos++] = r <= 0 ? 0 : r >= max ? 255 : r >> shift;
                                    out[pos++] = g <= 0 ? 0 : g >= max ? 255 : g >> shift;
                                    out[pos++] = b <= 0 ? 0 : b >= max ? 255 : b >> shift;
                                }
                            } else {
                                for (j = 0; j < jj; j++, pos += alpha01) {
                                    y0 = y0items[j] + offset;
                                    y1 = y1items[j];
                                    y2 = y2items[j];
                                    g = y0 - ((y2 + y1) >> 2);
                                    r = g + y2;
                                    b = g + y1;
                                    out[pos++] = r <= 0 ? 0 : r >= max ? 255 : r >> shift;
                                    out[pos++] = g <= 0 ? 0 : g >= max ? 255 : g >> shift;
                                    out[pos++] = b <= 0 ? 0 : b >= max ? 255 : b >> shift;
                                }
                            }
                            if (fourComponents) {
                                for (j = 0, pos = 3; j < jj; j++, pos += 4) {
                                    k = y3items[j];
                                    out[pos] = k <= min ? 0 : k >= maxK ? 255 : (k + offset) >> shift;
                                }
                            }
                        } else {
                            for (c = 0; c < componentsCount; c++) {
                                var items = transformedTiles[c].items;
                                shift = components[c].precision - 8;
                                offset = (128 << shift) + 0.5;
                                max = (127.5 * (1 << shift));
                                min = -max;
                                for (pos = c, j = 0, jj = items.length; j < jj; j++) {
                                    val = items[j];
                                    out[pos] = val <= min ? 0 : val >= max ? 255 : (val + offset) >> shift;
                                    pos += componentsCount;
                                }
                            }
                        }
                        resultImages.push(result);
                    }
                    return resultImages;
                }

                function initializeTile(context, tileIndex) {
                    var siz = context.SIZ;
                    var componentsCount = siz.Csiz;
                    var tile = context.tiles[tileIndex];
                    for (var c = 0; c < componentsCount; c++) {
                        var component = tile.components[c];
                        var qcdOrQcc = (context.currentTile.QCC[c] !== undefined ? context.currentTile.QCC[c] : context.currentTile.QCD);
                        component.quantizationParameters = qcdOrQcc;
                        var codOrCoc = (context.currentTile.COC[c] !== undefined ? context.currentTile.COC[c] : context.currentTile.COD);
                        component.codingStyleParameters = codOrCoc;
                    }
                    tile.codingStyleDefaultParameters = context.currentTile.COD;
                }
                var TagTree = (function TagTreeClosure() {
                    function TagTree(width, height) {
                        var levelsLength = log2(Math.max(width, height)) + 1;
                        this.levels = [];
                        for (var i = 0; i < levelsLength; i++) {
                            var level = {
                                width: width,
                                height: height,
                                items: []
                            };
                            this.levels.push(level);
                            width = Math.ceil(width / 2);
                            height = Math.ceil(height / 2);
                        }
                    }
                    TagTree.prototype = {
                        reset: function TagTree_reset(i, j) {
                            var currentLevel = 0,
                                value = 0,
                                level;
                            while (currentLevel < this.levels.length) {
                                level = this.levels[currentLevel];
                                var index = i + j * level.width;
                                if (level.items[index] !== undefined) {
                                    value = level.items[index];
                                    break;
                                }
                                level.index = index;
                                i >>= 1;
                                j >>= 1;
                                currentLevel++;
                            }
                            currentLevel--;
                            level = this.levels[currentLevel];
                            level.items[level.index] = value;
                            this.currentLevel = currentLevel;
                            delete this.value;
                        },
                        incrementValue: function TagTree_incrementValue() {
                            var level = this.levels[this.currentLevel];
                            level.items[level.index]++;
                        },
                        nextLevel: function TagTree_nextLevel() {
                            var currentLevel = this.currentLevel;
                            var level = this.levels[currentLevel];
                            var value = level.items[level.index];
                            currentLevel--;
                            if (currentLevel < 0) {
                                this.value = value;
                                return false;
                            }
                            this.currentLevel = currentLevel;
                            level = this.levels[currentLevel];
                            level.items[level.index] = value;
                            return true;
                        }
                    };
                    return TagTree;
                })();
                var InclusionTree = (function InclusionTreeClosure() {
                    function InclusionTree(width, height, defaultValue) {
                        var levelsLength = log2(Math.max(width, height)) + 1;
                        this.levels = [];
                        for (var i = 0; i < levelsLength; i++) {
                            var items = new Uint8Array(width * height);
                            for (var j = 0, jj = items.length; j < jj; j++) {
                                items[j] = defaultValue;
                            }
                            var level = {
                                width: width,
                                height: height,
                                items: items
                            };
                            this.levels.push(level);
                            width = Math.ceil(width / 2);
                            height = Math.ceil(height / 2);
                        }
                    }
                    InclusionTree.prototype = {
                        reset: function InclusionTree_reset(i, j, stopValue) {
                            var currentLevel = 0;
                            while (currentLevel < this.levels.length) {
                                var level = this.levels[currentLevel];
                                var index = i + j * level.width;
                                level.index = index;
                                var value = level.items[index];
                                if (value === 0xFF) {
                                    break;
                                }
                                if (value > stopValue) {
                                    this.currentLevel = currentLevel;
                                    this.propagateValues();
                                    return false;
                                }
                                i >>= 1;
                                j >>= 1;
                                currentLevel++;
                            }
                            this.currentLevel = currentLevel - 1;
                            return true;
                        },
                        incrementValue: function InclusionTree_incrementValue(stopValue) {
                            var level = this.levels[this.currentLevel];
                            level.items[level.index] = stopValue + 1;
                            this.propagateValues();
                        },
                        propagateValues: function InclusionTree_propagateValues() {
                            var levelIndex = this.currentLevel;
                            var level = this.levels[levelIndex];
                            var currentValue = level.items[level.index];
                            while (--levelIndex >= 0) {
                                level = this.levels[levelIndex];
                                level.items[level.index] = currentValue;
                            }
                        },
                        nextLevel: function InclusionTree_nextLevel() {
                            var currentLevel = this.currentLevel;
                            var level = this.levels[currentLevel];
                            var value = level.items[level.index];
                            level.items[level.index] = 0xFF;
                            currentLevel--;
                            if (currentLevel < 0) {
                                return false;
                            }
                            this.currentLevel = currentLevel;
                            level = this.levels[currentLevel];
                            level.items[level.index] = value;
                            return true;
                        }
                    };
                    return InclusionTree;
                })();
                var BitModel = (function BitModelClosure() {
                    var UNIFORM_CONTEXT = 17;
                    var RUNLENGTH_CONTEXT = 18;
                    var LLAndLHContextsLabel = new Uint8Array([0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8]);
                    var HLContextLabel = new Uint8Array([0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8]);
                    var HHContextLabel = new Uint8Array([0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5, 5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8]);

                    function BitModel(width, height, subband, zeroBitPlanes, mb) {
                        this.width = width;
                        this.height = height;
                        this.contextLabelTable = (subband === 'HH' ? HHContextLabel : (subband === 'HL' ? HLContextLabel : LLAndLHContextsLabel));
                        var coefficientCount = width * height;
                        this.neighborsSignificance = new Uint8Array(coefficientCount);
                        this.coefficentsSign = new Uint8Array(coefficientCount);
                        this.coefficentsMagnitude = mb > 14 ? new Uint32Array(coefficientCount) : mb > 6 ? new Uint16Array(coefficientCount) : new Uint8Array(coefficientCount);
                        this.processingFlags = new Uint8Array(coefficientCount);
                        var bitsDecoded = new Uint8Array(coefficientCount);
                        if (zeroBitPlanes !== 0) {
                            for (var i = 0; i < coefficientCount; i++) {
                                bitsDecoded[i] = zeroBitPlanes;
                            }
                        }
                        this.bitsDecoded = bitsDecoded;
                        this.reset();
                    }
                    BitModel.prototype = {
                        setDecoder: function BitModel_setDecoder(decoder) {
                            this.decoder = decoder;
                        },
                        reset: function BitModel_reset() {
                            this.contexts = new Int8Array(19);
                            this.contexts[0] = (4 << 1) | 0;
                            this.contexts[UNIFORM_CONTEXT] = (46 << 1) | 0;
                            this.contexts[RUNLENGTH_CONTEXT] = (3 << 1) | 0;
                        },
                        setNeighborsSignificance: function BitModel_setNeighborsSignificance(row, column, index) {
                            var neighborsSignificance = this.neighborsSignificance;
                            var width = this.width,
                                height = this.height;
                            var left = (column > 0);
                            var right = (column + 1 < width);
                            var i;
                            if (row > 0) {
                                i = index - width;
                                if (left) {
                                    neighborsSignificance[i - 1] += 0x10;
                                }
                                if (right) {
                                    neighborsSignificance[i + 1] += 0x10;
                                }
                                neighborsSignificance[i] += 0x04;
                            }
                            if (row + 1 < height) {
                                i = index + width;
                                if (left) {
                                    neighborsSignificance[i - 1] += 0x10;
                                }
                                if (right) {
                                    neighborsSignificance[i + 1] += 0x10;
                                }
                                neighborsSignificance[i] += 0x04;
                            }
                            if (left) {
                                neighborsSignificance[index - 1] += 0x01;
                            }
                            if (right) {
                                neighborsSignificance[index + 1] += 0x01;
                            }
                            neighborsSignificance[index] |= 0x80;
                        },
                        runSignificancePropogationPass: function BitModel_runSignificancePropogationPass() {
                            var decoder = this.decoder;
                            var width = this.width,
                                height = this.height;
                            var coefficentsMagnitude = this.coefficentsMagnitude;
                            var coefficentsSign = this.coefficentsSign;
                            var neighborsSignificance = this.neighborsSignificance;
                            var processingFlags = this.processingFlags;
                            var contexts = this.contexts;
                            var labels = this.contextLabelTable;
                            var bitsDecoded = this.bitsDecoded;
                            var processedInverseMask = ~1;
                            var processedMask = 1;
                            var firstMagnitudeBitMask = 2;
                            for (var i0 = 0; i0 < height; i0 += 4) {
                                for (var j = 0; j < width; j++) {
                                    var index = i0 * width + j;
                                    for (var i1 = 0; i1 < 4; i1++, index += width) {
                                        var i = i0 + i1;
                                        if (i >= height) {
                                            break;
                                        }
                                        processingFlags[index] &= processedInverseMask;
                                        if (coefficentsMagnitude[index] || !neighborsSignificance[index]) {
                                            continue;
                                        }
                                        var contextLabel = labels[neighborsSignificance[index]];
                                        var decision = decoder.readBit(contexts, contextLabel);
                                        if (decision) {
                                            var sign = this.decodeSignBit(i, j, index);
                                            coefficentsSign[index] = sign;
                                            coefficentsMagnitude[index] = 1;
                                            this.setNeighborsSignificance(i, j, index);
                                            processingFlags[index] |= firstMagnitudeBitMask;
                                        }
                                        bitsDecoded[index]++;
                                        processingFlags[index] |= processedMask;
                                    }
                                }
                            }
                        },
                        decodeSignBit: function BitModel_decodeSignBit(row, column, index) {
                            var width = this.width,
                                height = this.height;
                            var coefficentsMagnitude = this.coefficentsMagnitude;
                            var coefficentsSign = this.coefficentsSign;
                            var contribution, sign0, sign1, significance1;
                            var contextLabel, decoded;
                            significance1 = (column > 0 && coefficentsMagnitude[index - 1] !== 0);
                            if (column + 1 < width && coefficentsMagnitude[index + 1] !== 0) {
                                sign1 = coefficentsSign[index + 1];
                                if (significance1) {
                                    sign0 = coefficentsSign[index - 1];
                                    contribution = 1 - sign1 - sign0;
                                } else {
                                    contribution = 1 - sign1 - sign1;
                                }
                            } else if (significance1) {
                                sign0 = coefficentsSign[index - 1];
                                contribution = 1 - sign0 - sign0;
                            } else {
                                contribution = 0;
                            }
                            var horizontalContribution = 3 * contribution;
                            significance1 = (row > 0 && coefficentsMagnitude[index - width] !== 0);
                            if (row + 1 < height && coefficentsMagnitude[index + width] !== 0) {
                                sign1 = coefficentsSign[index + width];
                                if (significance1) {
                                    sign0 = coefficentsSign[index - width];
                                    contribution = 1 - sign1 - sign0 + horizontalContribution;
                                } else {
                                    contribution = 1 - sign1 - sign1 + horizontalContribution;
                                }
                            } else if (significance1) {
                                sign0 = coefficentsSign[index - width];
                                contribution = 1 - sign0 - sign0 + horizontalContribution;
                            } else {
                                contribution = horizontalContribution;
                            }
                            if (contribution >= 0) {
                                contextLabel = 9 + contribution;
                                decoded = this.decoder.readBit(this.contexts, contextLabel);
                            } else {
                                contextLabel = 9 - contribution;
                                decoded = this.decoder.readBit(this.contexts, contextLabel) ^ 1;
                            }
                            return decoded;
                        },
                        runMagnitudeRefinementPass: function BitModel_runMagnitudeRefinementPass() {
                            var decoder = this.decoder;
                            var width = this.width,
                                height = this.height;
                            var coefficentsMagnitude = this.coefficentsMagnitude;
                            var neighborsSignificance = this.neighborsSignificance;
                            var contexts = this.contexts;
                            var bitsDecoded = this.bitsDecoded;
                            var processingFlags = this.processingFlags;
                            var processedMask = 1;
                            var firstMagnitudeBitMask = 2;
                            var length = width * height;
                            var width4 = width * 4;
                            for (var index0 = 0, indexNext; index0 < length; index0 = indexNext) {
                                indexNext = Math.min(length, index0 + width4);
                                for (var j = 0; j < width; j++) {
                                    for (var index = index0 + j; index < indexNext; index += width) {
                                        if (!coefficentsMagnitude[index] || (processingFlags[index] & processedMask) !== 0) {
                                            continue;
                                        }
                                        var contextLabel = 16;
                                        if ((processingFlags[index] & firstMagnitudeBitMask) !== 0) {
                                            processingFlags[index] ^= firstMagnitudeBitMask;
                                            var significance = neighborsSignificance[index] & 127;
                                            contextLabel = significance === 0 ? 15 : 14;
                                        }
                                        var bit = decoder.readBit(contexts, contextLabel);
                                        coefficentsMagnitude[index] = (coefficentsMagnitude[index] << 1) | bit;
                                        bitsDecoded[index]++;
                                        processingFlags[index] |= processedMask;
                                    }
                                }
                            }
                        },
                        runCleanupPass: function BitModel_runCleanupPass() {
                            var decoder = this.decoder;
                            var width = this.width,
                                height = this.height;
                            var neighborsSignificance = this.neighborsSignificance;
                            var coefficentsMagnitude = this.coefficentsMagnitude;
                            var coefficentsSign = this.coefficentsSign;
                            var contexts = this.contexts;
                            var labels = this.contextLabelTable;
                            var bitsDecoded = this.bitsDecoded;
                            var processingFlags = this.processingFlags;
                            var processedMask = 1;
                            var firstMagnitudeBitMask = 2;
                            var oneRowDown = width;
                            var twoRowsDown = width * 2;
                            var threeRowsDown = width * 3;
                            var iNext;
                            for (var i0 = 0; i0 < height; i0 = iNext) {
                                iNext = Math.min(i0 + 4, height);
                                var indexBase = i0 * width;
                                var checkAllEmpty = i0 + 3 < height;
                                for (var j = 0; j < width; j++) {
                                    var index0 = indexBase + j;
                                    var allEmpty = (checkAllEmpty && processingFlags[index0] === 0 && processingFlags[index0 + oneRowDown] === 0 && processingFlags[index0 + twoRowsDown] === 0 && processingFlags[index0 + threeRowsDown] === 0 && neighborsSignificance[index0] === 0 && neighborsSignificance[index0 + oneRowDown] === 0 && neighborsSignificance[index0 + twoRowsDown] === 0 && neighborsSignificance[index0 + threeRowsDown] === 0);
                                    var i1 = 0,
                                        index = index0;
                                    var i = i0,
                                        sign;
                                    if (allEmpty) {
                                        var hasSignificantCoefficent = decoder.readBit(contexts, RUNLENGTH_CONTEXT);
                                        if (!hasSignificantCoefficent) {
                                            bitsDecoded[index0]++;
                                            bitsDecoded[index0 + oneRowDown]++;
                                            bitsDecoded[index0 + twoRowsDown]++;
                                            bitsDecoded[index0 + threeRowsDown]++;
                                            continue;
                                        }
                                        i1 = (decoder.readBit(contexts, UNIFORM_CONTEXT) << 1) | decoder.readBit(contexts, UNIFORM_CONTEXT);
                                        if (i1 !== 0) {
                                            i = i0 + i1;
                                            index += i1 * width;
                                        }
                                        sign = this.decodeSignBit(i, j, index);
                                        coefficentsSign[index] = sign;
                                        coefficentsMagnitude[index] = 1;
                                        this.setNeighborsSignificance(i, j, index);
                                        processingFlags[index] |= firstMagnitudeBitMask;
                                        index = index0;
                                        for (var i2 = i0; i2 <= i; i2++, index += width) {
                                            bitsDecoded[index]++;
                                        }
                                        i1++;
                                    }
                                    for (i = i0 + i1; i < iNext; i++, index += width) {
                                        if (coefficentsMagnitude[index] || (processingFlags[index] & processedMask) !== 0) {
                                            continue;
                                        }
                                        var contextLabel = labels[neighborsSignificance[index]];
                                        var decision = decoder.readBit(contexts, contextLabel);
                                        if (decision === 1) {
                                            sign = this.decodeSignBit(i, j, index);
                                            coefficentsSign[index] = sign;
                                            coefficentsMagnitude[index] = 1;
                                            this.setNeighborsSignificance(i, j, index);
                                            processingFlags[index] |= firstMagnitudeBitMask;
                                        }
                                        bitsDecoded[index]++;
                                    }
                                }
                            }
                        },
                        checkSegmentationSymbol: function BitModel_checkSegmentationSymbol() {
                            var decoder = this.decoder;
                            var contexts = this.contexts;
                            var symbol = (decoder.readBit(contexts, UNIFORM_CONTEXT) << 3) | (decoder.readBit(contexts, UNIFORM_CONTEXT) << 2) | (decoder.readBit(contexts, UNIFORM_CONTEXT) << 1) | decoder.readBit(contexts, UNIFORM_CONTEXT);
                            if (symbol !== 0xA) {
                                throw new Error('JPX Error: Invalid segmentation symbol');
                            }
                        }
                    };
                    return BitModel;
                })();
                var Transform = (function TransformClosure() {
                    function Transform() {}
                    Transform.prototype.calculate = function transformCalculate(subbands, u0, v0) {
                        var ll = subbands[0];
                        for (var i = 1, ii = subbands.length; i < ii; i++) {
                            ll = this.iterate(ll, subbands[i], u0, v0);
                        }
                        return ll;
                    };
                    Transform.prototype.extend = function extend(buffer, offset, size) {
                        var i1 = offset - 1,
                            j1 = offset + 1;
                        var i2 = offset + size - 2,
                            j2 = offset + size;
                        buffer[i1--] = buffer[j1++];
                        buffer[j2++] = buffer[i2--];
                        buffer[i1--] = buffer[j1++];
                        buffer[j2++] = buffer[i2--];
                        buffer[i1--] = buffer[j1++];
                        buffer[j2++] = buffer[i2--];
                        buffer[i1] = buffer[j1];
                        buffer[j2] = buffer[i2];
                    };
                    Transform.prototype.iterate = function Transform_iterate(ll, hl_lh_hh, u0, v0) {
                        var llWidth = ll.width,
                            llHeight = ll.height,
                            llItems = ll.items;
                        var width = hl_lh_hh.width;
                        var height = hl_lh_hh.height;
                        var items = hl_lh_hh.items;
                        var i, j, k, l, u, v;
                        for (k = 0, i = 0; i < llHeight; i++) {
                            l = i * 2 * width;
                            for (j = 0; j < llWidth; j++, k++, l += 2) {
                                items[l] = llItems[k];
                            }
                        }
                        llItems = ll.items = null;
                        var bufferPadding = 4;
                        var rowBuffer = new Float32Array(width + 2 * bufferPadding);
                        if (width === 1) {
                            if ((u0 & 1) !== 0) {
                                for (v = 0, k = 0; v < height; v++, k += width) {
                                    items[k] *= 0.5;
                                }
                            }
                        } else {
                            for (v = 0, k = 0; v < height; v++, k += width) {
                                rowBuffer.set(items.subarray(k, k + width), bufferPadding);
                                this.extend(rowBuffer, bufferPadding, width);
                                this.filter(rowBuffer, bufferPadding, width);
                                items.set(rowBuffer.subarray(bufferPadding, bufferPadding + width), k);
                            }
                        }
                        var numBuffers = 16;
                        var colBuffers = [];
                        for (i = 0; i < numBuffers; i++) {
                            colBuffers.push(new Float32Array(height + 2 * bufferPadding));
                        }
                        var b, currentBuffer = 0;
                        ll = bufferPadding + height;
                        if (height === 1) {
                            if ((v0 & 1) !== 0) {
                                for (u = 0; u < width; u++) {
                                    items[u] *= 0.5;
                                }
                            }
                        } else {
                            for (u = 0; u < width; u++) {
                                if (currentBuffer === 0) {
                                    numBuffers = Math.min(width - u, numBuffers);
                                    for (k = u, l = bufferPadding; l < ll; k += width, l++) {
                                        for (b = 0; b < numBuffers; b++) {
                                            colBuffers[b][l] = items[k + b];
                                        }
                                    }
                                    currentBuffer = numBuffers;
                                }
                                currentBuffer--;
                                var buffer = colBuffers[currentBuffer];
                                this.extend(buffer, bufferPadding, height);
                                this.filter(buffer, bufferPadding, height);
                                if (currentBuffer === 0) {
                                    k = u - numBuffers + 1;
                                    for (l = bufferPadding; l < ll; k += width, l++) {
                                        for (b = 0; b < numBuffers; b++) {
                                            items[k + b] = colBuffers[b][l];
                                        }
                                    }
                                }
                            }
                        }
                        return {
                            width: width,
                            height: height,
                            items: items
                        };
                    };
                    return Transform;
                })();
                var IrreversibleTransform = (function IrreversibleTransformClosure() {
                    function IrreversibleTransform() {
                        Transform.call(this);
                    }
                    IrreversibleTransform.prototype = Object.create(Transform.prototype);
                    IrreversibleTransform.prototype.filter = function irreversibleTransformFilter(x, offset, length) {
                        var len = length >> 1;
                        offset = offset | 0;
                        var j, n, current, next;
                        var alpha = -1.586134342059924;
                        var beta = -0.052980118572961;
                        var gamma = 0.882911075530934;
                        var delta = 0.443506852043971;
                        var K = 1.230174104914001;
                        var K_ = 1 / K;
                        j = offset - 3;
                        for (n = len + 4; n--; j += 2) {
                            x[j] *= K_;
                        }
                        j = offset - 2;
                        current = delta * x[j - 1];
                        for (n = len + 3; n--; j += 2) {
                            next = delta * x[j + 1];
                            x[j] = K * x[j] - current - next;
                            if (n--) {
                                j += 2;
                                current = delta * x[j + 1];
                                x[j] = K * x[j] - current - next;
                            } else {
                                break;
                            }
                        }
                        j = offset - 1;
                        current = gamma * x[j - 1];
                        for (n = len + 2; n--; j += 2) {
                            next = gamma * x[j + 1];
                            x[j] -= current + next;
                            if (n--) {
                                j += 2;
                                current = gamma * x[j + 1];
                                x[j] -= current + next;
                            } else {
                                break;
                            }
                        }
                        j = offset;
                        current = beta * x[j - 1];
                        for (n = len + 1; n--; j += 2) {
                            next = beta * x[j + 1];
                            x[j] -= current + next;
                            if (n--) {
                                j += 2;
                                current = beta * x[j + 1];
                                x[j] -= current + next;
                            } else {
                                break;
                            }
                        }
                        if (len !== 0) {
                            j = offset + 1;
                            current = alpha * x[j - 1];
                            for (n = len; n--; j += 2) {
                                next = alpha * x[j + 1];
                                x[j] -= current + next;
                                if (n--) {
                                    j += 2;
                                    current = alpha * x[j + 1];
                                    x[j] -= current + next;
                                } else {
                                    break;
                                }
                            }
                        }
                    };
                    return IrreversibleTransform;
                })();
                var ReversibleTransform = (function ReversibleTransformClosure() {
                    function ReversibleTransform() {
                        Transform.call(this);
                    }
                    ReversibleTransform.prototype = Object.create(Transform.prototype);
                    ReversibleTransform.prototype.filter = function reversibleTransformFilter(x, offset, length) {
                        var len = length >> 1;
                        offset = offset | 0;
                        var j, n;
                        for (j = offset, n = len + 1; n--; j += 2) {
                            x[j] -= (x[j - 1] + x[j + 1] + 2) >> 2;
                        }
                        for (j = offset + 1, n = len; n--; j += 2) {
                            x[j] += (x[j - 1] + x[j + 1]) >> 1;
                        }
                    };
                    return ReversibleTransform;
                })();
                return JpxImage;
            })();
            exports.JpxImage = JpxImage;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsCoreMurmurHash3 = {}), root.pdfjsSharedUtil);
            }
        }(this, function(exports, sharedUtil) {
            var Uint32ArrayView = sharedUtil.Uint32ArrayView;
            var MurmurHash3_64 = (function MurmurHash3_64Closure(seed) {
                var MASK_HIGH = 0xffff0000;
                var MASK_LOW = 0xffff;

                function MurmurHash3_64(seed) {
                    var SEED = 0xc3d2e1f0;
                    this.h1 = seed ? seed & 0xffffffff : SEED;
                    this.h2 = seed ? seed & 0xffffffff : SEED;
                }
                var alwaysUseUint32ArrayView = false;
                try {
                    new Uint32Array(new Uint8Array(5).buffer, 0, 1);
                } catch (e) {
                    alwaysUseUint32ArrayView = true;
                }
                MurmurHash3_64.prototype = {
                    update: function MurmurHash3_64_update(input) {
                        var useUint32ArrayView = alwaysUseUint32ArrayView;
                        var i;
                        if (typeof input === 'string') {
                            var data = new Uint8Array(input.length * 2);
                            var length = 0;
                            for (i = 0; i < input.length; i++) {
                                var code = input.charCodeAt(i);
                                if (code <= 0xff) {
                                    data[length++] = code;
                                } else {
                                    data[length++] = code >>> 8;
                                    data[length++] = code & 0xff;
                                }
                            }
                        } else if (input instanceof Uint8Array) {
                            data = input;
                            length = data.length;
                        } else if (typeof input === 'object' && ('length' in input)) {
                            data = input;
                            length = data.length;
                            useUint32ArrayView = true;
                        } else {
                            throw new Error('Wrong data format in MurmurHash3_64_update. ' + 'Input must be a string or array.');
                        }
                        var blockCounts = length >> 2;
                        var tailLength = length - blockCounts * 4;
                        var dataUint32 = useUint32ArrayView ? new Uint32ArrayView(data, blockCounts) : new Uint32Array(data.buffer, 0, blockCounts);
                        var k1 = 0;
                        var k2 = 0;
                        var h1 = this.h1;
                        var h2 = this.h2;
                        var C1 = 0xcc9e2d51;
                        var C2 = 0x1b873593;
                        var C1_LOW = C1 & MASK_LOW;
                        var C2_LOW = C2 & MASK_LOW;
                        for (i = 0; i < blockCounts; i++) {
                            if (i & 1) {
                                k1 = dataUint32[i];
                                k1 = (k1 * C1 & MASK_HIGH) | (k1 * C1_LOW & MASK_LOW);
                                k1 = k1 << 15 | k1 >>> 17;
                                k1 = (k1 * C2 & MASK_HIGH) | (k1 * C2_LOW & MASK_LOW);
                                h1 ^= k1;
                                h1 = h1 << 13 | h1 >>> 19;
                                h1 = h1 * 5 + 0xe6546b64;
                            } else {
                                k2 = dataUint32[i];
                                k2 = (k2 * C1 & MASK_HIGH) | (k2 * C1_LOW & MASK_LOW);
                                k2 = k2 << 15 | k2 >>> 17;
                                k2 = (k2 * C2 & MASK_HIGH) | (k2 * C2_LOW & MASK_LOW);
                                h2 ^= k2;
                                h2 = h2 << 13 | h2 >>> 19;
                                h2 = h2 * 5 + 0xe6546b64;
                            }
                        }
                        k1 = 0;
                        switch (tailLength) {
                            case 3:
                                k1 ^= data[blockCounts * 4 + 2] << 16;
                            case 2:
                                k1 ^= data[blockCounts * 4 + 1] << 8;
                            case 1:
                                k1 ^= data[blockCounts * 4];
                                k1 = (k1 * C1 & MASK_HIGH) | (k1 * C1_LOW & MASK_LOW);
                                k1 = k1 << 15 | k1 >>> 17;
                                k1 = (k1 * C2 & MASK_HIGH) | (k1 * C2_LOW & MASK_LOW);
                                if (blockCounts & 1) {
                                    h1 ^= k1;
                                } else {
                                    h2 ^= k1;
                                }
                        }
                        this.h1 = h1;
                        this.h2 = h2;
                        return this;
                    },
                    hexdigest: function MurmurHash3_64_hexdigest() {
                        var h1 = this.h1;
                        var h2 = this.h2;
                        h1 ^= h2 >>> 1;
                        h1 = (h1 * 0xed558ccd & MASK_HIGH) | (h1 * 0x8ccd & MASK_LOW);
                        h2 = (h2 * 0xff51afd7 & MASK_HIGH) | (((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16);
                        h1 ^= h2 >>> 1;
                        h1 = (h1 * 0x1a85ec53 & MASK_HIGH) | (h1 * 0xec53 & MASK_LOW);
                        h2 = (h2 * 0xc4ceb9fe & MASK_HIGH) | (((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16);
                        h1 ^= h2 >>> 1;
                        for (var i = 0, arr = [h1, h2], str = ''; i < arr.length; i++) {
                            var hex = (arr[i] >>> 0).toString(16);
                            while (hex.length < 8) {
                                hex = '0' + hex;
                            }
                            str += hex;
                        }
                        return str;
                    }
                };
                return MurmurHash3_64;
            })();
            exports.MurmurHash3_64 = MurmurHash3_64;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsCorePrimitives = {}), root.pdfjsSharedUtil);
            }
        }(this, function(exports, sharedUtil) {
            var isArray = sharedUtil.isArray;
            var Name = (function NameClosure() {
                function Name(name) {
                    this.name = name;
                }
                Name.prototype = {};
                var nameCache = {};
                Name.get = function Name_get(name) {
                    var nameValue = nameCache[name];
                    return (nameValue ? nameValue : (nameCache[name] = new Name(name)));
                };
                return Name;
            })();
            var Cmd = (function CmdClosure() {
                function Cmd(cmd) {
                    this.cmd = cmd;
                }
                Cmd.prototype = {};
                var cmdCache = {};
                Cmd.get = function Cmd_get(cmd) {
                    var cmdValue = cmdCache[cmd];
                    return (cmdValue ? cmdValue : (cmdCache[cmd] = new Cmd(cmd)));
                };
                return Cmd;
            })();
            var Dict = (function DictClosure() {
                var nonSerializable = function nonSerializableClosure() {
                    return nonSerializable;
                };
                var GETALL_DICTIONARY_TYPES_WHITELIST = {
                    'Background': true,
                    'ExtGState': true,
                    'Halftone': true,
                    'Layout': true,
                    'Mask': true,
                    'Pagination': true,
                    'Printing': true
                };

                function isRecursionAllowedFor(dict) {
                    if (!isName(dict.Type)) {
                        return true;
                    }
                    var dictType = dict.Type.name;
                    return GETALL_DICTIONARY_TYPES_WHITELIST[dictType] === true;
                }

                function Dict(xref) {
                    this.map = Object.create(null);
                    this.xref = xref;
                    this.objId = null;
                    this.__nonSerializable__ = nonSerializable;
                }
                Dict.prototype = {
                    assignXref: function Dict_assignXref(newXref) {
                        this.xref = newXref;
                    },
                    get: function Dict_get(key1, key2, key3) {
                        var value;
                        var xref = this.xref;
                        if (typeof(value = this.map[key1]) !== 'undefined' || key1 in this.map || typeof key2 === 'undefined') {
                            return xref ? xref.fetchIfRef(value) : value;
                        }
                        if (typeof(value = this.map[key2]) !== 'undefined' || key2 in this.map || typeof key3 === 'undefined') {
                            return xref ? xref.fetchIfRef(value) : value;
                        }
                        value = this.map[key3] || null;
                        return xref ? xref.fetchIfRef(value) : value;
                    },
                    getAsync: function Dict_getAsync(key1, key2, key3) {
                        var value;
                        var xref = this.xref;
                        if (typeof(value = this.map[key1]) !== 'undefined' || key1 in this.map || typeof key2 === 'undefined') {
                            if (xref) {
                                return xref.fetchIfRefAsync(value);
                            }
                            return Promise.resolve(value);
                        }
                        if (typeof(value = this.map[key2]) !== 'undefined' || key2 in this.map || typeof key3 === 'undefined') {
                            if (xref) {
                                return xref.fetchIfRefAsync(value);
                            }
                            return Promise.resolve(value);
                        }
                        value = this.map[key3] || null;
                        if (xref) {
                            return xref.fetchIfRefAsync(value);
                        }
                        return Promise.resolve(value);
                    },
                    getArray: function Dict_getArray(key1, key2, key3) {
                        var value = this.get(key1, key2, key3);
                        var xref = this.xref;
                        if (!isArray(value) || !xref) {
                            return value;
                        }
                        value = value.slice();
                        for (var i = 0, ii = value.length; i < ii; i++) {
                            if (!isRef(value[i])) {
                                continue;
                            }
                            value[i] = xref.fetch(value[i]);
                        }
                        return value;
                    },
                    getRaw: function Dict_getRaw(key) {
                        return this.map[key];
                    },
                    getAll: function Dict_getAll() {
                        var all = Object.create(null);
                        var queue = null;
                        var key, obj;
                        for (key in this.map) {
                            obj = this.get(key);
                            if (obj instanceof Dict) {
                                if (isRecursionAllowedFor(obj)) {
                                    (queue || (queue = [])).push({
                                        target: all,
                                        key: key,
                                        obj: obj
                                    });
                                } else {
                                    all[key] = this.getRaw(key);
                                }
                            } else {
                                all[key] = obj;
                            }
                        }
                        if (!queue) {
                            return all;
                        }
                        var processed = Object.create(null);
                        while (queue.length > 0) {
                            var item = queue.shift();
                            var itemObj = item.obj;
                            var objId = itemObj.objId;
                            if (objId && objId in processed) {
                                item.target[item.key] = processed[objId];
                                continue;
                            }
                            var dereferenced = Object.create(null);
                            for (key in itemObj.map) {
                                obj = itemObj.get(key);
                                if (obj instanceof Dict) {
                                    if (isRecursionAllowedFor(obj)) {
                                        queue.push({
                                            target: dereferenced,
                                            key: key,
                                            obj: obj
                                        });
                                    } else {
                                        dereferenced[key] = itemObj.getRaw(key);
                                    }
                                } else {
                                    dereferenced[key] = obj;
                                }
                            }
                            if (objId) {
                                processed[objId] = dereferenced;
                            }
                            item.target[item.key] = dereferenced;
                        }
                        return all;
                    },
                    getKeys: function Dict_getKeys() {
                        return Object.keys(this.map);
                    },
                    set: function Dict_set(key, value) {
                        this.map[key] = value;
                    },
                    has: function Dict_has(key) {
                        return key in this.map;
                    },
                    forEach: function Dict_forEach(callback) {
                        for (var key in this.map) {
                            callback(key, this.get(key));
                        }
                    }
                };
                Dict.empty = new Dict(null);
                Dict.merge = function Dict_merge(xref, dictArray) {
                    var mergedDict = new Dict(xref);
                    for (var i = 0, ii = dictArray.length; i < ii; i++) {
                        var dict = dictArray[i];
                        if (!isDict(dict)) {
                            continue;
                        }
                        for (var keyName in dict.map) {
                            if (mergedDict.map[keyName]) {
                                continue;
                            }
                            mergedDict.map[keyName] = dict.map[keyName];
                        }
                    }
                    return mergedDict;
                };
                return Dict;
            })();
            var Ref = (function RefClosure() {
                function Ref(num, gen) {
                    this.num = num;
                    this.gen = gen;
                }
                Ref.prototype = {
                    toString: function Ref_toString() {
                        var str = this.num + 'R';
                        if (this.gen !== 0) {
                            str += this.gen;
                        }
                        return str;
                    }
                };
                return Ref;
            })();
            var RefSet = (function RefSetClosure() {
                function RefSet() {
                    this.dict = {};
                }
                RefSet.prototype = {
                    has: function RefSet_has(ref) {
                        return ref.toString() in this.dict;
                    },
                    put: function RefSet_put(ref) {
                        this.dict[ref.toString()] = true;
                    },
                    remove: function RefSet_remove(ref) {
                        delete this.dict[ref.toString()];
                    }
                };
                return RefSet;
            })();
            var RefSetCache = (function RefSetCacheClosure() {
                function RefSetCache() {
                    this.dict = Object.create(null);
                }
                RefSetCache.prototype = {
                    get: function RefSetCache_get(ref) {
                        return this.dict[ref.toString()];
                    },
                    has: function RefSetCache_has(ref) {
                        return ref.toString() in this.dict;
                    },
                    put: function RefSetCache_put(ref, obj) {
                        this.dict[ref.toString()] = obj;
                    },
                    putAlias: function RefSetCache_putAlias(ref, aliasRef) {
                        this.dict[ref.toString()] = this.get(aliasRef);
                    },
                    forEach: function RefSetCache_forEach(fn, thisArg) {
                        for (var i in this.dict) {
                            fn.call(thisArg, this.dict[i]);
                        }
                    },
                    clear: function RefSetCache_clear() {
                        this.dict = Object.create(null);
                    }
                };
                return RefSetCache;
            })();

            function isName(v) {
                return v instanceof Name;
            }

            function isCmd(v, cmd) {
                return v instanceof Cmd && (cmd === undefined || v.cmd === cmd);
            }

            function isDict(v, type) {
                if (!(v instanceof Dict)) {
                    return false;
                }
                if (!type) {
                    return true;
                }
                var dictType = v.get('Type');
                return isName(dictType) && dictType.name === type;
            }

            function isRef(v) {
                return v instanceof Ref;
            }

            function isStream(v) {
                return typeof v === 'object' && v !== null && v.getBytes !== undefined;
            }
            exports.Cmd = Cmd;
            exports.Dict = Dict;
            exports.Name = Name;
            exports.Ref = Ref;
            exports.RefSet = RefSet;
            exports.RefSetCache = RefSetCache;
            exports.isCmd = isCmd;
            exports.isDict = isDict;
            exports.isName = isName;
            exports.isRef = isRef;
            exports.isStream = isStream;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsCoreStream = {}), root.pdfjsSharedUtil, root.pdfjsCorePrimitives, root.pdfjsCoreJbig2, root.pdfjsCoreJpg, root.pdfjsCoreJpx);
            }
        }(this, function(exports, sharedUtil, corePrimitives, coreJbig2, coreJpg, coreJpx) {
            var Util = sharedUtil.Util;
            var error = sharedUtil.error;
            var info = sharedUtil.info;
            var isArray = sharedUtil.isArray;
            var shadow = sharedUtil.shadow;
            var warn = sharedUtil.warn;
            var Dict = corePrimitives.Dict;
            var Jbig2Image = coreJbig2.Jbig2Image;
            var JpegImage = coreJpg.JpegImage;
            var JpxImage = coreJpx.JpxImage;
            var coreParser;
            var EOF;
            var Lexer;
            var coreColorSpace;
            var ColorSpace;
            var Stream = (function StreamClosure() {
                function Stream(arrayBuffer, start, length, dict) {
                    this.bytes = (arrayBuffer instanceof Uint8Array ? arrayBuffer : new Uint8Array(arrayBuffer));
                    this.start = start || 0;
                    this.pos = this.start;
                    this.end = (start + length) || this.bytes.length;
                    this.dict = dict;
                }
                Stream.prototype = {
                    get length() {
                        return this.end - this.start;
                    },
                    get isEmpty() {
                        return this.length === 0;
                    },
                    getByte: function Stream_getByte() {
                        if (this.pos >= this.end) {
                            return -1;
                        }
                        return this.bytes[this.pos++];
                    },
                    getUint16: function Stream_getUint16() {
                        var b0 = this.getByte();
                        var b1 = this.getByte();
                        if (b0 === -1 || b1 === -1) {
                            return -1;
                        }
                        return (b0 << 8) + b1;
                    },
                    getInt32: function Stream_getInt32() {
                        var b0 = this.getByte();
                        var b1 = this.getByte();
                        var b2 = this.getByte();
                        var b3 = this.getByte();
                        return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
                    },
                    getBytes: function Stream_getBytes(length) {
                        var bytes = this.bytes;
                        var pos = this.pos;
                        var strEnd = this.end;
                        if (!length) {
                            return bytes.subarray(pos, strEnd);
                        }
                        var end = pos + length;
                        if (end > strEnd) {
                            end = strEnd;
                        }
                        this.pos = end;
                        return bytes.subarray(pos, end);
                    },
                    peekByte: function Stream_peekByte() {
                        var peekedByte = this.getByte();
                        this.pos--;
                        return peekedByte;
                    },
                    peekBytes: function Stream_peekBytes(length) {
                        var bytes = this.getBytes(length);
                        this.pos -= bytes.length;
                        return bytes;
                    },
                    skip: function Stream_skip(n) {
                        if (!n) {
                            n = 1;
                        }
                        this.pos += n;
                    },
                    reset: function Stream_reset() {
                        this.pos = this.start;
                    },
                    moveStart: function Stream_moveStart() {
                        this.start = this.pos;
                    },
                    makeSubStream: function Stream_makeSubStream(start, length, dict) {
                        return new Stream(this.bytes.buffer, start, length, dict);
                    },
                    isStream: true
                };
                return Stream;
            })();
            var StringStream = (function StringStreamClosure() {
                function StringStream(str) {
                    var length = str.length;
                    var bytes = new Uint8Array(length);
                    for (var n = 0; n < length; ++n) {
                        bytes[n] = str.charCodeAt(n);
                    }
                    Stream.call(this, bytes);
                }
                StringStream.prototype = Stream.prototype;
                return StringStream;
            })();
            var DecodeStream = (function DecodeStreamClosure() {
                var emptyBuffer = new Uint8Array(0);

                function DecodeStream(maybeMinBufferLength) {
                    this.pos = 0;
                    this.bufferLength = 0;
                    this.eof = false;
                    this.buffer = emptyBuffer;
                    this.minBufferLength = 512;
                    if (maybeMinBufferLength) {
                        while (this.minBufferLength < maybeMinBufferLength) {
                            this.minBufferLength *= 2;
                        }
                    }
                }
                DecodeStream.prototype = {
                    get isEmpty() {
                        while (!this.eof && this.bufferLength === 0) {
                            this.readBlock();
                        }
                        return this.bufferLength === 0;
                    },
                    ensureBuffer: function DecodeStream_ensureBuffer(requested) {
                        var buffer = this.buffer;
                        if (requested <= buffer.byteLength) {
                            return buffer;
                        }
                        var size = this.minBufferLength;
                        while (size < requested) {
                            size *= 2;
                        }
                        var buffer2 = new Uint8Array(size);
                        buffer2.set(buffer);
                        return (this.buffer = buffer2);
                    },
                    getByte: function DecodeStream_getByte() {
                        var pos = this.pos;
                        while (this.bufferLength <= pos) {
                            if (this.eof) {
                                return -1;
                            }
                            this.readBlock();
                        }
                        return this.buffer[this.pos++];
                    },
                    getUint16: function DecodeStream_getUint16() {
                        var b0 = this.getByte();
                        var b1 = this.getByte();
                        if (b0 === -1 || b1 === -1) {
                            return -1;
                        }
                        return (b0 << 8) + b1;
                    },
                    getInt32: function DecodeStream_getInt32() {
                        var b0 = this.getByte();
                        var b1 = this.getByte();
                        var b2 = this.getByte();
                        var b3 = this.getByte();
                        return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
                    },
                    getBytes: function DecodeStream_getBytes(length) {
                        var end, pos = this.pos;
                        if (length) {
                            this.ensureBuffer(pos + length);
                            end = pos + length;
                            while (!this.eof && this.bufferLength < end) {
                                this.readBlock();
                            }
                            var bufEnd = this.bufferLength;
                            if (end > bufEnd) {
                                end = bufEnd;
                            }
                        } else {
                            while (!this.eof) {
                                this.readBlock();
                            }
                            end = this.bufferLength;
                        }
                        this.pos = end;
                        return this.buffer.subarray(pos, end);
                    },
                    peekByte: function DecodeStream_peekByte() {
                        var peekedByte = this.getByte();
                        this.pos--;
                        return peekedByte;
                    },
                    peekBytes: function DecodeStream_peekBytes(length) {
                        var bytes = this.getBytes(length);
                        this.pos -= bytes.length;
                        return bytes;
                    },
                    makeSubStream: function DecodeStream_makeSubStream(start, length, dict) {
                        var end = start + length;
                        while (this.bufferLength <= end && !this.eof) {
                            this.readBlock();
                        }
                        return new Stream(this.buffer, start, length, dict);
                    },
                    skip: function DecodeStream_skip(n) {
                        if (!n) {
                            n = 1;
                        }
                        this.pos += n;
                    },
                    reset: function DecodeStream_reset() {
                        this.pos = 0;
                    },
                    getBaseStreams: function DecodeStream_getBaseStreams() {
                        if (this.str && this.str.getBaseStreams) {
                            return this.str.getBaseStreams();
                        }
                        return [];
                    }
                };
                return DecodeStream;
            })();
            var StreamsSequenceStream = (function StreamsSequenceStreamClosure() {
                function StreamsSequenceStream(streams) {
                    this.streams = streams;
                    DecodeStream.call(this, null);
                }
                StreamsSequenceStream.prototype = Object.create(DecodeStream.prototype);
                StreamsSequenceStream.prototype.readBlock = function streamSequenceStreamReadBlock() {
                    var streams = this.streams;
                    if (streams.length === 0) {
                        this.eof = true;
                        return;
                    }
                    var stream = streams.shift();
                    var chunk = stream.getBytes();
                    var bufferLength = this.bufferLength;
                    var newLength = bufferLength + chunk.length;
                    var buffer = this.ensureBuffer(newLength);
                    buffer.set(chunk, bufferLength);
                    this.bufferLength = newLength;
                };
                StreamsSequenceStream.prototype.getBaseStreams = function StreamsSequenceStream_getBaseStreams() {
                    var baseStreams = [];
                    for (var i = 0, ii = this.streams.length; i < ii; i++) {
                        var stream = this.streams[i];
                        if (stream.getBaseStreams) {
                            Util.appendToArray(baseStreams, stream.getBaseStreams());
                        }
                    }
                    return baseStreams;
                };
                return StreamsSequenceStream;
            })();
            var FlateStream = (function FlateStreamClosure() {
                var codeLenCodeMap = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
                var lengthDecode = new Int32Array([0x00003, 0x00004, 0x00005, 0x00006, 0x00007, 0x00008, 0x00009, 0x0000a, 0x1000b, 0x1000d, 0x1000f, 0x10011, 0x20013, 0x20017, 0x2001b, 0x2001f, 0x30023, 0x3002b, 0x30033, 0x3003b, 0x40043, 0x40053, 0x40063, 0x40073, 0x50083, 0x500a3, 0x500c3, 0x500e3, 0x00102, 0x00102, 0x00102]);
                var distDecode = new Int32Array([0x00001, 0x00002, 0x00003, 0x00004, 0x10005, 0x10007, 0x20009, 0x2000d, 0x30011, 0x30019, 0x40021, 0x40031, 0x50041, 0x50061, 0x60081, 0x600c1, 0x70101, 0x70181, 0x80201, 0x80301, 0x90401, 0x90601, 0xa0801, 0xa0c01, 0xb1001, 0xb1801, 0xc2001, 0xc3001, 0xd4001, 0xd6001]);
                var fixedLitCodeTab = [new Int32Array([0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c0, 0x70108, 0x80060, 0x80020, 0x900a0, 0x80000, 0x80080, 0x80040, 0x900e0, 0x70104, 0x80058, 0x80018, 0x90090, 0x70114, 0x80078, 0x80038, 0x900d0, 0x7010c, 0x80068, 0x80028, 0x900b0, 0x80008, 0x80088, 0x80048, 0x900f0, 0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c8, 0x7010a, 0x80064, 0x80024, 0x900a8, 0x80004, 0x80084, 0x80044, 0x900e8, 0x70106, 0x8005c, 0x8001c, 0x90098, 0x70116, 0x8007c, 0x8003c, 0x900d8, 0x7010e, 0x8006c, 0x8002c, 0x900b8, 0x8000c, 0x8008c, 0x8004c, 0x900f8, 0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c4, 0x70109, 0x80062, 0x80022, 0x900a4, 0x80002, 0x80082, 0x80042, 0x900e4, 0x70105, 0x8005a, 0x8001a, 0x90094, 0x70115, 0x8007a, 0x8003a, 0x900d4, 0x7010d, 0x8006a, 0x8002a, 0x900b4, 0x8000a, 0x8008a, 0x8004a, 0x900f4, 0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cc, 0x7010b, 0x80066, 0x80026, 0x900ac, 0x80006, 0x80086, 0x80046, 0x900ec, 0x70107, 0x8005e, 0x8001e, 0x9009c, 0x70117, 0x8007e, 0x8003e, 0x900dc, 0x7010f, 0x8006e, 0x8002e, 0x900bc, 0x8000e, 0x8008e, 0x8004e, 0x900fc, 0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c2, 0x70108, 0x80061, 0x80021, 0x900a2, 0x80001, 0x80081, 0x80041, 0x900e2, 0x70104, 0x80059, 0x80019, 0x90092, 0x70114, 0x80079, 0x80039, 0x900d2, 0x7010c, 0x80069, 0x80029, 0x900b2, 0x80009, 0x80089, 0x80049, 0x900f2, 0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900ca, 0x7010a, 0x80065, 0x80025, 0x900aa, 0x80005, 0x80085, 0x80045, 0x900ea, 0x70106, 0x8005d, 0x8001d, 0x9009a, 0x70116, 0x8007d, 0x8003d, 0x900da, 0x7010e, 0x8006d, 0x8002d, 0x900ba, 0x8000d, 0x8008d, 0x8004d, 0x900fa, 0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c6, 0x70109, 0x80063, 0x80023, 0x900a6, 0x80003, 0x80083, 0x80043, 0x900e6, 0x70105, 0x8005b, 0x8001b, 0x90096, 0x70115, 0x8007b, 0x8003b, 0x900d6, 0x7010d, 0x8006b, 0x8002b, 0x900b6, 0x8000b, 0x8008b, 0x8004b, 0x900f6, 0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900ce, 0x7010b, 0x80067, 0x80027, 0x900ae, 0x80007, 0x80087, 0x80047, 0x900ee, 0x70107, 0x8005f, 0x8001f, 0x9009e, 0x70117, 0x8007f, 0x8003f, 0x900de, 0x7010f, 0x8006f, 0x8002f, 0x900be, 0x8000f, 0x8008f, 0x8004f, 0x900fe, 0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c1, 0x70108, 0x80060, 0x80020, 0x900a1, 0x80000, 0x80080, 0x80040, 0x900e1, 0x70104, 0x80058, 0x80018, 0x90091, 0x70114, 0x80078, 0x80038, 0x900d1, 0x7010c, 0x80068, 0x80028, 0x900b1, 0x80008, 0x80088, 0x80048, 0x900f1, 0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c9, 0x7010a, 0x80064, 0x80024, 0x900a9, 0x80004, 0x80084, 0x80044, 0x900e9, 0x70106, 0x8005c, 0x8001c, 0x90099, 0x70116, 0x8007c, 0x8003c, 0x900d9, 0x7010e, 0x8006c, 0x8002c, 0x900b9, 0x8000c, 0x8008c, 0x8004c, 0x900f9, 0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c5, 0x70109, 0x80062, 0x80022, 0x900a5, 0x80002, 0x80082, 0x80042, 0x900e5, 0x70105, 0x8005a, 0x8001a, 0x90095, 0x70115, 0x8007a, 0x8003a, 0x900d5, 0x7010d, 0x8006a, 0x8002a, 0x900b5, 0x8000a, 0x8008a, 0x8004a, 0x900f5, 0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cd, 0x7010b, 0x80066, 0x80026, 0x900ad, 0x80006, 0x80086, 0x80046, 0x900ed, 0x70107, 0x8005e, 0x8001e, 0x9009d, 0x70117, 0x8007e, 0x8003e, 0x900dd, 0x7010f, 0x8006e, 0x8002e, 0x900bd, 0x8000e, 0x8008e, 0x8004e, 0x900fd, 0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c3, 0x70108, 0x80061, 0x80021, 0x900a3, 0x80001, 0x80081, 0x80041, 0x900e3, 0x70104, 0x80059, 0x80019, 0x90093, 0x70114, 0x80079, 0x80039, 0x900d3, 0x7010c, 0x80069, 0x80029, 0x900b3, 0x80009, 0x80089, 0x80049, 0x900f3, 0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900cb, 0x7010a, 0x80065, 0x80025, 0x900ab, 0x80005, 0x80085, 0x80045, 0x900eb, 0x70106, 0x8005d, 0x8001d, 0x9009b, 0x70116, 0x8007d, 0x8003d, 0x900db, 0x7010e, 0x8006d, 0x8002d, 0x900bb, 0x8000d, 0x8008d, 0x8004d, 0x900fb, 0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c7, 0x70109, 0x80063, 0x80023, 0x900a7, 0x80003, 0x80083, 0x80043, 0x900e7, 0x70105, 0x8005b, 0x8001b, 0x90097, 0x70115, 0x8007b, 0x8003b, 0x900d7, 0x7010d, 0x8006b, 0x8002b, 0x900b7, 0x8000b, 0x8008b, 0x8004b, 0x900f7, 0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900cf, 0x7010b, 0x80067, 0x80027, 0x900af, 0x80007, 0x80087, 0x80047, 0x900ef, 0x70107, 0x8005f, 0x8001f, 0x9009f, 0x70117, 0x8007f, 0x8003f, 0x900df, 0x7010f, 0x8006f, 0x8002f, 0x900bf, 0x8000f, 0x8008f, 0x8004f, 0x900ff]), 9];
                var fixedDistCodeTab = [new Int32Array([0x50000, 0x50010, 0x50008, 0x50018, 0x50004, 0x50014, 0x5000c, 0x5001c, 0x50002, 0x50012, 0x5000a, 0x5001a, 0x50006, 0x50016, 0x5000e, 0x00000, 0x50001, 0x50011, 0x50009, 0x50019, 0x50005, 0x50015, 0x5000d, 0x5001d, 0x50003, 0x50013, 0x5000b, 0x5001b, 0x50007, 0x50017, 0x5000f, 0x00000]), 5];

                function FlateStream(str, maybeLength) {
                    this.str = str;
                    this.dict = str.dict;
                    var cmf = str.getByte();
                    var flg = str.getByte();
                    if (cmf === -1 || flg === -1) {
                        error('Invalid header in flate stream: ' + cmf + ', ' + flg);
                    }
                    if ((cmf & 0x0f) !== 0x08) {
                        error('Unknown compression method in flate stream: ' + cmf + ', ' + flg);
                    }
                    if ((((cmf << 8) + flg) % 31) !== 0) {
                        error('Bad FCHECK in flate stream: ' + cmf + ', ' + flg);
                    }
                    if (flg & 0x20) {
                        error('FDICT bit set in flate stream: ' + cmf + ', ' + flg);
                    }
                    this.codeSize = 0;
                    this.codeBuf = 0;
                    DecodeStream.call(this, maybeLength);
                }
                FlateStream.prototype = Object.create(DecodeStream.prototype);
                FlateStream.prototype.getBits = function FlateStream_getBits(bits) {
                    var str = this.str;
                    var codeSize = this.codeSize;
                    var codeBuf = this.codeBuf;
                    var b;
                    while (codeSize < bits) {
                        if ((b = str.getByte()) === -1) {
                            error('Bad encoding in flate stream');
                        }
                        codeBuf |= b << codeSize;
                        codeSize += 8;
                    }
                    b = codeBuf & ((1 << bits) - 1);
                    this.codeBuf = codeBuf >> bits;
                    this.codeSize = codeSize -= bits;
                    return b;
                };
                FlateStream.prototype.getCode = function FlateStream_getCode(table) {
                    var str = this.str;
                    var codes = table[0];
                    var maxLen = table[1];
                    var codeSize = this.codeSize;
                    var codeBuf = this.codeBuf;
                    var b;
                    while (codeSize < maxLen) {
                        if ((b = str.getByte()) === -1) {
                            break;
                        }
                        codeBuf |= (b << codeSize);
                        codeSize += 8;
                    }
                    var code = codes[codeBuf & ((1 << maxLen) - 1)];
                    var codeLen = code >> 16;
                    var codeVal = code & 0xffff;
                    if (codeLen < 1 || codeSize < codeLen) {
                        error('Bad encoding in flate stream');
                    }
                    this.codeBuf = (codeBuf >> codeLen);
                    this.codeSize = (codeSize - codeLen);
                    return codeVal;
                };
                FlateStream.prototype.generateHuffmanTable = function flateStreamGenerateHuffmanTable(lengths) {
                    var n = lengths.length;
                    var maxLen = 0;
                    var i;
                    for (i = 0; i < n; ++i) {
                        if (lengths[i] > maxLen) {
                            maxLen = lengths[i];
                        }
                    }
                    var size = 1 << maxLen;
                    var codes = new Int32Array(size);
                    for (var len = 1, code = 0, skip = 2; len <= maxLen; ++len, code <<= 1, skip <<= 1) {
                        for (var val = 0; val < n; ++val) {
                            if (lengths[val] === len) {
                                var code2 = 0;
                                var t = code;
                                for (i = 0; i < len; ++i) {
                                    code2 = (code2 << 1) | (t & 1);
                                    t >>= 1;
                                }
                                for (i = code2; i < size; i += skip) {
                                    codes[i] = (len << 16) | val;
                                }
                                ++code;
                            }
                        }
                    }
                    return [codes, maxLen];
                };
                FlateStream.prototype.readBlock = function FlateStream_readBlock() {
                    var buffer, len;
                    var str = this.str;
                    var hdr = this.getBits(3);
                    if (hdr & 1) {
                        this.eof = true;
                    }
                    hdr >>= 1;
                    if (hdr === 0) {
                        var b;
                        if ((b = str.getByte()) === -1) {
                            error('Bad block header in flate stream');
                        }
                        var blockLen = b;
                        if ((b = str.getByte()) === -1) {
                            error('Bad block header in flate stream');
                        }
                        blockLen |= (b << 8);
                        if ((b = str.getByte()) === -1) {
                            error('Bad block header in flate stream');
                        }
                        var check = b;
                        if ((b = str.getByte()) === -1) {
                            error('Bad block header in flate stream');
                        }
                        check |= (b << 8);
                        if (check !== (~blockLen & 0xffff) && (blockLen !== 0 || check !== 0)) {
                            error('Bad uncompressed block length in flate stream');
                        }
                        this.codeBuf = 0;
                        this.codeSize = 0;
                        var bufferLength = this.bufferLength;
                        buffer = this.ensureBuffer(bufferLength + blockLen);
                        var end = bufferLength + blockLen;
                        this.bufferLength = end;
                        if (blockLen === 0) {
                            if (str.peekByte() === -1) {
                                this.eof = true;
                            }
                        } else {
                            for (var n = bufferLength; n < end; ++n) {
                                if ((b = str.getByte()) === -1) {
                                    this.eof = true;
                                    break;
                                }
                                buffer[n] = b;
                            }
                        }
                        return;
                    }
                    var litCodeTable;
                    var distCodeTable;
                    if (hdr === 1) {
                        litCodeTable = fixedLitCodeTab;
                        distCodeTable = fixedDistCodeTab;
                    } else if (hdr === 2) {
                        var numLitCodes = this.getBits(5) + 257;
                        var numDistCodes = this.getBits(5) + 1;
                        var numCodeLenCodes = this.getBits(4) + 4;
                        var codeLenCodeLengths = new Uint8Array(codeLenCodeMap.length);
                        var i;
                        for (i = 0; i < numCodeLenCodes; ++i) {
                            codeLenCodeLengths[codeLenCodeMap[i]] = this.getBits(3);
                        }
                        var codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);
                        len = 0;
                        i = 0;
                        var codes = numLitCodes + numDistCodes;
                        var codeLengths = new Uint8Array(codes);
                        var bitsLength, bitsOffset, what;
                        while (i < codes) {
                            var code = this.getCode(codeLenCodeTab);
                            if (code === 16) {
                                bitsLength = 2;
                                bitsOffset = 3;
                                what = len;
                            } else if (code === 17) {
                                bitsLength = 3;
                                bitsOffset = 3;
                                what = (len = 0);
                            } else if (code === 18) {
                                bitsLength = 7;
                                bitsOffset = 11;
                                what = (len = 0);
                            } else {
                                codeLengths[i++] = len = code;
                                continue;
                            }
                            var repeatLength = this.getBits(bitsLength) + bitsOffset;
                            while (repeatLength-- > 0) {
                                codeLengths[i++] = what;
                            }
                        }
                        litCodeTable = this.generateHuffmanTable(codeLengths.subarray(0, numLitCodes));
                        distCodeTable = this.generateHuffmanTable(codeLengths.subarray(numLitCodes, codes));
                    } else {
                        error('Unknown block type in flate stream');
                    }
                    buffer = this.buffer;
                    var limit = buffer ? buffer.length : 0;
                    var pos = this.bufferLength;
                    while (true) {
                        var code1 = this.getCode(litCodeTable);
                        if (code1 < 256) {
                            if (pos + 1 >= limit) {
                                buffer = this.ensureBuffer(pos + 1);
                                limit = buffer.length;
                            }
                            buffer[pos++] = code1;
                            continue;
                        }
                        if (code1 === 256) {
                            this.bufferLength = pos;
                            return;
                        }
                        code1 -= 257;
                        code1 = lengthDecode[code1];
                        var code2 = code1 >> 16;
                        if (code2 > 0) {
                            code2 = this.getBits(code2);
                        }
                        len = (code1 & 0xffff) + code2;
                        code1 = this.getCode(distCodeTable);
                        code1 = distDecode[code1];
                        code2 = code1 >> 16;
                        if (code2 > 0) {
                            code2 = this.getBits(code2);
                        }
                        var dist = (code1 & 0xffff) + code2;
                        if (pos + len >= limit) {
                            buffer = this.ensureBuffer(pos + len);
                            limit = buffer.length;
                        }
                        for (var k = 0; k < len; ++k, ++pos) {
                            buffer[pos] = buffer[pos - dist];
                        }
                    }
                };
                return FlateStream;
            })();
            var PredictorStream = (function PredictorStreamClosure() {
                function PredictorStream(str, maybeLength, params) {
                    var predictor = this.predictor = params.get('Predictor') || 1;
                    if (predictor <= 1) {
                        return str;
                    }
                    if (predictor !== 2 && (predictor < 10 || predictor > 15)) {
                        error('Unsupported predictor: ' + predictor);
                    }
                    if (predictor === 2) {
                        this.readBlock = this.readBlockTiff;
                    } else {
                        this.readBlock = this.readBlockPng;
                    }
                    this.str = str;
                    this.dict = str.dict;
                    var colors = this.colors = params.get('Colors') || 1;
                    var bits = this.bits = params.get('BitsPerComponent') || 8;
                    var columns = this.columns = params.get('Columns') || 1;
                    this.pixBytes = (colors * bits + 7) >> 3;
                    this.rowBytes = (columns * colors * bits + 7) >> 3;
                    DecodeStream.call(this, maybeLength);
                    return this;
                }
                PredictorStream.prototype = Object.create(DecodeStream.prototype);
                PredictorStream.prototype.readBlockTiff = function predictorStreamReadBlockTiff() {
                    var rowBytes = this.rowBytes;
                    var bufferLength = this.bufferLength;
                    var buffer = this.ensureBuffer(bufferLength + rowBytes);
                    var bits = this.bits;
                    var colors = this.colors;
                    var rawBytes = this.str.getBytes(rowBytes);
                    this.eof = !rawBytes.length;
                    if (this.eof) {
                        return;
                    }
                    var inbuf = 0,
                        outbuf = 0;
                    var inbits = 0,
                        outbits = 0;
                    var pos = bufferLength;
                    var i;
                    if (bits === 1) {
                        for (i = 0; i < rowBytes; ++i) {
                            var c = rawBytes[i];
                            inbuf = (inbuf << 8) | c;
                            buffer[pos++] = (c ^ (inbuf >> colors)) & 0xFF;
                            inbuf &= 0xFFFF;
                        }
                    } else if (bits === 8) {
                        for (i = 0; i < colors; ++i) {
                            buffer[pos++] = rawBytes[i];
                        }
                        for (; i < rowBytes; ++i) {
                            buffer[pos] = buffer[pos - colors] + rawBytes[i];
                            pos++;
                        }
                    } else {
                        var compArray = new Uint8Array(colors + 1);
                        var bitMask = (1 << bits) - 1;
                        var j = 0,
                            k = bufferLength;
                        var columns = this.columns;
                        for (i = 0; i < columns; ++i) {
                            for (var kk = 0; kk < colors; ++kk) {
                                if (inbits < bits) {
                                    inbuf = (inbuf << 8) | (rawBytes[j++] & 0xFF);
                                    inbits += 8;
                                }
                                compArray[kk] = (compArray[kk] +
                                    (inbuf >> (inbits - bits))) & bitMask;
                                inbits -= bits;
                                outbuf = (outbuf << bits) | compArray[kk];
                                outbits += bits;
                                if (outbits >= 8) {
                                    buffer[k++] = (outbuf >> (outbits - 8)) & 0xFF;
                                    outbits -= 8;
                                }
                            }
                        }
                        if (outbits > 0) {
                            buffer[k++] = (outbuf << (8 - outbits)) +
                                (inbuf & ((1 << (8 - outbits)) - 1));
                        }
                    }
                    this.bufferLength += rowBytes;
                };
                PredictorStream.prototype.readBlockPng = function predictorStreamReadBlockPng() {
                    var rowBytes = this.rowBytes;
                    var pixBytes = this.pixBytes;
                    var predictor = this.str.getByte();
                    var rawBytes = this.str.getBytes(rowBytes);
                    this.eof = !rawBytes.length;
                    if (this.eof) {
                        return;
                    }
                    var bufferLength = this.bufferLength;
                    var buffer = this.ensureBuffer(bufferLength + rowBytes);
                    var prevRow = buffer.subarray(bufferLength - rowBytes, bufferLength);
                    if (prevRow.length === 0) {
                        prevRow = new Uint8Array(rowBytes);
                    }
                    var i, j = bufferLength,
                        up, c;
                    switch (predictor) {
                        case 0:
                            for (i = 0; i < rowBytes; ++i) {
                                buffer[j++] = rawBytes[i];
                            }
                            break;
                        case 1:
                            for (i = 0; i < pixBytes; ++i) {
                                buffer[j++] = rawBytes[i];
                            }
                            for (; i < rowBytes; ++i) {
                                buffer[j] = (buffer[j - pixBytes] + rawBytes[i]) & 0xFF;
                                j++;
                            }
                            break;
                        case 2:
                            for (i = 0; i < rowBytes; ++i) {
                                buffer[j++] = (prevRow[i] + rawBytes[i]) & 0xFF;
                            }
                            break;
                        case 3:
                            for (i = 0; i < pixBytes; ++i) {
                                buffer[j++] = (prevRow[i] >> 1) + rawBytes[i];
                            }
                            for (; i < rowBytes; ++i) {
                                buffer[j] = (((prevRow[i] + buffer[j - pixBytes]) >> 1) +
                                    rawBytes[i]) & 0xFF;
                                j++;
                            }
                            break;
                        case 4:
                            for (i = 0; i < pixBytes; ++i) {
                                up = prevRow[i];
                                c = rawBytes[i];
                                buffer[j++] = up + c;
                            }
                            for (; i < rowBytes; ++i) {
                                up = prevRow[i];
                                var upLeft = prevRow[i - pixBytes];
                                var left = buffer[j - pixBytes];
                                var p = left + up - upLeft;
                                var pa = p - left;
                                if (pa < 0) {
                                    pa = -pa;
                                }
                                var pb = p - up;
                                if (pb < 0) {
                                    pb = -pb;
                                }
                                var pc = p - upLeft;
                                if (pc < 0) {
                                    pc = -pc;
                                }
                                c = rawBytes[i];
                                if (pa <= pb && pa <= pc) {
                                    buffer[j++] = left + c;
                                } else if (pb <= pc) {
                                    buffer[j++] = up + c;
                                } else {
                                    buffer[j++] = upLeft + c;
                                }
                            }
                            break;
                        default:
                            error('Unsupported predictor: ' + predictor);
                    }
                    this.bufferLength += rowBytes;
                };
                return PredictorStream;
            })();
            var JpegStream = (function JpegStreamClosure() {
                function JpegStream(stream, maybeLength, dict, xref) {
                    var ch;
                    while ((ch = stream.getByte()) !== -1) {
                        if (ch === 0xFF) {
                            stream.skip(-1);
                            break;
                        }
                    }
                    this.stream = stream;
                    this.maybeLength = maybeLength;
                    this.dict = dict;
                    DecodeStream.call(this, maybeLength);
                }
                JpegStream.prototype = Object.create(DecodeStream.prototype);
                Object.defineProperty(JpegStream.prototype, 'bytes', {
                    get: function JpegStream_bytes() {
                        return shadow(this, 'bytes', this.stream.getBytes(this.maybeLength));
                    },
                    configurable: true
                });
                JpegStream.prototype.ensureBuffer = function JpegStream_ensureBuffer(req) {
                    if (this.bufferLength) {
                        return;
                    }
                    try {
                        var jpegImage = new JpegImage();
                        if (this.forceRGB && this.dict && isArray(this.dict.get('Decode'))) {
                            var decodeArr = this.dict.get('Decode');
                            var bitsPerComponent = this.dict.get('BitsPerComponent') || 8;
                            var decodeArrLength = decodeArr.length;
                            var transform = new Int32Array(decodeArrLength);
                            var transformNeeded = false;
                            var maxValue = (1 << bitsPerComponent) - 1;
                            for (var i = 0; i < decodeArrLength; i += 2) {
                                transform[i] = ((decodeArr[i + 1] - decodeArr[i]) * 256) | 0;
                                transform[i + 1] = (decodeArr[i] * maxValue) | 0;
                                if (transform[i] !== 256 || transform[i + 1] !== 0) {
                                    transformNeeded = true;
                                }
                            }
                            if (transformNeeded) {
                                jpegImage.decodeTransform = transform;
                            }
                        }
                        jpegImage.parse(this.bytes);
                        var data = jpegImage.getData(this.drawWidth, this.drawHeight, this.forceRGB);
                        this.buffer = data;
                        this.bufferLength = data.length;
                        this.eof = true;
                    } catch (e) {
                        error('JPEG error: ' + e);
                    }
                };
                JpegStream.prototype.getBytes = function JpegStream_getBytes(length) {
                    this.ensureBuffer();
                    return this.buffer;
                };
                JpegStream.prototype.getIR = function JpegStream_getIR() {
                    return PDFJS.createObjectURL(this.bytes, 'image/jpeg');
                };
                JpegStream.prototype.isNativelySupported = function JpegStream_isNativelySupported(xref, res) {
                    var cs = ColorSpace.parse(this.dict.get('ColorSpace', 'CS'), xref, res);
                    return (cs.name === 'DeviceGray' || cs.name === 'DeviceRGB') && cs.isDefaultDecode(this.dict.get('Decode', 'D'));
                };
                JpegStream.prototype.isNativelyDecodable = function JpegStream_isNativelyDecodable(xref, res) {
                    var cs = ColorSpace.parse(this.dict.get('ColorSpace', 'CS'), xref, res);
                    return (cs.numComps === 1 || cs.numComps === 3) && cs.isDefaultDecode(this.dict.get('Decode', 'D'));
                };
                return JpegStream;
            })();
            var JpxStream = (function JpxStreamClosure() {
                function JpxStream(stream, maybeLength, dict) {
                    this.stream = stream;
                    this.maybeLength = maybeLength;
                    this.dict = dict;
                    DecodeStream.call(this, maybeLength);
                }
                JpxStream.prototype = Object.create(DecodeStream.prototype);
                Object.defineProperty(JpxStream.prototype, 'bytes', {
                    get: function JpxStream_bytes() {
                        return shadow(this, 'bytes', this.stream.getBytes(this.maybeLength));
                    },
                    configurable: true
                });
                JpxStream.prototype.ensureBuffer = function JpxStream_ensureBuffer(req) {
                    if (this.bufferLength) {
                        return;
                    }
                    var jpxImage = new JpxImage();
                    jpxImage.parse(this.bytes);
                    var width = jpxImage.width;
                    var height = jpxImage.height;
                    var componentsCount = jpxImage.componentsCount;
                    var tileCount = jpxImage.tiles.length;
                    if (tileCount === 1) {
                        this.buffer = jpxImage.tiles[0].items;
                    } else {
                        var data = new Uint8Array(width * height * componentsCount);
                        for (var k = 0; k < tileCount; k++) {
                            var tileComponents = jpxImage.tiles[k];
                            var tileWidth = tileComponents.width;
                            var tileHeight = tileComponents.height;
                            var tileLeft = tileComponents.left;
                            var tileTop = tileComponents.top;
                            var src = tileComponents.items;
                            var srcPosition = 0;
                            var dataPosition = (width * tileTop + tileLeft) * componentsCount;
                            var imgRowSize = width * componentsCount;
                            var tileRowSize = tileWidth * componentsCount;
                            for (var j = 0; j < tileHeight; j++) {
                                var rowBytes = src.subarray(srcPosition, srcPosition + tileRowSize);
                                data.set(rowBytes, dataPosition);
                                srcPosition += tileRowSize;
                                dataPosition += imgRowSize;
                            }
                        }
                        this.buffer = data;
                    }
                    this.bufferLength = this.buffer.length;
                    this.eof = true;
                };
                return JpxStream;
            })();
            var Jbig2Stream = (function Jbig2StreamClosure() {
                function Jbig2Stream(stream, maybeLength, dict) {
                    this.stream = stream;
                    this.maybeLength = maybeLength;
                    this.dict = dict;
                    DecodeStream.call(this, maybeLength);
                }
                Jbig2Stream.prototype = Object.create(DecodeStream.prototype);
                Object.defineProperty(Jbig2Stream.prototype, 'bytes', {
                    get: function Jbig2Stream_bytes() {
                        return shadow(this, 'bytes', this.stream.getBytes(this.maybeLength));
                    },
                    configurable: true
                });
                Jbig2Stream.prototype.ensureBuffer = function Jbig2Stream_ensureBuffer(req) {
                    if (this.bufferLength) {
                        return;
                    }
                    var jbig2Image = new Jbig2Image();
                    var chunks = [],
                        xref = this.dict.xref;
                    var decodeParams = xref.fetchIfRef(this.dict.get('DecodeParms'));
                    if (isArray(decodeParams)) {
                        if (decodeParams.length > 1) {
                            warn('JBIG2 - \'DecodeParms\' array with multiple elements ' + 'not supported.');
                        }
                        decodeParams = xref.fetchIfRef(decodeParams[0]);
                    }
                    if (decodeParams && decodeParams.has('JBIG2Globals')) {
                        var globalsStream = decodeParams.get('JBIG2Globals');
                        var globals = globalsStream.getBytes();
                        chunks.push({
                            data: globals,
                            start: 0,
                            end: globals.length
                        });
                    }
                    chunks.push({
                        data: this.bytes,
                        start: 0,
                        end: this.bytes.length
                    });
                    var data = jbig2Image.parseChunks(chunks);
                    var dataLength = data.length;
                    for (var i = 0; i < dataLength; i++) {
                        data[i] ^= 0xFF;
                    }
                    this.buffer = data;
                    this.bufferLength = dataLength;
                    this.eof = true;
                };
                return Jbig2Stream;
            })();
            var DecryptStream = (function DecryptStreamClosure() {
                function DecryptStream(str, maybeLength, decrypt) {
                    this.str = str;
                    this.dict = str.dict;
                    this.decrypt = decrypt;
                    this.nextChunk = null;
                    this.initialized = false;
                    DecodeStream.call(this, maybeLength);
                }
                var chunkSize = 512;
                DecryptStream.prototype = Object.create(DecodeStream.prototype);
                DecryptStream.prototype.readBlock = function DecryptStream_readBlock() {
                    var chunk;
                    if (this.initialized) {
                        chunk = this.nextChunk;
                    } else {
                        chunk = this.str.getBytes(chunkSize);
                        this.initialized = true;
                    }
                    if (!chunk || chunk.length === 0) {
                        this.eof = true;
                        return;
                    }
                    this.nextChunk = this.str.getBytes(chunkSize);
                    var hasMoreData = this.nextChunk && this.nextChunk.length > 0;
                    var decrypt = this.decrypt;
                    chunk = decrypt(chunk, !hasMoreData);
                    var bufferLength = this.bufferLength;
                    var i, n = chunk.length;
                    var buffer = this.ensureBuffer(bufferLength + n);
                    for (i = 0; i < n; i++) {
                        buffer[bufferLength++] = chunk[i];
                    }
                    this.bufferLength = bufferLength;
                };
                return DecryptStream;
            })();
            var Ascii85Stream = (function Ascii85StreamClosure() {
                function Ascii85Stream(str, maybeLength) {
                    this.str = str;
                    this.dict = str.dict;
                    this.input = new Uint8Array(5);
                    if (maybeLength) {
                        maybeLength = 0.8 * maybeLength;
                    }
                    DecodeStream.call(this, maybeLength);
                }
                Ascii85Stream.prototype = Object.create(DecodeStream.prototype);
                Ascii85Stream.prototype.readBlock = function Ascii85Stream_readBlock() {
                    var TILDA_CHAR = 0x7E;
                    var Z_LOWER_CHAR = 0x7A;
                    var EOF = -1;
                    var str = this.str;
                    var c = str.getByte();
                    while (Lexer.isSpace(c)) {
                        c = str.getByte();
                    }
                    if (c === EOF || c === TILDA_CHAR) {
                        this.eof = true;
                        return;
                    }
                    var bufferLength = this.bufferLength,
                        buffer;
                    var i;
                    if (c === Z_LOWER_CHAR) {
                        buffer = this.ensureBuffer(bufferLength + 4);
                        for (i = 0; i < 4; ++i) {
                            buffer[bufferLength + i] = 0;
                        }
                        this.bufferLength += 4;
                    } else {
                        var input = this.input;
                        input[0] = c;
                        for (i = 1; i < 5; ++i) {
                            c = str.getByte();
                            while (Lexer.isSpace(c)) {
                                c = str.getByte();
                            }
                            input[i] = c;
                            if (c === EOF || c === TILDA_CHAR) {
                                break;
                            }
                        }
                        buffer = this.ensureBuffer(bufferLength + i - 1);
                        this.bufferLength += i - 1;
                        if (i < 5) {
                            for (; i < 5; ++i) {
                                input[i] = 0x21 + 84;
                            }
                            this.eof = true;
                        }
                        var t = 0;
                        for (i = 0; i < 5; ++i) {
                            t = t * 85 + (input[i] - 0x21);
                        }
                        for (i = 3; i >= 0; --i) {
                            buffer[bufferLength + i] = t & 0xFF;
                            t >>= 8;
                        }
                    }
                };
                return Ascii85Stream;
            })();
            var AsciiHexStream = (function AsciiHexStreamClosure() {
                function AsciiHexStream(str, maybeLength) {
                    this.str = str;
                    this.dict = str.dict;
                    this.firstDigit = -1;
                    if (maybeLength) {
                        maybeLength = 0.5 * maybeLength;
                    }
                    DecodeStream.call(this, maybeLength);
                }
                AsciiHexStream.prototype = Object.create(DecodeStream.prototype);
                AsciiHexStream.prototype.readBlock = function AsciiHexStream_readBlock() {
                    var UPSTREAM_BLOCK_SIZE = 8000;
                    var bytes = this.str.getBytes(UPSTREAM_BLOCK_SIZE);
                    if (!bytes.length) {
                        this.eof = true;
                        return;
                    }
                    var maxDecodeLength = (bytes.length + 1) >> 1;
                    var buffer = this.ensureBuffer(this.bufferLength + maxDecodeLength);
                    var bufferLength = this.bufferLength;
                    var firstDigit = this.firstDigit;
                    for (var i = 0, ii = bytes.length; i < ii; i++) {
                        var ch = bytes[i],
                            digit;
                        if (ch >= 0x30 && ch <= 0x39) {
                            digit = ch & 0x0F;
                        } else if ((ch >= 0x41 && ch <= 0x46) || (ch >= 0x61 && ch <= 0x66)) {
                            digit = (ch & 0x0F) + 9;
                        } else if (ch === 0x3E) {
                            this.eof = true;
                            break;
                        } else {
                            continue;
                        }
                        if (firstDigit < 0) {
                            firstDigit = digit;
                        } else {
                            buffer[bufferLength++] = (firstDigit << 4) | digit;
                            firstDigit = -1;
                        }
                    }
                    if (firstDigit >= 0 && this.eof) {
                        buffer[bufferLength++] = (firstDigit << 4);
                        firstDigit = -1;
                    }
                    this.firstDigit = firstDigit;
                    this.bufferLength = bufferLength;
                };
                return AsciiHexStream;
            })();
            var RunLengthStream = (function RunLengthStreamClosure() {
                function RunLengthStream(str, maybeLength) {
                    this.str = str;
                    this.dict = str.dict;
                    DecodeStream.call(this, maybeLength);
                }
                RunLengthStream.prototype = Object.create(DecodeStream.prototype);
                RunLengthStream.prototype.readBlock = function RunLengthStream_readBlock() {
                    var repeatHeader = this.str.getBytes(2);
                    if (!repeatHeader || repeatHeader.length < 2 || repeatHeader[0] === 128) {
                        this.eof = true;
                        return;
                    }
                    var buffer;
                    var bufferLength = this.bufferLength;
                    var n = repeatHeader[0];
                    if (n < 128) {
                        buffer = this.ensureBuffer(bufferLength + n + 1);
                        buffer[bufferLength++] = repeatHeader[1];
                        if (n > 0) {
                            var source = this.str.getBytes(n);
                            buffer.set(source, bufferLength);
                            bufferLength += n;
                        }
                    } else {
                        n = 257 - n;
                        var b = repeatHeader[1];
                        buffer = this.ensureBuffer(bufferLength + n + 1);
                        for (var i = 0; i < n; i++) {
                            buffer[bufferLength++] = b;
                        }
                    }
                    this.bufferLength = bufferLength;
                };
                return RunLengthStream;
            })();
            var CCITTFaxStream = (function CCITTFaxStreamClosure() {
                var ccittEOL = -2;
                var twoDimPass = 0;
                var twoDimHoriz = 1;
                var twoDimVert0 = 2;
                var twoDimVertR1 = 3;
                var twoDimVertL1 = 4;
                var twoDimVertR2 = 5;
                var twoDimVertL2 = 6;
                var twoDimVertR3 = 7;
                var twoDimVertL3 = 8;
                var twoDimTable = [
                    [-1, -1],
                    [-1, -1],
                    [7, twoDimVertL3],
                    [7, twoDimVertR3],
                    [6, twoDimVertL2],
                    [6, twoDimVertL2],
                    [6, twoDimVertR2],
                    [6, twoDimVertR2],
                    [4, twoDimPass],
                    [4, twoDimPass],
                    [4, twoDimPass],
                    [4, twoDimPass],
                    [4, twoDimPass],
                    [4, twoDimPass],
                    [4, twoDimPass],
                    [4, twoDimPass],
                    [3, twoDimHoriz],
                    [3, twoDimHoriz],
                    [3, twoDimHoriz],
                    [3, twoDimHoriz],
                    [3, twoDimHoriz],
                    [3, twoDimHoriz],
                    [3, twoDimHoriz],
                    [3, twoDimHoriz],
                    [3, twoDimHoriz],
                    [3, twoDimHoriz],
                    [3, twoDimHoriz],
                    [3, twoDimHoriz],
                    [3, twoDimHoriz],
                    [3, twoDimHoriz],
                    [3, twoDimHoriz],
                    [3, twoDimHoriz],
                    [3, twoDimVertL1],
                    [3, twoDimVertL1],
                    [3, twoDimVertL1],
                    [3, twoDimVertL1],
                    [3, twoDimVertL1],
                    [3, twoDimVertL1],
                    [3, twoDimVertL1],
                    [3, twoDimVertL1],
                    [3, twoDimVertL1],
                    [3, twoDimVertL1],
                    [3, twoDimVertL1],
                    [3, twoDimVertL1],
                    [3, twoDimVertL1],
                    [3, twoDimVertL1],
                    [3, twoDimVertL1],
                    [3, twoDimVertL1],
                    [3, twoDimVertR1],
                    [3, twoDimVertR1],
                    [3, twoDimVertR1],
                    [3, twoDimVertR1],
                    [3, twoDimVertR1],
                    [3, twoDimVertR1],
                    [3, twoDimVertR1],
                    [3, twoDimVertR1],
                    [3, twoDimVertR1],
                    [3, twoDimVertR1],
                    [3, twoDimVertR1],
                    [3, twoDimVertR1],
                    [3, twoDimVertR1],
                    [3, twoDimVertR1],
                    [3, twoDimVertR1],
                    [3, twoDimVertR1],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0],
                    [1, twoDimVert0]
                ];
                var whiteTable1 = [
                    [-1, -1],
                    [12, ccittEOL],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [11, 1792],
                    [11, 1792],
                    [12, 1984],
                    [12, 2048],
                    [12, 2112],
                    [12, 2176],
                    [12, 2240],
                    [12, 2304],
                    [11, 1856],
                    [11, 1856],
                    [11, 1920],
                    [11, 1920],
                    [12, 2368],
                    [12, 2432],
                    [12, 2496],
                    [12, 2560]
                ];
                var whiteTable2 = [
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [8, 29],
                    [8, 29],
                    [8, 30],
                    [8, 30],
                    [8, 45],
                    [8, 45],
                    [8, 46],
                    [8, 46],
                    [7, 22],
                    [7, 22],
                    [7, 22],
                    [7, 22],
                    [7, 23],
                    [7, 23],
                    [7, 23],
                    [7, 23],
                    [8, 47],
                    [8, 47],
                    [8, 48],
                    [8, 48],
                    [6, 13],
                    [6, 13],
                    [6, 13],
                    [6, 13],
                    [6, 13],
                    [6, 13],
                    [6, 13],
                    [6, 13],
                    [7, 20],
                    [7, 20],
                    [7, 20],
                    [7, 20],
                    [8, 33],
                    [8, 33],
                    [8, 34],
                    [8, 34],
                    [8, 35],
                    [8, 35],
                    [8, 36],
                    [8, 36],
                    [8, 37],
                    [8, 37],
                    [8, 38],
                    [8, 38],
                    [7, 19],
                    [7, 19],
                    [7, 19],
                    [7, 19],
                    [8, 31],
                    [8, 31],
                    [8, 32],
                    [8, 32],
                    [6, 1],
                    [6, 1],
                    [6, 1],
                    [6, 1],
                    [6, 1],
                    [6, 1],
                    [6, 1],
                    [6, 1],
                    [6, 12],
                    [6, 12],
                    [6, 12],
                    [6, 12],
                    [6, 12],
                    [6, 12],
                    [6, 12],
                    [6, 12],
                    [8, 53],
                    [8, 53],
                    [8, 54],
                    [8, 54],
                    [7, 26],
                    [7, 26],
                    [7, 26],
                    [7, 26],
                    [8, 39],
                    [8, 39],
                    [8, 40],
                    [8, 40],
                    [8, 41],
                    [8, 41],
                    [8, 42],
                    [8, 42],
                    [8, 43],
                    [8, 43],
                    [8, 44],
                    [8, 44],
                    [7, 21],
                    [7, 21],
                    [7, 21],
                    [7, 21],
                    [7, 28],
                    [7, 28],
                    [7, 28],
                    [7, 28],
                    [8, 61],
                    [8, 61],
                    [8, 62],
                    [8, 62],
                    [8, 63],
                    [8, 63],
                    [8, 0],
                    [8, 0],
                    [8, 320],
                    [8, 320],
                    [8, 384],
                    [8, 384],
                    [5, 10],
                    [5, 10],
                    [5, 10],
                    [5, 10],
                    [5, 10],
                    [5, 10],
                    [5, 10],
                    [5, 10],
                    [5, 10],
                    [5, 10],
                    [5, 10],
                    [5, 10],
                    [5, 10],
                    [5, 10],
                    [5, 10],
                    [5, 10],
                    [5, 11],
                    [5, 11],
                    [5, 11],
                    [5, 11],
                    [5, 11],
                    [5, 11],
                    [5, 11],
                    [5, 11],
                    [5, 11],
                    [5, 11],
                    [5, 11],
                    [5, 11],
                    [5, 11],
                    [5, 11],
                    [5, 11],
                    [5, 11],
                    [7, 27],
                    [7, 27],
                    [7, 27],
                    [7, 27],
                    [8, 59],
                    [8, 59],
                    [8, 60],
                    [8, 60],
                    [9, 1472],
                    [9, 1536],
                    [9, 1600],
                    [9, 1728],
                    [7, 18],
                    [7, 18],
                    [7, 18],
                    [7, 18],
                    [7, 24],
                    [7, 24],
                    [7, 24],
                    [7, 24],
                    [8, 49],
                    [8, 49],
                    [8, 50],
                    [8, 50],
                    [8, 51],
                    [8, 51],
                    [8, 52],
                    [8, 52],
                    [7, 25],
                    [7, 25],
                    [7, 25],
                    [7, 25],
                    [8, 55],
                    [8, 55],
                    [8, 56],
                    [8, 56],
                    [8, 57],
                    [8, 57],
                    [8, 58],
                    [8, 58],
                    [6, 192],
                    [6, 192],
                    [6, 192],
                    [6, 192],
                    [6, 192],
                    [6, 192],
                    [6, 192],
                    [6, 192],
                    [6, 1664],
                    [6, 1664],
                    [6, 1664],
                    [6, 1664],
                    [6, 1664],
                    [6, 1664],
                    [6, 1664],
                    [6, 1664],
                    [8, 448],
                    [8, 448],
                    [8, 512],
                    [8, 512],
                    [9, 704],
                    [9, 768],
                    [8, 640],
                    [8, 640],
                    [8, 576],
                    [8, 576],
                    [9, 832],
                    [9, 896],
                    [9, 960],
                    [9, 1024],
                    [9, 1088],
                    [9, 1152],
                    [9, 1216],
                    [9, 1280],
                    [9, 1344],
                    [9, 1408],
                    [7, 256],
                    [7, 256],
                    [7, 256],
                    [7, 256],
                    [4, 2],
                    [4, 2],
                    [4, 2],
                    [4, 2],
                    [4, 2],
                    [4, 2],
                    [4, 2],
                    [4, 2],
                    [4, 2],
                    [4, 2],
                    [4, 2],
                    [4, 2],
                    [4, 2],
                    [4, 2],
                    [4, 2],
                    [4, 2],
                    [4, 2],
                    [4, 2],
                    [4, 2],
                    [4, 2],
                    [4, 2],
                    [4, 2],
                    [4, 2],
                    [4, 2],
                    [4, 2],
                    [4, 2],
                    [4, 2],
                    [4, 2],
                    [4, 2],
                    [4, 2],
                    [4, 2],
                    [4, 2],
                    [4, 3],
                    [4, 3],
                    [4, 3],
                    [4, 3],
                    [4, 3],
                    [4, 3],
                    [4, 3],
                    [4, 3],
                    [4, 3],
                    [4, 3],
                    [4, 3],
                    [4, 3],
                    [4, 3],
                    [4, 3],
                    [4, 3],
                    [4, 3],
                    [4, 3],
                    [4, 3],
                    [4, 3],
                    [4, 3],
                    [4, 3],
                    [4, 3],
                    [4, 3],
                    [4, 3],
                    [4, 3],
                    [4, 3],
                    [4, 3],
                    [4, 3],
                    [4, 3],
                    [4, 3],
                    [4, 3],
                    [4, 3],
                    [5, 128],
                    [5, 128],
                    [5, 128],
                    [5, 128],
                    [5, 128],
                    [5, 128],
                    [5, 128],
                    [5, 128],
                    [5, 128],
                    [5, 128],
                    [5, 128],
                    [5, 128],
                    [5, 128],
                    [5, 128],
                    [5, 128],
                    [5, 128],
                    [5, 8],
                    [5, 8],
                    [5, 8],
                    [5, 8],
                    [5, 8],
                    [5, 8],
                    [5, 8],
                    [5, 8],
                    [5, 8],
                    [5, 8],
                    [5, 8],
                    [5, 8],
                    [5, 8],
                    [5, 8],
                    [5, 8],
                    [5, 8],
                    [5, 9],
                    [5, 9],
                    [5, 9],
                    [5, 9],
                    [5, 9],
                    [5, 9],
                    [5, 9],
                    [5, 9],
                    [5, 9],
                    [5, 9],
                    [5, 9],
                    [5, 9],
                    [5, 9],
                    [5, 9],
                    [5, 9],
                    [5, 9],
                    [6, 16],
                    [6, 16],
                    [6, 16],
                    [6, 16],
                    [6, 16],
                    [6, 16],
                    [6, 16],
                    [6, 16],
                    [6, 17],
                    [6, 17],
                    [6, 17],
                    [6, 17],
                    [6, 17],
                    [6, 17],
                    [6, 17],
                    [6, 17],
                    [4, 4],
                    [4, 4],
                    [4, 4],
                    [4, 4],
                    [4, 4],
                    [4, 4],
                    [4, 4],
                    [4, 4],
                    [4, 4],
                    [4, 4],
                    [4, 4],
                    [4, 4],
                    [4, 4],
                    [4, 4],
                    [4, 4],
                    [4, 4],
                    [4, 4],
                    [4, 4],
                    [4, 4],
                    [4, 4],
                    [4, 4],
                    [4, 4],
                    [4, 4],
                    [4, 4],
                    [4, 4],
                    [4, 4],
                    [4, 4],
                    [4, 4],
                    [4, 4],
                    [4, 4],
                    [4, 4],
                    [4, 4],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [6, 14],
                    [6, 14],
                    [6, 14],
                    [6, 14],
                    [6, 14],
                    [6, 14],
                    [6, 14],
                    [6, 14],
                    [6, 15],
                    [6, 15],
                    [6, 15],
                    [6, 15],
                    [6, 15],
                    [6, 15],
                    [6, 15],
                    [6, 15],
                    [5, 64],
                    [5, 64],
                    [5, 64],
                    [5, 64],
                    [5, 64],
                    [5, 64],
                    [5, 64],
                    [5, 64],
                    [5, 64],
                    [5, 64],
                    [5, 64],
                    [5, 64],
                    [5, 64],
                    [5, 64],
                    [5, 64],
                    [5, 64],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 7],
                    [4, 7],
                    [4, 7],
                    [4, 7],
                    [4, 7],
                    [4, 7],
                    [4, 7],
                    [4, 7],
                    [4, 7],
                    [4, 7],
                    [4, 7],
                    [4, 7],
                    [4, 7],
                    [4, 7],
                    [4, 7],
                    [4, 7],
                    [4, 7],
                    [4, 7],
                    [4, 7],
                    [4, 7],
                    [4, 7],
                    [4, 7],
                    [4, 7],
                    [4, 7],
                    [4, 7],
                    [4, 7],
                    [4, 7],
                    [4, 7],
                    [4, 7],
                    [4, 7],
                    [4, 7],
                    [4, 7]
                ];
                var blackTable1 = [
                    [-1, -1],
                    [-1, -1],
                    [12, ccittEOL],
                    [12, ccittEOL],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [11, 1792],
                    [11, 1792],
                    [11, 1792],
                    [11, 1792],
                    [12, 1984],
                    [12, 1984],
                    [12, 2048],
                    [12, 2048],
                    [12, 2112],
                    [12, 2112],
                    [12, 2176],
                    [12, 2176],
                    [12, 2240],
                    [12, 2240],
                    [12, 2304],
                    [12, 2304],
                    [11, 1856],
                    [11, 1856],
                    [11, 1856],
                    [11, 1856],
                    [11, 1920],
                    [11, 1920],
                    [11, 1920],
                    [11, 1920],
                    [12, 2368],
                    [12, 2368],
                    [12, 2432],
                    [12, 2432],
                    [12, 2496],
                    [12, 2496],
                    [12, 2560],
                    [12, 2560],
                    [10, 18],
                    [10, 18],
                    [10, 18],
                    [10, 18],
                    [10, 18],
                    [10, 18],
                    [10, 18],
                    [10, 18],
                    [12, 52],
                    [12, 52],
                    [13, 640],
                    [13, 704],
                    [13, 768],
                    [13, 832],
                    [12, 55],
                    [12, 55],
                    [12, 56],
                    [12, 56],
                    [13, 1280],
                    [13, 1344],
                    [13, 1408],
                    [13, 1472],
                    [12, 59],
                    [12, 59],
                    [12, 60],
                    [12, 60],
                    [13, 1536],
                    [13, 1600],
                    [11, 24],
                    [11, 24],
                    [11, 24],
                    [11, 24],
                    [11, 25],
                    [11, 25],
                    [11, 25],
                    [11, 25],
                    [13, 1664],
                    [13, 1728],
                    [12, 320],
                    [12, 320],
                    [12, 384],
                    [12, 384],
                    [12, 448],
                    [12, 448],
                    [13, 512],
                    [13, 576],
                    [12, 53],
                    [12, 53],
                    [12, 54],
                    [12, 54],
                    [13, 896],
                    [13, 960],
                    [13, 1024],
                    [13, 1088],
                    [13, 1152],
                    [13, 1216],
                    [10, 64],
                    [10, 64],
                    [10, 64],
                    [10, 64],
                    [10, 64],
                    [10, 64],
                    [10, 64],
                    [10, 64]
                ];
                var blackTable2 = [
                    [8, 13],
                    [8, 13],
                    [8, 13],
                    [8, 13],
                    [8, 13],
                    [8, 13],
                    [8, 13],
                    [8, 13],
                    [8, 13],
                    [8, 13],
                    [8, 13],
                    [8, 13],
                    [8, 13],
                    [8, 13],
                    [8, 13],
                    [8, 13],
                    [11, 23],
                    [11, 23],
                    [12, 50],
                    [12, 51],
                    [12, 44],
                    [12, 45],
                    [12, 46],
                    [12, 47],
                    [12, 57],
                    [12, 58],
                    [12, 61],
                    [12, 256],
                    [10, 16],
                    [10, 16],
                    [10, 16],
                    [10, 16],
                    [10, 17],
                    [10, 17],
                    [10, 17],
                    [10, 17],
                    [12, 48],
                    [12, 49],
                    [12, 62],
                    [12, 63],
                    [12, 30],
                    [12, 31],
                    [12, 32],
                    [12, 33],
                    [12, 40],
                    [12, 41],
                    [11, 22],
                    [11, 22],
                    [8, 14],
                    [8, 14],
                    [8, 14],
                    [8, 14],
                    [8, 14],
                    [8, 14],
                    [8, 14],
                    [8, 14],
                    [8, 14],
                    [8, 14],
                    [8, 14],
                    [8, 14],
                    [8, 14],
                    [8, 14],
                    [8, 14],
                    [8, 14],
                    [7, 10],
                    [7, 10],
                    [7, 10],
                    [7, 10],
                    [7, 10],
                    [7, 10],
                    [7, 10],
                    [7, 10],
                    [7, 10],
                    [7, 10],
                    [7, 10],
                    [7, 10],
                    [7, 10],
                    [7, 10],
                    [7, 10],
                    [7, 10],
                    [7, 10],
                    [7, 10],
                    [7, 10],
                    [7, 10],
                    [7, 10],
                    [7, 10],
                    [7, 10],
                    [7, 10],
                    [7, 10],
                    [7, 10],
                    [7, 10],
                    [7, 10],
                    [7, 10],
                    [7, 10],
                    [7, 10],
                    [7, 10],
                    [7, 11],
                    [7, 11],
                    [7, 11],
                    [7, 11],
                    [7, 11],
                    [7, 11],
                    [7, 11],
                    [7, 11],
                    [7, 11],
                    [7, 11],
                    [7, 11],
                    [7, 11],
                    [7, 11],
                    [7, 11],
                    [7, 11],
                    [7, 11],
                    [7, 11],
                    [7, 11],
                    [7, 11],
                    [7, 11],
                    [7, 11],
                    [7, 11],
                    [7, 11],
                    [7, 11],
                    [7, 11],
                    [7, 11],
                    [7, 11],
                    [7, 11],
                    [7, 11],
                    [7, 11],
                    [7, 11],
                    [7, 11],
                    [9, 15],
                    [9, 15],
                    [9, 15],
                    [9, 15],
                    [9, 15],
                    [9, 15],
                    [9, 15],
                    [9, 15],
                    [12, 128],
                    [12, 192],
                    [12, 26],
                    [12, 27],
                    [12, 28],
                    [12, 29],
                    [11, 19],
                    [11, 19],
                    [11, 20],
                    [11, 20],
                    [12, 34],
                    [12, 35],
                    [12, 36],
                    [12, 37],
                    [12, 38],
                    [12, 39],
                    [11, 21],
                    [11, 21],
                    [12, 42],
                    [12, 43],
                    [10, 0],
                    [10, 0],
                    [10, 0],
                    [10, 0],
                    [7, 12],
                    [7, 12],
                    [7, 12],
                    [7, 12],
                    [7, 12],
                    [7, 12],
                    [7, 12],
                    [7, 12],
                    [7, 12],
                    [7, 12],
                    [7, 12],
                    [7, 12],
                    [7, 12],
                    [7, 12],
                    [7, 12],
                    [7, 12],
                    [7, 12],
                    [7, 12],
                    [7, 12],
                    [7, 12],
                    [7, 12],
                    [7, 12],
                    [7, 12],
                    [7, 12],
                    [7, 12],
                    [7, 12],
                    [7, 12],
                    [7, 12],
                    [7, 12],
                    [7, 12],
                    [7, 12],
                    [7, 12]
                ];
                var blackTable3 = [
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [-1, -1],
                    [6, 9],
                    [6, 8],
                    [5, 7],
                    [5, 7],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 6],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [4, 5],
                    [3, 1],
                    [3, 1],
                    [3, 1],
                    [3, 1],
                    [3, 1],
                    [3, 1],
                    [3, 1],
                    [3, 1],
                    [3, 4],
                    [3, 4],
                    [3, 4],
                    [3, 4],
                    [3, 4],
                    [3, 4],
                    [3, 4],
                    [3, 4],
                    [2, 3],
                    [2, 3],
                    [2, 3],
                    [2, 3],
                    [2, 3],
                    [2, 3],
                    [2, 3],
                    [2, 3],
                    [2, 3],
                    [2, 3],
                    [2, 3],
                    [2, 3],
                    [2, 3],
                    [2, 3],
                    [2, 3],
                    [2, 3],
                    [2, 2],
                    [2, 2],
                    [2, 2],
                    [2, 2],
                    [2, 2],
                    [2, 2],
                    [2, 2],
                    [2, 2],
                    [2, 2],
                    [2, 2],
                    [2, 2],
                    [2, 2],
                    [2, 2],
                    [2, 2],
                    [2, 2],
                    [2, 2]
                ];

                function CCITTFaxStream(str, maybeLength, params) {
                    this.str = str;
                    this.dict = str.dict;
                    params = params || Dict.empty;
                    this.encoding = params.get('K') || 0;
                    this.eoline = params.get('EndOfLine') || false;
                    this.byteAlign = params.get('EncodedByteAlign') || false;
                    this.columns = params.get('Columns') || 1728;
                    this.rows = params.get('Rows') || 0;
                    var eoblock = params.get('EndOfBlock');
                    if (eoblock === null || eoblock === undefined) {
                        eoblock = true;
                    }
                    this.eoblock = eoblock;
                    this.black = params.get('BlackIs1') || false;
                    this.codingLine = new Uint32Array(this.columns + 1);
                    this.refLine = new Uint32Array(this.columns + 2);
                    this.codingLine[0] = this.columns;
                    this.codingPos = 0;
                    this.row = 0;
                    this.nextLine2D = this.encoding < 0;
                    this.inputBits = 0;
                    this.inputBuf = 0;
                    this.outputBits = 0;
                    var code1;
                    while ((code1 = this.lookBits(12)) === 0) {
                        this.eatBits(1);
                    }
                    if (code1 === 1) {
                        this.eatBits(12);
                    }
                    if (this.encoding > 0) {
                        this.nextLine2D = !this.lookBits(1);
                        this.eatBits(1);
                    }
                    DecodeStream.call(this, maybeLength);
                }
                CCITTFaxStream.prototype = Object.create(DecodeStream.prototype);
                CCITTFaxStream.prototype.readBlock = function CCITTFaxStream_readBlock() {
                    while (!this.eof) {
                        var c = this.lookChar();
                        this.ensureBuffer(this.bufferLength + 1);
                        this.buffer[this.bufferLength++] = c;
                    }
                };
                CCITTFaxStream.prototype.addPixels = function ccittFaxStreamAddPixels(a1, blackPixels) {
                    var codingLine = this.codingLine;
                    var codingPos = this.codingPos;
                    if (a1 > codingLine[codingPos]) {
                        if (a1 > this.columns) {
                            info('row is wrong length');
                            this.err = true;
                            a1 = this.columns;
                        }
                        if ((codingPos & 1) ^ blackPixels) {
                            ++codingPos;
                        }
                        codingLine[codingPos] = a1;
                    }
                    this.codingPos = codingPos;
                };
                CCITTFaxStream.prototype.addPixelsNeg = function ccittFaxStreamAddPixelsNeg(a1, blackPixels) {
                    var codingLine = this.codingLine;
                    var codingPos = this.codingPos;
                    if (a1 > codingLine[codingPos]) {
                        if (a1 > this.columns) {
                            info('row is wrong length');
                            this.err = true;
                            a1 = this.columns;
                        }
                        if ((codingPos & 1) ^ blackPixels) {
                            ++codingPos;
                        }
                        codingLine[codingPos] = a1;
                    } else if (a1 < codingLine[codingPos]) {
                        if (a1 < 0) {
                            info('invalid code');
                            this.err = true;
                            a1 = 0;
                        }
                        while (codingPos > 0 && a1 < codingLine[codingPos - 1]) {
                            --codingPos;
                        }
                        codingLine[codingPos] = a1;
                    }
                    this.codingPos = codingPos;
                };
                CCITTFaxStream.prototype.lookChar = function CCITTFaxStream_lookChar() {
                    var refLine = this.refLine;
                    var codingLine = this.codingLine;
                    var columns = this.columns;
                    var refPos, blackPixels, bits, i;
                    if (this.outputBits === 0) {
                        if (this.eof) {
                            return null;
                        }
                        this.err = false;
                        var code1, code2, code3;
                        if (this.nextLine2D) {
                            for (i = 0; codingLine[i] < columns; ++i) {
                                refLine[i] = codingLine[i];
                            }
                            refLine[i++] = columns;
                            refLine[i] = columns;
                            codingLine[0] = 0;
                            this.codingPos = 0;
                            refPos = 0;
                            blackPixels = 0;
                            while (codingLine[this.codingPos] < columns) {
                                code1 = this.getTwoDimCode();
                                switch (code1) {
                                    case twoDimPass:
                                        this.addPixels(refLine[refPos + 1], blackPixels);
                                        if (refLine[refPos + 1] < columns) {
                                            refPos += 2;
                                        }
                                        break;
                                    case twoDimHoriz:
                                        code1 = code2 = 0;
                                        if (blackPixels) {
                                            do {
                                                code1 += (code3 = this.getBlackCode());
                                            } while (code3 >= 64);
                                            do {
                                                code2 += (code3 = this.getWhiteCode());
                                            } while (code3 >= 64);
                                        } else {
                                            do {
                                                code1 += (code3 = this.getWhiteCode());
                                            } while (code3 >= 64);
                                            do {
                                                code2 += (code3 = this.getBlackCode());
                                            } while (code3 >= 64);
                                        }
                                        this.addPixels(codingLine[this.codingPos] +
                                            code1, blackPixels);
                                        if (codingLine[this.codingPos] < columns) {
                                            this.addPixels(codingLine[this.codingPos] + code2, blackPixels ^ 1);
                                        }
                                        while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                            refPos += 2;
                                        }
                                        break;
                                    case twoDimVertR3:
                                        this.addPixels(refLine[refPos] + 3, blackPixels);
                                        blackPixels ^= 1;
                                        if (codingLine[this.codingPos] < columns) {
                                            ++refPos;
                                            while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                                refPos += 2;
                                            }
                                        }
                                        break;
                                    case twoDimVertR2:
                                        this.addPixels(refLine[refPos] + 2, blackPixels);
                                        blackPixels ^= 1;
                                        if (codingLine[this.codingPos] < columns) {
                                            ++refPos;
                                            while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                                refPos += 2;
                                            }
                                        }
                                        break;
                                    case twoDimVertR1:
                                        this.addPixels(refLine[refPos] + 1, blackPixels);
                                        blackPixels ^= 1;
                                        if (codingLine[this.codingPos] < columns) {
                                            ++refPos;
                                            while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                                refPos += 2;
                                            }
                                        }
                                        break;
                                    case twoDimVert0:
                                        this.addPixels(refLine[refPos], blackPixels);
                                        blackPixels ^= 1;
                                        if (codingLine[this.codingPos] < columns) {
                                            ++refPos;
                                            while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                                refPos += 2;
                                            }
                                        }
                                        break;
                                    case twoDimVertL3:
                                        this.addPixelsNeg(refLine[refPos] - 3, blackPixels);
                                        blackPixels ^= 1;
                                        if (codingLine[this.codingPos] < columns) {
                                            if (refPos > 0) {
                                                --refPos;
                                            } else {
                                                ++refPos;
                                            }
                                            while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                                refPos += 2;
                                            }
                                        }
                                        break;
                                    case twoDimVertL2:
                                        this.addPixelsNeg(refLine[refPos] - 2, blackPixels);
                                        blackPixels ^= 1;
                                        if (codingLine[this.codingPos] < columns) {
                                            if (refPos > 0) {
                                                --refPos;
                                            } else {
                                                ++refPos;
                                            }
                                            while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                                refPos += 2;
                                            }
                                        }
                                        break;
                                    case twoDimVertL1:
                                        this.addPixelsNeg(refLine[refPos] - 1, blackPixels);
                                        blackPixels ^= 1;
                                        if (codingLine[this.codingPos] < columns) {
                                            if (refPos > 0) {
                                                --refPos;
                                            } else {
                                                ++refPos;
                                            }
                                            while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                                refPos += 2;
                                            }
                                        }
                                        break;
                                    case EOF:
                                        this.addPixels(columns, 0);
                                        this.eof = true;
                                        break;
                                    default:
                                        info('bad 2d code');
                                        this.addPixels(columns, 0);
                                        this.err = true;
                                }
                            }
                        } else {
                            codingLine[0] = 0;
                            this.codingPos = 0;
                            blackPixels = 0;
                            while (codingLine[this.codingPos] < columns) {
                                code1 = 0;
                                if (blackPixels) {
                                    do {
                                        code1 += (code3 = this.getBlackCode());
                                    } while (code3 >= 64);
                                } else {
                                    do {
                                        code1 += (code3 = this.getWhiteCode());
                                    } while (code3 >= 64);
                                }
                                this.addPixels(codingLine[this.codingPos] + code1, blackPixels);
                                blackPixels ^= 1;
                            }
                        }
                        var gotEOL = false;
                        if (this.byteAlign) {
                            this.inputBits &= ~7;
                        }
                        if (!this.eoblock && this.row === this.rows - 1) {
                            this.eof = true;
                        } else {
                            code1 = this.lookBits(12);
                            if (this.eoline) {
                                while (code1 !== EOF && code1 !== 1) {
                                    this.eatBits(1);
                                    code1 = this.lookBits(12);
                                }
                            } else {
                                while (code1 === 0) {
                                    this.eatBits(1);
                                    code1 = this.lookBits(12);
                                }
                            }
                            if (code1 === 1) {
                                this.eatBits(12);
                                gotEOL = true;
                            } else if (code1 === EOF) {
                                this.eof = true;
                            }
                        }
                        if (!this.eof && this.encoding > 0) {
                            this.nextLine2D = !this.lookBits(1);
                            this.eatBits(1);
                        }
                        if (this.eoblock && gotEOL && this.byteAlign) {
                            code1 = this.lookBits(12);
                            if (code1 === 1) {
                                this.eatBits(12);
                                if (this.encoding > 0) {
                                    this.lookBits(1);
                                    this.eatBits(1);
                                }
                                if (this.encoding >= 0) {
                                    for (i = 0; i < 4; ++i) {
                                        code1 = this.lookBits(12);
                                        if (code1 !== 1) {
                                            info('bad rtc code: ' + code1);
                                        }
                                        this.eatBits(12);
                                        if (this.encoding > 0) {
                                            this.lookBits(1);
                                            this.eatBits(1);
                                        }
                                    }
                                }
                                this.eof = true;
                            }
                        } else if (this.err && this.eoline) {
                            while (true) {
                                code1 = this.lookBits(13);
                                if (code1 === EOF) {
                                    this.eof = true;
                                    return null;
                                }
                                if ((code1 >> 1) === 1) {
                                    break;
                                }
                                this.eatBits(1);
                            }
                            this.eatBits(12);
                            if (this.encoding > 0) {
                                this.eatBits(1);
                                this.nextLine2D = !(code1 & 1);
                            }
                        }
                        if (codingLine[0] > 0) {
                            this.outputBits = codingLine[this.codingPos = 0];
                        } else {
                            this.outputBits = codingLine[this.codingPos = 1];
                        }
                        this.row++;
                    }
                    var c;
                    if (this.outputBits >= 8) {
                        c = (this.codingPos & 1) ? 0 : 0xFF;
                        this.outputBits -= 8;
                        if (this.outputBits === 0 && codingLine[this.codingPos] < columns) {
                            this.codingPos++;
                            this.outputBits = (codingLine[this.codingPos] -
                                codingLine[this.codingPos - 1]);
                        }
                    } else {
                        bits = 8;
                        c = 0;
                        do {
                            if (this.outputBits > bits) {
                                c <<= bits;
                                if (!(this.codingPos & 1)) {
                                    c |= 0xFF >> (8 - bits);
                                }
                                this.outputBits -= bits;
                                bits = 0;
                            } else {
                                c <<= this.outputBits;
                                if (!(this.codingPos & 1)) {
                                    c |= 0xFF >> (8 - this.outputBits);
                                }
                                bits -= this.outputBits;
                                this.outputBits = 0;
                                if (codingLine[this.codingPos] < columns) {
                                    this.codingPos++;
                                    this.outputBits = (codingLine[this.codingPos] -
                                        codingLine[this.codingPos - 1]);
                                } else if (bits > 0) {
                                    c <<= bits;
                                    bits = 0;
                                }
                            }
                        } while (bits);
                    }
                    if (this.black) {
                        c ^= 0xFF;
                    }
                    return c;
                };
                CCITTFaxStream.prototype.findTableCode = function ccittFaxStreamFindTableCode(start, end, table, limit) {
                    var limitValue = limit || 0;
                    for (var i = start; i <= end; ++i) {
                        var code = this.lookBits(i);
                        if (code === EOF) {
                            return [true, 1, false];
                        }
                        if (i < end) {
                            code <<= end - i;
                        }
                        if (!limitValue || code >= limitValue) {
                            var p = table[code - limitValue];
                            if (p[0] === i) {
                                this.eatBits(i);
                                return [true, p[1], true];
                            }
                        }
                    }
                    return [false, 0, false];
                };
                CCITTFaxStream.prototype.getTwoDimCode = function ccittFaxStreamGetTwoDimCode() {
                    var code = 0;
                    var p;
                    if (this.eoblock) {
                        code = this.lookBits(7);
                        p = twoDimTable[code];
                        if (p && p[0] > 0) {
                            this.eatBits(p[0]);
                            return p[1];
                        }
                    } else {
                        var result = this.findTableCode(1, 7, twoDimTable);
                        if (result[0] && result[2]) {
                            return result[1];
                        }
                    }
                    info('Bad two dim code');
                    return EOF;
                };
                CCITTFaxStream.prototype.getWhiteCode = function ccittFaxStreamGetWhiteCode() {
                    var code = 0;
                    var p;
                    if (this.eoblock) {
                        code = this.lookBits(12);
                        if (code === EOF) {
                            return 1;
                        }
                        if ((code >> 5) === 0) {
                            p = whiteTable1[code];
                        } else {
                            p = whiteTable2[code >> 3];
                        }
                        if (p[0] > 0) {
                            this.eatBits(p[0]);
                            return p[1];
                        }
                    } else {
                        var result = this.findTableCode(1, 9, whiteTable2);
                        if (result[0]) {
                            return result[1];
                        }
                        result = this.findTableCode(11, 12, whiteTable1);
                        if (result[0]) {
                            return result[1];
                        }
                    }
                    info('bad white code');
                    this.eatBits(1);
                    return 1;
                };
                CCITTFaxStream.prototype.getBlackCode = function ccittFaxStreamGetBlackCode() {
                    var code, p;
                    if (this.eoblock) {
                        code = this.lookBits(13);
                        if (code === EOF) {
                            return 1;
                        }
                        if ((code >> 7) === 0) {
                            p = blackTable1[code];
                        } else if ((code >> 9) === 0 && (code >> 7) !== 0) {
                            p = blackTable2[(code >> 1) - 64];
                        } else {
                            p = blackTable3[code >> 7];
                        }
                        if (p[0] > 0) {
                            this.eatBits(p[0]);
                            return p[1];
                        }
                    } else {
                        var result = this.findTableCode(2, 6, blackTable3);
                        if (result[0]) {
                            return result[1];
                        }
                        result = this.findTableCode(7, 12, blackTable2, 64);
                        if (result[0]) {
                            return result[1];
                        }
                        result = this.findTableCode(10, 13, blackTable1);
                        if (result[0]) {
                            return result[1];
                        }
                    }
                    info('bad black code');
                    this.eatBits(1);
                    return 1;
                };
                CCITTFaxStream.prototype.lookBits = function CCITTFaxStream_lookBits(n) {
                    var c;
                    while (this.inputBits < n) {
                        if ((c = this.str.getByte()) === -1) {
                            if (this.inputBits === 0) {
                                return EOF;
                            }
                            return ((this.inputBuf << (n - this.inputBits)) & (0xFFFF >> (16 - n)));
                        }
                        this.inputBuf = (this.inputBuf << 8) + c;
                        this.inputBits += 8;
                    }
                    return (this.inputBuf >> (this.inputBits - n)) & (0xFFFF >> (16 - n));
                };
                CCITTFaxStream.prototype.eatBits = function CCITTFaxStream_eatBits(n) {
                    if ((this.inputBits -= n) < 0) {
                        this.inputBits = 0;
                    }
                };
                return CCITTFaxStream;
            })();
            var LZWStream = (function LZWStreamClosure() {
                function LZWStream(str, maybeLength, earlyChange) {
                    this.str = str;
                    this.dict = str.dict;
                    this.cachedData = 0;
                    this.bitsCached = 0;
                    var maxLzwDictionarySize = 4096;
                    var lzwState = {
                        earlyChange: earlyChange,
                        codeLength: 9,
                        nextCode: 258,
                        dictionaryValues: new Uint8Array(maxLzwDictionarySize),
                        dictionaryLengths: new Uint16Array(maxLzwDictionarySize),
                        dictionaryPrevCodes: new Uint16Array(maxLzwDictionarySize),
                        currentSequence: new Uint8Array(maxLzwDictionarySize),
                        currentSequenceLength: 0
                    };
                    for (var i = 0; i < 256; ++i) {
                        lzwState.dictionaryValues[i] = i;
                        lzwState.dictionaryLengths[i] = 1;
                    }
                    this.lzwState = lzwState;
                    DecodeStream.call(this, maybeLength);
                }
                LZWStream.prototype = Object.create(DecodeStream.prototype);
                LZWStream.prototype.readBits = function LZWStream_readBits(n) {
                    var bitsCached = this.bitsCached;
                    var cachedData = this.cachedData;
                    while (bitsCached < n) {
                        var c = this.str.getByte();
                        if (c === -1) {
                            this.eof = true;
                            return null;
                        }
                        cachedData = (cachedData << 8) | c;
                        bitsCached += 8;
                    }
                    this.bitsCached = (bitsCached -= n);
                    this.cachedData = cachedData;
                    this.lastCode = null;
                    return (cachedData >>> bitsCached) & ((1 << n) - 1);
                };
                LZWStream.prototype.readBlock = function LZWStream_readBlock() {
                    var blockSize = 512;
                    var estimatedDecodedSize = blockSize * 2,
                        decodedSizeDelta = blockSize;
                    var i, j, q;
                    var lzwState = this.lzwState;
                    if (!lzwState) {
                        return;
                    }
                    var earlyChange = lzwState.earlyChange;
                    var nextCode = lzwState.nextCode;
                    var dictionaryValues = lzwState.dictionaryValues;
                    var dictionaryLengths = lzwState.dictionaryLengths;
                    var dictionaryPrevCodes = lzwState.dictionaryPrevCodes;
                    var codeLength = lzwState.codeLength;
                    var prevCode = lzwState.prevCode;
                    var currentSequence = lzwState.currentSequence;
                    var currentSequenceLength = lzwState.currentSequenceLength;
                    var decodedLength = 0;
                    var currentBufferLength = this.bufferLength;
                    var buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
                    for (i = 0; i < blockSize; i++) {
                        var code = this.readBits(codeLength);
                        var hasPrev = currentSequenceLength > 0;
                        if (code < 256) {
                            currentSequence[0] = code;
                            currentSequenceLength = 1;
                        } else if (code >= 258) {
                            if (code < nextCode) {
                                currentSequenceLength = dictionaryLengths[code];
                                for (j = currentSequenceLength - 1, q = code; j >= 0; j--) {
                                    currentSequence[j] = dictionaryValues[q];
                                    q = dictionaryPrevCodes[q];
                                }
                            } else {
                                currentSequence[currentSequenceLength++] = currentSequence[0];
                            }
                        } else if (code === 256) {
                            codeLength = 9;
                            nextCode = 258;
                            currentSequenceLength = 0;
                            continue;
                        } else {
                            this.eof = true;
                            delete this.lzwState;
                            break;
                        }
                        if (hasPrev) {
                            dictionaryPrevCodes[nextCode] = prevCode;
                            dictionaryLengths[nextCode] = dictionaryLengths[prevCode] + 1;
                            dictionaryValues[nextCode] = currentSequence[0];
                            nextCode++;
                            codeLength = (nextCode + earlyChange) & (nextCode + earlyChange - 1) ? codeLength : Math.min(Math.log(nextCode + earlyChange) / 0.6931471805599453 + 1, 12) | 0;
                        }
                        prevCode = code;
                        decodedLength += currentSequenceLength;
                        if (estimatedDecodedSize < decodedLength) {
                            do {
                                estimatedDecodedSize += decodedSizeDelta;
                            } while (estimatedDecodedSize < decodedLength);
                            buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
                        }
                        for (j = 0; j < currentSequenceLength; j++) {
                            buffer[currentBufferLength++] = currentSequence[j];
                        }
                    }
                    lzwState.nextCode = nextCode;
                    lzwState.codeLength = codeLength;
                    lzwState.prevCode = prevCode;
                    lzwState.currentSequenceLength = currentSequenceLength;
                    this.bufferLength = currentBufferLength;
                };
                return LZWStream;
            })();
            var NullStream = (function NullStreamClosure() {
                function NullStream() {
                    Stream.call(this, new Uint8Array(0));
                }
                NullStream.prototype = Stream.prototype;
                return NullStream;
            })();

            function _setCoreParser(coreParser_) {
                coreParser = coreParser_;
                EOF = coreParser_.EOF;
                Lexer = coreParser_.Lexer;
            }
            exports._setCoreParser = _setCoreParser;

            function _setCoreColorSpace(coreColorSpace_) {
                coreColorSpace = coreColorSpace_;
                ColorSpace = coreColorSpace_.ColorSpace;
            }
            exports._setCoreColorSpace = _setCoreColorSpace;
            exports.Ascii85Stream = Ascii85Stream;
            exports.AsciiHexStream = AsciiHexStream;
            exports.CCITTFaxStream = CCITTFaxStream;
            exports.DecryptStream = DecryptStream;
            exports.DecodeStream = DecodeStream;
            exports.FlateStream = FlateStream;
            exports.Jbig2Stream = Jbig2Stream;
            exports.JpegStream = JpegStream;
            exports.JpxStream = JpxStream;
            exports.NullStream = NullStream;
            exports.PredictorStream = PredictorStream;
            exports.RunLengthStream = RunLengthStream;
            exports.Stream = Stream;
            exports.StreamsSequenceStream = StreamsSequenceStream;
            exports.StringStream = StringStream;
            exports.LZWStream = LZWStream;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsCoreCrypto = {}), root.pdfjsSharedUtil, root.pdfjsCorePrimitives, root.pdfjsCoreStream);
            }
        }(this, function(exports, sharedUtil, corePrimitives, coreStream) {
            var PasswordException = sharedUtil.PasswordException;
            var PasswordResponses = sharedUtil.PasswordResponses;
            var bytesToString = sharedUtil.bytesToString;
            var error = sharedUtil.error;
            var isInt = sharedUtil.isInt;
            var stringToBytes = sharedUtil.stringToBytes;
            var utf8StringToString = sharedUtil.utf8StringToString;
            var warn = sharedUtil.warn;
            var Name = corePrimitives.Name;
            var isName = corePrimitives.isName;
            var isDict = corePrimitives.isDict;
            var DecryptStream = coreStream.DecryptStream;
            var ARCFourCipher = (function ARCFourCipherClosure() {
                function ARCFourCipher(key) {
                    this.a = 0;
                    this.b = 0;
                    var s = new Uint8Array(256);
                    var i, j = 0,
                        tmp, keyLength = key.length;
                    for (i = 0; i < 256; ++i) {
                        s[i] = i;
                    }
                    for (i = 0; i < 256; ++i) {
                        tmp = s[i];
                        j = (j + tmp + key[i % keyLength]) & 0xFF;
                        s[i] = s[j];
                        s[j] = tmp;
                    }
                    this.s = s;
                }
                ARCFourCipher.prototype = {
                    encryptBlock: function ARCFourCipher_encryptBlock(data) {
                        var i, n = data.length,
                            tmp, tmp2;
                        var a = this.a,
                            b = this.b,
                            s = this.s;
                        var output = new Uint8Array(n);
                        for (i = 0; i < n; ++i) {
                            a = (a + 1) & 0xFF;
                            tmp = s[a];
                            b = (b + tmp) & 0xFF;
                            tmp2 = s[b];
                            s[a] = tmp2;
                            s[b] = tmp;
                            output[i] = data[i] ^ s[(tmp + tmp2) & 0xFF];
                        }
                        this.a = a;
                        this.b = b;
                        return output;
                    }
                };
                ARCFourCipher.prototype.decryptBlock = ARCFourCipher.prototype.encryptBlock;
                return ARCFourCipher;
            })();
            var calculateMD5 = (function calculateMD5Closure() {
                var r = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]);
                var k = new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]);

                function hash(data, offset, length) {
                    var h0 = 1732584193,
                        h1 = -271733879,
                        h2 = -1732584194,
                        h3 = 271733878;
                    var paddedLength = (length + 72) & ~63;
                    var padded = new Uint8Array(paddedLength);
                    var i, j, n;
                    for (i = 0; i < length; ++i) {
                        padded[i] = data[offset++];
                    }
                    padded[i++] = 0x80;
                    n = paddedLength - 8;
                    while (i < n) {
                        padded[i++] = 0;
                    }
                    padded[i++] = (length << 3) & 0xFF;
                    padded[i++] = (length >> 5) & 0xFF;
                    padded[i++] = (length >> 13) & 0xFF;
                    padded[i++] = (length >> 21) & 0xFF;
                    padded[i++] = (length >>> 29) & 0xFF;
                    padded[i++] = 0;
                    padded[i++] = 0;
                    padded[i++] = 0;
                    var w = new Int32Array(16);
                    for (i = 0; i < paddedLength;) {
                        for (j = 0; j < 16; ++j, i += 4) {
                            w[j] = (padded[i] | (padded[i + 1] << 8) | (padded[i + 2] << 16) | (padded[i + 3] << 24));
                        }
                        var a = h0,
                            b = h1,
                            c = h2,
                            d = h3,
                            f, g;
                        for (j = 0; j < 64; ++j) {
                            if (j < 16) {
                                f = (b & c) | ((~b) & d);
                                g = j;
                            } else if (j < 32) {
                                f = (d & b) | ((~d) & c);
                                g = (5 * j + 1) & 15;
                            } else if (j < 48) {
                                f = b ^ c ^ d;
                                g = (3 * j + 5) & 15;
                            } else {
                                f = c ^ (b | (~d));
                                g = (7 * j) & 15;
                            }
                            var tmp = d,
                                rotateArg = (a + f + k[j] + w[g]) | 0,
                                rotate = r[j];
                            d = c;
                            c = b;
                            b = (b + ((rotateArg << rotate) | (rotateArg >>> (32 - rotate)))) | 0;
                            a = tmp;
                        }
                        h0 = (h0 + a) | 0;
                        h1 = (h1 + b) | 0;
                        h2 = (h2 + c) | 0;
                        h3 = (h3 + d) | 0;
                    }
                    return new Uint8Array([h0 & 0xFF, (h0 >> 8) & 0xFF, (h0 >> 16) & 0xFF, (h0 >>> 24) & 0xFF, h1 & 0xFF, (h1 >> 8) & 0xFF, (h1 >> 16) & 0xFF, (h1 >>> 24) & 0xFF, h2 & 0xFF, (h2 >> 8) & 0xFF, (h2 >> 16) & 0xFF, (h2 >>> 24) & 0xFF, h3 & 0xFF, (h3 >> 8) & 0xFF, (h3 >> 16) & 0xFF, (h3 >>> 24) & 0xFF]);
                }
                return hash;
            })();
            var Word64 = (function Word64Closure() {
                function Word64(highInteger, lowInteger) {
                    this.high = highInteger | 0;
                    this.low = lowInteger | 0;
                }
                Word64.prototype = {
                    and: function Word64_and(word) {
                        this.high &= word.high;
                        this.low &= word.low;
                    },
                    xor: function Word64_xor(word) {
                        this.high ^= word.high;
                        this.low ^= word.low;
                    },
                    or: function Word64_or(word) {
                        this.high |= word.high;
                        this.low |= word.low;
                    },
                    shiftRight: function Word64_shiftRight(places) {
                        if (places >= 32) {
                            this.low = (this.high >>> (places - 32)) | 0;
                            this.high = 0;
                        } else {
                            this.low = (this.low >>> places) | (this.high << (32 - places));
                            this.high = (this.high >>> places) | 0;
                        }
                    },
                    shiftLeft: function Word64_shiftLeft(places) {
                        if (places >= 32) {
                            this.high = this.low << (places - 32);
                            this.low = 0;
                        } else {
                            this.high = (this.high << places) | (this.low >>> (32 - places));
                            this.low = this.low << places;
                        }
                    },
                    rotateRight: function Word64_rotateRight(places) {
                        var low, high;
                        if (places & 32) {
                            high = this.low;
                            low = this.high;
                        } else {
                            low = this.low;
                            high = this.high;
                        }
                        places &= 31;
                        this.low = (low >>> places) | (high << (32 - places));
                        this.high = (high >>> places) | (low << (32 - places));
                    },
                    not: function Word64_not() {
                        this.high = ~this.high;
                        this.low = ~this.low;
                    },
                    add: function Word64_add(word) {
                        var lowAdd = (this.low >>> 0) + (word.low >>> 0);
                        var highAdd = (this.high >>> 0) + (word.high >>> 0);
                        if (lowAdd > 0xFFFFFFFF) {
                            highAdd += 1;
                        }
                        this.low = lowAdd | 0;
                        this.high = highAdd | 0;
                    },
                    copyTo: function Word64_copyTo(bytes, offset) {
                        bytes[offset] = (this.high >>> 24) & 0xFF;
                        bytes[offset + 1] = (this.high >> 16) & 0xFF;
                        bytes[offset + 2] = (this.high >> 8) & 0xFF;
                        bytes[offset + 3] = this.high & 0xFF;
                        bytes[offset + 4] = (this.low >>> 24) & 0xFF;
                        bytes[offset + 5] = (this.low >> 16) & 0xFF;
                        bytes[offset + 6] = (this.low >> 8) & 0xFF;
                        bytes[offset + 7] = this.low & 0xFF;
                    },
                    assign: function Word64_assign(word) {
                        this.high = word.high;
                        this.low = word.low;
                    }
                };
                return Word64;
            })();
            var calculateSHA256 = (function calculateSHA256Closure() {
                function rotr(x, n) {
                    return (x >>> n) | (x << 32 - n);
                }

                function ch(x, y, z) {
                    return (x & y) ^ (~x & z);
                }

                function maj(x, y, z) {
                    return (x & y) ^ (x & z) ^ (y & z);
                }

                function sigma(x) {
                    return rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22);
                }

                function sigmaPrime(x) {
                    return rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25);
                }

                function littleSigma(x) {
                    return rotr(x, 7) ^ rotr(x, 18) ^ x >>> 3;
                }

                function littleSigmaPrime(x) {
                    return rotr(x, 17) ^ rotr(x, 19) ^ x >>> 10;
                }
                var k = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];

                function hash(data, offset, length) {
                    var h0 = 0x6a09e667,
                        h1 = 0xbb67ae85,
                        h2 = 0x3c6ef372,
                        h3 = 0xa54ff53a,
                        h4 = 0x510e527f,
                        h5 = 0x9b05688c,
                        h6 = 0x1f83d9ab,
                        h7 = 0x5be0cd19;
                    var paddedLength = Math.ceil((length + 9) / 64) * 64;
                    var padded = new Uint8Array(paddedLength);
                    var i, j, n;
                    for (i = 0; i < length; ++i) {
                        padded[i] = data[offset++];
                    }
                    padded[i++] = 0x80;
                    n = paddedLength - 8;
                    while (i < n) {
                        padded[i++] = 0;
                    }
                    padded[i++] = 0;
                    padded[i++] = 0;
                    padded[i++] = 0;
                    padded[i++] = (length >>> 29) & 0xFF;
                    padded[i++] = (length >> 21) & 0xFF;
                    padded[i++] = (length >> 13) & 0xFF;
                    padded[i++] = (length >> 5) & 0xFF;
                    padded[i++] = (length << 3) & 0xFF;
                    var w = new Uint32Array(64);
                    for (i = 0; i < paddedLength;) {
                        for (j = 0; j < 16; ++j) {
                            w[j] = (padded[i] << 24 | (padded[i + 1] << 16) | (padded[i + 2] << 8) | (padded[i + 3]));
                            i += 4;
                        }
                        for (j = 16; j < 64; ++j) {
                            w[j] = littleSigmaPrime(w[j - 2]) + w[j - 7] +
                                littleSigma(w[j - 15]) + w[j - 16] | 0;
                        }
                        var a = h0,
                            b = h1,
                            c = h2,
                            d = h3,
                            e = h4,
                            f = h5,
                            g = h6,
                            h = h7,
                            t1, t2;
                        for (j = 0; j < 64; ++j) {
                            t1 = h + sigmaPrime(e) + ch(e, f, g) + k[j] + w[j];
                            t2 = sigma(a) + maj(a, b, c);
                            h = g;
                            g = f;
                            f = e;
                            e = (d + t1) | 0;
                            d = c;
                            c = b;
                            b = a;
                            a = (t1 + t2) | 0;
                        }
                        h0 = (h0 + a) | 0;
                        h1 = (h1 + b) | 0;
                        h2 = (h2 + c) | 0;
                        h3 = (h3 + d) | 0;
                        h4 = (h4 + e) | 0;
                        h5 = (h5 + f) | 0;
                        h6 = (h6 + g) | 0;
                        h7 = (h7 + h) | 0;
                    }
                    return new Uint8Array([(h0 >> 24) & 0xFF, (h0 >> 16) & 0xFF, (h0 >> 8) & 0xFF, (h0) & 0xFF, (h1 >> 24) & 0xFF, (h1 >> 16) & 0xFF, (h1 >> 8) & 0xFF, (h1) & 0xFF, (h2 >> 24) & 0xFF, (h2 >> 16) & 0xFF, (h2 >> 8) & 0xFF, (h2) & 0xFF, (h3 >> 24) & 0xFF, (h3 >> 16) & 0xFF, (h3 >> 8) & 0xFF, (h3) & 0xFF, (h4 >> 24) & 0xFF, (h4 >> 16) & 0xFF, (h4 >> 8) & 0xFF, (h4) & 0xFF, (h5 >> 24) & 0xFF, (h5 >> 16) & 0xFF, (h5 >> 8) & 0xFF, (h5) & 0xFF, (h6 >> 24) & 0xFF, (h6 >> 16) & 0xFF, (h6 >> 8) & 0xFF, (h6) & 0xFF, (h7 >> 24) & 0xFF, (h7 >> 16) & 0xFF, (h7 >> 8) & 0xFF, (h7) & 0xFF]);
                }
                return hash;
            })();
            var calculateSHA512 = (function calculateSHA512Closure() {
                function ch(result, x, y, z, tmp) {
                    result.assign(x);
                    result.and(y);
                    tmp.assign(x);
                    tmp.not();
                    tmp.and(z);
                    result.xor(tmp);
                }

                function maj(result, x, y, z, tmp) {
                    result.assign(x);
                    result.and(y);
                    tmp.assign(x);
                    tmp.and(z);
                    result.xor(tmp);
                    tmp.assign(y);
                    tmp.and(z);
                    result.xor(tmp);
                }

                function sigma(result, x, tmp) {
                    result.assign(x);
                    result.rotateRight(28);
                    tmp.assign(x);
                    tmp.rotateRight(34);
                    result.xor(tmp);
                    tmp.assign(x);
                    tmp.rotateRight(39);
                    result.xor(tmp);
                }

                function sigmaPrime(result, x, tmp) {
                    result.assign(x);
                    result.rotateRight(14);
                    tmp.assign(x);
                    tmp.rotateRight(18);
                    result.xor(tmp);
                    tmp.assign(x);
                    tmp.rotateRight(41);
                    result.xor(tmp);
                }

                function littleSigma(result, x, tmp) {
                    result.assign(x);
                    result.rotateRight(1);
                    tmp.assign(x);
                    tmp.rotateRight(8);
                    result.xor(tmp);
                    tmp.assign(x);
                    tmp.shiftRight(7);
                    result.xor(tmp);
                }

                function littleSigmaPrime(result, x, tmp) {
                    result.assign(x);
                    result.rotateRight(19);
                    tmp.assign(x);
                    tmp.rotateRight(61);
                    result.xor(tmp);
                    tmp.assign(x);
                    tmp.shiftRight(6);
                    result.xor(tmp);
                }
                var k = [new Word64(0x428a2f98, 0xd728ae22), new Word64(0x71374491, 0x23ef65cd), new Word64(0xb5c0fbcf, 0xec4d3b2f), new Word64(0xe9b5dba5, 0x8189dbbc), new Word64(0x3956c25b, 0xf348b538), new Word64(0x59f111f1, 0xb605d019), new Word64(0x923f82a4, 0xaf194f9b), new Word64(0xab1c5ed5, 0xda6d8118), new Word64(0xd807aa98, 0xa3030242), new Word64(0x12835b01, 0x45706fbe), new Word64(0x243185be, 0x4ee4b28c), new Word64(0x550c7dc3, 0xd5ffb4e2), new Word64(0x72be5d74, 0xf27b896f), new Word64(0x80deb1fe, 0x3b1696b1), new Word64(0x9bdc06a7, 0x25c71235), new Word64(0xc19bf174, 0xcf692694), new Word64(0xe49b69c1, 0x9ef14ad2), new Word64(0xefbe4786, 0x384f25e3), new Word64(0x0fc19dc6, 0x8b8cd5b5), new Word64(0x240ca1cc, 0x77ac9c65), new Word64(0x2de92c6f, 0x592b0275), new Word64(0x4a7484aa, 0x6ea6e483), new Word64(0x5cb0a9dc, 0xbd41fbd4), new Word64(0x76f988da, 0x831153b5), new Word64(0x983e5152, 0xee66dfab), new Word64(0xa831c66d, 0x2db43210), new Word64(0xb00327c8, 0x98fb213f), new Word64(0xbf597fc7, 0xbeef0ee4), new Word64(0xc6e00bf3, 0x3da88fc2), new Word64(0xd5a79147, 0x930aa725), new Word64(0x06ca6351, 0xe003826f), new Word64(0x14292967, 0x0a0e6e70), new Word64(0x27b70a85, 0x46d22ffc), new Word64(0x2e1b2138, 0x5c26c926), new Word64(0x4d2c6dfc, 0x5ac42aed), new Word64(0x53380d13, 0x9d95b3df), new Word64(0x650a7354, 0x8baf63de), new Word64(0x766a0abb, 0x3c77b2a8), new Word64(0x81c2c92e, 0x47edaee6), new Word64(0x92722c85, 0x1482353b), new Word64(0xa2bfe8a1, 0x4cf10364), new Word64(0xa81a664b, 0xbc423001), new Word64(0xc24b8b70, 0xd0f89791), new Word64(0xc76c51a3, 0x0654be30), new Word64(0xd192e819, 0xd6ef5218), new Word64(0xd6990624, 0x5565a910), new Word64(0xf40e3585, 0x5771202a), new Word64(0x106aa070, 0x32bbd1b8), new Word64(0x19a4c116, 0xb8d2d0c8), new Word64(0x1e376c08, 0x5141ab53), new Word64(0x2748774c, 0xdf8eeb99), new Word64(0x34b0bcb5, 0xe19b48a8), new Word64(0x391c0cb3, 0xc5c95a63), new Word64(0x4ed8aa4a, 0xe3418acb), new Word64(0x5b9cca4f, 0x7763e373), new Word64(0x682e6ff3, 0xd6b2b8a3), new Word64(0x748f82ee, 0x5defb2fc), new Word64(0x78a5636f, 0x43172f60), new Word64(0x84c87814, 0xa1f0ab72), new Word64(0x8cc70208, 0x1a6439ec), new Word64(0x90befffa, 0x23631e28), new Word64(0xa4506ceb, 0xde82bde9), new Word64(0xbef9a3f7, 0xb2c67915), new Word64(0xc67178f2, 0xe372532b), new Word64(0xca273ece, 0xea26619c), new Word64(0xd186b8c7, 0x21c0c207), new Word64(0xeada7dd6, 0xcde0eb1e), new Word64(0xf57d4f7f, 0xee6ed178), new Word64(0x06f067aa, 0x72176fba), new Word64(0x0a637dc5, 0xa2c898a6), new Word64(0x113f9804, 0xbef90dae), new Word64(0x1b710b35, 0x131c471b), new Word64(0x28db77f5, 0x23047d84), new Word64(0x32caab7b, 0x40c72493), new Word64(0x3c9ebe0a, 0x15c9bebc), new Word64(0x431d67c4, 0x9c100d4c), new Word64(0x4cc5d4be, 0xcb3e42b6), new Word64(0x597f299c, 0xfc657e2a), new Word64(0x5fcb6fab, 0x3ad6faec), new Word64(0x6c44198c, 0x4a475817)];

                function hash(data, offset, length, mode384) {
                    mode384 = !!mode384;
                    var h0, h1, h2, h3, h4, h5, h6, h7;
                    if (!mode384) {
                        h0 = new Word64(0x6a09e667, 0xf3bcc908);
                        h1 = new Word64(0xbb67ae85, 0x84caa73b);
                        h2 = new Word64(0x3c6ef372, 0xfe94f82b);
                        h3 = new Word64(0xa54ff53a, 0x5f1d36f1);
                        h4 = new Word64(0x510e527f, 0xade682d1);
                        h5 = new Word64(0x9b05688c, 0x2b3e6c1f);
                        h6 = new Word64(0x1f83d9ab, 0xfb41bd6b);
                        h7 = new Word64(0x5be0cd19, 0x137e2179);
                    } else {
                        h0 = new Word64(0xcbbb9d5d, 0xc1059ed8);
                        h1 = new Word64(0x629a292a, 0x367cd507);
                        h2 = new Word64(0x9159015a, 0x3070dd17);
                        h3 = new Word64(0x152fecd8, 0xf70e5939);
                        h4 = new Word64(0x67332667, 0xffc00b31);
                        h5 = new Word64(0x8eb44a87, 0x68581511);
                        h6 = new Word64(0xdb0c2e0d, 0x64f98fa7);
                        h7 = new Word64(0x47b5481d, 0xbefa4fa4);
                    }
                    var paddedLength = Math.ceil((length + 17) / 128) * 128;
                    var padded = new Uint8Array(paddedLength);
                    var i, j, n;
                    for (i = 0; i < length; ++i) {
                        padded[i] = data[offset++];
                    }
                    padded[i++] = 0x80;
                    n = paddedLength - 16;
                    while (i < n) {
                        padded[i++] = 0;
                    }
                    padded[i++] = 0;
                    padded[i++] = 0;
                    padded[i++] = 0;
                    padded[i++] = 0;
                    padded[i++] = 0;
                    padded[i++] = 0;
                    padded[i++] = 0;
                    padded[i++] = 0;
                    padded[i++] = 0;
                    padded[i++] = 0;
                    padded[i++] = 0;
                    padded[i++] = (length >>> 29) & 0xFF;
                    padded[i++] = (length >> 21) & 0xFF;
                    padded[i++] = (length >> 13) & 0xFF;
                    padded[i++] = (length >> 5) & 0xFF;
                    padded[i++] = (length << 3) & 0xFF;
                    var w = new Array(80);
                    for (i = 0; i < 80; i++) {
                        w[i] = new Word64(0, 0);
                    }
                    var a = new Word64(0, 0),
                        b = new Word64(0, 0),
                        c = new Word64(0, 0);
                    var d = new Word64(0, 0),
                        e = new Word64(0, 0),
                        f = new Word64(0, 0);
                    var g = new Word64(0, 0),
                        h = new Word64(0, 0);
                    var t1 = new Word64(0, 0),
                        t2 = new Word64(0, 0);
                    var tmp1 = new Word64(0, 0),
                        tmp2 = new Word64(0, 0),
                        tmp3;
                    for (i = 0; i < paddedLength;) {
                        for (j = 0; j < 16; ++j) {
                            w[j].high = (padded[i] << 24) | (padded[i + 1] << 16) | (padded[i + 2] << 8) | (padded[i + 3]);
                            w[j].low = (padded[i + 4]) << 24 | (padded[i + 5]) << 16 | (padded[i + 6]) << 8 | (padded[i + 7]);
                            i += 8;
                        }
                        for (j = 16; j < 80; ++j) {
                            tmp3 = w[j];
                            littleSigmaPrime(tmp3, w[j - 2], tmp2);
                            tmp3.add(w[j - 7]);
                            littleSigma(tmp1, w[j - 15], tmp2);
                            tmp3.add(tmp1);
                            tmp3.add(w[j - 16]);
                        }
                        a.assign(h0);
                        b.assign(h1);
                        c.assign(h2);
                        d.assign(h3);
                        e.assign(h4);
                        f.assign(h5);
                        g.assign(h6);
                        h.assign(h7);
                        for (j = 0; j < 80; ++j) {
                            t1.assign(h);
                            sigmaPrime(tmp1, e, tmp2);
                            t1.add(tmp1);
                            ch(tmp1, e, f, g, tmp2);
                            t1.add(tmp1);
                            t1.add(k[j]);
                            t1.add(w[j]);
                            sigma(t2, a, tmp2);
                            maj(tmp1, a, b, c, tmp2);
                            t2.add(tmp1);
                            tmp3 = h;
                            h = g;
                            g = f;
                            f = e;
                            d.add(t1);
                            e = d;
                            d = c;
                            c = b;
                            b = a;
                            tmp3.assign(t1);
                            tmp3.add(t2);
                            a = tmp3;
                        }
                        h0.add(a);
                        h1.add(b);
                        h2.add(c);
                        h3.add(d);
                        h4.add(e);
                        h5.add(f);
                        h6.add(g);
                        h7.add(h);
                    }
                    var result;
                    if (!mode384) {
                        result = new Uint8Array(64);
                        h0.copyTo(result, 0);
                        h1.copyTo(result, 8);
                        h2.copyTo(result, 16);
                        h3.copyTo(result, 24);
                        h4.copyTo(result, 32);
                        h5.copyTo(result, 40);
                        h6.copyTo(result, 48);
                        h7.copyTo(result, 56);
                    } else {
                        result = new Uint8Array(48);
                        h0.copyTo(result, 0);
                        h1.copyTo(result, 8);
                        h2.copyTo(result, 16);
                        h3.copyTo(result, 24);
                        h4.copyTo(result, 32);
                        h5.copyTo(result, 40);
                    }
                    return result;
                }
                return hash;
            })();
            var calculateSHA384 = (function calculateSHA384Closure() {
                function hash(data, offset, length) {
                    return calculateSHA512(data, offset, length, true);
                }
                return hash;
            })();
            var NullCipher = (function NullCipherClosure() {
                function NullCipher() {}
                NullCipher.prototype = {
                    decryptBlock: function NullCipher_decryptBlock(data) {
                        return data;
                    }
                };
                return NullCipher;
            })();
            var AES128Cipher = (function AES128CipherClosure() {
                var rcon = new Uint8Array([0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d]);
                var s = new Uint8Array([0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16]);
                var inv_s = new Uint8Array([0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d]);
                var mixCol = new Uint8Array(256);
                for (var i = 0; i < 256; i++) {
                    if (i < 128) {
                        mixCol[i] = i << 1;
                    } else {
                        mixCol[i] = (i << 1) ^ 0x1b;
                    }
                }
                var mix = new Uint32Array([0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3]);

                function expandKey128(cipherKey) {
                    var b = 176,
                        result = new Uint8Array(b);
                    result.set(cipherKey);
                    for (var j = 16, i = 1; j < b; ++i) {
                        var t1 = result[j - 3],
                            t2 = result[j - 2],
                            t3 = result[j - 1],
                            t4 = result[j - 4];
                        t1 = s[t1];
                        t2 = s[t2];
                        t3 = s[t3];
                        t4 = s[t4];
                        t1 = t1 ^ rcon[i];
                        for (var n = 0; n < 4; ++n) {
                            result[j] = (t1 ^= result[j - 16]);
                            j++;
                            result[j] = (t2 ^= result[j - 16]);
                            j++;
                            result[j] = (t3 ^= result[j - 16]);
                            j++;
                            result[j] = (t4 ^= result[j - 16]);
                            j++;
                        }
                    }
                    return result;
                }

                function decrypt128(input, key) {
                    var state = new Uint8Array(16);
                    state.set(input);
                    var i, j, k;
                    var t, u, v;
                    for (j = 0, k = 160; j < 16; ++j, ++k) {
                        state[j] ^= key[k];
                    }
                    for (i = 9; i >= 1; --i) {
                        t = state[13];
                        state[13] = state[9];
                        state[9] = state[5];
                        state[5] = state[1];
                        state[1] = t;
                        t = state[14];
                        u = state[10];
                        state[14] = state[6];
                        state[10] = state[2];
                        state[6] = t;
                        state[2] = u;
                        t = state[15];
                        u = state[11];
                        v = state[7];
                        state[15] = state[3];
                        state[11] = t;
                        state[7] = u;
                        state[3] = v;
                        for (j = 0; j < 16; ++j) {
                            state[j] = inv_s[state[j]];
                        }
                        for (j = 0, k = i * 16; j < 16; ++j, ++k) {
                            state[j] ^= key[k];
                        }
                        for (j = 0; j < 16; j += 4) {
                            var s0 = mix[state[j]],
                                s1 = mix[state[j + 1]],
                                s2 = mix[state[j + 2]],
                                s3 = mix[state[j + 3]];
                            t = (s0 ^ (s1 >>> 8) ^ (s1 << 24) ^ (s2 >>> 16) ^ (s2 << 16) ^ (s3 >>> 24) ^ (s3 << 8));
                            state[j] = (t >>> 24) & 0xFF;
                            state[j + 1] = (t >> 16) & 0xFF;
                            state[j + 2] = (t >> 8) & 0xFF;
                            state[j + 3] = t & 0xFF;
                        }
                    }
                    t = state[13];
                    state[13] = state[9];
                    state[9] = state[5];
                    state[5] = state[1];
                    state[1] = t;
                    t = state[14];
                    u = state[10];
                    state[14] = state[6];
                    state[10] = state[2];
                    state[6] = t;
                    state[2] = u;
                    t = state[15];
                    u = state[11];
                    v = state[7];
                    state[15] = state[3];
                    state[11] = t;
                    state[7] = u;
                    state[3] = v;
                    for (j = 0; j < 16; ++j) {
                        state[j] = inv_s[state[j]];
                        state[j] ^= key[j];
                    }
                    return state;
                }

                function encrypt128(input, key) {
                    var t, u, v, k;
                    var state = new Uint8Array(16);
                    state.set(input);
                    for (j = 0; j < 16; ++j) {
                        state[j] ^= key[j];
                    }
                    for (i = 1; i < 10; i++) {
                        for (j = 0; j < 16; ++j) {
                            state[j] = s[state[j]];
                        }
                        v = state[1];
                        state[1] = state[5];
                        state[5] = state[9];
                        state[9] = state[13];
                        state[13] = v;
                        v = state[2];
                        u = state[6];
                        state[2] = state[10];
                        state[6] = state[14];
                        state[10] = v;
                        state[14] = u;
                        v = state[3];
                        u = state[7];
                        t = state[11];
                        state[3] = state[15];
                        state[7] = v;
                        state[11] = u;
                        state[15] = t;
                        for (var j = 0; j < 16; j += 4) {
                            var s0 = state[j + 0],
                                s1 = state[j + 1];
                            var s2 = state[j + 2],
                                s3 = state[j + 3];
                            t = s0 ^ s1 ^ s2 ^ s3;
                            state[j + 0] ^= t ^ mixCol[s0 ^ s1];
                            state[j + 1] ^= t ^ mixCol[s1 ^ s2];
                            state[j + 2] ^= t ^ mixCol[s2 ^ s3];
                            state[j + 3] ^= t ^ mixCol[s3 ^ s0];
                        }
                        for (j = 0, k = i * 16; j < 16; ++j, ++k) {
                            state[j] ^= key[k];
                        }
                    }
                    for (j = 0; j < 16; ++j) {
                        state[j] = s[state[j]];
                    }
                    v = state[1];
                    state[1] = state[5];
                    state[5] = state[9];
                    state[9] = state[13];
                    state[13] = v;
                    v = state[2];
                    u = state[6];
                    state[2] = state[10];
                    state[6] = state[14];
                    state[10] = v;
                    state[14] = u;
                    v = state[3];
                    u = state[7];
                    t = state[11];
                    state[3] = state[15];
                    state[7] = v;
                    state[11] = u;
                    state[15] = t;
                    for (j = 0, k = 160; j < 16; ++j, ++k) {
                        state[j] ^= key[k];
                    }
                    return state;
                }

                function AES128Cipher(key) {
                    this.key = expandKey128(key);
                    this.buffer = new Uint8Array(16);
                    this.bufferPosition = 0;
                }

                function decryptBlock2(data, finalize) {
                    var i, j, ii, sourceLength = data.length,
                        buffer = this.buffer,
                        bufferLength = this.bufferPosition,
                        result = [],
                        iv = this.iv;
                    for (i = 0; i < sourceLength; ++i) {
                        buffer[bufferLength] = data[i];
                        ++bufferLength;
                        if (bufferLength < 16) {
                            continue;
                        }
                        var plain = decrypt128(buffer, this.key);
                        for (j = 0; j < 16; ++j) {
                            plain[j] ^= iv[j];
                        }
                        iv = buffer;
                        result.push(plain);
                        buffer = new Uint8Array(16);
                        bufferLength = 0;
                    }
                    this.buffer = buffer;
                    this.bufferLength = bufferLength;
                    this.iv = iv;
                    if (result.length === 0) {
                        return new Uint8Array([]);
                    }
                    var outputLength = 16 * result.length;
                    if (finalize) {
                        var lastBlock = result[result.length - 1];
                        var psLen = lastBlock[15];
                        if (psLen <= 16) {
                            for (i = 15, ii = 16 - psLen; i >= ii; --i) {
                                if (lastBlock[i] !== psLen) {
                                    psLen = 0;
                                    break;
                                }
                            }
                            outputLength -= psLen;
                            result[result.length - 1] = lastBlock.subarray(0, 16 - psLen);
                        }
                    }
                    var output = new Uint8Array(outputLength);
                    for (i = 0, j = 0, ii = result.length; i < ii; ++i, j += 16) {
                        output.set(result[i], j);
                    }
                    return output;
                }
                AES128Cipher.prototype = {
                    decryptBlock: function AES128Cipher_decryptBlock(data, finalize) {
                        var i, sourceLength = data.length;
                        var buffer = this.buffer,
                            bufferLength = this.bufferPosition;
                        for (i = 0; bufferLength < 16 && i < sourceLength; ++i, ++bufferLength) {
                            buffer[bufferLength] = data[i];
                        }
                        if (bufferLength < 16) {
                            this.bufferLength = bufferLength;
                            return new Uint8Array([]);
                        }
                        this.iv = buffer;
                        this.buffer = new Uint8Array(16);
                        this.bufferLength = 0;
                        this.decryptBlock = decryptBlock2;
                        return this.decryptBlock(data.subarray(16), finalize);
                    },
                    encrypt: function AES128Cipher_encrypt(data, iv) {
                        var i, j, ii, sourceLength = data.length,
                            buffer = this.buffer,
                            bufferLength = this.bufferPosition,
                            result = [];
                        if (!iv) {
                            iv = new Uint8Array(16);
                        }
                        for (i = 0; i < sourceLength; ++i) {
                            buffer[bufferLength] = data[i];
                            ++bufferLength;
                            if (bufferLength < 16) {
                                continue;
                            }
                            for (j = 0; j < 16; ++j) {
                                buffer[j] ^= iv[j];
                            }
                            var cipher = encrypt128(buffer, this.key);
                            iv = cipher;
                            result.push(cipher);
                            buffer = new Uint8Array(16);
                            bufferLength = 0;
                        }
                        this.buffer = buffer;
                        this.bufferLength = bufferLength;
                        this.iv = iv;
                        if (result.length === 0) {
                            return new Uint8Array([]);
                        }
                        var outputLength = 16 * result.length;
                        var output = new Uint8Array(outputLength);
                        for (i = 0, j = 0, ii = result.length; i < ii; ++i, j += 16) {
                            output.set(result[i], j);
                        }
                        return output;
                    }
                };
                return AES128Cipher;
            })();
            var AES256Cipher = (function AES256CipherClosure() {
                var rcon = new Uint8Array([0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d]);
                var s = new Uint8Array([0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16]);
                var inv_s = new Uint8Array([0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d]);
                var mixCol = new Uint8Array(256);
                for (var i = 0; i < 256; i++) {
                    if (i < 128) {
                        mixCol[i] = i << 1;
                    } else {
                        mixCol[i] = (i << 1) ^ 0x1b;
                    }
                }
                var mix = new Uint32Array([0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3]);

                function expandKey256(cipherKey) {
                    var b = 240,
                        result = new Uint8Array(b);
                    var r = 1;
                    result.set(cipherKey);
                    for (var j = 32, i = 1; j < b; ++i) {
                        if (j % 32 === 16) {
                            t1 = s[t1];
                            t2 = s[t2];
                            t3 = s[t3];
                            t4 = s[t4];
                        } else if (j % 32 === 0) {
                            var t1 = result[j - 3],
                                t2 = result[j - 2],
                                t3 = result[j - 1],
                                t4 = result[j - 4];
                            t1 = s[t1];
                            t2 = s[t2];
                            t3 = s[t3];
                            t4 = s[t4];
                            t1 = t1 ^ r;
                            if ((r <<= 1) >= 256) {
                                r = (r ^ 0x1b) & 0xFF;
                            }
                        }
                        for (var n = 0; n < 4; ++n) {
                            result[j] = (t1 ^= result[j - 32]);
                            j++;
                            result[j] = (t2 ^= result[j - 32]);
                            j++;
                            result[j] = (t3 ^= result[j - 32]);
                            j++;
                            result[j] = (t4 ^= result[j - 32]);
                            j++;
                        }
                    }
                    return result;
                }

                function decrypt256(input, key) {
                    var state = new Uint8Array(16);
                    state.set(input);
                    var i, j, k;
                    var t, u, v;
                    for (j = 0, k = 224; j < 16; ++j, ++k) {
                        state[j] ^= key[k];
                    }
                    for (i = 13; i >= 1; --i) {
                        t = state[13];
                        state[13] = state[9];
                        state[9] = state[5];
                        state[5] = state[1];
                        state[1] = t;
                        t = state[14];
                        u = state[10];
                        state[14] = state[6];
                        state[10] = state[2];
                        state[6] = t;
                        state[2] = u;
                        t = state[15];
                        u = state[11];
                        v = state[7];
                        state[15] = state[3];
                        state[11] = t;
                        state[7] = u;
                        state[3] = v;
                        for (j = 0; j < 16; ++j) {
                            state[j] = inv_s[state[j]];
                        }
                        for (j = 0, k = i * 16; j < 16; ++j, ++k) {
                            state[j] ^= key[k];
                        }
                        for (j = 0; j < 16; j += 4) {
                            var s0 = mix[state[j]],
                                s1 = mix[state[j + 1]],
                                s2 = mix[state[j + 2]],
                                s3 = mix[state[j + 3]];
                            t = (s0 ^ (s1 >>> 8) ^ (s1 << 24) ^ (s2 >>> 16) ^ (s2 << 16) ^ (s3 >>> 24) ^ (s3 << 8));
                            state[j] = (t >>> 24) & 0xFF;
                            state[j + 1] = (t >> 16) & 0xFF;
                            state[j + 2] = (t >> 8) & 0xFF;
                            state[j + 3] = t & 0xFF;
                        }
                    }
                    t = state[13];
                    state[13] = state[9];
                    state[9] = state[5];
                    state[5] = state[1];
                    state[1] = t;
                    t = state[14];
                    u = state[10];
                    state[14] = state[6];
                    state[10] = state[2];
                    state[6] = t;
                    state[2] = u;
                    t = state[15];
                    u = state[11];
                    v = state[7];
                    state[15] = state[3];
                    state[11] = t;
                    state[7] = u;
                    state[3] = v;
                    for (j = 0; j < 16; ++j) {
                        state[j] = inv_s[state[j]];
                        state[j] ^= key[j];
                    }
                    return state;
                }

                function encrypt256(input, key) {
                    var t, u, v, k;
                    var state = new Uint8Array(16);
                    state.set(input);
                    for (j = 0; j < 16; ++j) {
                        state[j] ^= key[j];
                    }
                    for (i = 1; i < 14; i++) {
                        for (j = 0; j < 16; ++j) {
                            state[j] = s[state[j]];
                        }
                        v = state[1];
                        state[1] = state[5];
                        state[5] = state[9];
                        state[9] = state[13];
                        state[13] = v;
                        v = state[2];
                        u = state[6];
                        state[2] = state[10];
                        state[6] = state[14];
                        state[10] = v;
                        state[14] = u;
                        v = state[3];
                        u = state[7];
                        t = state[11];
                        state[3] = state[15];
                        state[7] = v;
                        state[11] = u;
                        state[15] = t;
                        for (var j = 0; j < 16; j += 4) {
                            var s0 = state[j + 0],
                                s1 = state[j + 1];
                            var s2 = state[j + 2],
                                s3 = state[j + 3];
                            t = s0 ^ s1 ^ s2 ^ s3;
                            state[j + 0] ^= t ^ mixCol[s0 ^ s1];
                            state[j + 1] ^= t ^ mixCol[s1 ^ s2];
                            state[j + 2] ^= t ^ mixCol[s2 ^ s3];
                            state[j + 3] ^= t ^ mixCol[s3 ^ s0];
                        }
                        for (j = 0, k = i * 16; j < 16; ++j, ++k) {
                            state[j] ^= key[k];
                        }
                    }
                    for (j = 0; j < 16; ++j) {
                        state[j] = s[state[j]];
                    }
                    v = state[1];
                    state[1] = state[5];
                    state[5] = state[9];
                    state[9] = state[13];
                    state[13] = v;
                    v = state[2];
                    u = state[6];
                    state[2] = state[10];
                    state[6] = state[14];
                    state[10] = v;
                    state[14] = u;
                    v = state[3];
                    u = state[7];
                    t = state[11];
                    state[3] = state[15];
                    state[7] = v;
                    state[11] = u;
                    state[15] = t;
                    for (j = 0, k = 224; j < 16; ++j, ++k) {
                        state[j] ^= key[k];
                    }
                    return state;
                }

                function AES256Cipher(key) {
                    this.key = expandKey256(key);
                    this.buffer = new Uint8Array(16);
                    this.bufferPosition = 0;
                }

                function decryptBlock2(data, finalize) {
                    var i, j, ii, sourceLength = data.length,
                        buffer = this.buffer,
                        bufferLength = this.bufferPosition,
                        result = [],
                        iv = this.iv;
                    for (i = 0; i < sourceLength; ++i) {
                        buffer[bufferLength] = data[i];
                        ++bufferLength;
                        if (bufferLength < 16) {
                            continue;
                        }
                        var plain = decrypt256(buffer, this.key);
                        for (j = 0; j < 16; ++j) {
                            plain[j] ^= iv[j];
                        }
                        iv = buffer;
                        result.push(plain);
                        buffer = new Uint8Array(16);
                        bufferLength = 0;
                    }
                    this.buffer = buffer;
                    this.bufferLength = bufferLength;
                    this.iv = iv;
                    if (result.length === 0) {
                        return new Uint8Array([]);
                    }
                    var outputLength = 16 * result.length;
                    if (finalize) {
                        var lastBlock = result[result.length - 1];
                        var psLen = lastBlock[15];
                        if (psLen <= 16) {
                            for (i = 15, ii = 16 - psLen; i >= ii; --i) {
                                if (lastBlock[i] !== psLen) {
                                    psLen = 0;
                                    break;
                                }
                            }
                            outputLength -= psLen;
                            result[result.length - 1] = lastBlock.subarray(0, 16 - psLen);
                        }
                    }
                    var output = new Uint8Array(outputLength);
                    for (i = 0, j = 0, ii = result.length; i < ii; ++i, j += 16) {
                        output.set(result[i], j);
                    }
                    return output;
                }
                AES256Cipher.prototype = {
                    decryptBlock: function AES256Cipher_decryptBlock(data, finalize, iv) {
                        var i, sourceLength = data.length;
                        var buffer = this.buffer,
                            bufferLength = this.bufferPosition;
                        if (iv) {
                            this.iv = iv;
                        } else {
                            for (i = 0; bufferLength < 16 && i < sourceLength; ++i, ++bufferLength) {
                                buffer[bufferLength] = data[i];
                            }
                            if (bufferLength < 16) {
                                this.bufferLength = bufferLength;
                                return new Uint8Array([]);
                            }
                            this.iv = buffer;
                            data = data.subarray(16);
                        }
                        this.buffer = new Uint8Array(16);
                        this.bufferLength = 0;
                        this.decryptBlock = decryptBlock2;
                        return this.decryptBlock(data, finalize);
                    },
                    encrypt: function AES256Cipher_encrypt(data, iv) {
                        var i, j, ii, sourceLength = data.length,
                            buffer = this.buffer,
                            bufferLength = this.bufferPosition,
                            result = [];
                        if (!iv) {
                            iv = new Uint8Array(16);
                        }
                        for (i = 0; i < sourceLength; ++i) {
                            buffer[bufferLength] = data[i];
                            ++bufferLength;
                            if (bufferLength < 16) {
                                continue;
                            }
                            for (j = 0; j < 16; ++j) {
                                buffer[j] ^= iv[j];
                            }
                            var cipher = encrypt256(buffer, this.key);
                            this.iv = cipher;
                            result.push(cipher);
                            buffer = new Uint8Array(16);
                            bufferLength = 0;
                        }
                        this.buffer = buffer;
                        this.bufferLength = bufferLength;
                        this.iv = iv;
                        if (result.length === 0) {
                            return new Uint8Array([]);
                        }
                        var outputLength = 16 * result.length;
                        var output = new Uint8Array(outputLength);
                        for (i = 0, j = 0, ii = result.length; i < ii; ++i, j += 16) {
                            output.set(result[i], j);
                        }
                        return output;
                    }
                };
                return AES256Cipher;
            })();
            var PDF17 = (function PDF17Closure() {
                function compareByteArrays(array1, array2) {
                    if (array1.length !== array2.length) {
                        return false;
                    }
                    for (var i = 0; i < array1.length; i++) {
                        if (array1[i] !== array2[i]) {
                            return false;
                        }
                    }
                    return true;
                }

                function PDF17() {}
                PDF17.prototype = {
                    checkOwnerPassword: function PDF17_checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {
                        var hashData = new Uint8Array(password.length + 56);
                        hashData.set(password, 0);
                        hashData.set(ownerValidationSalt, password.length);
                        hashData.set(userBytes, password.length + ownerValidationSalt.length);
                        var result = calculateSHA256(hashData, 0, hashData.length);
                        return compareByteArrays(result, ownerPassword);
                    },
                    checkUserPassword: function PDF17_checkUserPassword(password, userValidationSalt, userPassword) {
                        var hashData = new Uint8Array(password.length + 8);
                        hashData.set(password, 0);
                        hashData.set(userValidationSalt, password.length);
                        var result = calculateSHA256(hashData, 0, hashData.length);
                        return compareByteArrays(result, userPassword);
                    },
                    getOwnerKey: function PDF17_getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {
                        var hashData = new Uint8Array(password.length + 56);
                        hashData.set(password, 0);
                        hashData.set(ownerKeySalt, password.length);
                        hashData.set(userBytes, password.length + ownerKeySalt.length);
                        var key = calculateSHA256(hashData, 0, hashData.length);
                        var cipher = new AES256Cipher(key);
                        return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16));
                    },
                    getUserKey: function PDF17_getUserKey(password, userKeySalt, userEncryption) {
                        var hashData = new Uint8Array(password.length + 8);
                        hashData.set(password, 0);
                        hashData.set(userKeySalt, password.length);
                        var key = calculateSHA256(hashData, 0, hashData.length);
                        var cipher = new AES256Cipher(key);
                        return cipher.decryptBlock(userEncryption, false, new Uint8Array(16));
                    }
                };
                return PDF17;
            })();
            var PDF20 = (function PDF20Closure() {
                function concatArrays(array1, array2) {
                    var t = new Uint8Array(array1.length + array2.length);
                    t.set(array1, 0);
                    t.set(array2, array1.length);
                    return t;
                }

                function calculatePDF20Hash(password, input, userBytes) {
                    var k = calculateSHA256(input, 0, input.length).subarray(0, 32);
                    var e = [0];
                    var i = 0;
                    while (i < 64 || e[e.length - 1] > i - 32) {
                        var arrayLength = password.length + k.length + userBytes.length;
                        var k1 = new Uint8Array(arrayLength * 64);
                        var array = concatArrays(password, k);
                        array = concatArrays(array, userBytes);
                        for (var j = 0, pos = 0; j < 64; j++, pos += arrayLength) {
                            k1.set(array, pos);
                        }
                        var cipher = new AES128Cipher(k.subarray(0, 16));
                        e = cipher.encrypt(k1, k.subarray(16, 32));
                        var remainder = 0;
                        for (var z = 0; z < 16; z++) {
                            remainder *= (256 % 3);
                            remainder %= 3;
                            remainder += ((e[z] >>> 0) % 3);
                            remainder %= 3;
                        }
                        if (remainder === 0) {
                            k = calculateSHA256(e, 0, e.length);
                        } else if (remainder === 1) {
                            k = calculateSHA384(e, 0, e.length);
                        } else if (remainder === 2) {
                            k = calculateSHA512(e, 0, e.length);
                        }
                        i++;
                    }
                    return k.subarray(0, 32);
                }

                function PDF20() {}

                function compareByteArrays(array1, array2) {
                    if (array1.length !== array2.length) {
                        return false;
                    }
                    for (var i = 0; i < array1.length; i++) {
                        if (array1[i] !== array2[i]) {
                            return false;
                        }
                    }
                    return true;
                }
                PDF20.prototype = {
                    hash: function PDF20_hash(password, concatBytes, userBytes) {
                        return calculatePDF20Hash(password, concatBytes, userBytes);
                    },
                    checkOwnerPassword: function PDF20_checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {
                        var hashData = new Uint8Array(password.length + 56);
                        hashData.set(password, 0);
                        hashData.set(ownerValidationSalt, password.length);
                        hashData.set(userBytes, password.length + ownerValidationSalt.length);
                        var result = calculatePDF20Hash(password, hashData, userBytes);
                        return compareByteArrays(result, ownerPassword);
                    },
                    checkUserPassword: function PDF20_checkUserPassword(password, userValidationSalt, userPassword) {
                        var hashData = new Uint8Array(password.length + 8);
                        hashData.set(password, 0);
                        hashData.set(userValidationSalt, password.length);
                        var result = calculatePDF20Hash(password, hashData, []);
                        return compareByteArrays(result, userPassword);
                    },
                    getOwnerKey: function PDF20_getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {
                        var hashData = new Uint8Array(password.length + 56);
                        hashData.set(password, 0);
                        hashData.set(ownerKeySalt, password.length);
                        hashData.set(userBytes, password.length + ownerKeySalt.length);
                        var key = calculatePDF20Hash(password, hashData, userBytes);
                        var cipher = new AES256Cipher(key);
                        return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16));
                    },
                    getUserKey: function PDF20_getUserKey(password, userKeySalt, userEncryption) {
                        var hashData = new Uint8Array(password.length + 8);
                        hashData.set(password, 0);
                        hashData.set(userKeySalt, password.length);
                        var key = calculatePDF20Hash(password, hashData, []);
                        var cipher = new AES256Cipher(key);
                        return cipher.decryptBlock(userEncryption, false, new Uint8Array(16));
                    }
                };
                return PDF20;
            })();
            var CipherTransform = (function CipherTransformClosure() {
                function CipherTransform(stringCipherConstructor, streamCipherConstructor) {
                    this.stringCipherConstructor = stringCipherConstructor;
                    this.streamCipherConstructor = streamCipherConstructor;
                }
                CipherTransform.prototype = {
                    createStream: function CipherTransform_createStream(stream, length) {
                        var cipher = new this.streamCipherConstructor();
                        return new DecryptStream(stream, length, function cipherTransformDecryptStream(data, finalize) {
                            return cipher.decryptBlock(data, finalize);
                        });
                    },
                    decryptString: function CipherTransform_decryptString(s) {
                        var cipher = new this.stringCipherConstructor();
                        var data = stringToBytes(s);
                        data = cipher.decryptBlock(data, true);
                        return bytesToString(data);
                    }
                };
                return CipherTransform;
            })();
            var CipherTransformFactory = (function CipherTransformFactoryClosure() {
                var defaultPasswordBytes = new Uint8Array([0x28, 0xBF, 0x4E, 0x5E, 0x4E, 0x75, 0x8A, 0x41, 0x64, 0x00, 0x4E, 0x56, 0xFF, 0xFA, 0x01, 0x08, 0x2E, 0x2E, 0x00, 0xB6, 0xD0, 0x68, 0x3E, 0x80, 0x2F, 0x0C, 0xA9, 0xFE, 0x64, 0x53, 0x69, 0x7A]);

                function createEncryptionKey20(revision, password, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption, perms) {
                    if (password) {
                        var passwordLength = Math.min(127, password.length);
                        password = password.subarray(0, passwordLength);
                    } else {
                        password = [];
                    }
                    var pdfAlgorithm;
                    if (revision === 6) {
                        pdfAlgorithm = new PDF20();
                    } else {
                        pdfAlgorithm = new PDF17();
                    }
                    if (pdfAlgorithm) {
                        if (pdfAlgorithm.checkUserPassword(password, userValidationSalt, userPassword)) {
                            return pdfAlgorithm.getUserKey(password, userKeySalt, userEncryption);
                        } else if (password.length && pdfAlgorithm.checkOwnerPassword(password, ownerValidationSalt, uBytes, ownerPassword)) {
                            return pdfAlgorithm.getOwnerKey(password, ownerKeySalt, uBytes, ownerEncryption);
                        }
                    }
                    return null;
                }

                function prepareKeyData(fileId, password, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata) {
                    var hashDataSize = 40 + ownerPassword.length + fileId.length;
                    var hashData = new Uint8Array(hashDataSize),
                        i = 0,
                        j, n;
                    if (password) {
                        n = Math.min(32, password.length);
                        for (; i < n; ++i) {
                            hashData[i] = password[i];
                        }
                    }
                    j = 0;
                    while (i < 32) {
                        hashData[i++] = defaultPasswordBytes[j++];
                    }
                    for (j = 0, n = ownerPassword.length; j < n; ++j) {
                        hashData[i++] = ownerPassword[j];
                    }
                    hashData[i++] = flags & 0xFF;
                    hashData[i++] = (flags >> 8) & 0xFF;
                    hashData[i++] = (flags >> 16) & 0xFF;
                    hashData[i++] = (flags >>> 24) & 0xFF;
                    for (j = 0, n = fileId.length; j < n; ++j) {
                        hashData[i++] = fileId[j];
                    }
                    if (revision >= 4 && !encryptMetadata) {
                        hashData[i++] = 0xFF;
                        hashData[i++] = 0xFF;
                        hashData[i++] = 0xFF;
                        hashData[i++] = 0xFF;
                    }
                    var hash = calculateMD5(hashData, 0, i);
                    var keyLengthInBytes = keyLength >> 3;
                    if (revision >= 3) {
                        for (j = 0; j < 50; ++j) {
                            hash = calculateMD5(hash, 0, keyLengthInBytes);
                        }
                    }
                    var encryptionKey = hash.subarray(0, keyLengthInBytes);
                    var cipher, checkData;
                    if (revision >= 3) {
                        for (i = 0; i < 32; ++i) {
                            hashData[i] = defaultPasswordBytes[i];
                        }
                        for (j = 0, n = fileId.length; j < n; ++j) {
                            hashData[i++] = fileId[j];
                        }
                        cipher = new ARCFourCipher(encryptionKey);
                        checkData = cipher.encryptBlock(calculateMD5(hashData, 0, i));
                        n = encryptionKey.length;
                        var derivedKey = new Uint8Array(n),
                            k;
                        for (j = 1; j <= 19; ++j) {
                            for (k = 0; k < n; ++k) {
                                derivedKey[k] = encryptionKey[k] ^ j;
                            }
                            cipher = new ARCFourCipher(derivedKey);
                            checkData = cipher.encryptBlock(checkData);
                        }
                        for (j = 0, n = checkData.length; j < n; ++j) {
                            if (userPassword[j] !== checkData[j]) {
                                return null;
                            }
                        }
                    } else {
                        cipher = new ARCFourCipher(encryptionKey);
                        checkData = cipher.encryptBlock(defaultPasswordBytes);
                        for (j = 0, n = checkData.length; j < n; ++j) {
                            if (userPassword[j] !== checkData[j]) {
                                return null;
                            }
                        }
                    }
                    return encryptionKey;
                }

                function decodeUserPassword(password, ownerPassword, revision, keyLength) {
                    var hashData = new Uint8Array(32),
                        i = 0,
                        j, n;
                    n = Math.min(32, password.length);
                    for (; i < n; ++i) {
                        hashData[i] = password[i];
                    }
                    j = 0;
                    while (i < 32) {
                        hashData[i++] = defaultPasswordBytes[j++];
                    }
                    var hash = calculateMD5(hashData, 0, i);
                    var keyLengthInBytes = keyLength >> 3;
                    if (revision >= 3) {
                        for (j = 0; j < 50; ++j) {
                            hash = calculateMD5(hash, 0, hash.length);
                        }
                    }
                    var cipher, userPassword;
                    if (revision >= 3) {
                        userPassword = ownerPassword;
                        var derivedKey = new Uint8Array(keyLengthInBytes),
                            k;
                        for (j = 19; j >= 0; j--) {
                            for (k = 0; k < keyLengthInBytes; ++k) {
                                derivedKey[k] = hash[k] ^ j;
                            }
                            cipher = new ARCFourCipher(derivedKey);
                            userPassword = cipher.encryptBlock(userPassword);
                        }
                    } else {
                        cipher = new ARCFourCipher(hash.subarray(0, keyLengthInBytes));
                        userPassword = cipher.encryptBlock(ownerPassword);
                    }
                    return userPassword;
                }
                var identityName = Name.get('Identity');

                function CipherTransformFactory(dict, fileId, password) {
                    var filter = dict.get('Filter');
                    if (!isName(filter) || filter.name !== 'Standard') {
                        error('unknown encryption method');
                    }
                    this.dict = dict;
                    var algorithm = dict.get('V');
                    if (!isInt(algorithm) || (algorithm !== 1 && algorithm !== 2 && algorithm !== 4 && algorithm !== 5)) {
                        error('unsupported encryption algorithm');
                    }
                    this.algorithm = algorithm;
                    var keyLength = dict.get('Length');
                    if (!keyLength) {
                        if (algorithm <= 3) {
                            keyLength = 40;
                        } else {
                            var cfDict = dict.get('CF');
                            var streamCryptoName = dict.get('StmF');
                            if (isDict(cfDict) && isName(streamCryptoName)) {
                                var handlerDict = cfDict.get(streamCryptoName.name);
                                keyLength = (handlerDict && handlerDict.get('Length')) || 128;
                                if (keyLength < 40) {
                                    keyLength <<= 3;
                                }
                            }
                        }
                    }
                    if (!isInt(keyLength) || keyLength < 40 || (keyLength % 8) !== 0) {
                        error('invalid key length');
                    }
                    var ownerPassword = stringToBytes(dict.get('O')).subarray(0, 32);
                    var userPassword = stringToBytes(dict.get('U')).subarray(0, 32);
                    var flags = dict.get('P');
                    var revision = dict.get('R');
                    var encryptMetadata = ((algorithm === 4 || algorithm === 5) && dict.get('EncryptMetadata') !== false);
                    this.encryptMetadata = encryptMetadata;
                    var fileIdBytes = stringToBytes(fileId);
                    var passwordBytes;
                    if (password) {
                        if (revision === 6) {
                            try {
                                password = utf8StringToString(password);
                            } catch (ex) {
                                warn('CipherTransformFactory: ' + 'Unable to convert UTF8 encoded password.');
                            }
                        }
                        passwordBytes = stringToBytes(password);
                    }
                    var encryptionKey;
                    if (algorithm !== 5) {
                        encryptionKey = prepareKeyData(fileIdBytes, passwordBytes, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata);
                    } else {
                        var ownerValidationSalt = stringToBytes(dict.get('O')).subarray(32, 40);
                        var ownerKeySalt = stringToBytes(dict.get('O')).subarray(40, 48);
                        var uBytes = stringToBytes(dict.get('U')).subarray(0, 48);
                        var userValidationSalt = stringToBytes(dict.get('U')).subarray(32, 40);
                        var userKeySalt = stringToBytes(dict.get('U')).subarray(40, 48);
                        var ownerEncryption = stringToBytes(dict.get('OE'));
                        var userEncryption = stringToBytes(dict.get('UE'));
                        var perms = stringToBytes(dict.get('Perms'));
                        encryptionKey = createEncryptionKey20(revision, passwordBytes, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption, perms);
                    }
                    if (!encryptionKey && !password) {
                        throw new PasswordException('No password given', PasswordResponses.NEED_PASSWORD);
                    } else if (!encryptionKey && password) {
                        var decodedPassword = decodeUserPassword(passwordBytes, ownerPassword, revision, keyLength);
                        encryptionKey = prepareKeyData(fileIdBytes, decodedPassword, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata);
                    }
                    if (!encryptionKey) {
                        throw new PasswordException('Incorrect Password', PasswordResponses.INCORRECT_PASSWORD);
                    }
                    this.encryptionKey = encryptionKey;
                    if (algorithm >= 4) {
                        this.cf = dict.get('CF');
                        this.stmf = dict.get('StmF') || identityName;
                        this.strf = dict.get('StrF') || identityName;
                        this.eff = dict.get('EFF') || this.stmf;
                    }
                }

                function buildObjectKey(num, gen, encryptionKey, isAes) {
                    var key = new Uint8Array(encryptionKey.length + 9),
                        i, n;
                    for (i = 0, n = encryptionKey.length; i < n; ++i) {
                        key[i] = encryptionKey[i];
                    }
                    key[i++] = num & 0xFF;
                    key[i++] = (num >> 8) & 0xFF;
                    key[i++] = (num >> 16) & 0xFF;
                    key[i++] = gen & 0xFF;
                    key[i++] = (gen >> 8) & 0xFF;
                    if (isAes) {
                        key[i++] = 0x73;
                        key[i++] = 0x41;
                        key[i++] = 0x6C;
                        key[i++] = 0x54;
                    }
                    var hash = calculateMD5(key, 0, i);
                    return hash.subarray(0, Math.min(encryptionKey.length + 5, 16));
                }

                function buildCipherConstructor(cf, name, num, gen, key) {
                    var cryptFilter = cf.get(name.name);
                    var cfm;
                    if (cryptFilter !== null && cryptFilter !== undefined) {
                        cfm = cryptFilter.get('CFM');
                    }
                    if (!cfm || cfm.name === 'None') {
                        return function cipherTransformFactoryBuildCipherConstructorNone() {
                            return new NullCipher();
                        };
                    }
                    if ('V2' === cfm.name) {
                        return function cipherTransformFactoryBuildCipherConstructorV2() {
                            return new ARCFourCipher(buildObjectKey(num, gen, key, false));
                        };
                    }
                    if ('AESV2' === cfm.name) {
                        return function cipherTransformFactoryBuildCipherConstructorAESV2() {
                            return new AES128Cipher(buildObjectKey(num, gen, key, true));
                        };
                    }
                    if ('AESV3' === cfm.name) {
                        return function cipherTransformFactoryBuildCipherConstructorAESV3() {
                            return new AES256Cipher(key);
                        };
                    }
                    error('Unknown crypto method');
                }
                CipherTransformFactory.prototype = {
                    createCipherTransform: function CipherTransformFactory_createCipherTransform(num, gen) {
                        if (this.algorithm === 4 || this.algorithm === 5) {
                            return new CipherTransform(buildCipherConstructor(this.cf, this.stmf, num, gen, this.encryptionKey), buildCipherConstructor(this.cf, this.strf, num, gen, this.encryptionKey));
                        }
                        var key = buildObjectKey(num, gen, this.encryptionKey, false);
                        var cipherConstructor = function buildCipherCipherConstructor() {
                            return new ARCFourCipher(key);
                        };
                        return new CipherTransform(cipherConstructor, cipherConstructor);
                    }
                };
                return CipherTransformFactory;
            })();
            exports.AES128Cipher = AES128Cipher;
            exports.AES256Cipher = AES256Cipher;
            exports.ARCFourCipher = ARCFourCipher;
            exports.CipherTransformFactory = CipherTransformFactory;
            exports.PDF17 = PDF17;
            exports.PDF20 = PDF20;
            exports.calculateMD5 = calculateMD5;
            exports.calculateSHA256 = calculateSHA256;
            exports.calculateSHA384 = calculateSHA384;
            exports.calculateSHA512 = calculateSHA512;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsCoreFontRenderer = {}), root.pdfjsSharedUtil, root.pdfjsCoreStream, root.pdfjsCoreGlyphList);
            }
        }(this, function(exports, sharedUtil, coreStream, coreGlyphList) {
            var Util = sharedUtil.Util;
            var bytesToString = sharedUtil.bytesToString;
            var error = sharedUtil.error;
            var Stream = coreStream.Stream;
            var GlyphsUnicode = coreGlyphList.GlyphsUnicode;
            var coreFonts;
            var CFFParser;
            var Encodings;
            var FontRendererFactory = (function FontRendererFactoryClosure() {
                function getLong(data, offset) {
                    return (data[offset] << 24) | (data[offset + 1] << 16) | (data[offset + 2] << 8) | data[offset + 3];
                }

                function getUshort(data, offset) {
                    return (data[offset] << 8) | data[offset + 1];
                }

                function parseCmap(data, start, end) {
                    var offset = (getUshort(data, start + 2) === 1 ? getLong(data, start + 8) : getLong(data, start + 16));
                    var format = getUshort(data, start + offset);
                    var length, ranges, p, i;
                    if (format === 4) {
                        length = getUshort(data, start + offset + 2);
                        var segCount = getUshort(data, start + offset + 6) >> 1;
                        p = start + offset + 14;
                        ranges = [];
                        for (i = 0; i < segCount; i++, p += 2) {
                            ranges[i] = {
                                end: getUshort(data, p)
                            };
                        }
                        p += 2;
                        for (i = 0; i < segCount; i++, p += 2) {
                            ranges[i].start = getUshort(data, p);
                        }
                        for (i = 0; i < segCount; i++, p += 2) {
                            ranges[i].idDelta = getUshort(data, p);
                        }
                        for (i = 0; i < segCount; i++, p += 2) {
                            var idOffset = getUshort(data, p);
                            if (idOffset === 0) {
                                continue;
                            }
                            ranges[i].ids = [];
                            for (var j = 0, jj = ranges[i].end - ranges[i].start + 1; j < jj; j++) {
                                ranges[i].ids[j] = getUshort(data, p + idOffset);
                                idOffset += 2;
                            }
                        }
                        return ranges;
                    } else if (format === 12) {
                        length = getLong(data, start + offset + 4);
                        var groups = getLong(data, start + offset + 12);
                        p = start + offset + 16;
                        ranges = [];
                        for (i = 0; i < groups; i++) {
                            ranges.push({
                                start: getLong(data, p),
                                end: getLong(data, p + 4),
                                idDelta: getLong(data, p + 8) - getLong(data, p)
                            });
                            p += 12;
                        }
                        return ranges;
                    }
                    error('not supported cmap: ' + format);
                }

                function parseCff(data, start, end) {
                    var properties = {};
                    var parser = new CFFParser(new Stream(data, start, end - start), properties);
                    var cff = parser.parse();
                    return {
                        glyphs: cff.charStrings.objects,
                        subrs: (cff.topDict.privateDict && cff.topDict.privateDict.subrsIndex && cff.topDict.privateDict.subrsIndex.objects),
                        gsubrs: cff.globalSubrIndex && cff.globalSubrIndex.objects
                    };
                }

                function parseGlyfTable(glyf, loca, isGlyphLocationsLong) {
                    var itemSize, itemDecode;
                    if (isGlyphLocationsLong) {
                        itemSize = 4;
                        itemDecode = function fontItemDecodeLong(data, offset) {
                            return (data[offset] << 24) | (data[offset + 1] << 16) | (data[offset + 2] << 8) | data[offset + 3];
                        };
                    } else {
                        itemSize = 2;
                        itemDecode = function fontItemDecode(data, offset) {
                            return (data[offset] << 9) | (data[offset + 1] << 1);
                        };
                    }
                    var glyphs = [];
                    var startOffset = itemDecode(loca, 0);
                    for (var j = itemSize; j < loca.length; j += itemSize) {
                        var endOffset = itemDecode(loca, j);
                        glyphs.push(glyf.subarray(startOffset, endOffset));
                        startOffset = endOffset;
                    }
                    return glyphs;
                }

                function lookupCmap(ranges, unicode) {
                    var code = unicode.charCodeAt(0);
                    var l = 0,
                        r = ranges.length - 1;
                    while (l < r) {
                        var c = (l + r + 1) >> 1;
                        if (code < ranges[c].start) {
                            r = c - 1;
                        } else {
                            l = c;
                        }
                    }
                    if (ranges[l].start <= code && code <= ranges[l].end) {
                        return (ranges[l].idDelta + (ranges[l].ids ? ranges[l].ids[code - ranges[l].start] : code)) & 0xFFFF;
                    }
                    return 0;
                }

                function compileGlyf(code, cmds, font) {
                    function moveTo(x, y) {
                        cmds.push({
                            cmd: 'moveTo',
                            args: [x, y]
                        });
                    }

                    function lineTo(x, y) {
                        cmds.push({
                            cmd: 'lineTo',
                            args: [x, y]
                        });
                    }

                    function quadraticCurveTo(xa, ya, x, y) {
                        cmds.push({
                            cmd: 'quadraticCurveTo',
                            args: [xa, ya, x, y]
                        });
                    }
                    var i = 0;
                    var numberOfContours = ((code[i] << 24) | (code[i + 1] << 16)) >> 16;
                    var flags;
                    var x = 0,
                        y = 0;
                    i += 10;
                    if (numberOfContours < 0) {
                        do {
                            flags = (code[i] << 8) | code[i + 1];
                            var glyphIndex = (code[i + 2] << 8) | code[i + 3];
                            i += 4;
                            var arg1, arg2;
                            if ((flags & 0x01)) {
                                arg1 = ((code[i] << 24) | (code[i + 1] << 16)) >> 16;
                                arg2 = ((code[i + 2] << 24) | (code[i + 3] << 16)) >> 16;
                                i += 4;
                            } else {
                                arg1 = code[i++];
                                arg2 = code[i++];
                            }
                            if ((flags & 0x02)) {
                                x = arg1;
                                y = arg2;
                            } else {
                                x = 0;
                                y = 0;
                            }
                            var scaleX = 1,
                                scaleY = 1,
                                scale01 = 0,
                                scale10 = 0;
                            if ((flags & 0x08)) {
                                scaleX = scaleY = ((code[i] << 24) | (code[i + 1] << 16)) / 1073741824;
                                i += 2;
                            } else if ((flags & 0x40)) {
                                scaleX = ((code[i] << 24) | (code[i + 1] << 16)) / 1073741824;
                                scaleY = ((code[i + 2] << 24) | (code[i + 3] << 16)) / 1073741824;
                                i += 4;
                            } else if ((flags & 0x80)) {
                                scaleX = ((code[i] << 24) | (code[i + 1] << 16)) / 1073741824;
                                scale01 = ((code[i + 2] << 24) | (code[i + 3] << 16)) / 1073741824;
                                scale10 = ((code[i + 4] << 24) | (code[i + 5] << 16)) / 1073741824;
                                scaleY = ((code[i + 6] << 24) | (code[i + 7] << 16)) / 1073741824;
                                i += 8;
                            }
                            var subglyph = font.glyphs[glyphIndex];
                            if (subglyph) {
                                cmds.push({
                                    cmd: 'save'
                                });
                                cmds.push({
                                    cmd: 'transform',
                                    args: [scaleX, scale01, scale10, scaleY, x, y]
                                });
                                compileGlyf(subglyph, cmds, font);
                                cmds.push({
                                    cmd: 'restore'
                                });
                            }
                        } while ((flags & 0x20));
                    } else {
                        var endPtsOfContours = [];
                        var j, jj;
                        for (j = 0; j < numberOfContours; j++) {
                            endPtsOfContours.push((code[i] << 8) | code[i + 1]);
                            i += 2;
                        }
                        var instructionLength = (code[i] << 8) | code[i + 1];
                        i += 2 + instructionLength;
                        var numberOfPoints = endPtsOfContours[endPtsOfContours.length - 1] + 1;
                        var points = [];
                        while (points.length < numberOfPoints) {
                            flags = code[i++];
                            var repeat = 1;
                            if ((flags & 0x08)) {
                                repeat += code[i++];
                            }
                            while (repeat-- > 0) {
                                points.push({
                                    flags: flags
                                });
                            }
                        }
                        for (j = 0; j < numberOfPoints; j++) {
                            switch (points[j].flags & 0x12) {
                                case 0x00:
                                    x += ((code[i] << 24) | (code[i + 1] << 16)) >> 16;
                                    i += 2;
                                    break;
                                case 0x02:
                                    x -= code[i++];
                                    break;
                                case 0x12:
                                    x += code[i++];
                                    break;
                            }
                            points[j].x = x;
                        }
                        for (j = 0; j < numberOfPoints; j++) {
                            switch (points[j].flags & 0x24) {
                                case 0x00:
                                    y += ((code[i] << 24) | (code[i + 1] << 16)) >> 16;
                                    i += 2;
                                    break;
                                case 0x04:
                                    y -= code[i++];
                                    break;
                                case 0x24:
                                    y += code[i++];
                                    break;
                            }
                            points[j].y = y;
                        }
                        var startPoint = 0;
                        for (i = 0; i < numberOfContours; i++) {
                            var endPoint = endPtsOfContours[i];
                            var contour = points.slice(startPoint, endPoint + 1);
                            if ((contour[0].flags & 1)) {
                                contour.push(contour[0]);
                            } else if ((contour[contour.length - 1].flags & 1)) {
                                contour.unshift(contour[contour.length - 1]);
                            } else {
                                var p = {
                                    flags: 1,
                                    x: (contour[0].x + contour[contour.length - 1].x) / 2,
                                    y: (contour[0].y + contour[contour.length - 1].y) / 2
                                };
                                contour.unshift(p);
                                contour.push(p);
                            }
                            moveTo(contour[0].x, contour[0].y);
                            for (j = 1, jj = contour.length; j < jj; j++) {
                                if ((contour[j].flags & 1)) {
                                    lineTo(contour[j].x, contour[j].y);
                                } else if ((contour[j + 1].flags & 1)) {
                                    quadraticCurveTo(contour[j].x, contour[j].y, contour[j + 1].x, contour[j + 1].y);
                                    j++;
                                } else {
                                    quadraticCurveTo(contour[j].x, contour[j].y, (contour[j].x + contour[j + 1].x) / 2, (contour[j].y + contour[j + 1].y) / 2);
                                }
                            }
                            startPoint = endPoint + 1;
                        }
                    }
                }

                function compileCharString(code, cmds, font) {
                    var stack = [];
                    var x = 0,
                        y = 0;
                    var stems = 0;

                    function moveTo(x, y) {
                        cmds.push({
                            cmd: 'moveTo',
                            args: [x, y]
                        });
                    }

                    function lineTo(x, y) {
                        cmds.push({
                            cmd: 'lineTo',
                            args: [x, y]
                        });
                    }

                    function bezierCurveTo(x1, y1, x2, y2, x, y) {
                        cmds.push({
                            cmd: 'bezierCurveTo',
                            args: [x1, y1, x2, y2, x, y]
                        });
                    }

                    function parse(code) {
                        var i = 0;
                        while (i < code.length) {
                            var stackClean = false;
                            var v = code[i++];
                            var xa, xb, ya, yb, y1, y2, y3, n, subrCode;
                            switch (v) {
                                case 1:
                                    stems += stack.length >> 1;
                                    stackClean = true;
                                    break;
                                case 3:
                                    stems += stack.length >> 1;
                                    stackClean = true;
                                    break;
                                case 4:
                                    y += stack.pop();
                                    moveTo(x, y);
                                    stackClean = true;
                                    break;
                                case 5:
                                    while (stack.length > 0) {
                                        x += stack.shift();
                                        y += stack.shift();
                                        lineTo(x, y);
                                    }
                                    break;
                                case 6:
                                    while (stack.length > 0) {
                                        x += stack.shift();
                                        lineTo(x, y);
                                        if (stack.length === 0) {
                                            break;
                                        }
                                        y += stack.shift();
                                        lineTo(x, y);
                                    }
                                    break;
                                case 7:
                                    while (stack.length > 0) {
                                        y += stack.shift();
                                        lineTo(x, y);
                                        if (stack.length === 0) {
                                            break;
                                        }
                                        x += stack.shift();
                                        lineTo(x, y);
                                    }
                                    break;
                                case 8:
                                    while (stack.length > 0) {
                                        xa = x + stack.shift();
                                        ya = y + stack.shift();
                                        xb = xa + stack.shift();
                                        yb = ya + stack.shift();
                                        x = xb + stack.shift();
                                        y = yb + stack.shift();
                                        bezierCurveTo(xa, ya, xb, yb, x, y);
                                    }
                                    break;
                                case 10:
                                    n = stack.pop() + font.subrsBias;
                                    subrCode = font.subrs[n];
                                    if (subrCode) {
                                        parse(subrCode);
                                    }
                                    break;
                                case 11:
                                    return;
                                case 12:
                                    v = code[i++];
                                    switch (v) {
                                        case 34:
                                            xa = x + stack.shift();
                                            xb = xa + stack.shift();
                                            y1 = y + stack.shift();
                                            x = xb + stack.shift();
                                            bezierCurveTo(xa, y, xb, y1, x, y1);
                                            xa = x + stack.shift();
                                            xb = xa + stack.shift();
                                            x = xb + stack.shift();
                                            bezierCurveTo(xa, y1, xb, y, x, y);
                                            break;
                                        case 35:
                                            xa = x + stack.shift();
                                            ya = y + stack.shift();
                                            xb = xa + stack.shift();
                                            yb = ya + stack.shift();
                                            x = xb + stack.shift();
                                            y = yb + stack.shift();
                                            bezierCurveTo(xa, ya, xb, yb, x, y);
                                            xa = x + stack.shift();
                                            ya = y + stack.shift();
                                            xb = xa + stack.shift();
                                            yb = ya + stack.shift();
                                            x = xb + stack.shift();
                                            y = yb + stack.shift();
                                            bezierCurveTo(xa, ya, xb, yb, x, y);
                                            stack.pop();
                                            break;
                                        case 36:
                                            xa = x + stack.shift();
                                            y1 = y + stack.shift();
                                            xb = xa + stack.shift();
                                            y2 = y1 + stack.shift();
                                            x = xb + stack.shift();
                                            bezierCurveTo(xa, y1, xb, y2, x, y2);
                                            xa = x + stack.shift();
                                            xb = xa + stack.shift();
                                            y3 = y2 + stack.shift();
                                            x = xb + stack.shift();
                                            bezierCurveTo(xa, y2, xb, y3, x, y);
                                            break;
                                        case 37:
                                            var x0 = x,
                                                y0 = y;
                                            xa = x + stack.shift();
                                            ya = y + stack.shift();
                                            xb = xa + stack.shift();
                                            yb = ya + stack.shift();
                                            x = xb + stack.shift();
                                            y = yb + stack.shift();
                                            bezierCurveTo(xa, ya, xb, yb, x, y);
                                            xa = x + stack.shift();
                                            ya = y + stack.shift();
                                            xb = xa + stack.shift();
                                            yb = ya + stack.shift();
                                            x = xb;
                                            y = yb;
                                            if (Math.abs(x - x0) > Math.abs(y - y0)) {
                                                x += stack.shift();
                                            } else {
                                                y += stack.shift();
                                            }
                                            bezierCurveTo(xa, ya, xb, yb, x, y);
                                            break;
                                        default:
                                            error('unknown operator: 12 ' + v);
                                    }
                                    break;
                                case 14:
                                    if (stack.length >= 4) {
                                        var achar = stack.pop();
                                        var bchar = stack.pop();
                                        y = stack.pop();
                                        x = stack.pop();
                                        cmds.push({
                                            cmd: 'save'
                                        });
                                        cmds.push({
                                            cmd: 'translate',
                                            args: [x, y]
                                        });
                                        var gid = lookupCmap(font.cmap, String.fromCharCode(font.glyphNameMap[Encodings.StandardEncoding[achar]]));
                                        compileCharString(font.glyphs[gid], cmds, font);
                                        cmds.push({
                                            cmd: 'restore'
                                        });
                                        gid = lookupCmap(font.cmap, String.fromCharCode(font.glyphNameMap[Encodings.StandardEncoding[bchar]]));
                                        compileCharString(font.glyphs[gid], cmds, font);
                                    }
                                    return;
                                case 18:
                                    stems += stack.length >> 1;
                                    stackClean = true;
                                    break;
                                case 19:
                                    stems += stack.length >> 1;
                                    i += (stems + 7) >> 3;
                                    stackClean = true;
                                    break;
                                case 20:
                                    stems += stack.length >> 1;
                                    i += (stems + 7) >> 3;
                                    stackClean = true;
                                    break;
                                case 21:
                                    y += stack.pop();
                                    x += stack.pop();
                                    moveTo(x, y);
                                    stackClean = true;
                                    break;
                                case 22:
                                    x += stack.pop();
                                    moveTo(x, y);
                                    stackClean = true;
                                    break;
                                case 23:
                                    stems += stack.length >> 1;
                                    stackClean = true;
                                    break;
                                case 24:
                                    while (stack.length > 2) {
                                        xa = x + stack.shift();
                                        ya = y + stack.shift();
                                        xb = xa + stack.shift();
                                        yb = ya + stack.shift();
                                        x = xb + stack.shift();
                                        y = yb + stack.shift();
                                        bezierCurveTo(xa, ya, xb, yb, x, y);
                                    }
                                    x += stack.shift();
                                    y += stack.shift();
                                    lineTo(x, y);
                                    break;
                                case 25:
                                    while (stack.length > 6) {
                                        x += stack.shift();
                                        y += stack.shift();
                                        lineTo(x, y);
                                    }
                                    xa = x + stack.shift();
                                    ya = y + stack.shift();
                                    xb = xa + stack.shift();
                                    yb = ya + stack.shift();
                                    x = xb + stack.shift();
                                    y = yb + stack.shift();
                                    bezierCurveTo(xa, ya, xb, yb, x, y);
                                    break;
                                case 26:
                                    if (stack.length % 2) {
                                        x += stack.shift();
                                    }
                                    while (stack.length > 0) {
                                        xa = x;
                                        ya = y + stack.shift();
                                        xb = xa + stack.shift();
                                        yb = ya + stack.shift();
                                        x = xb;
                                        y = yb + stack.shift();
                                        bezierCurveTo(xa, ya, xb, yb, x, y);
                                    }
                                    break;
                                case 27:
                                    if (stack.length % 2) {
                                        y += stack.shift();
                                    }
                                    while (stack.length > 0) {
                                        xa = x + stack.shift();
                                        ya = y;
                                        xb = xa + stack.shift();
                                        yb = ya + stack.shift();
                                        x = xb + stack.shift();
                                        y = yb;
                                        bezierCurveTo(xa, ya, xb, yb, x, y);
                                    }
                                    break;
                                case 28:
                                    stack.push(((code[i] << 24) | (code[i + 1] << 16)) >> 16);
                                    i += 2;
                                    break;
                                case 29:
                                    n = stack.pop() + font.gsubrsBias;
                                    subrCode = font.gsubrs[n];
                                    if (subrCode) {
                                        parse(subrCode);
                                    }
                                    break;
                                case 30:
                                    while (stack.length > 0) {
                                        xa = x;
                                        ya = y + stack.shift();
                                        xb = xa + stack.shift();
                                        yb = ya + stack.shift();
                                        x = xb + stack.shift();
                                        y = yb + (stack.length === 1 ? stack.shift() : 0);
                                        bezierCurveTo(xa, ya, xb, yb, x, y);
                                        if (stack.length === 0) {
                                            break;
                                        }
                                        xa = x + stack.shift();
                                        ya = y;
                                        xb = xa + stack.shift();
                                        yb = ya + stack.shift();
                                        y = yb + stack.shift();
                                        x = xb + (stack.length === 1 ? stack.shift() : 0);
                                        bezierCurveTo(xa, ya, xb, yb, x, y);
                                    }
                                    break;
                                case 31:
                                    while (stack.length > 0) {
                                        xa = x + stack.shift();
                                        ya = y;
                                        xb = xa + stack.shift();
                                        yb = ya + stack.shift();
                                        y = yb + stack.shift();
                                        x = xb + (stack.length === 1 ? stack.shift() : 0);
                                        bezierCurveTo(xa, ya, xb, yb, x, y);
                                        if (stack.length === 0) {
                                            break;
                                        }
                                        xa = x;
                                        ya = y + stack.shift();
                                        xb = xa + stack.shift();
                                        yb = ya + stack.shift();
                                        x = xb + stack.shift();
                                        y = yb + (stack.length === 1 ? stack.shift() : 0);
                                        bezierCurveTo(xa, ya, xb, yb, x, y);
                                    }
                                    break;
                                default:
                                    if (v < 32) {
                                        error('unknown operator: ' + v);
                                    }
                                    if (v < 247) {
                                        stack.push(v - 139);
                                    } else if (v < 251) {
                                        stack.push((v - 247) * 256 + code[i++] + 108);
                                    } else if (v < 255) {
                                        stack.push(-(v - 251) * 256 - code[i++] - 108);
                                    } else {
                                        stack.push(((code[i] << 24) | (code[i + 1] << 16) | (code[i + 2] << 8) | code[i + 3]) / 65536);
                                        i += 4;
                                    }
                                    break;
                            }
                            if (stackClean) {
                                stack.length = 0;
                            }
                        }
                    }
                    parse(code);
                }
                var noop = '';

                function CompiledFont(fontMatrix) {
                    this.compiledGlyphs = {};
                    this.fontMatrix = fontMatrix;
                }
                CompiledFont.prototype = {
                    getPathJs: function(unicode) {
                        var gid = lookupCmap(this.cmap, unicode);
                        var fn = this.compiledGlyphs[gid];
                        if (!fn) {
                            this.compiledGlyphs[gid] = fn = this.compileGlyph(this.glyphs[gid]);
                        }
                        return fn;
                    },
                    compileGlyph: function(code) {
                        if (!code || code.length === 0 || code[0] === 14) {
                            return noop;
                        }
                        var cmds = [];
                        cmds.push({
                            cmd: 'save'
                        });
                        cmds.push({
                            cmd: 'transform',
                            args: this.fontMatrix.slice()
                        });
                        cmds.push({
                            cmd: 'scale',
                            args: ['size', '-size']
                        });
                        this.compileGlyphImpl(code, cmds);
                        cmds.push({
                            cmd: 'restore'
                        });
                        return cmds;
                    },
                    compileGlyphImpl: function() {
                        error('Children classes should implement this.');
                    },
                    hasBuiltPath: function(unicode) {
                        var gid = lookupCmap(this.cmap, unicode);
                        return gid in this.compiledGlyphs;
                    }
                };

                function TrueTypeCompiled(glyphs, cmap, fontMatrix) {
                    fontMatrix = fontMatrix || [0.000488, 0, 0, 0.000488, 0, 0];
                    CompiledFont.call(this, fontMatrix);
                    this.glyphs = glyphs;
                    this.cmap = cmap;
                    this.compiledGlyphs = [];
                }
                Util.inherit(TrueTypeCompiled, CompiledFont, {
                    compileGlyphImpl: function(code, cmds) {
                        compileGlyf(code, cmds, this);
                    }
                });

                function Type2Compiled(cffInfo, cmap, fontMatrix, glyphNameMap) {
                    fontMatrix = fontMatrix || [0.001, 0, 0, 0.001, 0, 0];
                    CompiledFont.call(this, fontMatrix);
                    this.glyphs = cffInfo.glyphs;
                    this.gsubrs = cffInfo.gsubrs || [];
                    this.subrs = cffInfo.subrs || [];
                    this.cmap = cmap;
                    this.glyphNameMap = glyphNameMap || GlyphsUnicode;
                    this.compiledGlyphs = [];
                    this.gsubrsBias = (this.gsubrs.length < 1240 ? 107 : (this.gsubrs.length < 33900 ? 1131 : 32768));
                    this.subrsBias = (this.subrs.length < 1240 ? 107 : (this.subrs.length < 33900 ? 1131 : 32768));
                }
                Util.inherit(Type2Compiled, CompiledFont, {
                    compileGlyphImpl: function(code, cmds) {
                        compileCharString(code, cmds, this);
                    }
                });
                return {
                    create: function FontRendererFactory_create(font) {
                        var data = new Uint8Array(font.data);
                        var cmap, glyf, loca, cff, indexToLocFormat, unitsPerEm;
                        var numTables = getUshort(data, 4);
                        for (var i = 0, p = 12; i < numTables; i++, p += 16) {
                            var tag = bytesToString(data.subarray(p, p + 4));
                            var offset = getLong(data, p + 8);
                            var length = getLong(data, p + 12);
                            switch (tag) {
                                case 'cmap':
                                    cmap = parseCmap(data, offset, offset + length);
                                    break;
                                case 'glyf':
                                    glyf = data.subarray(offset, offset + length);
                                    break;
                                case 'loca':
                                    loca = data.subarray(offset, offset + length);
                                    break;
                                case 'head':
                                    unitsPerEm = getUshort(data, offset + 18);
                                    indexToLocFormat = getUshort(data, offset + 50);
                                    break;
                                case 'CFF ':
                                    cff = parseCff(data, offset, offset + length);
                                    break;
                            }
                        }
                        if (glyf) {
                            var fontMatrix = (!unitsPerEm ? font.fontMatrix : [1 / unitsPerEm, 0, 0, 1 / unitsPerEm, 0, 0]);
                            return new TrueTypeCompiled(parseGlyfTable(glyf, loca, indexToLocFormat), cmap, fontMatrix);
                        } else {
                            return new Type2Compiled(cff, cmap, font.fontMatrix, font.glyphNameMap);
                        }
                    }
                };
            })();

            function _setCoreFonts(coreFonts_) {
                coreFonts = coreFonts_;
                Encodings = coreFonts_.Encodings;
                CFFParser = coreFonts_.CFFParser;
            }
            exports._setCoreFonts = _setCoreFonts;
            exports.FontRendererFactory = FontRendererFactory;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsCoreParser = {}), root.pdfjsSharedUtil, root.pdfjsCorePrimitives, root.pdfjsCoreStream);
            }
        }(this, function(exports, sharedUtil, corePrimitives, coreStream) {
            var MissingDataException = sharedUtil.MissingDataException;
            var StreamType = sharedUtil.StreamType;
            var assert = sharedUtil.assert;
            var error = sharedUtil.error;
            var info = sharedUtil.info;
            var isArray = sharedUtil.isArray;
            var isInt = sharedUtil.isInt;
            var isNum = sharedUtil.isNum;
            var isString = sharedUtil.isString;
            var warn = sharedUtil.warn;
            var Cmd = corePrimitives.Cmd;
            var Dict = corePrimitives.Dict;
            var Name = corePrimitives.Name;
            var Ref = corePrimitives.Ref;
            var isCmd = corePrimitives.isCmd;
            var isDict = corePrimitives.isDict;
            var isName = corePrimitives.isName;
            var Ascii85Stream = coreStream.Ascii85Stream;
            var AsciiHexStream = coreStream.AsciiHexStream;
            var CCITTFaxStream = coreStream.CCITTFaxStream;
            var FlateStream = coreStream.FlateStream;
            var Jbig2Stream = coreStream.Jbig2Stream;
            var JpegStream = coreStream.JpegStream;
            var JpxStream = coreStream.JpxStream;
            var LZWStream = coreStream.LZWStream;
            var NullStream = coreStream.NullStream;
            var PredictorStream = coreStream.PredictorStream;
            var RunLengthStream = coreStream.RunLengthStream;
            var EOF = {};

            function isEOF(v) {
                return (v === EOF);
            }
            var MAX_LENGTH_TO_CACHE = 1000;
            var Parser = (function ParserClosure() {
                function Parser(lexer, allowStreams, xref) {
                    this.lexer = lexer;
                    this.allowStreams = allowStreams;
                    this.xref = xref;
                    this.imageCache = {};
                    this.refill();
                }
                Parser.prototype = {
                    refill: function Parser_refill() {
                        this.buf1 = this.lexer.getObj();
                        this.buf2 = this.lexer.getObj();
                    },
                    shift: function Parser_shift() {
                        if (isCmd(this.buf2, 'ID')) {
                            this.buf1 = this.buf2;
                            this.buf2 = null;
                        } else {
                            this.buf1 = this.buf2;
                            this.buf2 = this.lexer.getObj();
                        }
                    },
                    tryShift: function Parser_tryShift() {
                        try {
                            this.shift();
                            return true;
                        } catch (e) {
                            if (e instanceof MissingDataException) {
                                throw e;
                            }
                            return false;
                        }
                    },
                    getObj: function Parser_getObj(cipherTransform) {
                        var buf1 = this.buf1;
                        this.shift();
                        if (buf1 instanceof Cmd) {
                            switch (buf1.cmd) {
                                case 'BI':
                                    return this.makeInlineImage(cipherTransform);
                                case '[':
                                    var array = [];
                                    while (!isCmd(this.buf1, ']') && !isEOF(this.buf1)) {
                                        array.push(this.getObj(cipherTransform));
                                    }
                                    if (isEOF(this.buf1)) {
                                        error('End of file inside array');
                                    }
                                    this.shift();
                                    return array;
                                case '<<':
                                    var dict = new Dict(this.xref);
                                    while (!isCmd(this.buf1, '>>') && !isEOF(this.buf1)) {
                                        if (!isName(this.buf1)) {
                                            info('Malformed dictionary: key must be a name object');
                                            this.shift();
                                            continue;
                                        }
                                        var key = this.buf1.name;
                                        this.shift();
                                        if (isEOF(this.buf1)) {
                                            break;
                                        }
                                        dict.set(key, this.getObj(cipherTransform));
                                    }
                                    if (isEOF(this.buf1)) {
                                        error('End of file inside dictionary');
                                    }
                                    if (isCmd(this.buf2, 'stream')) {
                                        return (this.allowStreams ? this.makeStream(dict, cipherTransform) : dict);
                                    }
                                    this.shift();
                                    return dict;
                                default:
                                    return buf1;
                            }
                        }
                        if (isInt(buf1)) {
                            var num = buf1;
                            if (isInt(this.buf1) && isCmd(this.buf2, 'R')) {
                                var ref = new Ref(num, this.buf1);
                                this.shift();
                                this.shift();
                                return ref;
                            }
                            return num;
                        }
                        if (isString(buf1)) {
                            var str = buf1;
                            if (cipherTransform) {
                                str = cipherTransform.decryptString(str);
                            }
                            return str;
                        }
                        return buf1;
                    },
                    findDefaultInlineStreamEnd: function Parser_findDefaultInlineStreamEnd(stream) {
                        var E = 0x45,
                            I = 0x49,
                            SPACE = 0x20,
                            LF = 0xA,
                            CR = 0xD;
                        var startPos = stream.pos,
                            state = 0,
                            ch, i, n, followingBytes;
                        while ((ch = stream.getByte()) !== -1) {
                            if (state === 0) {
                                state = (ch === E) ? 1 : 0;
                            } else if (state === 1) {
                                state = (ch === I) ? 2 : 0;
                            } else {
                                assert(state === 2);
                                if (ch === SPACE || ch === LF || ch === CR) {
                                    n = 5;
                                    followingBytes = stream.peekBytes(n);
                                    for (i = 0; i < n; i++) {
                                        ch = followingBytes[i];
                                        if (ch !== LF && ch !== CR && (ch < SPACE || ch > 0x7F)) {
                                            state = 0;
                                            break;
                                        }
                                    }
                                    if (state === 2) {
                                        break;
                                    }
                                } else {
                                    state = 0;
                                }
                            }
                        }
                        return ((stream.pos - 4) - startPos);
                    },
                    findDCTDecodeInlineStreamEnd: function Parser_findDCTDecodeInlineStreamEnd(stream) {
                        var startPos = stream.pos,
                            foundEOI = false,
                            b, markerLength, length;
                        while ((b = stream.getByte()) !== -1) {
                            if (b !== 0xFF) {
                                continue;
                            }
                            switch (stream.getByte()) {
                                case 0x00:
                                    break;
                                case 0xFF:
                                    stream.skip(-1);
                                    break;
                                case 0xD9:
                                    foundEOI = true;
                                    break;
                                case 0xC0:
                                case 0xC1:
                                case 0xC2:
                                case 0xC3:
                                case 0xC5:
                                case 0xC6:
                                case 0xC7:
                                case 0xC9:
                                case 0xCA:
                                case 0xCB:
                                case 0xCD:
                                case 0xCE:
                                case 0xCF:
                                case 0xC4:
                                case 0xCC:
                                case 0xDA:
                                case 0xDB:
                                case 0xDC:
                                case 0xDD:
                                case 0xDE:
                                case 0xDF:
                                case 0xE0:
                                case 0xE1:
                                case 0xE2:
                                case 0xE3:
                                case 0xE4:
                                case 0xE5:
                                case 0xE6:
                                case 0xE7:
                                case 0xE8:
                                case 0xE9:
                                case 0xEA:
                                case 0xEB:
                                case 0xEC:
                                case 0xED:
                                case 0xEE:
                                case 0xEF:
                                case 0xFE:
                                    markerLength = stream.getUint16();
                                    if (markerLength > 2) {
                                        stream.skip(markerLength - 2);
                                    } else {
                                        stream.skip(-2);
                                    }
                                    break;
                            }
                            if (foundEOI) {
                                break;
                            }
                        }
                        length = stream.pos - startPos;
                        if (b === -1) {
                            warn('Inline DCTDecode image stream: ' + 'EOI marker not found, searching for /EI/ instead.');
                            stream.skip(-length);
                            return this.findDefaultInlineStreamEnd(stream);
                        }
                        this.inlineStreamSkipEI(stream);
                        return length;
                    },
                    findASCII85DecodeInlineStreamEnd: function Parser_findASCII85DecodeInlineStreamEnd(stream) {
                        var TILDE = 0x7E,
                            GT = 0x3E;
                        var startPos = stream.pos,
                            ch, length;
                        while ((ch = stream.getByte()) !== -1) {
                            if (ch === TILDE && stream.peekByte() === GT) {
                                stream.skip();
                                break;
                            }
                        }
                        length = stream.pos - startPos;
                        if (ch === -1) {
                            warn('Inline ASCII85Decode image stream: ' + 'EOD marker not found, searching for /EI/ instead.');
                            stream.skip(-length);
                            return this.findDefaultInlineStreamEnd(stream);
                        }
                        this.inlineStreamSkipEI(stream);
                        return length;
                    },
                    findASCIIHexDecodeInlineStreamEnd: function Parser_findASCIIHexDecodeInlineStreamEnd(stream) {
                        var GT = 0x3E;
                        var startPos = stream.pos,
                            ch, length;
                        while ((ch = stream.getByte()) !== -1) {
                            if (ch === GT) {
                                break;
                            }
                        }
                        length = stream.pos - startPos;
                        if (ch === -1) {
                            warn('Inline ASCIIHexDecode image stream: ' + 'EOD marker not found, searching for /EI/ instead.');
                            stream.skip(-length);
                            return this.findDefaultInlineStreamEnd(stream);
                        }
                        this.inlineStreamSkipEI(stream);
                        return length;
                    },
                    inlineStreamSkipEI: function Parser_inlineStreamSkipEI(stream) {
                        var E = 0x45,
                            I = 0x49;
                        var state = 0,
                            ch;
                        while ((ch = stream.getByte()) !== -1) {
                            if (state === 0) {
                                state = (ch === E) ? 1 : 0;
                            } else if (state === 1) {
                                state = (ch === I) ? 2 : 0;
                            } else if (state === 2) {
                                break;
                            }
                        }
                    },
                    makeInlineImage: function Parser_makeInlineImage(cipherTransform) {
                        var lexer = this.lexer;
                        var stream = lexer.stream;
                        var dict = new Dict(this.xref);
                        while (!isCmd(this.buf1, 'ID') && !isEOF(this.buf1)) {
                            if (!isName(this.buf1)) {
                                error('Dictionary key must be a name object');
                            }
                            var key = this.buf1.name;
                            this.shift();
                            if (isEOF(this.buf1)) {
                                break;
                            }
                            dict.set(key, this.getObj(cipherTransform));
                        }
                        var filter = dict.get('Filter', 'F'),
                            filterName;
                        if (isName(filter)) {
                            filterName = filter.name;
                        } else if (isArray(filter) && isName(filter[0])) {
                            filterName = filter[0].name;
                        }
                        var startPos = stream.pos,
                            length, i, ii;
                        if (filterName === 'DCTDecode' || filterName === 'DCT') {
                            length = this.findDCTDecodeInlineStreamEnd(stream);
                        } else if (filterName === 'ASCII85Decide' || filterName === 'A85') {
                            length = this.findASCII85DecodeInlineStreamEnd(stream);
                        } else if (filterName === 'ASCIIHexDecode' || filterName === 'AHx') {
                            length = this.findASCIIHexDecodeInlineStreamEnd(stream);
                        } else {
                            length = this.findDefaultInlineStreamEnd(stream);
                        }
                        var imageStream = stream.makeSubStream(startPos, length, dict);
                        var adler32;
                        if (length < MAX_LENGTH_TO_CACHE) {
                            var imageBytes = imageStream.getBytes();
                            imageStream.reset();
                            var a = 1;
                            var b = 0;
                            for (i = 0, ii = imageBytes.length; i < ii; ++i) {
                                a += imageBytes[i] & 0xff;
                                b += a;
                            }
                            adler32 = ((b % 65521) << 16) | (a % 65521);
                            if (this.imageCache.adler32 === adler32) {
                                this.buf2 = Cmd.get('EI');
                                this.shift();
                                this.imageCache[adler32].reset();
                                return this.imageCache[adler32];
                            }
                        }
                        if (cipherTransform) {
                            imageStream = cipherTransform.createStream(imageStream, length);
                        }
                        imageStream = this.filter(imageStream, dict, length);
                        imageStream.dict = dict;
                        if (adler32 !== undefined) {
                            imageStream.cacheKey = 'inline_' + length + '_' + adler32;
                            this.imageCache[adler32] = imageStream;
                        }
                        this.buf2 = Cmd.get('EI');
                        this.shift();
                        return imageStream;
                    },
                    makeStream: function Parser_makeStream(dict, cipherTransform) {
                        var lexer = this.lexer;
                        var stream = lexer.stream;
                        lexer.skipToNextLine();
                        var pos = stream.pos - 1;
                        var length = dict.get('Length');
                        if (!isInt(length)) {
                            info('Bad ' + length + ' attribute in stream');
                            length = 0;
                        }
                        stream.pos = pos + length;
                        lexer.nextChar();
                        if (this.tryShift() && isCmd(this.buf2, 'endstream')) {
                            this.shift();
                        } else {
                            stream.pos = pos;
                            var SCAN_BLOCK_SIZE = 2048;
                            var ENDSTREAM_SIGNATURE_LENGTH = 9;
                            var ENDSTREAM_SIGNATURE = [0x65, 0x6E, 0x64, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D];
                            var skipped = 0,
                                found = false,
                                i, j;
                            while (stream.pos < stream.end) {
                                var scanBytes = stream.peekBytes(SCAN_BLOCK_SIZE);
                                var scanLength = scanBytes.length - ENDSTREAM_SIGNATURE_LENGTH;
                                if (scanLength <= 0) {
                                    break;
                                }
                                found = false;
                                i = 0;
                                while (i < scanLength) {
                                    j = 0;
                                    while (j < ENDSTREAM_SIGNATURE_LENGTH && scanBytes[i + j] === ENDSTREAM_SIGNATURE[j]) {
                                        j++;
                                    }
                                    if (j >= ENDSTREAM_SIGNATURE_LENGTH) {
                                        found = true;
                                        break;
                                    }
                                    i++;
                                }
                                if (found) {
                                    skipped += i;
                                    stream.pos += i;
                                    break;
                                }
                                skipped += scanLength;
                                stream.pos += scanLength;
                            }
                            if (!found) {
                                error('Missing endstream');
                            }
                            length = skipped;
                            lexer.nextChar();
                            this.shift();
                            this.shift();
                        }
                        this.shift();
                        stream = stream.makeSubStream(pos, length, dict);
                        if (cipherTransform) {
                            stream = cipherTransform.createStream(stream, length);
                        }
                        stream = this.filter(stream, dict, length);
                        stream.dict = dict;
                        return stream;
                    },
                    filter: function Parser_filter(stream, dict, length) {
                        var filter = dict.get('Filter', 'F');
                        var params = dict.get('DecodeParms', 'DP');
                        if (isName(filter)) {
                            return this.makeFilter(stream, filter.name, length, params);
                        }
                        var maybeLength = length;
                        if (isArray(filter)) {
                            var filterArray = filter;
                            var paramsArray = params;
                            for (var i = 0, ii = filterArray.length; i < ii; ++i) {
                                filter = filterArray[i];
                                if (!isName(filter)) {
                                    error('Bad filter name: ' + filter);
                                }
                                params = null;
                                if (isArray(paramsArray) && (i in paramsArray)) {
                                    params = paramsArray[i];
                                }
                                stream = this.makeFilter(stream, filter.name, maybeLength, params);
                                maybeLength = null;
                            }
                        }
                        return stream;
                    },
                    makeFilter: function Parser_makeFilter(stream, name, maybeLength, params) {
                        if (stream.dict.get('Length') === 0 && !maybeLength) {
                            warn('Empty "' + name + '" stream.');
                            return new NullStream(stream);
                        }
                        try {
                            if (params && this.xref) {
                                params = this.xref.fetchIfRef(params);
                            }
                            var xrefStreamStats = this.xref.stats.streamTypes;
                            if (name === 'FlateDecode' || name === 'Fl') {
                                xrefStreamStats[StreamType.FLATE] = true;
                                if (params) {
                                    return new PredictorStream(new FlateStream(stream, maybeLength), maybeLength, params);
                                }
                                return new FlateStream(stream, maybeLength);
                            }
                            if (name === 'LZWDecode' || name === 'LZW') {
                                xrefStreamStats[StreamType.LZW] = true;
                                var earlyChange = 1;
                                if (params) {
                                    if (params.has('EarlyChange')) {
                                        earlyChange = params.get('EarlyChange');
                                    }
                                    return new PredictorStream(new LZWStream(stream, maybeLength, earlyChange), maybeLength, params);
                                }
                                return new LZWStream(stream, maybeLength, earlyChange);
                            }
                            if (name === 'DCTDecode' || name === 'DCT') {
                                xrefStreamStats[StreamType.DCT] = true;
                                return new JpegStream(stream, maybeLength, stream.dict, this.xref);
                            }
                            if (name === 'JPXDecode' || name === 'JPX') {
                                xrefStreamStats[StreamType.JPX] = true;
                                return new JpxStream(stream, maybeLength, stream.dict);
                            }
                            if (name === 'ASCII85Decode' || name === 'A85') {
                                xrefStreamStats[StreamType.A85] = true;
                                return new Ascii85Stream(stream, maybeLength);
                            }
                            if (name === 'ASCIIHexDecode' || name === 'AHx') {
                                xrefStreamStats[StreamType.AHX] = true;
                                return new AsciiHexStream(stream, maybeLength);
                            }
                            if (name === 'CCITTFaxDecode' || name === 'CCF') {
                                xrefStreamStats[StreamType.CCF] = true;
                                return new CCITTFaxStream(stream, maybeLength, params);
                            }
                            if (name === 'RunLengthDecode' || name === 'RL') {
                                xrefStreamStats[StreamType.RL] = true;
                                return new RunLengthStream(stream, maybeLength);
                            }
                            if (name === 'JBIG2Decode') {
                                xrefStreamStats[StreamType.JBIG] = true;
                                return new Jbig2Stream(stream, maybeLength, stream.dict);
                            }
                            warn('filter "' + name + '" not supported yet');
                            return stream;
                        } catch (ex) {
                            if (ex instanceof MissingDataException) {
                                throw ex;
                            }
                            warn('Invalid stream: \"' + ex + '\"');
                            return new NullStream(stream);
                        }
                    }
                };
                return Parser;
            })();
            var Lexer = (function LexerClosure() {
                function Lexer(stream, knownCommands) {
                    this.stream = stream;
                    this.nextChar();
                    this.strBuf = [];
                    this.knownCommands = knownCommands;
                }
                Lexer.isSpace = function Lexer_isSpace(ch) {
                    return (ch === 0x20 || ch === 0x09 || ch === 0x0D || ch === 0x0A);
                };
                var specialChars = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

                function toHexDigit(ch) {
                    if (ch >= 0x30 && ch <= 0x39) {
                        return ch & 0x0F;
                    }
                    if ((ch >= 0x41 && ch <= 0x46) || (ch >= 0x61 && ch <= 0x66)) {
                        return (ch & 0x0F) + 9;
                    }
                    return -1;
                }
                Lexer.prototype = {
                    nextChar: function Lexer_nextChar() {
                        return (this.currentChar = this.stream.getByte());
                    },
                    peekChar: function Lexer_peekChar() {
                        return this.stream.peekByte();
                    },
                    getNumber: function Lexer_getNumber() {
                        var ch = this.currentChar;
                        var eNotation = false;
                        var divideBy = 0;
                        var sign = 1;
                        if (ch === 0x2D) {
                            sign = -1;
                            ch = this.nextChar();
                            if (ch === 0x2D) {
                                ch = this.nextChar();
                            }
                        } else if (ch === 0x2B) {
                            ch = this.nextChar();
                        }
                        if (ch === 0x2E) {
                            divideBy = 10;
                            ch = this.nextChar();
                        }
                        if (ch < 0x30 || ch > 0x39) {
                            error('Invalid number: ' + String.fromCharCode(ch));
                            return 0;
                        }
                        var baseValue = ch - 0x30;
                        var powerValue = 0;
                        var powerValueSign = 1;
                        while ((ch = this.nextChar()) >= 0) {
                            if (0x30 <= ch && ch <= 0x39) {
                                var currentDigit = ch - 0x30;
                                if (eNotation) {
                                    powerValue = powerValue * 10 + currentDigit;
                                } else {
                                    if (divideBy !== 0) {
                                        divideBy *= 10;
                                    }
                                    baseValue = baseValue * 10 + currentDigit;
                                }
                            } else if (ch === 0x2E) {
                                if (divideBy === 0) {
                                    divideBy = 1;
                                } else {
                                    break;
                                }
                            } else if (ch === 0x2D) {
                                warn('Badly formated number');
                            } else if (ch === 0x45 || ch === 0x65) {
                                ch = this.peekChar();
                                if (ch === 0x2B || ch === 0x2D) {
                                    powerValueSign = (ch === 0x2D) ? -1 : 1;
                                    this.nextChar();
                                } else if (ch < 0x30 || ch > 0x39) {
                                    break;
                                }
                                eNotation = true;
                            } else {
                                break;
                            }
                        }
                        if (divideBy !== 0) {
                            baseValue /= divideBy;
                        }
                        if (eNotation) {
                            baseValue *= Math.pow(10, powerValueSign * powerValue);
                        }
                        return sign * baseValue;
                    },
                    getString: function Lexer_getString() {
                        var numParen = 1;
                        var done = false;
                        var strBuf = this.strBuf;
                        strBuf.length = 0;
                        var ch = this.nextChar();
                        while (true) {
                            var charBuffered = false;
                            switch (ch | 0) {
                                case -1:
                                    warn('Unterminated string');
                                    done = true;
                                    break;
                                case 0x28:
                                    ++numParen;
                                    strBuf.push('(');
                                    break;
                                case 0x29:
                                    if (--numParen === 0) {
                                        this.nextChar();
                                        done = true;
                                    } else {
                                        strBuf.push(')');
                                    }
                                    break;
                                case 0x5C:
                                    ch = this.nextChar();
                                    switch (ch) {
                                        case -1:
                                            warn('Unterminated string');
                                            done = true;
                                            break;
                                        case 0x6E:
                                            strBuf.push('\n');
                                            break;
                                        case 0x72:
                                            strBuf.push('\r');
                                            break;
                                        case 0x74:
                                            strBuf.push('\t');
                                            break;
                                        case 0x62:
                                            strBuf.push('\b');
                                            break;
                                        case 0x66:
                                            strBuf.push('\f');
                                            break;
                                        case 0x5C:
                                        case 0x28:
                                        case 0x29:
                                            strBuf.push(String.fromCharCode(ch));
                                            break;
                                        case 0x30:
                                        case 0x31:
                                        case 0x32:
                                        case 0x33:
                                        case 0x34:
                                        case 0x35:
                                        case 0x36:
                                        case 0x37:
                                            var x = ch & 0x0F;
                                            ch = this.nextChar();
                                            charBuffered = true;
                                            if (ch >= 0x30 && ch <= 0x37) {
                                                x = (x << 3) + (ch & 0x0F);
                                                ch = this.nextChar();
                                                if (ch >= 0x30 && ch <= 0x37) {
                                                    charBuffered = false;
                                                    x = (x << 3) + (ch & 0x0F);
                                                }
                                            }
                                            strBuf.push(String.fromCharCode(x));
                                            break;
                                        case 0x0D:
                                            if (this.peekChar() === 0x0A) {
                                                this.nextChar();
                                            }
                                            break;
                                        case 0x0A:
                                            break;
                                        default:
                                            strBuf.push(String.fromCharCode(ch));
                                            break;
                                    }
                                    break;
                                default:
                                    strBuf.push(String.fromCharCode(ch));
                                    break;
                            }
                            if (done) {
                                break;
                            }
                            if (!charBuffered) {
                                ch = this.nextChar();
                            }
                        }
                        return strBuf.join('');
                    },
                    getName: function Lexer_getName() {
                        var ch, previousCh;
                        var strBuf = this.strBuf;
                        strBuf.length = 0;
                        while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
                            if (ch === 0x23) {
                                ch = this.nextChar();
                                if (specialChars[ch]) {
                                    warn('Lexer_getName: ' + 'NUMBER SIGN (#) should be followed by a hexadecimal number.');
                                    strBuf.push('#');
                                    break;
                                }
                                var x = toHexDigit(ch);
                                if (x !== -1) {
                                    previousCh = ch;
                                    ch = this.nextChar();
                                    var x2 = toHexDigit(ch);
                                    if (x2 === -1) {
                                        warn('Lexer_getName: Illegal digit (' +
                                            String.fromCharCode(ch) + ') in hexadecimal number.');
                                        strBuf.push('#', String.fromCharCode(previousCh));
                                        if (specialChars[ch]) {
                                            break;
                                        }
                                        strBuf.push(String.fromCharCode(ch));
                                        continue;
                                    }
                                    strBuf.push(String.fromCharCode((x << 4) | x2));
                                } else {
                                    strBuf.push('#', String.fromCharCode(ch));
                                }
                            } else {
                                strBuf.push(String.fromCharCode(ch));
                            }
                        }
                        if (strBuf.length > 127) {
                            warn('name token is longer than allowed by the spec: ' + strBuf.length);
                        }
                        return Name.get(strBuf.join(''));
                    },
                    getHexString: function Lexer_getHexString() {
                        var strBuf = this.strBuf;
                        strBuf.length = 0;
                        var ch = this.currentChar;
                        var isFirstHex = true;
                        var firstDigit;
                        var secondDigit;
                        while (true) {
                            if (ch < 0) {
                                warn('Unterminated hex string');
                                break;
                            } else if (ch === 0x3E) {
                                this.nextChar();
                                break;
                            } else if (specialChars[ch] === 1) {
                                ch = this.nextChar();
                                continue;
                            } else {
                                if (isFirstHex) {
                                    firstDigit = toHexDigit(ch);
                                    if (firstDigit === -1) {
                                        warn('Ignoring invalid character "' + ch + '" in hex string');
                                        ch = this.nextChar();
                                        continue;
                                    }
                                } else {
                                    secondDigit = toHexDigit(ch);
                                    if (secondDigit === -1) {
                                        warn('Ignoring invalid character "' + ch + '" in hex string');
                                        ch = this.nextChar();
                                        continue;
                                    }
                                    strBuf.push(String.fromCharCode((firstDigit << 4) | secondDigit));
                                }
                                isFirstHex = !isFirstHex;
                                ch = this.nextChar();
                            }
                        }
                        return strBuf.join('');
                    },
                    getObj: function Lexer_getObj() {
                        var comment = false;
                        var ch = this.currentChar;
                        while (true) {
                            if (ch < 0) {
                                return EOF;
                            }
                            if (comment) {
                                if (ch === 0x0A || ch === 0x0D) {
                                    comment = false;
                                }
                            } else if (ch === 0x25) {
                                comment = true;
                            } else if (specialChars[ch] !== 1) {
                                break;
                            }
                            ch = this.nextChar();
                        }
                        switch (ch | 0) {
                            case 0x30:
                            case 0x31:
                            case 0x32:
                            case 0x33:
                            case 0x34:
                            case 0x35:
                            case 0x36:
                            case 0x37:
                            case 0x38:
                            case 0x39:
                            case 0x2B:
                            case 0x2D:
                            case 0x2E:
                                return this.getNumber();
                            case 0x28:
                                return this.getString();
                            case 0x2F:
                                return this.getName();
                            case 0x5B:
                                this.nextChar();
                                return Cmd.get('[');
                            case 0x5D:
                                this.nextChar();
                                return Cmd.get(']');
                            case 0x3C:
                                ch = this.nextChar();
                                if (ch === 0x3C) {
                                    this.nextChar();
                                    return Cmd.get('<<');
                                }
                                return this.getHexString();
                            case 0x3E:
                                ch = this.nextChar();
                                if (ch === 0x3E) {
                                    this.nextChar();
                                    return Cmd.get('>>');
                                }
                                return Cmd.get('>');
                            case 0x7B:
                                this.nextChar();
                                return Cmd.get('{');
                            case 0x7D:
                                this.nextChar();
                                return Cmd.get('}');
                            case 0x29:
                                error('Illegal character: ' + ch);
                                break;
                        }
                        var str = String.fromCharCode(ch);
                        var knownCommands = this.knownCommands;
                        var knownCommandFound = knownCommands && knownCommands[str] !== undefined;
                        while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
                            var possibleCommand = str + String.fromCharCode(ch);
                            if (knownCommandFound && knownCommands[possibleCommand] === undefined) {
                                break;
                            }
                            if (str.length === 128) {
                                error('Command token too long: ' + str.length);
                            }
                            str = possibleCommand;
                            knownCommandFound = knownCommands && knownCommands[str] !== undefined;
                        }
                        if (str === 'true') {
                            return true;
                        }
                        if (str === 'false') {
                            return false;
                        }
                        if (str === 'null') {
                            return null;
                        }
                        return Cmd.get(str);
                    },
                    skipToNextLine: function Lexer_skipToNextLine() {
                        var ch = this.currentChar;
                        while (ch >= 0) {
                            if (ch === 0x0D) {
                                ch = this.nextChar();
                                if (ch === 0x0A) {
                                    this.nextChar();
                                }
                                break;
                            } else if (ch === 0x0A) {
                                this.nextChar();
                                break;
                            }
                            ch = this.nextChar();
                        }
                    }
                };
                return Lexer;
            })();
            var Linearization = {
                create: function LinearizationCreate(stream) {
                    function getInt(name, allowZeroValue) {
                        var obj = linDict.get(name);
                        if (isInt(obj) && (allowZeroValue ? obj >= 0 : obj > 0)) {
                            return obj;
                        }
                        throw new Error('The "' + name + '" parameter in the linearization ' + 'dictionary is invalid.');
                    }

                    function getHints() {
                        var hints = linDict.get('H'),
                            hintsLength, item;
                        if (isArray(hints) && ((hintsLength = hints.length) === 2 || hintsLength === 4)) {
                            for (var index = 0; index < hintsLength; index++) {
                                if (!(isInt(item = hints[index]) && item > 0)) {
                                    throw new Error('Hint (' + index + ') in the linearization dictionary is invalid.');
                                }
                            }
                            return hints;
                        }
                        throw new Error('Hint array in the linearization dictionary is invalid.');
                    }
                    var parser = new Parser(new Lexer(stream), false, null);
                    var obj1 = parser.getObj();
                    var obj2 = parser.getObj();
                    var obj3 = parser.getObj();
                    var linDict = parser.getObj();
                    var obj, length;
                    if (!(isInt(obj1) && isInt(obj2) && isCmd(obj3, 'obj') && isDict(linDict) && isNum(obj = linDict.get('Linearized')) && obj > 0)) {
                        return null;
                    } else if ((length = getInt('L')) !== stream.length) {
                        throw new Error('The "L" parameter in the linearization dictionary ' + 'does not equal the stream length.');
                    }
                    return {
                        length: length,
                        hints: getHints(),
                        objectNumberFirst: getInt('O'),
                        endFirst: getInt('E'),
                        numPages: getInt('N'),
                        mainXRefEntriesOffset: getInt('T'),
                        pageFirst: (linDict.has('P') ? getInt('P', true) : 0)
                    };
                }
            };
            exports.EOF = EOF;
            exports.Lexer = Lexer;
            exports.Linearization = Linearization;
            exports.Parser = Parser;
            exports.isEOF = isEOF;
            coreStream._setCoreParser(exports);
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsCoreCMap = {}), root.pdfjsSharedUtil, root.pdfjsCorePrimitives, root.pdfjsCoreStream, root.pdfjsCoreParser);
            }
        }(this, function(exports, sharedUtil, corePrimitives, coreStream, coreParser) {
            var Util = sharedUtil.Util;
            var assert = sharedUtil.assert;
            var error = sharedUtil.error;
            var isInt = sharedUtil.isInt;
            var isString = sharedUtil.isString;
            var warn = sharedUtil.warn;
            var isName = corePrimitives.isName;
            var isCmd = corePrimitives.isCmd;
            var isStream = corePrimitives.isStream;
            var StringStream = coreStream.StringStream;
            var Lexer = coreParser.Lexer;
            var isEOF = coreParser.isEOF;
            var BUILT_IN_CMAPS = ['Adobe-GB1-UCS2', 'Adobe-CNS1-UCS2', 'Adobe-Japan1-UCS2', 'Adobe-Korea1-UCS2', '78-EUC-H', '78-EUC-V', '78-H', '78-RKSJ-H', '78-RKSJ-V', '78-V', '78ms-RKSJ-H', '78ms-RKSJ-V', '83pv-RKSJ-H', '90ms-RKSJ-H', '90ms-RKSJ-V', '90msp-RKSJ-H', '90msp-RKSJ-V', '90pv-RKSJ-H', '90pv-RKSJ-V', 'Add-H', 'Add-RKSJ-H', 'Add-RKSJ-V', 'Add-V', 'Adobe-CNS1-0', 'Adobe-CNS1-1', 'Adobe-CNS1-2', 'Adobe-CNS1-3', 'Adobe-CNS1-4', 'Adobe-CNS1-5', 'Adobe-CNS1-6', 'Adobe-GB1-0', 'Adobe-GB1-1', 'Adobe-GB1-2', 'Adobe-GB1-3', 'Adobe-GB1-4', 'Adobe-GB1-5', 'Adobe-Japan1-0', 'Adobe-Japan1-1', 'Adobe-Japan1-2', 'Adobe-Japan1-3', 'Adobe-Japan1-4', 'Adobe-Japan1-5', 'Adobe-Japan1-6', 'Adobe-Korea1-0', 'Adobe-Korea1-1', 'Adobe-Korea1-2', 'B5-H', 'B5-V', 'B5pc-H', 'B5pc-V', 'CNS-EUC-H', 'CNS-EUC-V', 'CNS1-H', 'CNS1-V', 'CNS2-H', 'CNS2-V', 'ETHK-B5-H', 'ETHK-B5-V', 'ETen-B5-H', 'ETen-B5-V', 'ETenms-B5-H', 'ETenms-B5-V', 'EUC-H', 'EUC-V', 'Ext-H', 'Ext-RKSJ-H', 'Ext-RKSJ-V', 'Ext-V', 'GB-EUC-H', 'GB-EUC-V', 'GB-H', 'GB-V', 'GBK-EUC-H', 'GBK-EUC-V', 'GBK2K-H', 'GBK2K-V', 'GBKp-EUC-H', 'GBKp-EUC-V', 'GBT-EUC-H', 'GBT-EUC-V', 'GBT-H', 'GBT-V', 'GBTpc-EUC-H', 'GBTpc-EUC-V', 'GBpc-EUC-H', 'GBpc-EUC-V', 'H', 'HKdla-B5-H', 'HKdla-B5-V', 'HKdlb-B5-H', 'HKdlb-B5-V', 'HKgccs-B5-H', 'HKgccs-B5-V', 'HKm314-B5-H', 'HKm314-B5-V', 'HKm471-B5-H', 'HKm471-B5-V', 'HKscs-B5-H', 'HKscs-B5-V', 'Hankaku', 'Hiragana', 'KSC-EUC-H', 'KSC-EUC-V', 'KSC-H', 'KSC-Johab-H', 'KSC-Johab-V', 'KSC-V', 'KSCms-UHC-H', 'KSCms-UHC-HW-H', 'KSCms-UHC-HW-V', 'KSCms-UHC-V', 'KSCpc-EUC-H', 'KSCpc-EUC-V', 'Katakana', 'NWP-H', 'NWP-V', 'RKSJ-H', 'RKSJ-V', 'Roman', 'UniCNS-UCS2-H', 'UniCNS-UCS2-V', 'UniCNS-UTF16-H', 'UniCNS-UTF16-V', 'UniCNS-UTF32-H', 'UniCNS-UTF32-V', 'UniCNS-UTF8-H', 'UniCNS-UTF8-V', 'UniGB-UCS2-H', 'UniGB-UCS2-V', 'UniGB-UTF16-H', 'UniGB-UTF16-V', 'UniGB-UTF32-H', 'UniGB-UTF32-V', 'UniGB-UTF8-H', 'UniGB-UTF8-V', 'UniJIS-UCS2-H', 'UniJIS-UCS2-HW-H', 'UniJIS-UCS2-HW-V', 'UniJIS-UCS2-V', 'UniJIS-UTF16-H', 'UniJIS-UTF16-V', 'UniJIS-UTF32-H', 'UniJIS-UTF32-V', 'UniJIS-UTF8-H', 'UniJIS-UTF8-V', 'UniJIS2004-UTF16-H', 'UniJIS2004-UTF16-V', 'UniJIS2004-UTF32-H', 'UniJIS2004-UTF32-V', 'UniJIS2004-UTF8-H', 'UniJIS2004-UTF8-V', 'UniJISPro-UCS2-HW-V', 'UniJISPro-UCS2-V', 'UniJISPro-UTF8-V', 'UniJISX0213-UTF32-H', 'UniJISX0213-UTF32-V', 'UniJISX02132004-UTF32-H', 'UniJISX02132004-UTF32-V', 'UniKS-UCS2-H', 'UniKS-UCS2-V', 'UniKS-UTF16-H', 'UniKS-UTF16-V', 'UniKS-UTF32-H', 'UniKS-UTF32-V', 'UniKS-UTF8-H', 'UniKS-UTF8-V', 'V', 'WP-Symbol'];
            var CMap = (function CMapClosure() {
                function CMap(builtInCMap) {
                    this.codespaceRanges = [
                        [],
                        [],
                        [],
                        []
                    ];
                    this.numCodespaceRanges = 0;
                    this._map = [];
                    this.name = '';
                    this.vertical = false;
                    this.useCMap = null;
                    this.builtInCMap = builtInCMap;
                }
                CMap.prototype = {
                    addCodespaceRange: function(n, low, high) {
                        this.codespaceRanges[n - 1].push(low, high);
                        this.numCodespaceRanges++;
                    },
                    mapCidRange: function(low, high, dstLow) {
                        while (low <= high) {
                            this._map[low++] = dstLow++;
                        }
                    },
                    mapBfRange: function(low, high, dstLow) {
                        var lastByte = dstLow.length - 1;
                        while (low <= high) {
                            this._map[low++] = dstLow;
                            dstLow = dstLow.substr(0, lastByte) +
                                String.fromCharCode(dstLow.charCodeAt(lastByte) + 1);
                        }
                    },
                    mapBfRangeToArray: function(low, high, array) {
                        var i = 0,
                            ii = array.length;
                        while (low <= high && i < ii) {
                            this._map[low] = array[i++];
                            ++low;
                        }
                    },
                    mapOne: function(src, dst) {
                        this._map[src] = dst;
                    },
                    lookup: function(code) {
                        return this._map[code];
                    },
                    contains: function(code) {
                        return this._map[code] !== undefined;
                    },
                    forEach: function(callback) {
                        var map = this._map;
                        var length = map.length;
                        var i;
                        if (length <= 0x10000) {
                            for (i = 0; i < length; i++) {
                                if (map[i] !== undefined) {
                                    callback(i, map[i]);
                                }
                            }
                        } else {
                            for (i in this._map) {
                                callback(i, map[i]);
                            }
                        }
                    },
                    charCodeOf: function(value) {
                        return this._map.indexOf(value);
                    },
                    getMap: function() {
                        return this._map;
                    },
                    readCharCode: function(str, offset, out) {
                        var c = 0;
                        var codespaceRanges = this.codespaceRanges;
                        var codespaceRangesLen = this.codespaceRanges.length;
                        for (var n = 0; n < codespaceRangesLen; n++) {
                            c = ((c << 8) | str.charCodeAt(offset + n)) >>> 0;
                            var codespaceRange = codespaceRanges[n];
                            for (var k = 0, kk = codespaceRange.length; k < kk;) {
                                var low = codespaceRange[k++];
                                var high = codespaceRange[k++];
                                if (c >= low && c <= high) {
                                    out.charcode = c;
                                    out.length = n + 1;
                                    return;
                                }
                            }
                        }
                        out.charcode = 0;
                        out.length = 1;
                    },
                    get length() {
                        return this._map.length;
                    },
                    get isIdentityCMap() {
                        if (!(this.name === 'Identity-H' || this.name === 'Identity-V')) {
                            return false;
                        }
                        if (this._map.length !== 0x10000) {
                            return false;
                        }
                        for (var i = 0; i < 0x10000; i++) {
                            if (this._map[i] !== i) {
                                return false;
                            }
                        }
                        return true;
                    }
                };
                return CMap;
            })();
            var IdentityCMap = (function IdentityCMapClosure() {
                function IdentityCMap(vertical, n) {
                    CMap.call(this);
                    this.vertical = vertical;
                    this.addCodespaceRange(n, 0, 0xffff);
                }
                Util.inherit(IdentityCMap, CMap, {});
                IdentityCMap.prototype = {
                    addCodespaceRange: CMap.prototype.addCodespaceRange,
                    mapCidRange: function(low, high, dstLow) {
                        error('should not call mapCidRange');
                    },
                    mapBfRange: function(low, high, dstLow) {
                        error('should not call mapBfRange');
                    },
                    mapBfRangeToArray: function(low, high, array) {
                        error('should not call mapBfRangeToArray');
                    },
                    mapOne: function(src, dst) {
                        error('should not call mapCidOne');
                    },
                    lookup: function(code) {
                        return (isInt(code) && code <= 0xffff) ? code : undefined;
                    },
                    contains: function(code) {
                        return isInt(code) && code <= 0xffff;
                    },
                    forEach: function(callback) {
                        for (var i = 0; i <= 0xffff; i++) {
                            callback(i, i);
                        }
                    },
                    charCodeOf: function(value) {
                        return (isInt(value) && value <= 0xffff) ? value : -1;
                    },
                    getMap: function() {
                        var map = new Array(0x10000);
                        for (var i = 0; i <= 0xffff; i++) {
                            map[i] = i;
                        }
                        return map;
                    },
                    readCharCode: CMap.prototype.readCharCode,
                    get length() {
                        return 0x10000;
                    },
                    get isIdentityCMap() {
                        error('should not access .isIdentityCMap');
                    }
                };
                return IdentityCMap;
            })();
            var BinaryCMapReader = (function BinaryCMapReaderClosure() {
                function fetchBinaryData(url) {
                    var nonBinaryRequest = PDFJS.disableWorker;
                    var request = new XMLHttpRequest();
                    request.open('GET', url, false);
                    if (!nonBinaryRequest) {
                        try {
                            request.responseType = 'arraybuffer';
                            nonBinaryRequest = request.responseType !== 'arraybuffer';
                        } catch (e) {
                            nonBinaryRequest = true;
                        }
                    }
                    if (nonBinaryRequest && request.overrideMimeType) {
                        request.overrideMimeType('text/plain; charset=x-user-defined');
                    }
                    request.send(null);
                    if (nonBinaryRequest ? !request.responseText : !request.response) {
                        error('Unable to get binary cMap at: ' + url);
                    }
                    if (nonBinaryRequest) {
                        var data = Array.prototype.map.call(request.responseText, function(ch) {
                            return ch.charCodeAt(0) & 255;
                        });
                        return new Uint8Array(data);
                    }
                    return new Uint8Array(request.response);
                }

                function hexToInt(a, size) {
                    var n = 0;
                    for (var i = 0; i <= size; i++) {
                        n = (n << 8) | a[i];
                    }
                    return n >>> 0;
                }

                function hexToStr(a, size) {
                    if (size === 1) {
                        return String.fromCharCode(a[0], a[1]);
                    }
                    if (size === 3) {
                        return String.fromCharCode(a[0], a[1], a[2], a[3]);
                    }
                    return String.fromCharCode.apply(null, a.subarray(0, size + 1));
                }

                function addHex(a, b, size) {
                    var c = 0;
                    for (var i = size; i >= 0; i--) {
                        c += a[i] + b[i];
                        a[i] = c & 255;
                        c >>= 8;
                    }
                }

                function incHex(a, size) {
                    var c = 1;
                    for (var i = size; i >= 0 && c > 0; i--) {
                        c += a[i];
                        a[i] = c & 255;
                        c >>= 8;
                    }
                }
                var MAX_NUM_SIZE = 16;
                var MAX_ENCODED_NUM_SIZE = 19;

                function BinaryCMapStream(data) {
                    this.buffer = data;
                    this.pos = 0;
                    this.end = data.length;
                    this.tmpBuf = new Uint8Array(MAX_ENCODED_NUM_SIZE);
                }
                BinaryCMapStream.prototype = {
                    readByte: function() {
                        if (this.pos >= this.end) {
                            return -1;
                        }
                        return this.buffer[this.pos++];
                    },
                    readNumber: function() {
                        var n = 0;
                        var last;
                        do {
                            var b = this.readByte();
                            if (b < 0) {
                                error('unexpected EOF in bcmap');
                            }
                            last = !(b & 0x80);
                            n = (n << 7) | (b & 0x7F);
                        } while (!last);
                        return n;
                    },
                    readSigned: function() {
                        var n = this.readNumber();
                        return (n & 1) ? ~(n >>> 1) : n >>> 1;
                    },
                    readHex: function(num, size) {
                        num.set(this.buffer.subarray(this.pos, this.pos + size + 1));
                        this.pos += size + 1;
                    },
                    readHexNumber: function(num, size) {
                        var last;
                        var stack = this.tmpBuf,
                            sp = 0;
                        do {
                            var b = this.readByte();
                            if (b < 0) {
                                error('unexpected EOF in bcmap');
                            }
                            last = !(b & 0x80);
                            stack[sp++] = b & 0x7F;
                        } while (!last);
                        var i = size,
                            buffer = 0,
                            bufferSize = 0;
                        while (i >= 0) {
                            while (bufferSize < 8 && stack.length > 0) {
                                buffer = (stack[--sp] << bufferSize) | buffer;
                                bufferSize += 7;
                            }
                            num[i] = buffer & 255;
                            i--;
                            buffer >>= 8;
                            bufferSize -= 8;
                        }
                    },
                    readHexSigned: function(num, size) {
                        this.readHexNumber(num, size);
                        var sign = num[size] & 1 ? 255 : 0;
                        var c = 0;
                        for (var i = 0; i <= size; i++) {
                            c = ((c & 1) << 8) | num[i];
                            num[i] = (c >> 1) ^ sign;
                        }
                    },
                    readString: function() {
                        var len = this.readNumber();
                        var s = '';
                        for (var i = 0; i < len; i++) {
                            s += String.fromCharCode(this.readNumber());
                        }
                        return s;
                    }
                };

                function processBinaryCMap(url, cMap, extend) {
                    var data = fetchBinaryData(url);
                    var stream = new BinaryCMapStream(data);
                    var header = stream.readByte();
                    cMap.vertical = !!(header & 1);
                    var useCMap = null;
                    var start = new Uint8Array(MAX_NUM_SIZE);
                    var end = new Uint8Array(MAX_NUM_SIZE);
                    var char = new Uint8Array(MAX_NUM_SIZE);
                    var charCode = new Uint8Array(MAX_NUM_SIZE);
                    var tmp = new Uint8Array(MAX_NUM_SIZE);
                    var code;
                    var b;
                    while ((b = stream.readByte()) >= 0) {
                        var type = b >> 5;
                        if (type === 7) {
                            switch (b & 0x1F) {
                                case 0:
                                    stream.readString();
                                    break;
                                case 1:
                                    useCMap = stream.readString();
                                    break;
                            }
                            continue;
                        }
                        var sequence = !!(b & 0x10);
                        var dataSize = b & 15;
                        assert(dataSize + 1 <= MAX_NUM_SIZE);
                        var ucs2DataSize = 1;
                        var subitemsCount = stream.readNumber();
                        var i;
                        switch (type) {
                            case 0:
                                stream.readHex(start, dataSize);
                                stream.readHexNumber(end, dataSize);
                                addHex(end, start, dataSize);
                                cMap.addCodespaceRange(dataSize + 1, hexToInt(start, dataSize), hexToInt(end, dataSize));
                                for (i = 1; i < subitemsCount; i++) {
                                    incHex(end, dataSize);
                                    stream.readHexNumber(start, dataSize);
                                    addHex(start, end, dataSize);
                                    stream.readHexNumber(end, dataSize);
                                    addHex(end, start, dataSize);
                                    cMap.addCodespaceRange(dataSize + 1, hexToInt(start, dataSize), hexToInt(end, dataSize));
                                }
                                break;
                            case 1:
                                stream.readHex(start, dataSize);
                                stream.readHexNumber(end, dataSize);
                                addHex(end, start, dataSize);
                                code = stream.readNumber();
                                for (i = 1; i < subitemsCount; i++) {
                                    incHex(end, dataSize);
                                    stream.readHexNumber(start, dataSize);
                                    addHex(start, end, dataSize);
                                    stream.readHexNumber(end, dataSize);
                                    addHex(end, start, dataSize);
                                    code = stream.readNumber();
                                }
                                break;
                            case 2:
                                stream.readHex(char, dataSize);
                                code = stream.readNumber();
                                cMap.mapOne(hexToInt(char, dataSize), code);
                                for (i = 1; i < subitemsCount; i++) {
                                    incHex(char, dataSize);
                                    if (!sequence) {
                                        stream.readHexNumber(tmp, dataSize);
                                        addHex(char, tmp, dataSize);
                                    }
                                    code = stream.readSigned() + (code + 1);
                                    cMap.mapOne(hexToInt(char, dataSize), code);
                                }
                                break;
                            case 3:
                                stream.readHex(start, dataSize);
                                stream.readHexNumber(end, dataSize);
                                addHex(end, start, dataSize);
                                code = stream.readNumber();
                                cMap.mapCidRange(hexToInt(start, dataSize), hexToInt(end, dataSize), code);
                                for (i = 1; i < subitemsCount; i++) {
                                    incHex(end, dataSize);
                                    if (!sequence) {
                                        stream.readHexNumber(start, dataSize);
                                        addHex(start, end, dataSize);
                                    } else {
                                        start.set(end);
                                    }
                                    stream.readHexNumber(end, dataSize);
                                    addHex(end, start, dataSize);
                                    code = stream.readNumber();
                                    cMap.mapCidRange(hexToInt(start, dataSize), hexToInt(end, dataSize), code);
                                }
                                break;
                            case 4:
                                stream.readHex(char, ucs2DataSize);
                                stream.readHex(charCode, dataSize);
                                cMap.mapOne(hexToInt(char, ucs2DataSize), hexToStr(charCode, dataSize));
                                for (i = 1; i < subitemsCount; i++) {
                                    incHex(char, ucs2DataSize);
                                    if (!sequence) {
                                        stream.readHexNumber(tmp, ucs2DataSize);
                                        addHex(char, tmp, ucs2DataSize);
                                    }
                                    incHex(charCode, dataSize);
                                    stream.readHexSigned(tmp, dataSize);
                                    addHex(charCode, tmp, dataSize);
                                    cMap.mapOne(hexToInt(char, ucs2DataSize), hexToStr(charCode, dataSize));
                                }
                                break;
                            case 5:
                                stream.readHex(start, ucs2DataSize);
                                stream.readHexNumber(end, ucs2DataSize);
                                addHex(end, start, ucs2DataSize);
                                stream.readHex(charCode, dataSize);
                                cMap.mapBfRange(hexToInt(start, ucs2DataSize), hexToInt(end, ucs2DataSize), hexToStr(charCode, dataSize));
                                for (i = 1; i < subitemsCount; i++) {
                                    incHex(end, ucs2DataSize);
                                    if (!sequence) {
                                        stream.readHexNumber(start, ucs2DataSize);
                                        addHex(start, end, ucs2DataSize);
                                    } else {
                                        start.set(end);
                                    }
                                    stream.readHexNumber(end, ucs2DataSize);
                                    addHex(end, start, ucs2DataSize);
                                    stream.readHex(charCode, dataSize);
                                    cMap.mapBfRange(hexToInt(start, ucs2DataSize), hexToInt(end, ucs2DataSize), hexToStr(charCode, dataSize));
                                }
                                break;
                            default:
                                error('Unknown type: ' + type);
                                break;
                        }
                    }
                    if (useCMap) {
                        extend(useCMap);
                    }
                    return cMap;
                }

                function BinaryCMapReader() {}
                BinaryCMapReader.prototype = {
                    read: processBinaryCMap
                };
                return BinaryCMapReader;
            })();
            var CMapFactory = (function CMapFactoryClosure() {
                function strToInt(str) {
                    var a = 0;
                    for (var i = 0; i < str.length; i++) {
                        a = (a << 8) | str.charCodeAt(i);
                    }
                    return a >>> 0;
                }

                function expectString(obj) {
                    if (!isString(obj)) {
                        error('Malformed CMap: expected string.');
                    }
                }

                function expectInt(obj) {
                    if (!isInt(obj)) {
                        error('Malformed CMap: expected int.');
                    }
                }

                function parseBfChar(cMap, lexer) {
                    while (true) {
                        var obj = lexer.getObj();
                        if (isEOF(obj)) {
                            break;
                        }
                        if (isCmd(obj, 'endbfchar')) {
                            return;
                        }
                        expectString(obj);
                        var src = strToInt(obj);
                        obj = lexer.getObj();
                        expectString(obj);
                        var dst = obj;
                        cMap.mapOne(src, dst);
                    }
                }

                function parseBfRange(cMap, lexer) {
                    while (true) {
                        var obj = lexer.getObj();
                        if (isEOF(obj)) {
                            break;
                        }
                        if (isCmd(obj, 'endbfrange')) {
                            return;
                        }
                        expectString(obj);
                        var low = strToInt(obj);
                        obj = lexer.getObj();
                        expectString(obj);
                        var high = strToInt(obj);
                        obj = lexer.getObj();
                        if (isInt(obj) || isString(obj)) {
                            var dstLow = isInt(obj) ? String.fromCharCode(obj) : obj;
                            cMap.mapBfRange(low, high, dstLow);
                        } else if (isCmd(obj, '[')) {
                            obj = lexer.getObj();
                            var array = [];
                            while (!isCmd(obj, ']') && !isEOF(obj)) {
                                array.push(obj);
                                obj = lexer.getObj();
                            }
                            cMap.mapBfRangeToArray(low, high, array);
                        } else {
                            break;
                        }
                    }
                    error('Invalid bf range.');
                }

                function parseCidChar(cMap, lexer) {
                    while (true) {
                        var obj = lexer.getObj();
                        if (isEOF(obj)) {
                            break;
                        }
                        if (isCmd(obj, 'endcidchar')) {
                            return;
                        }
                        expectString(obj);
                        var src = strToInt(obj);
                        obj = lexer.getObj();
                        expectInt(obj);
                        var dst = obj;
                        cMap.mapOne(src, dst);
                    }
                }

                function parseCidRange(cMap, lexer) {
                    while (true) {
                        var obj = lexer.getObj();
                        if (isEOF(obj)) {
                            break;
                        }
                        if (isCmd(obj, 'endcidrange')) {
                            return;
                        }
                        expectString(obj);
                        var low = strToInt(obj);
                        obj = lexer.getObj();
                        expectString(obj);
                        var high = strToInt(obj);
                        obj = lexer.getObj();
                        expectInt(obj);
                        var dstLow = obj;
                        cMap.mapCidRange(low, high, dstLow);
                    }
                }

                function parseCodespaceRange(cMap, lexer) {
                    while (true) {
                        var obj = lexer.getObj();
                        if (isEOF(obj)) {
                            break;
                        }
                        if (isCmd(obj, 'endcodespacerange')) {
                            return;
                        }
                        if (!isString(obj)) {
                            break;
                        }
                        var low = strToInt(obj);
                        obj = lexer.getObj();
                        if (!isString(obj)) {
                            break;
                        }
                        var high = strToInt(obj);
                        cMap.addCodespaceRange(obj.length, low, high);
                    }
                    error('Invalid codespace range.');
                }

                function parseWMode(cMap, lexer) {
                    var obj = lexer.getObj();
                    if (isInt(obj)) {
                        cMap.vertical = !!obj;
                    }
                }

                function parseCMapName(cMap, lexer) {
                    var obj = lexer.getObj();
                    if (isName(obj) && isString(obj.name)) {
                        cMap.name = obj.name;
                    }
                }

                function parseCMap(cMap, lexer, builtInCMapParams, useCMap) {
                    var previous;
                    var embededUseCMap;
                    objLoop: while (true) {
                        var obj = lexer.getObj();
                        if (isEOF(obj)) {
                            break;
                        } else if (isName(obj)) {
                            if (obj.name === 'WMode') {
                                parseWMode(cMap, lexer);
                            } else if (obj.name === 'CMapName') {
                                parseCMapName(cMap, lexer);
                            }
                            previous = obj;
                        } else if (isCmd(obj)) {
                            switch (obj.cmd) {
                                case 'endcmap':
                                    break objLoop;
                                case 'usecmap':
                                    if (isName(previous)) {
                                        embededUseCMap = previous.name;
                                    }
                                    break;
                                case 'begincodespacerange':
                                    parseCodespaceRange(cMap, lexer);
                                    break;
                                case 'beginbfchar':
                                    parseBfChar(cMap, lexer);
                                    break;
                                case 'begincidchar':
                                    parseCidChar(cMap, lexer);
                                    break;
                                case 'beginbfrange':
                                    parseBfRange(cMap, lexer);
                                    break;
                                case 'begincidrange':
                                    parseCidRange(cMap, lexer);
                                    break;
                            }
                        }
                    }
                    if (!useCMap && embededUseCMap) {
                        useCMap = embededUseCMap;
                    }
                    if (useCMap) {
                        extendCMap(cMap, builtInCMapParams, useCMap);
                    }
                }

                function extendCMap(cMap, builtInCMapParams, useCMap) {
                    cMap.useCMap = createBuiltInCMap(useCMap, builtInCMapParams);
                    if (cMap.numCodespaceRanges === 0) {
                        var useCodespaceRanges = cMap.useCMap.codespaceRanges;
                        for (var i = 0; i < useCodespaceRanges.length; i++) {
                            cMap.codespaceRanges[i] = useCodespaceRanges[i].slice();
                        }
                        cMap.numCodespaceRanges = cMap.useCMap.numCodespaceRanges;
                    }
                    cMap.useCMap.forEach(function(key, value) {
                        if (!cMap.contains(key)) {
                            cMap.mapOne(key, cMap.useCMap.lookup(key));
                        }
                    });
                }

                function parseBinaryCMap(name, builtInCMapParams) {
                    var url = builtInCMapParams.url + name + '.bcmap';
                    var cMap = new CMap(true);
                    new BinaryCMapReader().read(url, cMap, function(useCMap) {
                        extendCMap(cMap, builtInCMapParams, useCMap);
                    });
                    return cMap;
                }

                function createBuiltInCMap(name, builtInCMapParams) {
                    if (name === 'Identity-H') {
                        return new IdentityCMap(false, 2);
                    } else if (name === 'Identity-V') {
                        return new IdentityCMap(true, 2);
                    }
                    if (BUILT_IN_CMAPS.indexOf(name) === -1) {
                        error('Unknown cMap name: ' + name);
                    }
                    assert(builtInCMapParams, 'built-in cMap parameters are not provided');
                    if (builtInCMapParams.packed) {
                        return parseBinaryCMap(name, builtInCMapParams);
                    }
                    var request = new XMLHttpRequest();
                    var url = builtInCMapParams.url + name;
                    request.open('GET', url, false);
                    request.send(null);
                    if (!request.responseText) {
                        error('Unable to get cMap at: ' + url);
                    }
                    var cMap = new CMap(true);
                    var lexer = new Lexer(new StringStream(request.responseText));
                    parseCMap(cMap, lexer, builtInCMapParams, null);
                    return cMap;
                }
                return {
                    create: function(encoding, builtInCMapParams, useCMap) {
                        if (isName(encoding)) {
                            return createBuiltInCMap(encoding.name, builtInCMapParams);
                        } else if (isStream(encoding)) {
                            var cMap = new CMap();
                            var lexer = new Lexer(encoding);
                            try {
                                parseCMap(cMap, lexer, builtInCMapParams, useCMap);
                            } catch (e) {
                                warn('Invalid CMap data. ' + e);
                            }
                            if (cMap.isIdentityCMap) {
                                return createBuiltInCMap(cMap.name, builtInCMapParams);
                            }
                            return cMap;
                        }
                        error('Encoding required.');
                    }
                };
            })();
            exports.CMap = CMap;
            exports.CMapFactory = CMapFactory;
            exports.IdentityCMap = IdentityCMap;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsCoreObj = {}), root.pdfjsSharedUtil, root.pdfjsCorePrimitives, root.pdfjsCoreCrypto, root.pdfjsCoreParser, root.pdfjsCoreChunkedStream);
            }
        }(this, function(exports, sharedUtil, corePrimitives, coreCrypto, coreParser, coreChunkedStream) {
            var InvalidPDFException = sharedUtil.InvalidPDFException;
            var MissingDataException = sharedUtil.MissingDataException;
            var XRefParseException = sharedUtil.XRefParseException;
            var assert = sharedUtil.assert;
            var bytesToString = sharedUtil.bytesToString;
            var createPromiseCapability = sharedUtil.createPromiseCapability;
            var error = sharedUtil.error;
            var info = sharedUtil.info;
            var isArray = sharedUtil.isArray;
            var isInt = sharedUtil.isInt;
            var isString = sharedUtil.isString;
            var shadow = sharedUtil.shadow;
            var stringToPDFString = sharedUtil.stringToPDFString;
            var stringToUTF8String = sharedUtil.stringToUTF8String;
            var warn = sharedUtil.warn;
            var isValidUrl = sharedUtil.isValidUrl;
            var Util = sharedUtil.Util;
            var Ref = corePrimitives.Ref;
            var RefSet = corePrimitives.RefSet;
            var RefSetCache = corePrimitives.RefSetCache;
            var isName = corePrimitives.isName;
            var isCmd = corePrimitives.isCmd;
            var isDict = corePrimitives.isDict;
            var isRef = corePrimitives.isRef;
            var isStream = corePrimitives.isStream;
            var CipherTransformFactory = coreCrypto.CipherTransformFactory;
            var Lexer = coreParser.Lexer;
            var Parser = coreParser.Parser;
            var ChunkedStream = coreChunkedStream.ChunkedStream;
            var Catalog = (function CatalogClosure() {
                function Catalog(pdfManager, xref, pageFactory) {
                    this.pdfManager = pdfManager;
                    this.xref = xref;
                    this.catDict = xref.getCatalogObj();
                    this.fontCache = new RefSetCache();
                    assert(isDict(this.catDict), 'catalog object is not a dictionary');
                    this.pageFactory = pageFactory;
                    this.pagePromises = [];
                }
                Catalog.prototype = {
                    get metadata() {
                        var streamRef = this.catDict.getRaw('Metadata');
                        if (!isRef(streamRef)) {
                            return shadow(this, 'metadata', null);
                        }
                        var encryptMetadata = (!this.xref.encrypt ? false : this.xref.encrypt.encryptMetadata);
                        var stream = this.xref.fetch(streamRef, !encryptMetadata);
                        var metadata;
                        if (stream && isDict(stream.dict)) {
                            var type = stream.dict.get('Type');
                            var subtype = stream.dict.get('Subtype');
                            if (isName(type) && isName(subtype) && type.name === 'Metadata' && subtype.name === 'XML') {
                                try {
                                    metadata = stringToUTF8String(bytesToString(stream.getBytes()));
                                } catch (e) {
                                    info('Skipping invalid metadata.');
                                }
                            }
                        }
                        return shadow(this, 'metadata', metadata);
                    },
                    get toplevelPagesDict() {
                        var pagesObj = this.catDict.get('Pages');
                        assert(isDict(pagesObj), 'invalid top-level pages dictionary');
                        return shadow(this, 'toplevelPagesDict', pagesObj);
                    },
                    get documentOutline() {
                        var obj = null;
                        try {
                            obj = this.readDocumentOutline();
                        } catch (ex) {
                            if (ex instanceof MissingDataException) {
                                throw ex;
                            }
                            warn('Unable to read document outline');
                        }
                        return shadow(this, 'documentOutline', obj);
                    },
                    readDocumentOutline: function Catalog_readDocumentOutline() {
                        var xref = this.xref;
                        var obj = this.catDict.get('Outlines');
                        var root = {
                            items: []
                        };
                        if (isDict(obj)) {
                            obj = obj.getRaw('First');
                            var processed = new RefSet();
                            if (isRef(obj)) {
                                var queue = [{
                                    obj: obj,
                                    parent: root
                                }];
                                processed.put(obj);
                                while (queue.length > 0) {
                                    var i = queue.shift();
                                    var outlineDict = xref.fetchIfRef(i.obj);
                                    if (outlineDict === null) {
                                        continue;
                                    }
                                    if (!outlineDict.has('Title')) {
                                        error('Invalid outline item');
                                    }
                                    var actionDict = outlineDict.get('A'),
                                        dest = null,
                                        url = null;
                                    if (actionDict) {
                                        var destEntry = actionDict.get('D');
                                        if (destEntry) {
                                            dest = destEntry;
                                        } else {
                                            var uriEntry = actionDict.get('URI');
                                            if (isString(uriEntry) && isValidUrl(uriEntry, false)) {
                                                url = uriEntry;
                                            }
                                        }
                                    } else if (outlineDict.has('Dest')) {
                                        dest = outlineDict.getRaw('Dest');
                                        if (isName(dest)) {
                                            dest = dest.name;
                                        }
                                    }
                                    var title = outlineDict.get('Title');
                                    var outlineItem = {
                                        dest: dest,
                                        url: url,
                                        title: stringToPDFString(title),
                                        color: outlineDict.get('C') || [0, 0, 0],
                                        count: outlineDict.get('Count'),
                                        bold: !!(outlineDict.get('F') & 2),
                                        italic: !!(outlineDict.get('F') & 1),
                                        items: []
                                    };
                                    i.parent.items.push(outlineItem);
                                    obj = outlineDict.getRaw('First');
                                    if (isRef(obj) && !processed.has(obj)) {
                                        queue.push({
                                            obj: obj,
                                            parent: outlineItem
                                        });
                                        processed.put(obj);
                                    }
                                    obj = outlineDict.getRaw('Next');
                                    if (isRef(obj) && !processed.has(obj)) {
                                        queue.push({
                                            obj: obj,
                                            parent: i.parent
                                        });
                                        processed.put(obj);
                                    }
                                }
                            }
                        }
                        return (root.items.length > 0 ? root.items : null);
                    },
                    get numPages() {
                        var obj = this.toplevelPagesDict.get('Count');
                        assert(isInt(obj), 'page count in top level pages object is not an integer');
                        return shadow(this, 'num', obj);
                    },
                    get destinations() {
                        function fetchDestination(dest) {
                            return isDict(dest) ? dest.get('D') : dest;
                        }
                        var xref = this.xref;
                        var dests = {},
                            nameTreeRef, nameDictionaryRef;
                        var obj = this.catDict.get('Names');
                        if (obj && obj.has('Dests')) {
                            nameTreeRef = obj.getRaw('Dests');
                        } else if (this.catDict.has('Dests')) {
                            nameDictionaryRef = this.catDict.get('Dests');
                        }
                        if (nameDictionaryRef) {
                            obj = nameDictionaryRef;
                            obj.forEach(function catalogForEach(key, value) {
                                if (!value) {
                                    return;
                                }
                                dests[key] = fetchDestination(value);
                            });
                        }
                        if (nameTreeRef) {
                            var nameTree = new NameTree(nameTreeRef, xref);
                            var names = nameTree.getAll();
                            for (var name in names) {
                                if (!names.hasOwnProperty(name)) {
                                    continue;
                                }
                                dests[name] = fetchDestination(names[name]);
                            }
                        }
                        return shadow(this, 'destinations', dests);
                    },
                    getDestination: function Catalog_getDestination(destinationId) {
                        function fetchDestination(dest) {
                            return isDict(dest) ? dest.get('D') : dest;
                        }
                        var xref = this.xref;
                        var dest = null,
                            nameTreeRef, nameDictionaryRef;
                        var obj = this.catDict.get('Names');
                        if (obj && obj.has('Dests')) {
                            nameTreeRef = obj.getRaw('Dests');
                        } else if (this.catDict.has('Dests')) {
                            nameDictionaryRef = this.catDict.get('Dests');
                        }
                        if (nameDictionaryRef) {
                            var value = nameDictionaryRef.get(destinationId);
                            if (value) {
                                dest = fetchDestination(value);
                            }
                        }
                        if (nameTreeRef) {
                            var nameTree = new NameTree(nameTreeRef, xref);
                            dest = fetchDestination(nameTree.get(destinationId));
                        }
                        return dest;
                    },
                    get pageLabels() {
                        var obj = null;
                        try {
                            obj = this.readPageLabels();
                        } catch (ex) {
                            if (ex instanceof MissingDataException) {
                                throw ex;
                            }
                            warn('Unable to read page labels.');
                        }
                        return shadow(this, 'pageLabels', obj);
                    },
                    readPageLabels: function Catalog_readPageLabels() {
                        var obj = this.catDict.getRaw('PageLabels');
                        if (!obj) {
                            return null;
                        }
                        var pageLabels = new Array(this.numPages);
                        var style = null;
                        var prefix = '';
                        var start = 1;
                        var numberTree = new NumberTree(obj, this.xref);
                        var nums = numberTree.getAll();
                        var currentLabel = '',
                            currentIndex = 1;
                        for (var i = 0, ii = this.numPages; i < ii; i++) {
                            if (nums.hasOwnProperty(i)) {
                                var labelDict = nums[i];
                                assert(isDict(labelDict), 'The PageLabel is not a dictionary.');
                                var type = labelDict.get('Type');
                                assert(!type || (isName(type) && type.name === 'PageLabel'), 'Invalid type in PageLabel dictionary.');
                                var s = labelDict.get('S');
                                assert(!s || isName(s), 'Invalid style in PageLabel dictionary.');
                                style = (s ? s.name : null);
                                prefix = labelDict.get('P') || '';
                                assert(isString(prefix), 'Invalid prefix in PageLabel dictionary.');
                                start = labelDict.get('St') || 1;
                                assert(isInt(start), 'Invalid start in PageLabel dictionary.');
                                currentIndex = start;
                            }
                            switch (style) {
                                case 'D':
                                    currentLabel = currentIndex;
                                    break;
                                case 'R':
                                case 'r':
                                    currentLabel = Util.toRoman(currentIndex, style === 'r');
                                    break;
                                case 'A':
                                case 'a':
                                    var LIMIT = 26;
                                    var A_UPPER_CASE = 0x41,
                                        A_LOWER_CASE = 0x61;
                                    var baseCharCode = (style === 'a' ? A_LOWER_CASE : A_UPPER_CASE);
                                    var letterIndex = currentIndex - 1;
                                    var character = String.fromCharCode(baseCharCode +
                                        (letterIndex % LIMIT));
                                    var charBuf = [];
                                    for (var j = 0, jj = (letterIndex / LIMIT) | 0; j <= jj; j++) {
                                        charBuf.push(character);
                                    }
                                    currentLabel = charBuf.join('');
                                    break;
                                default:
                                    assert(!style, 'Invalid style "' + style + '" in PageLabel dictionary.');
                            }
                            pageLabels[i] = prefix + currentLabel;
                            currentLabel = '';
                            currentIndex++;
                        }
                        return pageLabels;
                    },
                    get attachments() {
                        var xref = this.xref;
                        var attachments = null,
                            nameTreeRef;
                        var obj = this.catDict.get('Names');
                        if (obj) {
                            nameTreeRef = obj.getRaw('EmbeddedFiles');
                        }
                        if (nameTreeRef) {
                            var nameTree = new NameTree(nameTreeRef, xref);
                            var names = nameTree.getAll();
                            for (var name in names) {
                                if (!names.hasOwnProperty(name)) {
                                    continue;
                                }
                                var fs = new FileSpec(names[name], xref);
                                if (!attachments) {
                                    attachments = {};
                                }
                                attachments[stringToPDFString(name)] = fs.serializable;
                            }
                        }
                        return shadow(this, 'attachments', attachments);
                    },
                    get javaScript() {
                        var xref = this.xref;
                        var obj = this.catDict.get('Names');
                        var javaScript = [];

                        function appendIfJavaScriptDict(jsDict) {
                            var type = jsDict.get('S');
                            if (!isName(type) || type.name !== 'JavaScript') {
                                return;
                            }
                            var js = jsDict.get('JS');
                            if (isStream(js)) {
                                js = bytesToString(js.getBytes());
                            } else if (!isString(js)) {
                                return;
                            }
                            javaScript.push(stringToPDFString(js));
                        }
                        if (obj && obj.has('JavaScript')) {
                            var nameTree = new NameTree(obj.getRaw('JavaScript'), xref);
                            var names = nameTree.getAll();
                            for (var name in names) {
                                if (!names.hasOwnProperty(name)) {
                                    continue;
                                }
                                var jsDict = names[name];
                                if (isDict(jsDict)) {
                                    appendIfJavaScriptDict(jsDict);
                                }
                            }
                        }
                        var openactionDict = this.catDict.get('OpenAction');
                        if (isDict(openactionDict, 'Action')) {
                            var actionType = openactionDict.get('S');
                            if (isName(actionType) && actionType.name === 'Named') {
                                var action = openactionDict.get('N');
                                if (isName(action) && action.name === 'Print') {
                                    javaScript.push('print({});');
                                }
                            } else {
                                appendIfJavaScriptDict(openactionDict);
                            }
                        }
                        return shadow(this, 'javaScript', javaScript);
                    },
                    cleanup: function Catalog_cleanup() {
                        var promises = [];
                        this.fontCache.forEach(function(promise) {
                            promises.push(promise);
                        });
                        return Promise.all(promises).then(function(translatedFonts) {
                            for (var i = 0, ii = translatedFonts.length; i < ii; i++) {
                                var font = translatedFonts[i].dict;
                                delete font.translated;
                            }
                            this.fontCache.clear();
                        }.bind(this));
                    },
                    getPage: function Catalog_getPage(pageIndex) {
                        if (!(pageIndex in this.pagePromises)) {
                            this.pagePromises[pageIndex] = this.getPageDict(pageIndex).then(function(a) {
                                var dict = a[0];
                                var ref = a[1];
                                return this.pageFactory.createPage(pageIndex, dict, ref, this.fontCache);
                            }.bind(this));
                        }
                        return this.pagePromises[pageIndex];
                    },
                    getPageDict: function Catalog_getPageDict(pageIndex) {
                        var capability = createPromiseCapability();
                        var nodesToVisit = [this.catDict.getRaw('Pages')];
                        var currentPageIndex = 0;
                        var xref = this.xref;
                        var checkAllKids = false;

                        function next() {
                            while (nodesToVisit.length) {
                                var currentNode = nodesToVisit.pop();
                                if (isRef(currentNode)) {
                                    xref.fetchAsync(currentNode).then(function(obj) {
                                        if (isDict(obj, 'Page') || (isDict(obj) && !obj.has('Kids'))) {
                                            if (pageIndex === currentPageIndex) {
                                                capability.resolve([obj, currentNode]);
                                            } else {
                                                currentPageIndex++;
                                                next();
                                            }
                                            return;
                                        }
                                        nodesToVisit.push(obj);
                                        next();
                                    }, capability.reject);
                                    return;
                                }
                                assert(isDict(currentNode), 'page dictionary kid reference points to wrong type of object');
                                var count = currentNode.get('Count');
                                if (count === 0) {
                                    checkAllKids = true;
                                }
                                if (currentPageIndex + count <= pageIndex) {
                                    currentPageIndex += count;
                                    continue;
                                }
                                var kids = currentNode.get('Kids');
                                assert(isArray(kids), 'page dictionary kids object is not an array');
                                if (!checkAllKids && count === kids.length) {
                                    nodesToVisit = [kids[pageIndex - currentPageIndex]];
                                    currentPageIndex = pageIndex;
                                    continue;
                                } else {
                                    for (var last = kids.length - 1; last >= 0; last--) {
                                        nodesToVisit.push(kids[last]);
                                    }
                                }
                            }
                            capability.reject('Page index ' + pageIndex + ' not found.');
                        }
                        next();
                        return capability.promise;
                    },
                    getPageIndex: function Catalog_getPageIndex(ref) {
                        var xref = this.xref;

                        function pagesBeforeRef(kidRef) {
                            var total = 0;
                            var parentRef;
                            return xref.fetchAsync(kidRef).then(function(node) {
                                if (!node) {
                                    return null;
                                }
                                parentRef = node.getRaw('Parent');
                                return node.getAsync('Parent');
                            }).then(function(parent) {
                                if (!parent) {
                                    return null;
                                }
                                return parent.getAsync('Kids');
                            }).then(function(kids) {
                                if (!kids) {
                                    return null;
                                }
                                var kidPromises = [];
                                var found = false;
                                for (var i = 0; i < kids.length; i++) {
                                    var kid = kids[i];
                                    assert(isRef(kid), 'kids must be a ref');
                                    if (kid.num === kidRef.num) {
                                        found = true;
                                        break;
                                    }
                                    kidPromises.push(xref.fetchAsync(kid).then(function(kid) {
                                        if (kid.has('Count')) {
                                            var count = kid.get('Count');
                                            total += count;
                                        } else {
                                            total++;
                                        }
                                    }));
                                }
                                if (!found) {
                                    error('kid ref not found in parents kids');
                                }
                                return Promise.all(kidPromises).then(function() {
                                    return [total, parentRef];
                                });
                            });
                        }
                        var total = 0;

                        function next(ref) {
                            return pagesBeforeRef(ref).then(function(args) {
                                if (!args) {
                                    return total;
                                }
                                var count = args[0];
                                var parentRef = args[1];
                                total += count;
                                return next(parentRef);
                            });
                        }
                        return next(ref);
                    }
                };
                return Catalog;
            })();
            var XRef = (function XRefClosure() {
                function XRef(stream, password) {
                    this.stream = stream;
                    this.entries = [];
                    this.xrefstms = {};
                    this.cache = [];
                    this.password = password;
                    this.stats = {
                        streamTypes: [],
                        fontTypes: []
                    };
                }
                XRef.prototype = {
                    setStartXRef: function XRef_setStartXRef(startXRef) {
                        this.startXRefQueue = [startXRef];
                    },
                    parse: function XRef_parse(recoveryMode) {
                        var trailerDict;
                        if (!recoveryMode) {
                            trailerDict = this.readXRef();
                        } else {
                            warn('Indexing all PDF objects');
                            trailerDict = this.indexObjects();
                        }
                        trailerDict.assignXref(this);
                        this.trailer = trailerDict;
                        var encrypt = trailerDict.get('Encrypt');
                        if (encrypt) {
                            var ids = trailerDict.get('ID');
                            var fileId = (ids && ids.length) ? ids[0] : '';
                            this.encrypt = new CipherTransformFactory(encrypt, fileId, this.password);
                        }
                        if (!(this.root = trailerDict.get('Root'))) {
                            error('Invalid root reference');
                        }
                    },
                    processXRefTable: function XRef_processXRefTable(parser) {
                        if (!('tableState' in this)) {
                            this.tableState = {
                                entryNum: 0,
                                streamPos: parser.lexer.stream.pos,
                                parserBuf1: parser.buf1,
                                parserBuf2: parser.buf2
                            };
                        }
                        var obj = this.readXRefTable(parser);
                        if (!isCmd(obj, 'trailer')) {
                            error('Invalid XRef table: could not find trailer dictionary');
                        }
                        var dict = parser.getObj();
                        if (!isDict(dict) && dict.dict) {
                            dict = dict.dict;
                        }
                        if (!isDict(dict)) {
                            error('Invalid XRef table: could not parse trailer dictionary');
                        }
                        delete this.tableState;
                        return dict;
                    },
                    readXRefTable: function XRef_readXRefTable(parser) {
                        var stream = parser.lexer.stream;
                        var tableState = this.tableState;
                        stream.pos = tableState.streamPos;
                        parser.buf1 = tableState.parserBuf1;
                        parser.buf2 = tableState.parserBuf2;
                        var obj;
                        while (true) {
                            if (!('firstEntryNum' in tableState) || !('entryCount' in tableState)) {
                                if (isCmd(obj = parser.getObj(), 'trailer')) {
                                    break;
                                }
                                tableState.firstEntryNum = obj;
                                tableState.entryCount = parser.getObj();
                            }
                            var first = tableState.firstEntryNum;
                            var count = tableState.entryCount;
                            if (!isInt(first) || !isInt(count)) {
                                error('Invalid XRef table: wrong types in subsection header');
                            }
                            for (var i = tableState.entryNum; i < count; i++) {
                                tableState.streamPos = stream.pos;
                                tableState.entryNum = i;
                                tableState.parserBuf1 = parser.buf1;
                                tableState.parserBuf2 = parser.buf2;
                                var entry = {};
                                entry.offset = parser.getObj();
                                entry.gen = parser.getObj();
                                var type = parser.getObj();
                                if (isCmd(type, 'f')) {
                                    entry.free = true;
                                } else if (isCmd(type, 'n')) {
                                    entry.uncompressed = true;
                                }
                                if (!isInt(entry.offset) || !isInt(entry.gen) || !(entry.free || entry.uncompressed)) {
                                    error('Invalid entry in XRef subsection: ' + first + ', ' + count);
                                }
                                if (!this.entries[i + first]) {
                                    this.entries[i + first] = entry;
                                }
                            }
                            tableState.entryNum = 0;
                            tableState.streamPos = stream.pos;
                            tableState.parserBuf1 = parser.buf1;
                            tableState.parserBuf2 = parser.buf2;
                            delete tableState.firstEntryNum;
                            delete tableState.entryCount;
                        }
                        if (first === 1 && this.entries[1] && this.entries[1].free) {
                            this.entries.shift();
                        }
                        if (this.entries[0] && !this.entries[0].free) {
                            error('Invalid XRef table: unexpected first object');
                        }
                        return obj;
                    },
                    processXRefStream: function XRef_processXRefStream(stream) {
                        if (!('streamState' in this)) {
                            var streamParameters = stream.dict;
                            var byteWidths = streamParameters.get('W');
                            var range = streamParameters.get('Index');
                            if (!range) {
                                range = [0, streamParameters.get('Size')];
                            }
                            this.streamState = {
                                entryRanges: range,
                                byteWidths: byteWidths,
                                entryNum: 0,
                                streamPos: stream.pos
                            };
                        }
                        this.readXRefStream(stream);
                        delete this.streamState;
                        return stream.dict;
                    },
                    readXRefStream: function XRef_readXRefStream(stream) {
                        var i, j;
                        var streamState = this.streamState;
                        stream.pos = streamState.streamPos;
                        var byteWidths = streamState.byteWidths;
                        var typeFieldWidth = byteWidths[0];
                        var offsetFieldWidth = byteWidths[1];
                        var generationFieldWidth = byteWidths[2];
                        var entryRanges = streamState.entryRanges;
                        while (entryRanges.length > 0) {
                            var first = entryRanges[0];
                            var n = entryRanges[1];
                            if (!isInt(first) || !isInt(n)) {
                                error('Invalid XRef range fields: ' + first + ', ' + n);
                            }
                            if (!isInt(typeFieldWidth) || !isInt(offsetFieldWidth) || !isInt(generationFieldWidth)) {
                                error('Invalid XRef entry fields length: ' + first + ', ' + n);
                            }
                            for (i = streamState.entryNum; i < n; ++i) {
                                streamState.entryNum = i;
                                streamState.streamPos = stream.pos;
                                var type = 0,
                                    offset = 0,
                                    generation = 0;
                                for (j = 0; j < typeFieldWidth; ++j) {
                                    type = (type << 8) | stream.getByte();
                                }
                                if (typeFieldWidth === 0) {
                                    type = 1;
                                }
                                for (j = 0; j < offsetFieldWidth; ++j) {
                                    offset = (offset << 8) | stream.getByte();
                                }
                                for (j = 0; j < generationFieldWidth; ++j) {
                                    generation = (generation << 8) | stream.getByte();
                                }
                                var entry = {};
                                entry.offset = offset;
                                entry.gen = generation;
                                switch (type) {
                                    case 0:
                                        entry.free = true;
                                        break;
                                    case 1:
                                        entry.uncompressed = true;
                                        break;
                                    case 2:
                                        break;
                                    default:
                                        error('Invalid XRef entry type: ' + type);
                                }
                                if (!this.entries[first + i]) {
                                    this.entries[first + i] = entry;
                                }
                            }
                            streamState.entryNum = 0;
                            streamState.streamPos = stream.pos;
                            entryRanges.splice(0, 2);
                        }
                    },
                    indexObjects: function XRef_indexObjects() {
                        var TAB = 0x9,
                            LF = 0xA,
                            CR = 0xD,
                            SPACE = 0x20;
                        var PERCENT = 0x25,
                            LT = 0x3C;

                        function readToken(data, offset) {
                            var token = '',
                                ch = data[offset];
                            while (ch !== LF && ch !== CR && ch !== LT) {
                                if (++offset >= data.length) {
                                    break;
                                }
                                token += String.fromCharCode(ch);
                                ch = data[offset];
                            }
                            return token;
                        }

                        function skipUntil(data, offset, what) {
                            var length = what.length,
                                dataLength = data.length;
                            var skipped = 0;
                            while (offset < dataLength) {
                                var i = 0;
                                while (i < length && data[offset + i] === what[i]) {
                                    ++i;
                                }
                                if (i >= length) {
                                    break;
                                }
                                offset++;
                                skipped++;
                            }
                            return skipped;
                        }
                        var objRegExp = /^(\d+)\s+(\d+)\s+obj\b/;
                        var trailerBytes = new Uint8Array([116, 114, 97, 105, 108, 101, 114]);
                        var startxrefBytes = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);
                        var endobjBytes = new Uint8Array([101, 110, 100, 111, 98, 106]);
                        var xrefBytes = new Uint8Array([47, 88, 82, 101, 102]);
                        this.entries.length = 0;
                        var stream = this.stream;
                        stream.pos = 0;
                        var buffer = stream.getBytes();
                        var position = stream.start,
                            length = buffer.length;
                        var trailers = [],
                            xrefStms = [];
                        while (position < length) {
                            var ch = buffer[position];
                            if (ch === TAB || ch === LF || ch === CR || ch === SPACE) {
                                ++position;
                                continue;
                            }
                            if (ch === PERCENT) {
                                do {
                                    ++position;
                                    if (position >= length) {
                                        break;
                                    }
                                    ch = buffer[position];
                                } while (ch !== LF && ch !== CR);
                                continue;
                            }
                            var token = readToken(buffer, position);
                            var m;
                            if (token.indexOf('xref') === 0 && (token.length === 4 || /\s/.test(token[4]))) {
                                position += skipUntil(buffer, position, trailerBytes);
                                trailers.push(position);
                                position += skipUntil(buffer, position, startxrefBytes);
                            } else if ((m = objRegExp.exec(token))) {
                                if (typeof this.entries[m[1]] === 'undefined') {
                                    this.entries[m[1]] = {
                                        offset: position - stream.start,
                                        gen: m[2] | 0,
                                        uncompressed: true
                                    };
                                }
                                var contentLength = skipUntil(buffer, position, endobjBytes) + 7;
                                var content = buffer.subarray(position, position + contentLength);
                                var xrefTagOffset = skipUntil(content, 0, xrefBytes);
                                if (xrefTagOffset < contentLength && content[xrefTagOffset + 5] < 64) {
                                    xrefStms.push(position - stream.start);
                                    this.xrefstms[position - stream.start] = 1;
                                }
                                position += contentLength;
                            } else if (token.indexOf('trailer') === 0 && (token.length === 7 || /\s/.test(token[7]))) {
                                trailers.push(position);
                                position += skipUntil(buffer, position, startxrefBytes);
                            } else {
                                position += token.length + 1;
                            }
                        }
                        var i, ii;
                        for (i = 0, ii = xrefStms.length; i < ii; ++i) {
                            this.startXRefQueue.push(xrefStms[i]);
                            this.readXRef(true);
                        }
                        var dict;
                        for (i = 0, ii = trailers.length; i < ii; ++i) {
                            stream.pos = trailers[i];
                            var parser = new Parser(new Lexer(stream), true, this);
                            var obj = parser.getObj();
                            if (!isCmd(obj, 'trailer')) {
                                continue;
                            }
                            if (!isDict(dict = parser.getObj())) {
                                continue;
                            }
                            if (dict.has('ID')) {
                                return dict;
                            }
                        }
                        if (dict) {
                            return dict;
                        }
                        throw new InvalidPDFException('Invalid PDF structure');
                    },
                    readXRef: function XRef_readXRef(recoveryMode) {
                        var stream = this.stream;
                        try {
                            while (this.startXRefQueue.length) {
                                var startXRef = this.startXRefQueue[0];
                                stream.pos = startXRef + stream.start;
                                var parser = new Parser(new Lexer(stream), true, this);
                                var obj = parser.getObj();
                                var dict;
                                if (isCmd(obj, 'xref')) {
                                    dict = this.processXRefTable(parser);
                                    if (!this.topDict) {
                                        this.topDict = dict;
                                    }
                                    obj = dict.get('XRefStm');
                                    if (isInt(obj)) {
                                        var pos = obj;
                                        if (!(pos in this.xrefstms)) {
                                            this.xrefstms[pos] = 1;
                                            this.startXRefQueue.push(pos);
                                        }
                                    }
                                } else if (isInt(obj)) {
                                    if (!isInt(parser.getObj()) || !isCmd(parser.getObj(), 'obj') || !isStream(obj = parser.getObj())) {
                                        error('Invalid XRef stream');
                                    }
                                    dict = this.processXRefStream(obj);
                                    if (!this.topDict) {
                                        this.topDict = dict;
                                    }
                                    if (!dict) {
                                        error('Failed to read XRef stream');
                                    }
                                } else {
                                    error('Invalid XRef stream header');
                                }
                                obj = dict.get('Prev');
                                if (isInt(obj)) {
                                    this.startXRefQueue.push(obj);
                                } else if (isRef(obj)) {
                                    this.startXRefQueue.push(obj.num);
                                }
                                this.startXRefQueue.shift();
                            }
                            return this.topDict;
                        } catch (e) {
                            if (e instanceof MissingDataException) {
                                throw e;
                            }
                            info('(while reading XRef): ' + e);
                        }
                        if (recoveryMode) {
                            return;
                        }
                        throw new XRefParseException();
                    },
                    getEntry: function XRef_getEntry(i) {
                        var xrefEntry = this.entries[i];
                        if (xrefEntry && !xrefEntry.free && xrefEntry.offset) {
                            return xrefEntry;
                        }
                        return null;
                    },
                    fetchIfRef: function XRef_fetchIfRef(obj) {
                        if (!isRef(obj)) {
                            return obj;
                        }
                        return this.fetch(obj);
                    },
                    fetch: function XRef_fetch(ref, suppressEncryption) {
                        assert(isRef(ref), 'ref object is not a reference');
                        var num = ref.num;
                        if (num in this.cache) {
                            var cacheEntry = this.cache[num];
                            return cacheEntry;
                        }
                        var xrefEntry = this.getEntry(num);
                        if (xrefEntry === null) {
                            return (this.cache[num] = null);
                        }
                        if (xrefEntry.uncompressed) {
                            xrefEntry = this.fetchUncompressed(ref, xrefEntry, suppressEncryption);
                        } else {
                            xrefEntry = this.fetchCompressed(xrefEntry, suppressEncryption);
                        }
                        if (isDict(xrefEntry)) {
                            xrefEntry.objId = ref.toString();
                        } else if (isStream(xrefEntry)) {
                            xrefEntry.dict.objId = ref.toString();
                        }
                        return xrefEntry;
                    },
                    fetchUncompressed: function XRef_fetchUncompressed(ref, xrefEntry, suppressEncryption) {
                        var gen = ref.gen;
                        var num = ref.num;
                        if (xrefEntry.gen !== gen) {
                            error('inconsistent generation in XRef');
                        }
                        var stream = this.stream.makeSubStream(xrefEntry.offset +
                            this.stream.start);
                        var parser = new Parser(new Lexer(stream), true, this);
                        var obj1 = parser.getObj();
                        var obj2 = parser.getObj();
                        var obj3 = parser.getObj();
                        if (!isInt(obj1) || parseInt(obj1, 10) !== num || !isInt(obj2) || parseInt(obj2, 10) !== gen || !isCmd(obj3)) {
                            error('bad XRef entry');
                        }
                        if (!isCmd(obj3, 'obj')) {
                            if (obj3.cmd.indexOf('obj') === 0) {
                                num = parseInt(obj3.cmd.substring(3), 10);
                                if (!isNaN(num)) {
                                    return num;
                                }
                            }
                            error('bad XRef entry');
                        }
                        if (this.encrypt && !suppressEncryption) {
                            xrefEntry = parser.getObj(this.encrypt.createCipherTransform(num, gen));
                        } else {
                            xrefEntry = parser.getObj();
                        }
                        if (!isStream(xrefEntry)) {
                            this.cache[num] = xrefEntry;
                        }
                        return xrefEntry;
                    },
                    fetchCompressed: function XRef_fetchCompressed(xrefEntry, suppressEncryption) {
                        var tableOffset = xrefEntry.offset;
                        var stream = this.fetch(new Ref(tableOffset, 0));
                        if (!isStream(stream)) {
                            error('bad ObjStm stream');
                        }
                        var first = stream.dict.get('First');
                        var n = stream.dict.get('N');
                        if (!isInt(first) || !isInt(n)) {
                            error('invalid first and n parameters for ObjStm stream');
                        }
                        var parser = new Parser(new Lexer(stream), false, this);
                        parser.allowStreams = true;
                        var i, entries = [],
                            num, nums = [];
                        for (i = 0; i < n; ++i) {
                            num = parser.getObj();
                            if (!isInt(num)) {
                                error('invalid object number in the ObjStm stream: ' + num);
                            }
                            nums.push(num);
                            var offset = parser.getObj();
                            if (!isInt(offset)) {
                                error('invalid object offset in the ObjStm stream: ' + offset);
                            }
                        }
                        for (i = 0; i < n; ++i) {
                            entries.push(parser.getObj());
                            num = nums[i];
                            var entry = this.entries[num];
                            if (entry && entry.offset === tableOffset && entry.gen === i) {
                                this.cache[num] = entries[i];
                            }
                        }
                        xrefEntry = entries[xrefEntry.gen];
                        if (xrefEntry === undefined) {
                            error('bad XRef entry for compressed object');
                        }
                        return xrefEntry;
                    },
                    fetchIfRefAsync: function XRef_fetchIfRefAsync(obj) {
                        if (!isRef(obj)) {
                            return Promise.resolve(obj);
                        }
                        return this.fetchAsync(obj);
                    },
                    fetchAsync: function XRef_fetchAsync(ref, suppressEncryption) {
                        var streamManager = this.stream.manager;
                        var xref = this;
                        return new Promise(function tryFetch(resolve, reject) {
                            try {
                                resolve(xref.fetch(ref, suppressEncryption));
                            } catch (e) {
                                if (e instanceof MissingDataException) {
                                    streamManager.requestRange(e.begin, e.end).then(function() {
                                        tryFetch(resolve, reject);
                                    }, reject);
                                    return;
                                }
                                reject(e);
                            }
                        });
                    },
                    getCatalogObj: function XRef_getCatalogObj() {
                        return this.root;
                    }
                };
                return XRef;
            })();
            var NameOrNumberTree = (function NameOrNumberTreeClosure() {
                function NameOrNumberTree(root, xref) {
                    throw new Error('Cannot initialize NameOrNumberTree.');
                }
                NameOrNumberTree.prototype = {
                    getAll: function NameOrNumberTree_getAll() {
                        var dict = {};
                        if (!this.root) {
                            return dict;
                        }
                        var xref = this.xref;
                        var processed = new RefSet();
                        processed.put(this.root);
                        var queue = [this.root];
                        while (queue.length > 0) {
                            var i, n;
                            var obj = xref.fetchIfRef(queue.shift());
                            if (!isDict(obj)) {
                                continue;
                            }
                            if (obj.has('Kids')) {
                                var kids = obj.get('Kids');
                                for (i = 0, n = kids.length; i < n; i++) {
                                    var kid = kids[i];
                                    assert(!processed.has(kid), 'Duplicate entry in "' + this._type + '" tree.');
                                    queue.push(kid);
                                    processed.put(kid);
                                }
                                continue;
                            }
                            var entries = obj.get(this._type);
                            if (isArray(entries)) {
                                for (i = 0, n = entries.length; i < n; i += 2) {
                                    dict[xref.fetchIfRef(entries[i])] = xref.fetchIfRef(entries[i + 1]);
                                }
                            }
                        }
                        return dict;
                    },
                    get: function NameOrNumberTree_get(key) {
                        if (!this.root) {
                            return null;
                        }
                        var xref = this.xref;
                        var kidsOrEntries = xref.fetchIfRef(this.root);
                        var loopCount = 0;
                        var MAX_LEVELS = 10;
                        var l, r, m;
                        while (kidsOrEntries.has('Kids')) {
                            if (++loopCount > MAX_LEVELS) {
                                warn('Search depth limit reached for "' + this._type + '" tree.');
                                return null;
                            }
                            var kids = kidsOrEntries.get('Kids');
                            if (!isArray(kids)) {
                                return null;
                            }
                            l = 0;
                            r = kids.length - 1;
                            while (l <= r) {
                                m = (l + r) >> 1;
                                var kid = xref.fetchIfRef(kids[m]);
                                var limits = kid.get('Limits');
                                if (key < xref.fetchIfRef(limits[0])) {
                                    r = m - 1;
                                } else if (key > xref.fetchIfRef(limits[1])) {
                                    l = m + 1;
                                } else {
                                    kidsOrEntries = xref.fetchIfRef(kids[m]);
                                    break;
                                }
                            }
                            if (l > r) {
                                return null;
                            }
                        }
                        var entries = kidsOrEntries.get(this._type);
                        if (isArray(entries)) {
                            l = 0;
                            r = entries.length - 2;
                            while (l <= r) {
                                m = (l + r) & ~1;
                                var currentKey = xref.fetchIfRef(entries[m]);
                                if (key < currentKey) {
                                    r = m - 2;
                                } else if (key > currentKey) {
                                    l = m + 2;
                                } else {
                                    return xref.fetchIfRef(entries[m + 1]);
                                }
                            }
                        }
                        return null;
                    }
                };
                return NameOrNumberTree;
            })();
            var NameTree = (function NameTreeClosure() {
                function NameTree(root, xref) {
                    this.root = root;
                    this.xref = xref;
                    this._type = 'Names';
                }
                Util.inherit(NameTree, NameOrNumberTree, {});
                return NameTree;
            })();
            var NumberTree = (function NumberTreeClosure() {
                function NumberTree(root, xref) {
                    this.root = root;
                    this.xref = xref;
                    this._type = 'Nums';
                }
                Util.inherit(NumberTree, NameOrNumberTree, {});
                return NumberTree;
            })();
            var FileSpec = (function FileSpecClosure() {
                function FileSpec(root, xref) {
                    if (!root || !isDict(root)) {
                        return;
                    }
                    this.xref = xref;
                    this.root = root;
                    if (root.has('FS')) {
                        this.fs = root.get('FS');
                    }
                    this.description = root.has('Desc') ? stringToPDFString(root.get('Desc')) : '';
                    if (root.has('RF')) {
                        warn('Related file specifications are not supported');
                    }
                    this.contentAvailable = true;
                    if (!root.has('EF')) {
                        this.contentAvailable = false;
                        warn('Non-embedded file specifications are not supported');
                    }
                }

                function pickPlatformItem(dict) {
                    if (dict.has('UF')) {
                        return dict.get('UF');
                    } else if (dict.has('F')) {
                        return dict.get('F');
                    } else if (dict.has('Unix')) {
                        return dict.get('Unix');
                    } else if (dict.has('Mac')) {
                        return dict.get('Mac');
                    } else if (dict.has('DOS')) {
                        return dict.get('DOS');
                    } else {
                        return null;
                    }
                }
                FileSpec.prototype = {
                    get filename() {
                        if (!this._filename && this.root) {
                            var filename = pickPlatformItem(this.root) || 'unnamed';
                            this._filename = stringToPDFString(filename).replace(/\\\\/g, '\\').replace(/\\\//g, '/').replace(/\\/g, '/');
                        }
                        return this._filename;
                    },
                    get content() {
                        if (!this.contentAvailable) {
                            return null;
                        }
                        if (!this.contentRef && this.root) {
                            this.contentRef = pickPlatformItem(this.root.get('EF'));
                        }
                        var content = null;
                        if (this.contentRef) {
                            var xref = this.xref;
                            var fileObj = xref.fetchIfRef(this.contentRef);
                            if (fileObj && isStream(fileObj)) {
                                content = fileObj.getBytes();
                            } else {
                                warn('Embedded file specification points to non-existing/invalid ' + 'content');
                            }
                        } else {
                            warn('Embedded file specification does not have a content');
                        }
                        return content;
                    },
                    get serializable() {
                        return {
                            filename: this.filename,
                            content: this.content
                        };
                    }
                };
                return FileSpec;
            })();
            var ObjectLoader = (function() {
                function mayHaveChildren(value) {
                    return isRef(value) || isDict(value) || isArray(value) || isStream(value);
                }

                function addChildren(node, nodesToVisit) {
                    var value;
                    if (isDict(node) || isStream(node)) {
                        var map;
                        if (isDict(node)) {
                            map = node.map;
                        } else {
                            map = node.dict.map;
                        }
                        for (var key in map) {
                            value = map[key];
                            if (mayHaveChildren(value)) {
                                nodesToVisit.push(value);
                            }
                        }
                    } else if (isArray(node)) {
                        for (var i = 0, ii = node.length; i < ii; i++) {
                            value = node[i];
                            if (mayHaveChildren(value)) {
                                nodesToVisit.push(value);
                            }
                        }
                    }
                }

                function ObjectLoader(obj, keys, xref) {
                    this.obj = obj;
                    this.keys = keys;
                    this.xref = xref;
                    this.refSet = null;
                    this.capability = null;
                }
                ObjectLoader.prototype = {
                    load: function ObjectLoader_load() {
                        var keys = this.keys;
                        this.capability = createPromiseCapability();
                        if (!(this.xref.stream instanceof ChunkedStream) || this.xref.stream.getMissingChunks().length === 0) {
                            this.capability.resolve();
                            return this.capability.promise;
                        }
                        this.refSet = new RefSet();
                        var nodesToVisit = [];
                        for (var i = 0; i < keys.length; i++) {
                            nodesToVisit.push(this.obj[keys[i]]);
                        }
                        this._walk(nodesToVisit);
                        return this.capability.promise;
                    },
                    _walk: function ObjectLoader_walk(nodesToVisit) {
                        var nodesToRevisit = [];
                        var pendingRequests = [];
                        while (nodesToVisit.length) {
                            var currentNode = nodesToVisit.pop();
                            if (isRef(currentNode)) {
                                if (this.refSet.has(currentNode)) {
                                    continue;
                                }
                                try {
                                    var ref = currentNode;
                                    this.refSet.put(ref);
                                    currentNode = this.xref.fetch(currentNode);
                                } catch (e) {
                                    if (!(e instanceof MissingDataException)) {
                                        throw e;
                                    }
                                    nodesToRevisit.push(currentNode);
                                    pendingRequests.push({
                                        begin: e.begin,
                                        end: e.end
                                    });
                                }
                            }
                            if (currentNode && currentNode.getBaseStreams) {
                                var baseStreams = currentNode.getBaseStreams();
                                var foundMissingData = false;
                                for (var i = 0; i < baseStreams.length; i++) {
                                    var stream = baseStreams[i];
                                    if (stream.getMissingChunks && stream.getMissingChunks().length) {
                                        foundMissingData = true;
                                        pendingRequests.push({
                                            begin: stream.start,
                                            end: stream.end
                                        });
                                    }
                                }
                                if (foundMissingData) {
                                    nodesToRevisit.push(currentNode);
                                }
                            }
                            addChildren(currentNode, nodesToVisit);
                        }
                        if (pendingRequests.length) {
                            this.xref.stream.manager.requestRanges(pendingRequests).then(function pendingRequestCallback() {
                                nodesToVisit = nodesToRevisit;
                                for (var i = 0; i < nodesToRevisit.length; i++) {
                                    var node = nodesToRevisit[i];
                                    if (isRef(node)) {
                                        this.refSet.remove(node);
                                    }
                                }
                                this._walk(nodesToVisit);
                            }.bind(this), this.capability.reject);
                            return;
                        }
                        this.refSet = null;
                        this.capability.resolve();
                    }
                };
                return ObjectLoader;
            })();
            exports.Catalog = Catalog;
            exports.ObjectLoader = ObjectLoader;
            exports.XRef = XRef;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsCorePsParser = {}), root.pdfjsSharedUtil, root.pdfjsCoreParser);
            }
        }(this, function(exports, sharedUtil, coreParser) {
            var error = sharedUtil.error;
            var EOF = coreParser.EOF;
            var Lexer = coreParser.Lexer;
            var PostScriptParser = (function PostScriptParserClosure() {
                function PostScriptParser(lexer) {
                    this.lexer = lexer;
                    this.operators = [];
                    this.token = null;
                    this.prev = null;
                }
                PostScriptParser.prototype = {
                    nextToken: function PostScriptParser_nextToken() {
                        this.prev = this.token;
                        this.token = this.lexer.getToken();
                    },
                    accept: function PostScriptParser_accept(type) {
                        if (this.token.type === type) {
                            this.nextToken();
                            return true;
                        }
                        return false;
                    },
                    expect: function PostScriptParser_expect(type) {
                        if (this.accept(type)) {
                            return true;
                        }
                        error('Unexpected symbol: found ' + this.token.type + ' expected ' +
                            type + '.');
                    },
                    parse: function PostScriptParser_parse() {
                        this.nextToken();
                        this.expect(PostScriptTokenTypes.LBRACE);
                        this.parseBlock();
                        this.expect(PostScriptTokenTypes.RBRACE);
                        return this.operators;
                    },
                    parseBlock: function PostScriptParser_parseBlock() {
                        while (true) {
                            if (this.accept(PostScriptTokenTypes.NUMBER)) {
                                this.operators.push(this.prev.value);
                            } else if (this.accept(PostScriptTokenTypes.OPERATOR)) {
                                this.operators.push(this.prev.value);
                            } else if (this.accept(PostScriptTokenTypes.LBRACE)) {
                                this.parseCondition();
                            } else {
                                return;
                            }
                        }
                    },
                    parseCondition: function PostScriptParser_parseCondition() {
                        var conditionLocation = this.operators.length;
                        this.operators.push(null, null);
                        this.parseBlock();
                        this.expect(PostScriptTokenTypes.RBRACE);
                        if (this.accept(PostScriptTokenTypes.IF)) {
                            this.operators[conditionLocation] = this.operators.length;
                            this.operators[conditionLocation + 1] = 'jz';
                        } else if (this.accept(PostScriptTokenTypes.LBRACE)) {
                            var jumpLocation = this.operators.length;
                            this.operators.push(null, null);
                            var endOfTrue = this.operators.length;
                            this.parseBlock();
                            this.expect(PostScriptTokenTypes.RBRACE);
                            this.expect(PostScriptTokenTypes.IFELSE);
                            this.operators[jumpLocation] = this.operators.length;
                            this.operators[jumpLocation + 1] = 'j';
                            this.operators[conditionLocation] = endOfTrue;
                            this.operators[conditionLocation + 1] = 'jz';
                        } else {
                            error('PS Function: error parsing conditional.');
                        }
                    }
                };
                return PostScriptParser;
            })();
            var PostScriptTokenTypes = {
                LBRACE: 0,
                RBRACE: 1,
                NUMBER: 2,
                OPERATOR: 3,
                IF: 4,
                IFELSE: 5
            };
            var PostScriptToken = (function PostScriptTokenClosure() {
                function PostScriptToken(type, value) {
                    this.type = type;
                    this.value = value;
                }
                var opCache = {};
                PostScriptToken.getOperator = function PostScriptToken_getOperator(op) {
                    var opValue = opCache[op];
                    if (opValue) {
                        return opValue;
                    }
                    return opCache[op] = new PostScriptToken(PostScriptTokenTypes.OPERATOR, op);
                };
                PostScriptToken.LBRACE = new PostScriptToken(PostScriptTokenTypes.LBRACE, '{');
                PostScriptToken.RBRACE = new PostScriptToken(PostScriptTokenTypes.RBRACE, '}');
                PostScriptToken.IF = new PostScriptToken(PostScriptTokenTypes.IF, 'IF');
                PostScriptToken.IFELSE = new PostScriptToken(PostScriptTokenTypes.IFELSE, 'IFELSE');
                return PostScriptToken;
            })();
            var PostScriptLexer = (function PostScriptLexerClosure() {
                function PostScriptLexer(stream) {
                    this.stream = stream;
                    this.nextChar();
                    this.strBuf = [];
                }
                PostScriptLexer.prototype = {
                    nextChar: function PostScriptLexer_nextChar() {
                        return (this.currentChar = this.stream.getByte());
                    },
                    getToken: function PostScriptLexer_getToken() {
                        var comment = false;
                        var ch = this.currentChar;
                        while (true) {
                            if (ch < 0) {
                                return EOF;
                            }
                            if (comment) {
                                if (ch === 0x0A || ch === 0x0D) {
                                    comment = false;
                                }
                            } else if (ch === 0x25) {
                                comment = true;
                            } else if (!Lexer.isSpace(ch)) {
                                break;
                            }
                            ch = this.nextChar();
                        }
                        switch (ch | 0) {
                            case 0x30:
                            case 0x31:
                            case 0x32:
                            case 0x33:
                            case 0x34:
                            case 0x35:
                            case 0x36:
                            case 0x37:
                            case 0x38:
                            case 0x39:
                            case 0x2B:
                            case 0x2D:
                            case 0x2E:
                                return new PostScriptToken(PostScriptTokenTypes.NUMBER, this.getNumber());
                            case 0x7B:
                                this.nextChar();
                                return PostScriptToken.LBRACE;
                            case 0x7D:
                                this.nextChar();
                                return PostScriptToken.RBRACE;
                        }
                        var strBuf = this.strBuf;
                        strBuf.length = 0;
                        strBuf[0] = String.fromCharCode(ch);
                        while ((ch = this.nextChar()) >= 0 && ((ch >= 0x41 && ch <= 0x5A) || (ch >= 0x61 && ch <= 0x7A))) {
                            strBuf.push(String.fromCharCode(ch));
                        }
                        var str = strBuf.join('');
                        switch (str.toLowerCase()) {
                            case 'if':
                                return PostScriptToken.IF;
                            case 'ifelse':
                                return PostScriptToken.IFELSE;
                            default:
                                return PostScriptToken.getOperator(str);
                        }
                    },
                    getNumber: function PostScriptLexer_getNumber() {
                        var ch = this.currentChar;
                        var strBuf = this.strBuf;
                        strBuf.length = 0;
                        strBuf[0] = String.fromCharCode(ch);
                        while ((ch = this.nextChar()) >= 0) {
                            if ((ch >= 0x30 && ch <= 0x39) || ch === 0x2D || ch === 0x2E) {
                                strBuf.push(String.fromCharCode(ch));
                            } else {
                                break;
                            }
                        }
                        var value = parseFloat(strBuf.join(''));
                        if (isNaN(value)) {
                            error('Invalid floating point number: ' + value);
                        }
                        return value;
                    }
                };
                return PostScriptLexer;
            })();
            exports.PostScriptLexer = PostScriptLexer;
            exports.PostScriptParser = PostScriptParser;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsCoreFonts = {}), root.pdfjsSharedUtil, root.pdfjsCorePrimitives, root.pdfjsCoreStream, root.pdfjsCoreParser, root.pdfjsCoreCMap, root.pdfjsCoreGlyphList, root.pdfjsCoreCharsets, root.pdfjsCoreFontRenderer);
            }
        }(this, function(exports, sharedUtil, corePrimitives, coreStream, coreParser, coreCMap, coreGlyphList, coreCharsets, coreFontRenderer) {
            var FONT_IDENTITY_MATRIX = sharedUtil.FONT_IDENTITY_MATRIX;
            var FontType = sharedUtil.FontType;
            var Util = sharedUtil.Util;
            var assert = sharedUtil.assert;
            var bytesToString = sharedUtil.bytesToString;
            var error = sharedUtil.error;
            var info = sharedUtil.info;
            var isArray = sharedUtil.isArray;
            var isInt = sharedUtil.isInt;
            var isNum = sharedUtil.isNum;
            var readUint32 = sharedUtil.readUint32;
            var shadow = sharedUtil.shadow;
            var stringToBytes = sharedUtil.stringToBytes;
            var string32 = sharedUtil.string32;
            var warn = sharedUtil.warn;
            var Name = corePrimitives.Name;
            var Stream = coreStream.Stream;
            var Lexer = coreParser.Lexer;
            var CMapFactory = coreCMap.CMapFactory;
            var IdentityCMap = coreCMap.IdentityCMap;
            var GlyphsUnicode = coreGlyphList.GlyphsUnicode;
            var DingbatsGlyphsUnicode = coreGlyphList.DingbatsGlyphsUnicode;
            var ISOAdobeCharset = coreCharsets.ISOAdobeCharset;
            var ExpertCharset = coreCharsets.ExpertCharset;
            var ExpertSubsetCharset = coreCharsets.ExpertSubsetCharset;
            var FontRendererFactory = coreFontRenderer.FontRendererFactory;
            var PRIVATE_USE_OFFSET_START = 0xE000;
            var PRIVATE_USE_OFFSET_END = 0xF8FF;
            var SKIP_PRIVATE_USE_RANGE_F000_TO_F01F = false;
            var PDF_GLYPH_SPACE_UNITS = 1000;
            var HINTING_ENABLED = false;
            var SEAC_ANALYSIS_ENABLED = false;
            var MAX_SUBR_NESTING = 10;
            var FontFlags = {
                FixedPitch: 1,
                Serif: 2,
                Symbolic: 4,
                Script: 8,
                Nonsymbolic: 32,
                Italic: 64,
                AllCap: 65536,
                SmallCap: 131072,
                ForceBold: 262144
            };
            var Encodings = {
                ExpertEncoding: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior', 'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader', 'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon', 'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior', 'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall', 'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall', 'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall', 'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior', '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters', 'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '', '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'],
                MacExpertEncoding: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', 'centoldstyle', 'dollaroldstyle', 'dollarsuperior', 'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader', 'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon', 'semicolon', '', 'threequartersemdash', '', 'questionsmall', '', '', '', '', 'Ethsmall', '', '', 'onequarter', 'onehalf', 'threequarters', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '', '', '', '', '', '', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hypheninferior', 'Gravesmall', 'Asmall', 'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall', 'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall', 'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', 'asuperior', 'centsuperior', '', '', '', '', 'Aacutesmall', 'Agravesmall', 'Acircumflexsmall', 'Adieresissmall', 'Atildesmall', 'Aringsmall', 'Ccedillasmall', 'Eacutesmall', 'Egravesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Iacutesmall', 'Igravesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ntildesmall', 'Oacutesmall', 'Ogravesmall', 'Ocircumflexsmall', 'Odieresissmall', 'Otildesmall', 'Uacutesmall', 'Ugravesmall', 'Ucircumflexsmall', 'Udieresissmall', '', 'eightsuperior', 'fourinferior', 'threeinferior', 'sixinferior', 'eightinferior', 'seveninferior', 'Scaronsmall', '', 'centinferior', 'twoinferior', '', 'Dieresissmall', '', 'Caronsmall', 'osuperior', 'fiveinferior', '', 'commainferior', 'periodinferior', 'Yacutesmall', '', 'dollarinferior', '', 'Thornsmall', '', 'nineinferior', 'zeroinferior', 'Zcaronsmall', 'AEsmall', 'Oslashsmall', 'questiondownsmall', 'oneinferior', 'Lslashsmall', '', '', '', '', '', '', 'Cedillasmall', '', '', '', '', '', 'OEsmall', 'figuredash', 'hyphensuperior', '', '', '', '', 'exclamdownsmall', '', 'Ydieresissmall', '', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'ninesuperior', 'zerosuperior', '', 'esuperior', 'rsuperior', 'tsuperior', '', '', 'isuperior', 'ssuperior', 'dsuperior', '', '', '', '', '', 'lsuperior', 'Ogoneksmall', 'Brevesmall', 'Macronsmall', 'bsuperior', 'nsuperior', 'msuperior', 'commasuperior', 'periodsuperior', 'Dotaccentsmall', 'Ringsmall'],
                MacRomanEncoding: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', 'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave', 'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis', 'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis', 'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section', 'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal', 'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation', 'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown', 'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright', 'ellipsis', 'space', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft', 'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction', 'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase', 'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex', 'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut', 'ogonek', 'caron'],
                StandardEncoding: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger', 'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron', 'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '', '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '', 'lslash', 'oslash', 'oe', 'germandbls'],
                WinAnsiEncoding: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'bullet', 'Euro', 'bullet', 'quotesinglbase', 'florin', 'quotedblbase', 'ellipsis', 'dagger', 'daggerdbl', 'circumflex', 'perthousand', 'Scaron', 'guilsinglleft', 'OE', 'bullet', 'Zcaron', 'bullet', 'bullet', 'quoteleft', 'quoteright', 'quotedblleft', 'quotedblright', 'bullet', 'endash', 'emdash', 'tilde', 'trademark', 'scaron', 'guilsinglright', 'oe', 'bullet', 'zcaron', 'Ydieresis', 'space', 'exclamdown', 'cent', 'sterling', 'currency', 'yen', 'brokenbar', 'section', 'dieresis', 'copyright', 'ordfeminine', 'guillemotleft', 'logicalnot', 'hyphen', 'registered', 'macron', 'degree', 'plusminus', 'twosuperior', 'threesuperior', 'acute', 'mu', 'paragraph', 'periodcentered', 'cedilla', 'onesuperior', 'ordmasculine', 'guillemotright', 'onequarter', 'onehalf', 'threequarters', 'questiondown', 'Agrave', 'Aacute', 'Acircumflex', 'Atilde', 'Adieresis', 'Aring', 'AE', 'Ccedilla', 'Egrave', 'Eacute', 'Ecircumflex', 'Edieresis', 'Igrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Eth', 'Ntilde', 'Ograve', 'Oacute', 'Ocircumflex', 'Otilde', 'Odieresis', 'multiply', 'Oslash', 'Ugrave', 'Uacute', 'Ucircumflex', 'Udieresis', 'Yacute', 'Thorn', 'germandbls', 'agrave', 'aacute', 'acircumflex', 'atilde', 'adieresis', 'aring', 'ae', 'ccedilla', 'egrave', 'eacute', 'ecircumflex', 'edieresis', 'igrave', 'iacute', 'icircumflex', 'idieresis', 'eth', 'ntilde', 'ograve', 'oacute', 'ocircumflex', 'otilde', 'odieresis', 'divide', 'oslash', 'ugrave', 'uacute', 'ucircumflex', 'udieresis', 'yacute', 'thorn', 'ydieresis'],
                SymbolSetEncoding: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclam', 'universal', 'numbersign', 'existential', 'percent', 'ampersand', 'suchthat', 'parenleft', 'parenright', 'asteriskmath', 'plus', 'comma', 'minus', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'congruent', 'Alpha', 'Beta', 'Chi', 'Delta', 'Epsilon', 'Phi', 'Gamma', 'Eta', 'Iota', 'theta1', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Omicron', 'Pi', 'Theta', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'sigma1', 'Omega', 'Xi', 'Psi', 'Zeta', 'bracketleft', 'therefore', 'bracketright', 'perpendicular', 'underscore', 'radicalex', 'alpha', 'beta', 'chi', 'delta', 'epsilon', 'phi', 'gamma', 'eta', 'iota', 'phi1', 'kappa', 'lambda', 'mu', 'nu', 'omicron', 'pi', 'theta', 'rho', 'sigma', 'tau', 'upsilon', 'omega1', 'omega', 'xi', 'psi', 'zeta', 'braceleft', 'bar', 'braceright', 'similar', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'Euro', 'Upsilon1', 'minute', 'lessequal', 'fraction', 'infinity', 'florin', 'club', 'diamond', 'heart', 'spade', 'arrowboth', 'arrowleft', 'arrowup', 'arrowright', 'arrowdown', 'degree', 'plusminus', 'second', 'greaterequal', 'multiply', 'proportional', 'partialdiff', 'bullet', 'divide', 'notequal', 'equivalence', 'approxequal', 'ellipsis', 'arrowvertex', 'arrowhorizex', 'carriagereturn', 'aleph', 'Ifraktur', 'Rfraktur', 'weierstrass', 'circlemultiply', 'circleplus', 'emptyset', 'intersection', 'union', 'propersuperset', 'reflexsuperset', 'notsubset', 'propersubset', 'reflexsubset', 'element', 'notelement', 'angle', 'gradient', 'registerserif', 'copyrightserif', 'trademarkserif', 'product', 'radical', 'dotmath', 'logicalnot', 'logicaland', 'logicalor', 'arrowdblboth', 'arrowdblleft', 'arrowdblup', 'arrowdblright', 'arrowdbldown', 'lozenge', 'angleleft', 'registersans', 'copyrightsans', 'trademarksans', 'summation', 'parenlefttp', 'parenleftex', 'parenleftbt', 'bracketlefttp', 'bracketleftex', 'bracketleftbt', 'bracelefttp', 'braceleftmid', 'braceleftbt', 'braceex', '', 'angleright', 'integral', 'integraltp', 'integralex', 'integralbt', 'parenrighttp', 'parenrightex', 'parenrightbt', 'bracketrighttp', 'bracketrightex', 'bracketrightbt', 'bracerighttp', 'bracerightmid', 'bracerightbt'],
                ZapfDingbatsEncoding: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'a1', 'a2', 'a202', 'a3', 'a4', 'a5', 'a119', 'a118', 'a117', 'a11', 'a12', 'a13', 'a14', 'a15', 'a16', 'a105', 'a17', 'a18', 'a19', 'a20', 'a21', 'a22', 'a23', 'a24', 'a25', 'a26', 'a27', 'a28', 'a6', 'a7', 'a8', 'a9', 'a10', 'a29', 'a30', 'a31', 'a32', 'a33', 'a34', 'a35', 'a36', 'a37', 'a38', 'a39', 'a40', 'a41', 'a42', 'a43', 'a44', 'a45', 'a46', 'a47', 'a48', 'a49', 'a50', 'a51', 'a52', 'a53', 'a54', 'a55', 'a56', 'a57', 'a58', 'a59', 'a60', 'a61', 'a62', 'a63', 'a64', 'a65', 'a66', 'a67', 'a68', 'a69', 'a70', 'a71', 'a72', 'a73', 'a74', 'a203', 'a75', 'a204', 'a76', 'a77', 'a78', 'a79', 'a81', 'a82', 'a83', 'a84', 'a97', 'a98', 'a99', 'a100', '', 'a89', 'a90', 'a93', 'a94', 'a91', 'a92', 'a205', 'a85', 'a206', 'a86', 'a87', 'a88', 'a95', 'a96', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'a101', 'a102', 'a103', 'a104', 'a106', 'a107', 'a108', 'a112', 'a111', 'a110', 'a109', 'a120', 'a121', 'a122', 'a123', 'a124', 'a125', 'a126', 'a127', 'a128', 'a129', 'a130', 'a131', 'a132', 'a133', 'a134', 'a135', 'a136', 'a137', 'a138', 'a139', 'a140', 'a141', 'a142', 'a143', 'a144', 'a145', 'a146', 'a147', 'a148', 'a149', 'a150', 'a151', 'a152', 'a153', 'a154', 'a155', 'a156', 'a157', 'a158', 'a159', 'a160', 'a161', 'a163', 'a164', 'a196', 'a165', 'a192', 'a166', 'a167', 'a168', 'a169', 'a170', 'a171', 'a172', 'a173', 'a162', 'a174', 'a175', 'a176', 'a177', 'a178', 'a179', 'a193', 'a180', 'a199', 'a181', 'a200', 'a182', '', 'a201', 'a183', 'a184', 'a197', 'a185', 'a194', 'a198', 'a186', 'a195', 'a187', 'a188', 'a189', 'a190', 'a191']
            };
            var stdFontMap = {
                'ArialNarrow': 'Helvetica',
                'ArialNarrow-Bold': 'Helvetica-Bold',
                'ArialNarrow-BoldItalic': 'Helvetica-BoldOblique',
                'ArialNarrow-Italic': 'Helvetica-Oblique',
                'ArialBlack': 'Helvetica',
                'ArialBlack-Bold': 'Helvetica-Bold',
                'ArialBlack-BoldItalic': 'Helvetica-BoldOblique',
                'ArialBlack-Italic': 'Helvetica-Oblique',
                'Arial': 'Helvetica',
                'Arial-Bold': 'Helvetica-Bold',
                'Arial-BoldItalic': 'Helvetica-BoldOblique',
                'Arial-Italic': 'Helvetica-Oblique',
                'Arial-BoldItalicMT': 'Helvetica-BoldOblique',
                'Arial-BoldMT': 'Helvetica-Bold',
                'Arial-ItalicMT': 'Helvetica-Oblique',
                'ArialMT': 'Helvetica',
                'Courier-Bold': 'Courier-Bold',
                'Courier-BoldItalic': 'Courier-BoldOblique',
                'Courier-Italic': 'Courier-Oblique',
                'CourierNew': 'Courier',
                'CourierNew-Bold': 'Courier-Bold',
                'CourierNew-BoldItalic': 'Courier-BoldOblique',
                'CourierNew-Italic': 'Courier-Oblique',
                'CourierNewPS-BoldItalicMT': 'Courier-BoldOblique',
                'CourierNewPS-BoldMT': 'Courier-Bold',
                'CourierNewPS-ItalicMT': 'Courier-Oblique',
                'CourierNewPSMT': 'Courier',
                'Helvetica': 'Helvetica',
                'Helvetica-Bold': 'Helvetica-Bold',
                'Helvetica-BoldItalic': 'Helvetica-BoldOblique',
                'Helvetica-BoldOblique': 'Helvetica-BoldOblique',
                'Helvetica-Italic': 'Helvetica-Oblique',
                'Helvetica-Oblique': 'Helvetica-Oblique',
                'Symbol-Bold': 'Symbol',
                'Symbol-BoldItalic': 'Symbol',
                'Symbol-Italic': 'Symbol',
                'TimesNewRoman': 'Times-Roman',
                'TimesNewRoman-Bold': 'Times-Bold',
                'TimesNewRoman-BoldItalic': 'Times-BoldItalic',
                'TimesNewRoman-Italic': 'Times-Italic',
                'TimesNewRomanPS': 'Times-Roman',
                'TimesNewRomanPS-Bold': 'Times-Bold',
                'TimesNewRomanPS-BoldItalic': 'Times-BoldItalic',
                'TimesNewRomanPS-BoldItalicMT': 'Times-BoldItalic',
                'TimesNewRomanPS-BoldMT': 'Times-Bold',
                'TimesNewRomanPS-Italic': 'Times-Italic',
                'TimesNewRomanPS-ItalicMT': 'Times-Italic',
                'TimesNewRomanPSMT': 'Times-Roman',
                'TimesNewRomanPSMT-Bold': 'Times-Bold',
                'TimesNewRomanPSMT-BoldItalic': 'Times-BoldItalic',
                'TimesNewRomanPSMT-Italic': 'Times-Italic'
            };
            var nonStdFontMap = {
                'CenturyGothic': 'Helvetica',
                'CenturyGothic-Bold': 'Helvetica-Bold',
                'CenturyGothic-BoldItalic': 'Helvetica-BoldOblique',
                'CenturyGothic-Italic': 'Helvetica-Oblique',
                'ComicSansMS': 'Comic Sans MS',
                'ComicSansMS-Bold': 'Comic Sans MS-Bold',
                'ComicSansMS-BoldItalic': 'Comic Sans MS-BoldItalic',
                'ComicSansMS-Italic': 'Comic Sans MS-Italic',
                'LucidaConsole': 'Courier',
                'LucidaConsole-Bold': 'Courier-Bold',
                'LucidaConsole-BoldItalic': 'Courier-BoldOblique',
                'LucidaConsole-Italic': 'Courier-Oblique',
                'MS-Gothic': 'MS Gothic',
                'MS-Gothic-Bold': 'MS Gothic-Bold',
                'MS-Gothic-BoldItalic': 'MS Gothic-BoldItalic',
                'MS-Gothic-Italic': 'MS Gothic-Italic',
                'MS-Mincho': 'MS Mincho',
                'MS-Mincho-Bold': 'MS Mincho-Bold',
                'MS-Mincho-BoldItalic': 'MS Mincho-BoldItalic',
                'MS-Mincho-Italic': 'MS Mincho-Italic',
                'MS-PGothic': 'MS PGothic',
                'MS-PGothic-Bold': 'MS PGothic-Bold',
                'MS-PGothic-BoldItalic': 'MS PGothic-BoldItalic',
                'MS-PGothic-Italic': 'MS PGothic-Italic',
                'MS-PMincho': 'MS PMincho',
                'MS-PMincho-Bold': 'MS PMincho-Bold',
                'MS-PMincho-BoldItalic': 'MS PMincho-BoldItalic',
                'MS-PMincho-Italic': 'MS PMincho-Italic',
                'Wingdings': 'ZapfDingbats'
            };
            var serifFonts = {
                'Adobe Jenson': true,
                'Adobe Text': true,
                'Albertus': true,
                'Aldus': true,
                'Alexandria': true,
                'Algerian': true,
                'American Typewriter': true,
                'Antiqua': true,
                'Apex': true,
                'Arno': true,
                'Aster': true,
                'Aurora': true,
                'Baskerville': true,
                'Bell': true,
                'Bembo': true,
                'Bembo Schoolbook': true,
                'Benguiat': true,
                'Berkeley Old Style': true,
                'Bernhard Modern': true,
                'Berthold City': true,
                'Bodoni': true,
                'Bauer Bodoni': true,
                'Book Antiqua': true,
                'Bookman': true,
                'Bordeaux Roman': true,
                'Californian FB': true,
                'Calisto': true,
                'Calvert': true,
                'Capitals': true,
                'Cambria': true,
                'Cartier': true,
                'Caslon': true,
                'Catull': true,
                'Centaur': true,
                'Century Old Style': true,
                'Century Schoolbook': true,
                'Chaparral': true,
                'Charis SIL': true,
                'Cheltenham': true,
                'Cholla Slab': true,
                'Clarendon': true,
                'Clearface': true,
                'Cochin': true,
                'Colonna': true,
                'Computer Modern': true,
                'Concrete Roman': true,
                'Constantia': true,
                'Cooper Black': true,
                'Corona': true,
                'Ecotype': true,
                'Egyptienne': true,
                'Elephant': true,
                'Excelsior': true,
                'Fairfield': true,
                'FF Scala': true,
                'Folkard': true,
                'Footlight': true,
                'FreeSerif': true,
                'Friz Quadrata': true,
                'Garamond': true,
                'Gentium': true,
                'Georgia': true,
                'Gloucester': true,
                'Goudy Old Style': true,
                'Goudy Schoolbook': true,
                'Goudy Pro Font': true,
                'Granjon': true,
                'Guardian Egyptian': true,
                'Heather': true,
                'Hercules': true,
                'High Tower Text': true,
                'Hiroshige': true,
                'Hoefler Text': true,
                'Humana Serif': true,
                'Imprint': true,
                'Ionic No. 5': true,
                'Janson': true,
                'Joanna': true,
                'Korinna': true,
                'Lexicon': true,
                'Liberation Serif': true,
                'Linux Libertine': true,
                'Literaturnaya': true,
                'Lucida': true,
                'Lucida Bright': true,
                'Melior': true,
                'Memphis': true,
                'Miller': true,
                'Minion': true,
                'Modern': true,
                'Mona Lisa': true,
                'Mrs Eaves': true,
                'MS Serif': true,
                'Museo Slab': true,
                'New York': true,
                'Nimbus Roman': true,
                'NPS Rawlinson Roadway': true,
                'Palatino': true,
                'Perpetua': true,
                'Plantin': true,
                'Plantin Schoolbook': true,
                'Playbill': true,
                'Poor Richard': true,
                'Rawlinson Roadway': true,
                'Renault': true,
                'Requiem': true,
                'Rockwell': true,
                'Roman': true,
                'Rotis Serif': true,
                'Sabon': true,
                'Scala': true,
                'Seagull': true,
                'Sistina': true,
                'Souvenir': true,
                'STIX': true,
                'Stone Informal': true,
                'Stone Serif': true,
                'Sylfaen': true,
                'Times': true,
                'Trajan': true,
                'Trinité': true,
                'Trump Mediaeval': true,
                'Utopia': true,
                'Vale Type': true,
                'Bitstream Vera': true,
                'Vera Serif': true,
                'Versailles': true,
                'Wanted': true,
                'Weiss': true,
                'Wide Latin': true,
                'Windsor': true,
                'XITS': true
            };
            var symbolsFonts = {
                'Dingbats': true,
                'Symbol': true,
                'ZapfDingbats': true
            };
            var GlyphMapForStandardFonts = {
                '2': 10,
                '3': 32,
                '4': 33,
                '5': 34,
                '6': 35,
                '7': 36,
                '8': 37,
                '9': 38,
                '10': 39,
                '11': 40,
                '12': 41,
                '13': 42,
                '14': 43,
                '15': 44,
                '16': 45,
                '17': 46,
                '18': 47,
                '19': 48,
                '20': 49,
                '21': 50,
                '22': 51,
                '23': 52,
                '24': 53,
                '25': 54,
                '26': 55,
                '27': 56,
                '28': 57,
                '29': 58,
                '30': 894,
                '31': 60,
                '32': 61,
                '33': 62,
                '34': 63,
                '35': 64,
                '36': 65,
                '37': 66,
                '38': 67,
                '39': 68,
                '40': 69,
                '41': 70,
                '42': 71,
                '43': 72,
                '44': 73,
                '45': 74,
                '46': 75,
                '47': 76,
                '48': 77,
                '49': 78,
                '50': 79,
                '51': 80,
                '52': 81,
                '53': 82,
                '54': 83,
                '55': 84,
                '56': 85,
                '57': 86,
                '58': 87,
                '59': 88,
                '60': 89,
                '61': 90,
                '62': 91,
                '63': 92,
                '64': 93,
                '65': 94,
                '66': 95,
                '67': 96,
                '68': 97,
                '69': 98,
                '70': 99,
                '71': 100,
                '72': 101,
                '73': 102,
                '74': 103,
                '75': 104,
                '76': 105,
                '77': 106,
                '78': 107,
                '79': 108,
                '80': 109,
                '81': 110,
                '82': 111,
                '83': 112,
                '84': 113,
                '85': 114,
                '86': 115,
                '87': 116,
                '88': 117,
                '89': 118,
                '90': 119,
                '91': 120,
                '92': 121,
                '93': 122,
                '94': 123,
                '95': 124,
                '96': 125,
                '97': 126,
                '98': 196,
                '99': 197,
                '100': 199,
                '101': 201,
                '102': 209,
                '103': 214,
                '104': 220,
                '105': 225,
                '106': 224,
                '107': 226,
                '108': 228,
                '109': 227,
                '110': 229,
                '111': 231,
                '112': 233,
                '113': 232,
                '114': 234,
                '115': 235,
                '116': 237,
                '117': 236,
                '118': 238,
                '119': 239,
                '120': 241,
                '121': 243,
                '122': 242,
                '123': 244,
                '124': 246,
                '125': 245,
                '126': 250,
                '127': 249,
                '128': 251,
                '129': 252,
                '130': 8224,
                '131': 176,
                '132': 162,
                '133': 163,
                '134': 167,
                '135': 8226,
                '136': 182,
                '137': 223,
                '138': 174,
                '139': 169,
                '140': 8482,
                '141': 180,
                '142': 168,
                '143': 8800,
                '144': 198,
                '145': 216,
                '146': 8734,
                '147': 177,
                '148': 8804,
                '149': 8805,
                '150': 165,
                '151': 181,
                '152': 8706,
                '153': 8721,
                '154': 8719,
                '156': 8747,
                '157': 170,
                '158': 186,
                '159': 8486,
                '160': 230,
                '161': 248,
                '162': 191,
                '163': 161,
                '164': 172,
                '165': 8730,
                '166': 402,
                '167': 8776,
                '168': 8710,
                '169': 171,
                '170': 187,
                '171': 8230,
                '210': 218,
                '223': 711,
                '224': 321,
                '225': 322,
                '227': 353,
                '229': 382,
                '234': 253,
                '252': 263,
                '253': 268,
                '254': 269,
                '258': 258,
                '260': 260,
                '261': 261,
                '265': 280,
                '266': 281,
                '268': 283,
                '269': 313,
                '275': 323,
                '276': 324,
                '278': 328,
                '284': 345,
                '285': 346,
                '286': 347,
                '292': 367,
                '295': 377,
                '296': 378,
                '298': 380,
                '305': 963,
                '306': 964,
                '307': 966,
                '308': 8215,
                '309': 8252,
                '310': 8319,
                '311': 8359,
                '312': 8592,
                '313': 8593,
                '337': 9552,
                '493': 1039,
                '494': 1040,
                '705': 1524,
                '706': 8362,
                '710': 64288,
                '711': 64298,
                '759': 1617,
                '761': 1776,
                '763': 1778,
                '775': 1652,
                '777': 1764,
                '778': 1780,
                '779': 1781,
                '780': 1782,
                '782': 771,
                '783': 64726,
                '786': 8363,
                '788': 8532,
                '790': 768,
                '791': 769,
                '792': 768,
                '795': 803,
                '797': 64336,
                '798': 64337,
                '799': 64342,
                '800': 64343,
                '801': 64344,
                '802': 64345,
                '803': 64362,
                '804': 64363,
                '805': 64364,
                '2424': 7821,
                '2425': 7822,
                '2426': 7823,
                '2427': 7824,
                '2428': 7825,
                '2429': 7826,
                '2430': 7827,
                '2433': 7682,
                '2678': 8045,
                '2679': 8046,
                '2830': 1552,
                '2838': 686,
                '2840': 751,
                '2842': 753,
                '2843': 754,
                '2844': 755,
                '2846': 757,
                '2856': 767,
                '2857': 848,
                '2858': 849,
                '2862': 853,
                '2863': 854,
                '2864': 855,
                '2865': 861,
                '2866': 862,
                '2906': 7460,
                '2908': 7462,
                '2909': 7463,
                '2910': 7464,
                '2912': 7466,
                '2913': 7467,
                '2914': 7468,
                '2916': 7470,
                '2917': 7471,
                '2918': 7472,
                '2920': 7474,
                '2921': 7475,
                '2922': 7476,
                '2924': 7478,
                '2925': 7479,
                '2926': 7480,
                '2928': 7482,
                '2929': 7483,
                '2930': 7484,
                '2932': 7486,
                '2933': 7487,
                '2934': 7488,
                '2936': 7490,
                '2937': 7491,
                '2938': 7492,
                '2940': 7494,
                '2941': 7495,
                '2942': 7496,
                '2944': 7498,
                '2946': 7500,
                '2948': 7502,
                '2950': 7504,
                '2951': 7505,
                '2952': 7506,
                '2954': 7508,
                '2955': 7509,
                '2956': 7510,
                '2958': 7512,
                '2959': 7513,
                '2960': 7514,
                '2962': 7516,
                '2963': 7517,
                '2964': 7518,
                '2966': 7520,
                '2967': 7521,
                '2968': 7522,
                '2970': 7524,
                '2971': 7525,
                '2972': 7526,
                '2974': 7528,
                '2975': 7529,
                '2976': 7530,
                '2978': 1537,
                '2979': 1538,
                '2980': 1539,
                '2982': 1549,
                '2983': 1551,
                '2984': 1552,
                '2986': 1554,
                '2987': 1555,
                '2988': 1556,
                '2990': 1623,
                '2991': 1624,
                '2995': 1775,
                '2999': 1791,
                '3002': 64290,
                '3003': 64291,
                '3004': 64292,
                '3006': 64294,
                '3007': 64295,
                '3008': 64296,
                '3011': 1900,
                '3014': 8223,
                '3015': 8244,
                '3017': 7532,
                '3018': 7533,
                '3019': 7534,
                '3075': 7590,
                '3076': 7591,
                '3079': 7594,
                '3080': 7595,
                '3083': 7598,
                '3084': 7599,
                '3087': 7602,
                '3088': 7603,
                '3091': 7606,
                '3092': 7607,
                '3095': 7610,
                '3096': 7611,
                '3099': 7614,
                '3100': 7615,
                '3103': 7618,
                '3104': 7619,
                '3107': 8337,
                '3108': 8338,
                '3116': 1884,
                '3119': 1885,
                '3120': 1885,
                '3123': 1886,
                '3124': 1886,
                '3127': 1887,
                '3128': 1887,
                '3131': 1888,
                '3132': 1888,
                '3135': 1889,
                '3136': 1889,
                '3139': 1890,
                '3140': 1890,
                '3143': 1891,
                '3144': 1891,
                '3147': 1892,
                '3148': 1892,
                '3153': 580,
                '3154': 581,
                '3157': 584,
                '3158': 585,
                '3161': 588,
                '3162': 589,
                '3165': 891,
                '3166': 892,
                '3169': 1274,
                '3170': 1275,
                '3173': 1278,
                '3174': 1279,
                '3181': 7622,
                '3182': 7623,
                '3282': 11799,
                '3316': 578,
                '3379': 42785,
                '3393': 1159,
                '3416': 8377
            };
            var SupplementalGlyphMapForArialBlack = {
                '227': 322,
                '264': 261,
                '291': 346,
            };
            var SpecialPUASymbols = {
                '63721': 0x00A9,
                '63193': 0x00A9,
                '63720': 0x00AE,
                '63194': 0x00AE,
                '63722': 0x2122,
                '63195': 0x2122,
                '63729': 0x23A7,
                '63730': 0x23A8,
                '63731': 0x23A9,
                '63740': 0x23AB,
                '63741': 0x23AC,
                '63742': 0x23AD,
                '63726': 0x23A1,
                '63727': 0x23A2,
                '63728': 0x23A3,
                '63737': 0x23A4,
                '63738': 0x23A5,
                '63739': 0x23A6,
                '63723': 0x239B,
                '63724': 0x239C,
                '63725': 0x239D,
                '63734': 0x239E,
                '63735': 0x239F,
                '63736': 0x23A0,
            };

            function mapSpecialUnicodeValues(code) {
                if (code >= 0xFFF0 && code <= 0xFFFF) {
                    return 0;
                } else if (code >= 0xF600 && code <= 0xF8FF) {
                    return (SpecialPUASymbols[code] || code);
                }
                return code;
            }
            var UnicodeRanges = [{
                'begin': 0x0000,
                'end': 0x007F
            }, {
                'begin': 0x0080,
                'end': 0x00FF
            }, {
                'begin': 0x0100,
                'end': 0x017F
            }, {
                'begin': 0x0180,
                'end': 0x024F
            }, {
                'begin': 0x0250,
                'end': 0x02AF
            }, {
                'begin': 0x02B0,
                'end': 0x02FF
            }, {
                'begin': 0x0300,
                'end': 0x036F
            }, {
                'begin': 0x0370,
                'end': 0x03FF
            }, {
                'begin': 0x2C80,
                'end': 0x2CFF
            }, {
                'begin': 0x0400,
                'end': 0x04FF
            }, {
                'begin': 0x0530,
                'end': 0x058F
            }, {
                'begin': 0x0590,
                'end': 0x05FF
            }, {
                'begin': 0xA500,
                'end': 0xA63F
            }, {
                'begin': 0x0600,
                'end': 0x06FF
            }, {
                'begin': 0x07C0,
                'end': 0x07FF
            }, {
                'begin': 0x0900,
                'end': 0x097F
            }, {
                'begin': 0x0980,
                'end': 0x09FF
            }, {
                'begin': 0x0A00,
                'end': 0x0A7F
            }, {
                'begin': 0x0A80,
                'end': 0x0AFF
            }, {
                'begin': 0x0B00,
                'end': 0x0B7F
            }, {
                'begin': 0x0B80,
                'end': 0x0BFF
            }, {
                'begin': 0x0C00,
                'end': 0x0C7F
            }, {
                'begin': 0x0C80,
                'end': 0x0CFF
            }, {
                'begin': 0x0D00,
                'end': 0x0D7F
            }, {
                'begin': 0x0E00,
                'end': 0x0E7F
            }, {
                'begin': 0x0E80,
                'end': 0x0EFF
            }, {
                'begin': 0x10A0,
                'end': 0x10FF
            }, {
                'begin': 0x1B00,
                'end': 0x1B7F
            }, {
                'begin': 0x1100,
                'end': 0x11FF
            }, {
                'begin': 0x1E00,
                'end': 0x1EFF
            }, {
                'begin': 0x1F00,
                'end': 0x1FFF
            }, {
                'begin': 0x2000,
                'end': 0x206F
            }, {
                'begin': 0x2070,
                'end': 0x209F
            }, {
                'begin': 0x20A0,
                'end': 0x20CF
            }, {
                'begin': 0x20D0,
                'end': 0x20FF
            }, {
                'begin': 0x2100,
                'end': 0x214F
            }, {
                'begin': 0x2150,
                'end': 0x218F
            }, {
                'begin': 0x2190,
                'end': 0x21FF
            }, {
                'begin': 0x2200,
                'end': 0x22FF
            }, {
                'begin': 0x2300,
                'end': 0x23FF
            }, {
                'begin': 0x2400,
                'end': 0x243F
            }, {
                'begin': 0x2440,
                'end': 0x245F
            }, {
                'begin': 0x2460,
                'end': 0x24FF
            }, {
                'begin': 0x2500,
                'end': 0x257F
            }, {
                'begin': 0x2580,
                'end': 0x259F
            }, {
                'begin': 0x25A0,
                'end': 0x25FF
            }, {
                'begin': 0x2600,
                'end': 0x26FF
            }, {
                'begin': 0x2700,
                'end': 0x27BF
            }, {
                'begin': 0x3000,
                'end': 0x303F
            }, {
                'begin': 0x3040,
                'end': 0x309F
            }, {
                'begin': 0x30A0,
                'end': 0x30FF
            }, {
                'begin': 0x3100,
                'end': 0x312F
            }, {
                'begin': 0x3130,
                'end': 0x318F
            }, {
                'begin': 0xA840,
                'end': 0xA87F
            }, {
                'begin': 0x3200,
                'end': 0x32FF
            }, {
                'begin': 0x3300,
                'end': 0x33FF
            }, {
                'begin': 0xAC00,
                'end': 0xD7AF
            }, {
                'begin': 0xD800,
                'end': 0xDFFF
            }, {
                'begin': 0x10900,
                'end': 0x1091F
            }, {
                'begin': 0x4E00,
                'end': 0x9FFF
            }, {
                'begin': 0xE000,
                'end': 0xF8FF
            }, {
                'begin': 0x31C0,
                'end': 0x31EF
            }, {
                'begin': 0xFB00,
                'end': 0xFB4F
            }, {
                'begin': 0xFB50,
                'end': 0xFDFF
            }, {
                'begin': 0xFE20,
                'end': 0xFE2F
            }, {
                'begin': 0xFE10,
                'end': 0xFE1F
            }, {
                'begin': 0xFE50,
                'end': 0xFE6F
            }, {
                'begin': 0xFE70,
                'end': 0xFEFF
            }, {
                'begin': 0xFF00,
                'end': 0xFFEF
            }, {
                'begin': 0xFFF0,
                'end': 0xFFFF
            }, {
                'begin': 0x0F00,
                'end': 0x0FFF
            }, {
                'begin': 0x0700,
                'end': 0x074F
            }, {
                'begin': 0x0780,
                'end': 0x07BF
            }, {
                'begin': 0x0D80,
                'end': 0x0DFF
            }, {
                'begin': 0x1000,
                'end': 0x109F
            }, {
                'begin': 0x1200,
                'end': 0x137F
            }, {
                'begin': 0x13A0,
                'end': 0x13FF
            }, {
                'begin': 0x1400,
                'end': 0x167F
            }, {
                'begin': 0x1680,
                'end': 0x169F
            }, {
                'begin': 0x16A0,
                'end': 0x16FF
            }, {
                'begin': 0x1780,
                'end': 0x17FF
            }, {
                'begin': 0x1800,
                'end': 0x18AF
            }, {
                'begin': 0x2800,
                'end': 0x28FF
            }, {
                'begin': 0xA000,
                'end': 0xA48F
            }, {
                'begin': 0x1700,
                'end': 0x171F
            }, {
                'begin': 0x10300,
                'end': 0x1032F
            }, {
                'begin': 0x10330,
                'end': 0x1034F
            }, {
                'begin': 0x10400,
                'end': 0x1044F
            }, {
                'begin': 0x1D000,
                'end': 0x1D0FF
            }, {
                'begin': 0x1D400,
                'end': 0x1D7FF
            }, {
                'begin': 0xFF000,
                'end': 0xFFFFD
            }, {
                'begin': 0xFE00,
                'end': 0xFE0F
            }, {
                'begin': 0xE0000,
                'end': 0xE007F
            }, {
                'begin': 0x1900,
                'end': 0x194F
            }, {
                'begin': 0x1950,
                'end': 0x197F
            }, {
                'begin': 0x1980,
                'end': 0x19DF
            }, {
                'begin': 0x1A00,
                'end': 0x1A1F
            }, {
                'begin': 0x2C00,
                'end': 0x2C5F
            }, {
                'begin': 0x2D30,
                'end': 0x2D7F
            }, {
                'begin': 0x4DC0,
                'end': 0x4DFF
            }, {
                'begin': 0xA800,
                'end': 0xA82F
            }, {
                'begin': 0x10000,
                'end': 0x1007F
            }, {
                'begin': 0x10140,
                'end': 0x1018F
            }, {
                'begin': 0x10380,
                'end': 0x1039F
            }, {
                'begin': 0x103A0,
                'end': 0x103DF
            }, {
                'begin': 0x10450,
                'end': 0x1047F
            }, {
                'begin': 0x10480,
                'end': 0x104AF
            }, {
                'begin': 0x10800,
                'end': 0x1083F
            }, {
                'begin': 0x10A00,
                'end': 0x10A5F
            }, {
                'begin': 0x1D300,
                'end': 0x1D35F
            }, {
                'begin': 0x12000,
                'end': 0x123FF
            }, {
                'begin': 0x1D360,
                'end': 0x1D37F
            }, {
                'begin': 0x1B80,
                'end': 0x1BBF
            }, {
                'begin': 0x1C00,
                'end': 0x1C4F
            }, {
                'begin': 0x1C50,
                'end': 0x1C7F
            }, {
                'begin': 0xA880,
                'end': 0xA8DF
            }, {
                'begin': 0xA900,
                'end': 0xA92F
            }, {
                'begin': 0xA930,
                'end': 0xA95F
            }, {
                'begin': 0xAA00,
                'end': 0xAA5F
            }, {
                'begin': 0x10190,
                'end': 0x101CF
            }, {
                'begin': 0x101D0,
                'end': 0x101FF
            }, {
                'begin': 0x102A0,
                'end': 0x102DF
            }, {
                'begin': 0x1F030,
                'end': 0x1F09F
            }];
            var MacStandardGlyphOrdering = ['.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave', 'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis', 'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis', 'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section', 'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal', 'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation', 'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown', 'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright', 'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft', 'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction', 'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase', 'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex', 'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth', 'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior', 'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla', 'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];

            function getUnicodeRangeFor(value) {
                for (var i = 0, ii = UnicodeRanges.length; i < ii; i++) {
                    var range = UnicodeRanges[i];
                    if (value >= range.begin && value < range.end) {
                        return i;
                    }
                }
                return -1;
            }

            function isRTLRangeFor(value) {
                var range = UnicodeRanges[13];
                if (value >= range.begin && value < range.end) {
                    return true;
                }
                range = UnicodeRanges[11];
                if (value >= range.begin && value < range.end) {
                    return true;
                }
                return false;
            }
            var NormalizedUnicodes = {
                '\u00A8': '\u0020\u0308',
                '\u00AF': '\u0020\u0304',
                '\u00B4': '\u0020\u0301',
                '\u00B5': '\u03BC',
                '\u00B8': '\u0020\u0327',
                '\u0132': '\u0049\u004A',
                '\u0133': '\u0069\u006A',
                '\u013F': '\u004C\u00B7',
                '\u0140': '\u006C\u00B7',
                '\u0149': '\u02BC\u006E',
                '\u017F': '\u0073',
                '\u01C4': '\u0044\u017D',
                '\u01C5': '\u0044\u017E',
                '\u01C6': '\u0064\u017E',
                '\u01C7': '\u004C\u004A',
                '\u01C8': '\u004C\u006A',
                '\u01C9': '\u006C\u006A',
                '\u01CA': '\u004E\u004A',
                '\u01CB': '\u004E\u006A',
                '\u01CC': '\u006E\u006A',
                '\u01F1': '\u0044\u005A',
                '\u01F2': '\u0044\u007A',
                '\u01F3': '\u0064\u007A',
                '\u02D8': '\u0020\u0306',
                '\u02D9': '\u0020\u0307',
                '\u02DA': '\u0020\u030A',
                '\u02DB': '\u0020\u0328',
                '\u02DC': '\u0020\u0303',
                '\u02DD': '\u0020\u030B',
                '\u037A': '\u0020\u0345',
                '\u0384': '\u0020\u0301',
                '\u03D0': '\u03B2',
                '\u03D1': '\u03B8',
                '\u03D2': '\u03A5',
                '\u03D5': '\u03C6',
                '\u03D6': '\u03C0',
                '\u03F0': '\u03BA',
                '\u03F1': '\u03C1',
                '\u03F2': '\u03C2',
                '\u03F4': '\u0398',
                '\u03F5': '\u03B5',
                '\u03F9': '\u03A3',
                '\u0587': '\u0565\u0582',
                '\u0675': '\u0627\u0674',
                '\u0676': '\u0648\u0674',
                '\u0677': '\u06C7\u0674',
                '\u0678': '\u064A\u0674',
                '\u0E33': '\u0E4D\u0E32',
                '\u0EB3': '\u0ECD\u0EB2',
                '\u0EDC': '\u0EAB\u0E99',
                '\u0EDD': '\u0EAB\u0EA1',
                '\u0F77': '\u0FB2\u0F81',
                '\u0F79': '\u0FB3\u0F81',
                '\u1E9A': '\u0061\u02BE',
                '\u1FBD': '\u0020\u0313',
                '\u1FBF': '\u0020\u0313',
                '\u1FC0': '\u0020\u0342',
                '\u1FFE': '\u0020\u0314',
                '\u2002': '\u0020',
                '\u2003': '\u0020',
                '\u2004': '\u0020',
                '\u2005': '\u0020',
                '\u2006': '\u0020',
                '\u2008': '\u0020',
                '\u2009': '\u0020',
                '\u200A': '\u0020',
                '\u2017': '\u0020\u0333',
                '\u2024': '\u002E',
                '\u2025': '\u002E\u002E',
                '\u2026': '\u002E\u002E\u002E',
                '\u2033': '\u2032\u2032',
                '\u2034': '\u2032\u2032\u2032',
                '\u2036': '\u2035\u2035',
                '\u2037': '\u2035\u2035\u2035',
                '\u203C': '\u0021\u0021',
                '\u203E': '\u0020\u0305',
                '\u2047': '\u003F\u003F',
                '\u2048': '\u003F\u0021',
                '\u2049': '\u0021\u003F',
                '\u2057': '\u2032\u2032\u2032\u2032',
                '\u205F': '\u0020',
                '\u20A8': '\u0052\u0073',
                '\u2100': '\u0061\u002F\u0063',
                '\u2101': '\u0061\u002F\u0073',
                '\u2103': '\u00B0\u0043',
                '\u2105': '\u0063\u002F\u006F',
                '\u2106': '\u0063\u002F\u0075',
                '\u2107': '\u0190',
                '\u2109': '\u00B0\u0046',
                '\u2116': '\u004E\u006F',
                '\u2121': '\u0054\u0045\u004C',
                '\u2135': '\u05D0',
                '\u2136': '\u05D1',
                '\u2137': '\u05D2',
                '\u2138': '\u05D3',
                '\u213B': '\u0046\u0041\u0058',
                '\u2160': '\u0049',
                '\u2161': '\u0049\u0049',
                '\u2162': '\u0049\u0049\u0049',
                '\u2163': '\u0049\u0056',
                '\u2164': '\u0056',
                '\u2165': '\u0056\u0049',
                '\u2166': '\u0056\u0049\u0049',
                '\u2167': '\u0056\u0049\u0049\u0049',
                '\u2168': '\u0049\u0058',
                '\u2169': '\u0058',
                '\u216A': '\u0058\u0049',
                '\u216B': '\u0058\u0049\u0049',
                '\u216C': '\u004C',
                '\u216D': '\u0043',
                '\u216E': '\u0044',
                '\u216F': '\u004D',
                '\u2170': '\u0069',
                '\u2171': '\u0069\u0069',
                '\u2172': '\u0069\u0069\u0069',
                '\u2173': '\u0069\u0076',
                '\u2174': '\u0076',
                '\u2175': '\u0076\u0069',
                '\u2176': '\u0076\u0069\u0069',
                '\u2177': '\u0076\u0069\u0069\u0069',
                '\u2178': '\u0069\u0078',
                '\u2179': '\u0078',
                '\u217A': '\u0078\u0069',
                '\u217B': '\u0078\u0069\u0069',
                '\u217C': '\u006C',
                '\u217D': '\u0063',
                '\u217E': '\u0064',
                '\u217F': '\u006D',
                '\u222C': '\u222B\u222B',
                '\u222D': '\u222B\u222B\u222B',
                '\u222F': '\u222E\u222E',
                '\u2230': '\u222E\u222E\u222E',
                '\u2474': '\u0028\u0031\u0029',
                '\u2475': '\u0028\u0032\u0029',
                '\u2476': '\u0028\u0033\u0029',
                '\u2477': '\u0028\u0034\u0029',
                '\u2478': '\u0028\u0035\u0029',
                '\u2479': '\u0028\u0036\u0029',
                '\u247A': '\u0028\u0037\u0029',
                '\u247B': '\u0028\u0038\u0029',
                '\u247C': '\u0028\u0039\u0029',
                '\u247D': '\u0028\u0031\u0030\u0029',
                '\u247E': '\u0028\u0031\u0031\u0029',
                '\u247F': '\u0028\u0031\u0032\u0029',
                '\u2480': '\u0028\u0031\u0033\u0029',
                '\u2481': '\u0028\u0031\u0034\u0029',
                '\u2482': '\u0028\u0031\u0035\u0029',
                '\u2483': '\u0028\u0031\u0036\u0029',
                '\u2484': '\u0028\u0031\u0037\u0029',
                '\u2485': '\u0028\u0031\u0038\u0029',
                '\u2486': '\u0028\u0031\u0039\u0029',
                '\u2487': '\u0028\u0032\u0030\u0029',
                '\u2488': '\u0031\u002E',
                '\u2489': '\u0032\u002E',
                '\u248A': '\u0033\u002E',
                '\u248B': '\u0034\u002E',
                '\u248C': '\u0035\u002E',
                '\u248D': '\u0036\u002E',
                '\u248E': '\u0037\u002E',
                '\u248F': '\u0038\u002E',
                '\u2490': '\u0039\u002E',
                '\u2491': '\u0031\u0030\u002E',
                '\u2492': '\u0031\u0031\u002E',
                '\u2493': '\u0031\u0032\u002E',
                '\u2494': '\u0031\u0033\u002E',
                '\u2495': '\u0031\u0034\u002E',
                '\u2496': '\u0031\u0035\u002E',
                '\u2497': '\u0031\u0036\u002E',
                '\u2498': '\u0031\u0037\u002E',
                '\u2499': '\u0031\u0038\u002E',
                '\u249A': '\u0031\u0039\u002E',
                '\u249B': '\u0032\u0030\u002E',
                '\u249C': '\u0028\u0061\u0029',
                '\u249D': '\u0028\u0062\u0029',
                '\u249E': '\u0028\u0063\u0029',
                '\u249F': '\u0028\u0064\u0029',
                '\u24A0': '\u0028\u0065\u0029',
                '\u24A1': '\u0028\u0066\u0029',
                '\u24A2': '\u0028\u0067\u0029',
                '\u24A3': '\u0028\u0068\u0029',
                '\u24A4': '\u0028\u0069\u0029',
                '\u24A5': '\u0028\u006A\u0029',
                '\u24A6': '\u0028\u006B\u0029',
                '\u24A7': '\u0028\u006C\u0029',
                '\u24A8': '\u0028\u006D\u0029',
                '\u24A9': '\u0028\u006E\u0029',
                '\u24AA': '\u0028\u006F\u0029',
                '\u24AB': '\u0028\u0070\u0029',
                '\u24AC': '\u0028\u0071\u0029',
                '\u24AD': '\u0028\u0072\u0029',
                '\u24AE': '\u0028\u0073\u0029',
                '\u24AF': '\u0028\u0074\u0029',
                '\u24B0': '\u0028\u0075\u0029',
                '\u24B1': '\u0028\u0076\u0029',
                '\u24B2': '\u0028\u0077\u0029',
                '\u24B3': '\u0028\u0078\u0029',
                '\u24B4': '\u0028\u0079\u0029',
                '\u24B5': '\u0028\u007A\u0029',
                '\u2A0C': '\u222B\u222B\u222B\u222B',
                '\u2A74': '\u003A\u003A\u003D',
                '\u2A75': '\u003D\u003D',
                '\u2A76': '\u003D\u003D\u003D',
                '\u2E9F': '\u6BCD',
                '\u2EF3': '\u9F9F',
                '\u2F00': '\u4E00',
                '\u2F01': '\u4E28',
                '\u2F02': '\u4E36',
                '\u2F03': '\u4E3F',
                '\u2F04': '\u4E59',
                '\u2F05': '\u4E85',
                '\u2F06': '\u4E8C',
                '\u2F07': '\u4EA0',
                '\u2F08': '\u4EBA',
                '\u2F09': '\u513F',
                '\u2F0A': '\u5165',
                '\u2F0B': '\u516B',
                '\u2F0C': '\u5182',
                '\u2F0D': '\u5196',
                '\u2F0E': '\u51AB',
                '\u2F0F': '\u51E0',
                '\u2F10': '\u51F5',
                '\u2F11': '\u5200',
                '\u2F12': '\u529B',
                '\u2F13': '\u52F9',
                '\u2F14': '\u5315',
                '\u2F15': '\u531A',
                '\u2F16': '\u5338',
                '\u2F17': '\u5341',
                '\u2F18': '\u535C',
                '\u2F19': '\u5369',
                '\u2F1A': '\u5382',
                '\u2F1B': '\u53B6',
                '\u2F1C': '\u53C8',
                '\u2F1D': '\u53E3',
                '\u2F1E': '\u56D7',
                '\u2F1F': '\u571F',
                '\u2F20': '\u58EB',
                '\u2F21': '\u5902',
                '\u2F22': '\u590A',
                '\u2F23': '\u5915',
                '\u2F24': '\u5927',
                '\u2F25': '\u5973',
                '\u2F26': '\u5B50',
                '\u2F27': '\u5B80',
                '\u2F28': '\u5BF8',
                '\u2F29': '\u5C0F',
                '\u2F2A': '\u5C22',
                '\u2F2B': '\u5C38',
                '\u2F2C': '\u5C6E',
                '\u2F2D': '\u5C71',
                '\u2F2E': '\u5DDB',
                '\u2F2F': '\u5DE5',
                '\u2F30': '\u5DF1',
                '\u2F31': '\u5DFE',
                '\u2F32': '\u5E72',
                '\u2F33': '\u5E7A',
                '\u2F34': '\u5E7F',
                '\u2F35': '\u5EF4',
                '\u2F36': '\u5EFE',
                '\u2F37': '\u5F0B',
                '\u2F38': '\u5F13',
                '\u2F39': '\u5F50',
                '\u2F3A': '\u5F61',
                '\u2F3B': '\u5F73',
                '\u2F3C': '\u5FC3',
                '\u2F3D': '\u6208',
                '\u2F3E': '\u6236',
                '\u2F3F': '\u624B',
                '\u2F40': '\u652F',
                '\u2F41': '\u6534',
                '\u2F42': '\u6587',
                '\u2F43': '\u6597',
                '\u2F44': '\u65A4',
                '\u2F45': '\u65B9',
                '\u2F46': '\u65E0',
                '\u2F47': '\u65E5',
                '\u2F48': '\u66F0',
                '\u2F49': '\u6708',
                '\u2F4A': '\u6728',
                '\u2F4B': '\u6B20',
                '\u2F4C': '\u6B62',
                '\u2F4D': '\u6B79',
                '\u2F4E': '\u6BB3',
                '\u2F4F': '\u6BCB',
                '\u2F50': '\u6BD4',
                '\u2F51': '\u6BDB',
                '\u2F52': '\u6C0F',
                '\u2F53': '\u6C14',
                '\u2F54': '\u6C34',
                '\u2F55': '\u706B',
                '\u2F56': '\u722A',
                '\u2F57': '\u7236',
                '\u2F58': '\u723B',
                '\u2F59': '\u723F',
                '\u2F5A': '\u7247',
                '\u2F5B': '\u7259',
                '\u2F5C': '\u725B',
                '\u2F5D': '\u72AC',
                '\u2F5E': '\u7384',
                '\u2F5F': '\u7389',
                '\u2F60': '\u74DC',
                '\u2F61': '\u74E6',
                '\u2F62': '\u7518',
                '\u2F63': '\u751F',
                '\u2F64': '\u7528',
                '\u2F65': '\u7530',
                '\u2F66': '\u758B',
                '\u2F67': '\u7592',
                '\u2F68': '\u7676',
                '\u2F69': '\u767D',
                '\u2F6A': '\u76AE',
                '\u2F6B': '\u76BF',
                '\u2F6C': '\u76EE',
                '\u2F6D': '\u77DB',
                '\u2F6E': '\u77E2',
                '\u2F6F': '\u77F3',
                '\u2F70': '\u793A',
                '\u2F71': '\u79B8',
                '\u2F72': '\u79BE',
                '\u2F73': '\u7A74',
                '\u2F74': '\u7ACB',
                '\u2F75': '\u7AF9',
                '\u2F76': '\u7C73',
                '\u2F77': '\u7CF8',
                '\u2F78': '\u7F36',
                '\u2F79': '\u7F51',
                '\u2F7A': '\u7F8A',
                '\u2F7B': '\u7FBD',
                '\u2F7C': '\u8001',
                '\u2F7D': '\u800C',
                '\u2F7E': '\u8012',
                '\u2F7F': '\u8033',
                '\u2F80': '\u807F',
                '\u2F81': '\u8089',
                '\u2F82': '\u81E3',
                '\u2F83': '\u81EA',
                '\u2F84': '\u81F3',
                '\u2F85': '\u81FC',
                '\u2F86': '\u820C',
                '\u2F87': '\u821B',
                '\u2F88': '\u821F',
                '\u2F89': '\u826E',
                '\u2F8A': '\u8272',
                '\u2F8B': '\u8278',
                '\u2F8C': '\u864D',
                '\u2F8D': '\u866B',
                '\u2F8E': '\u8840',
                '\u2F8F': '\u884C',
                '\u2F90': '\u8863',
                '\u2F91': '\u897E',
                '\u2F92': '\u898B',
                '\u2F93': '\u89D2',
                '\u2F94': '\u8A00',
                '\u2F95': '\u8C37',
                '\u2F96': '\u8C46',
                '\u2F97': '\u8C55',
                '\u2F98': '\u8C78',
                '\u2F99': '\u8C9D',
                '\u2F9A': '\u8D64',
                '\u2F9B': '\u8D70',
                '\u2F9C': '\u8DB3',
                '\u2F9D': '\u8EAB',
                '\u2F9E': '\u8ECA',
                '\u2F9F': '\u8F9B',
                '\u2FA0': '\u8FB0',
                '\u2FA1': '\u8FB5',
                '\u2FA2': '\u9091',
                '\u2FA3': '\u9149',
                '\u2FA4': '\u91C6',
                '\u2FA5': '\u91CC',
                '\u2FA6': '\u91D1',
                '\u2FA7': '\u9577',
                '\u2FA8': '\u9580',
                '\u2FA9': '\u961C',
                '\u2FAA': '\u96B6',
                '\u2FAB': '\u96B9',
                '\u2FAC': '\u96E8',
                '\u2FAD': '\u9751',
                '\u2FAE': '\u975E',
                '\u2FAF': '\u9762',
                '\u2FB0': '\u9769',
                '\u2FB1': '\u97CB',
                '\u2FB2': '\u97ED',
                '\u2FB3': '\u97F3',
                '\u2FB4': '\u9801',
                '\u2FB5': '\u98A8',
                '\u2FB6': '\u98DB',
                '\u2FB7': '\u98DF',
                '\u2FB8': '\u9996',
                '\u2FB9': '\u9999',
                '\u2FBA': '\u99AC',
                '\u2FBB': '\u9AA8',
                '\u2FBC': '\u9AD8',
                '\u2FBD': '\u9ADF',
                '\u2FBE': '\u9B25',
                '\u2FBF': '\u9B2F',
                '\u2FC0': '\u9B32',
                '\u2FC1': '\u9B3C',
                '\u2FC2': '\u9B5A',
                '\u2FC3': '\u9CE5',
                '\u2FC4': '\u9E75',
                '\u2FC5': '\u9E7F',
                '\u2FC6': '\u9EA5',
                '\u2FC7': '\u9EBB',
                '\u2FC8': '\u9EC3',
                '\u2FC9': '\u9ECD',
                '\u2FCA': '\u9ED1',
                '\u2FCB': '\u9EF9',
                '\u2FCC': '\u9EFD',
                '\u2FCD': '\u9F0E',
                '\u2FCE': '\u9F13',
                '\u2FCF': '\u9F20',
                '\u2FD0': '\u9F3B',
                '\u2FD1': '\u9F4A',
                '\u2FD2': '\u9F52',
                '\u2FD3': '\u9F8D',
                '\u2FD4': '\u9F9C',
                '\u2FD5': '\u9FA0',
                '\u3036': '\u3012',
                '\u3038': '\u5341',
                '\u3039': '\u5344',
                '\u303A': '\u5345',
                '\u309B': '\u0020\u3099',
                '\u309C': '\u0020\u309A',
                '\u3131': '\u1100',
                '\u3132': '\u1101',
                '\u3133': '\u11AA',
                '\u3134': '\u1102',
                '\u3135': '\u11AC',
                '\u3136': '\u11AD',
                '\u3137': '\u1103',
                '\u3138': '\u1104',
                '\u3139': '\u1105',
                '\u313A': '\u11B0',
                '\u313B': '\u11B1',
                '\u313C': '\u11B2',
                '\u313D': '\u11B3',
                '\u313E': '\u11B4',
                '\u313F': '\u11B5',
                '\u3140': '\u111A',
                '\u3141': '\u1106',
                '\u3142': '\u1107',
                '\u3143': '\u1108',
                '\u3144': '\u1121',
                '\u3145': '\u1109',
                '\u3146': '\u110A',
                '\u3147': '\u110B',
                '\u3148': '\u110C',
                '\u3149': '\u110D',
                '\u314A': '\u110E',
                '\u314B': '\u110F',
                '\u314C': '\u1110',
                '\u314D': '\u1111',
                '\u314E': '\u1112',
                '\u314F': '\u1161',
                '\u3150': '\u1162',
                '\u3151': '\u1163',
                '\u3152': '\u1164',
                '\u3153': '\u1165',
                '\u3154': '\u1166',
                '\u3155': '\u1167',
                '\u3156': '\u1168',
                '\u3157': '\u1169',
                '\u3158': '\u116A',
                '\u3159': '\u116B',
                '\u315A': '\u116C',
                '\u315B': '\u116D',
                '\u315C': '\u116E',
                '\u315D': '\u116F',
                '\u315E': '\u1170',
                '\u315F': '\u1171',
                '\u3160': '\u1172',
                '\u3161': '\u1173',
                '\u3162': '\u1174',
                '\u3163': '\u1175',
                '\u3164': '\u1160',
                '\u3165': '\u1114',
                '\u3166': '\u1115',
                '\u3167': '\u11C7',
                '\u3168': '\u11C8',
                '\u3169': '\u11CC',
                '\u316A': '\u11CE',
                '\u316B': '\u11D3',
                '\u316C': '\u11D7',
                '\u316D': '\u11D9',
                '\u316E': '\u111C',
                '\u316F': '\u11DD',
                '\u3170': '\u11DF',
                '\u3171': '\u111D',
                '\u3172': '\u111E',
                '\u3173': '\u1120',
                '\u3174': '\u1122',
                '\u3175': '\u1123',
                '\u3176': '\u1127',
                '\u3177': '\u1129',
                '\u3178': '\u112B',
                '\u3179': '\u112C',
                '\u317A': '\u112D',
                '\u317B': '\u112E',
                '\u317C': '\u112F',
                '\u317D': '\u1132',
                '\u317E': '\u1136',
                '\u317F': '\u1140',
                '\u3180': '\u1147',
                '\u3181': '\u114C',
                '\u3182': '\u11F1',
                '\u3183': '\u11F2',
                '\u3184': '\u1157',
                '\u3185': '\u1158',
                '\u3186': '\u1159',
                '\u3187': '\u1184',
                '\u3188': '\u1185',
                '\u3189': '\u1188',
                '\u318A': '\u1191',
                '\u318B': '\u1192',
                '\u318C': '\u1194',
                '\u318D': '\u119E',
                '\u318E': '\u11A1',
                '\u3200': '\u0028\u1100\u0029',
                '\u3201': '\u0028\u1102\u0029',
                '\u3202': '\u0028\u1103\u0029',
                '\u3203': '\u0028\u1105\u0029',
                '\u3204': '\u0028\u1106\u0029',
                '\u3205': '\u0028\u1107\u0029',
                '\u3206': '\u0028\u1109\u0029',
                '\u3207': '\u0028\u110B\u0029',
                '\u3208': '\u0028\u110C\u0029',
                '\u3209': '\u0028\u110E\u0029',
                '\u320A': '\u0028\u110F\u0029',
                '\u320B': '\u0028\u1110\u0029',
                '\u320C': '\u0028\u1111\u0029',
                '\u320D': '\u0028\u1112\u0029',
                '\u320E': '\u0028\u1100\u1161\u0029',
                '\u320F': '\u0028\u1102\u1161\u0029',
                '\u3210': '\u0028\u1103\u1161\u0029',
                '\u3211': '\u0028\u1105\u1161\u0029',
                '\u3212': '\u0028\u1106\u1161\u0029',
                '\u3213': '\u0028\u1107\u1161\u0029',
                '\u3214': '\u0028\u1109\u1161\u0029',
                '\u3215': '\u0028\u110B\u1161\u0029',
                '\u3216': '\u0028\u110C\u1161\u0029',
                '\u3217': '\u0028\u110E\u1161\u0029',
                '\u3218': '\u0028\u110F\u1161\u0029',
                '\u3219': '\u0028\u1110\u1161\u0029',
                '\u321A': '\u0028\u1111\u1161\u0029',
                '\u321B': '\u0028\u1112\u1161\u0029',
                '\u321C': '\u0028\u110C\u116E\u0029',
                '\u321D': '\u0028\u110B\u1169\u110C\u1165\u11AB\u0029',
                '\u321E': '\u0028\u110B\u1169\u1112\u116E\u0029',
                '\u3220': '\u0028\u4E00\u0029',
                '\u3221': '\u0028\u4E8C\u0029',
                '\u3222': '\u0028\u4E09\u0029',
                '\u3223': '\u0028\u56DB\u0029',
                '\u3224': '\u0028\u4E94\u0029',
                '\u3225': '\u0028\u516D\u0029',
                '\u3226': '\u0028\u4E03\u0029',
                '\u3227': '\u0028\u516B\u0029',
                '\u3228': '\u0028\u4E5D\u0029',
                '\u3229': '\u0028\u5341\u0029',
                '\u322A': '\u0028\u6708\u0029',
                '\u322B': '\u0028\u706B\u0029',
                '\u322C': '\u0028\u6C34\u0029',
                '\u322D': '\u0028\u6728\u0029',
                '\u322E': '\u0028\u91D1\u0029',
                '\u322F': '\u0028\u571F\u0029',
                '\u3230': '\u0028\u65E5\u0029',
                '\u3231': '\u0028\u682A\u0029',
                '\u3232': '\u0028\u6709\u0029',
                '\u3233': '\u0028\u793E\u0029',
                '\u3234': '\u0028\u540D\u0029',
                '\u3235': '\u0028\u7279\u0029',
                '\u3236': '\u0028\u8CA1\u0029',
                '\u3237': '\u0028\u795D\u0029',
                '\u3238': '\u0028\u52B4\u0029',
                '\u3239': '\u0028\u4EE3\u0029',
                '\u323A': '\u0028\u547C\u0029',
                '\u323B': '\u0028\u5B66\u0029',
                '\u323C': '\u0028\u76E3\u0029',
                '\u323D': '\u0028\u4F01\u0029',
                '\u323E': '\u0028\u8CC7\u0029',
                '\u323F': '\u0028\u5354\u0029',
                '\u3240': '\u0028\u796D\u0029',
                '\u3241': '\u0028\u4F11\u0029',
                '\u3242': '\u0028\u81EA\u0029',
                '\u3243': '\u0028\u81F3\u0029',
                '\u32C0': '\u0031\u6708',
                '\u32C1': '\u0032\u6708',
                '\u32C2': '\u0033\u6708',
                '\u32C3': '\u0034\u6708',
                '\u32C4': '\u0035\u6708',
                '\u32C5': '\u0036\u6708',
                '\u32C6': '\u0037\u6708',
                '\u32C7': '\u0038\u6708',
                '\u32C8': '\u0039\u6708',
                '\u32C9': '\u0031\u0030\u6708',
                '\u32CA': '\u0031\u0031\u6708',
                '\u32CB': '\u0031\u0032\u6708',
                '\u3358': '\u0030\u70B9',
                '\u3359': '\u0031\u70B9',
                '\u335A': '\u0032\u70B9',
                '\u335B': '\u0033\u70B9',
                '\u335C': '\u0034\u70B9',
                '\u335D': '\u0035\u70B9',
                '\u335E': '\u0036\u70B9',
                '\u335F': '\u0037\u70B9',
                '\u3360': '\u0038\u70B9',
                '\u3361': '\u0039\u70B9',
                '\u3362': '\u0031\u0030\u70B9',
                '\u3363': '\u0031\u0031\u70B9',
                '\u3364': '\u0031\u0032\u70B9',
                '\u3365': '\u0031\u0033\u70B9',
                '\u3366': '\u0031\u0034\u70B9',
                '\u3367': '\u0031\u0035\u70B9',
                '\u3368': '\u0031\u0036\u70B9',
                '\u3369': '\u0031\u0037\u70B9',
                '\u336A': '\u0031\u0038\u70B9',
                '\u336B': '\u0031\u0039\u70B9',
                '\u336C': '\u0032\u0030\u70B9',
                '\u336D': '\u0032\u0031\u70B9',
                '\u336E': '\u0032\u0032\u70B9',
                '\u336F': '\u0032\u0033\u70B9',
                '\u3370': '\u0032\u0034\u70B9',
                '\u33E0': '\u0031\u65E5',
                '\u33E1': '\u0032\u65E5',
                '\u33E2': '\u0033\u65E5',
                '\u33E3': '\u0034\u65E5',
                '\u33E4': '\u0035\u65E5',
                '\u33E5': '\u0036\u65E5',
                '\u33E6': '\u0037\u65E5',
                '\u33E7': '\u0038\u65E5',
                '\u33E8': '\u0039\u65E5',
                '\u33E9': '\u0031\u0030\u65E5',
                '\u33EA': '\u0031\u0031\u65E5',
                '\u33EB': '\u0031\u0032\u65E5',
                '\u33EC': '\u0031\u0033\u65E5',
                '\u33ED': '\u0031\u0034\u65E5',
                '\u33EE': '\u0031\u0035\u65E5',
                '\u33EF': '\u0031\u0036\u65E5',
                '\u33F0': '\u0031\u0037\u65E5',
                '\u33F1': '\u0031\u0038\u65E5',
                '\u33F2': '\u0031\u0039\u65E5',
                '\u33F3': '\u0032\u0030\u65E5',
                '\u33F4': '\u0032\u0031\u65E5',
                '\u33F5': '\u0032\u0032\u65E5',
                '\u33F6': '\u0032\u0033\u65E5',
                '\u33F7': '\u0032\u0034\u65E5',
                '\u33F8': '\u0032\u0035\u65E5',
                '\u33F9': '\u0032\u0036\u65E5',
                '\u33FA': '\u0032\u0037\u65E5',
                '\u33FB': '\u0032\u0038\u65E5',
                '\u33FC': '\u0032\u0039\u65E5',
                '\u33FD': '\u0033\u0030\u65E5',
                '\u33FE': '\u0033\u0031\u65E5',
                '\uFB00': '\u0066\u0066',
                '\uFB01': '\u0066\u0069',
                '\uFB02': '\u0066\u006C',
                '\uFB03': '\u0066\u0066\u0069',
                '\uFB04': '\u0066\u0066\u006C',
                '\uFB05': '\u017F\u0074',
                '\uFB06': '\u0073\u0074',
                '\uFB13': '\u0574\u0576',
                '\uFB14': '\u0574\u0565',
                '\uFB15': '\u0574\u056B',
                '\uFB16': '\u057E\u0576',
                '\uFB17': '\u0574\u056D',
                '\uFB4F': '\u05D0\u05DC',
                '\uFB50': '\u0671',
                '\uFB51': '\u0671',
                '\uFB52': '\u067B',
                '\uFB53': '\u067B',
                '\uFB54': '\u067B',
                '\uFB55': '\u067B',
                '\uFB56': '\u067E',
                '\uFB57': '\u067E',
                '\uFB58': '\u067E',
                '\uFB59': '\u067E',
                '\uFB5A': '\u0680',
                '\uFB5B': '\u0680',
                '\uFB5C': '\u0680',
                '\uFB5D': '\u0680',
                '\uFB5E': '\u067A',
                '\uFB5F': '\u067A',
                '\uFB60': '\u067A',
                '\uFB61': '\u067A',
                '\uFB62': '\u067F',
                '\uFB63': '\u067F',
                '\uFB64': '\u067F',
                '\uFB65': '\u067F',
                '\uFB66': '\u0679',
                '\uFB67': '\u0679',
                '\uFB68': '\u0679',
                '\uFB69': '\u0679',
                '\uFB6A': '\u06A4',
                '\uFB6B': '\u06A4',
                '\uFB6C': '\u06A4',
                '\uFB6D': '\u06A4',
                '\uFB6E': '\u06A6',
                '\uFB6F': '\u06A6',
                '\uFB70': '\u06A6',
                '\uFB71': '\u06A6',
                '\uFB72': '\u0684',
                '\uFB73': '\u0684',
                '\uFB74': '\u0684',
                '\uFB75': '\u0684',
                '\uFB76': '\u0683',
                '\uFB77': '\u0683',
                '\uFB78': '\u0683',
                '\uFB79': '\u0683',
                '\uFB7A': '\u0686',
                '\uFB7B': '\u0686',
                '\uFB7C': '\u0686',
                '\uFB7D': '\u0686',
                '\uFB7E': '\u0687',
                '\uFB7F': '\u0687',
                '\uFB80': '\u0687',
                '\uFB81': '\u0687',
                '\uFB82': '\u068D',
                '\uFB83': '\u068D',
                '\uFB84': '\u068C',
                '\uFB85': '\u068C',
                '\uFB86': '\u068E',
                '\uFB87': '\u068E',
                '\uFB88': '\u0688',
                '\uFB89': '\u0688',
                '\uFB8A': '\u0698',
                '\uFB8B': '\u0698',
                '\uFB8C': '\u0691',
                '\uFB8D': '\u0691',
                '\uFB8E': '\u06A9',
                '\uFB8F': '\u06A9',
                '\uFB90': '\u06A9',
                '\uFB91': '\u06A9',
                '\uFB92': '\u06AF',
                '\uFB93': '\u06AF',
                '\uFB94': '\u06AF',
                '\uFB95': '\u06AF',
                '\uFB96': '\u06B3',
                '\uFB97': '\u06B3',
                '\uFB98': '\u06B3',
                '\uFB99': '\u06B3',
                '\uFB9A': '\u06B1',
                '\uFB9B': '\u06B1',
                '\uFB9C': '\u06B1',
                '\uFB9D': '\u06B1',
                '\uFB9E': '\u06BA',
                '\uFB9F': '\u06BA',
                '\uFBA0': '\u06BB',
                '\uFBA1': '\u06BB',
                '\uFBA2': '\u06BB',
                '\uFBA3': '\u06BB',
                '\uFBA4': '\u06C0',
                '\uFBA5': '\u06C0',
                '\uFBA6': '\u06C1',
                '\uFBA7': '\u06C1',
                '\uFBA8': '\u06C1',
                '\uFBA9': '\u06C1',
                '\uFBAA': '\u06BE',
                '\uFBAB': '\u06BE',
                '\uFBAC': '\u06BE',
                '\uFBAD': '\u06BE',
                '\uFBAE': '\u06D2',
                '\uFBAF': '\u06D2',
                '\uFBB0': '\u06D3',
                '\uFBB1': '\u06D3',
                '\uFBD3': '\u06AD',
                '\uFBD4': '\u06AD',
                '\uFBD5': '\u06AD',
                '\uFBD6': '\u06AD',
                '\uFBD7': '\u06C7',
                '\uFBD8': '\u06C7',
                '\uFBD9': '\u06C6',
                '\uFBDA': '\u06C6',
                '\uFBDB': '\u06C8',
                '\uFBDC': '\u06C8',
                '\uFBDD': '\u0677',
                '\uFBDE': '\u06CB',
                '\uFBDF': '\u06CB',
                '\uFBE0': '\u06C5',
                '\uFBE1': '\u06C5',
                '\uFBE2': '\u06C9',
                '\uFBE3': '\u06C9',
                '\uFBE4': '\u06D0',
                '\uFBE5': '\u06D0',
                '\uFBE6': '\u06D0',
                '\uFBE7': '\u06D0',
                '\uFBE8': '\u0649',
                '\uFBE9': '\u0649',
                '\uFBEA': '\u0626\u0627',
                '\uFBEB': '\u0626\u0627',
                '\uFBEC': '\u0626\u06D5',
                '\uFBED': '\u0626\u06D5',
                '\uFBEE': '\u0626\u0648',
                '\uFBEF': '\u0626\u0648',
                '\uFBF0': '\u0626\u06C7',
                '\uFBF1': '\u0626\u06C7',
                '\uFBF2': '\u0626\u06C6',
                '\uFBF3': '\u0626\u06C6',
                '\uFBF4': '\u0626\u06C8',
                '\uFBF5': '\u0626\u06C8',
                '\uFBF6': '\u0626\u06D0',
                '\uFBF7': '\u0626\u06D0',
                '\uFBF8': '\u0626\u06D0',
                '\uFBF9': '\u0626\u0649',
                '\uFBFA': '\u0626\u0649',
                '\uFBFB': '\u0626\u0649',
                '\uFBFC': '\u06CC',
                '\uFBFD': '\u06CC',
                '\uFBFE': '\u06CC',
                '\uFBFF': '\u06CC',
                '\uFC00': '\u0626\u062C',
                '\uFC01': '\u0626\u062D',
                '\uFC02': '\u0626\u0645',
                '\uFC03': '\u0626\u0649',
                '\uFC04': '\u0626\u064A',
                '\uFC05': '\u0628\u062C',
                '\uFC06': '\u0628\u062D',
                '\uFC07': '\u0628\u062E',
                '\uFC08': '\u0628\u0645',
                '\uFC09': '\u0628\u0649',
                '\uFC0A': '\u0628\u064A',
                '\uFC0B': '\u062A\u062C',
                '\uFC0C': '\u062A\u062D',
                '\uFC0D': '\u062A\u062E',
                '\uFC0E': '\u062A\u0645',
                '\uFC0F': '\u062A\u0649',
                '\uFC10': '\u062A\u064A',
                '\uFC11': '\u062B\u062C',
                '\uFC12': '\u062B\u0645',
                '\uFC13': '\u062B\u0649',
                '\uFC14': '\u062B\u064A',
                '\uFC15': '\u062C\u062D',
                '\uFC16': '\u062C\u0645',
                '\uFC17': '\u062D\u062C',
                '\uFC18': '\u062D\u0645',
                '\uFC19': '\u062E\u062C',
                '\uFC1A': '\u062E\u062D',
                '\uFC1B': '\u062E\u0645',
                '\uFC1C': '\u0633\u062C',
                '\uFC1D': '\u0633\u062D',
                '\uFC1E': '\u0633\u062E',
                '\uFC1F': '\u0633\u0645',
                '\uFC20': '\u0635\u062D',
                '\uFC21': '\u0635\u0645',
                '\uFC22': '\u0636\u062C',
                '\uFC23': '\u0636\u062D',
                '\uFC24': '\u0636\u062E',
                '\uFC25': '\u0636\u0645',
                '\uFC26': '\u0637\u062D',
                '\uFC27': '\u0637\u0645',
                '\uFC28': '\u0638\u0645',
                '\uFC29': '\u0639\u062C',
                '\uFC2A': '\u0639\u0645',
                '\uFC2B': '\u063A\u062C',
                '\uFC2C': '\u063A\u0645',
                '\uFC2D': '\u0641\u062C',
                '\uFC2E': '\u0641\u062D',
                '\uFC2F': '\u0641\u062E',
                '\uFC30': '\u0641\u0645',
                '\uFC31': '\u0641\u0649',
                '\uFC32': '\u0641\u064A',
                '\uFC33': '\u0642\u062D',
                '\uFC34': '\u0642\u0645',
                '\uFC35': '\u0642\u0649',
                '\uFC36': '\u0642\u064A',
                '\uFC37': '\u0643\u0627',
                '\uFC38': '\u0643\u062C',
                '\uFC39': '\u0643\u062D',
                '\uFC3A': '\u0643\u062E',
                '\uFC3B': '\u0643\u0644',
                '\uFC3C': '\u0643\u0645',
                '\uFC3D': '\u0643\u0649',
                '\uFC3E': '\u0643\u064A',
                '\uFC3F': '\u0644\u062C',
                '\uFC40': '\u0644\u062D',
                '\uFC41': '\u0644\u062E',
                '\uFC42': '\u0644\u0645',
                '\uFC43': '\u0644\u0649',
                '\uFC44': '\u0644\u064A',
                '\uFC45': '\u0645\u062C',
                '\uFC46': '\u0645\u062D',
                '\uFC47': '\u0645\u062E',
                '\uFC48': '\u0645\u0645',
                '\uFC49': '\u0645\u0649',
                '\uFC4A': '\u0645\u064A',
                '\uFC4B': '\u0646\u062C',
                '\uFC4C': '\u0646\u062D',
                '\uFC4D': '\u0646\u062E',
                '\uFC4E': '\u0646\u0645',
                '\uFC4F': '\u0646\u0649',
                '\uFC50': '\u0646\u064A',
                '\uFC51': '\u0647\u062C',
                '\uFC52': '\u0647\u0645',
                '\uFC53': '\u0647\u0649',
                '\uFC54': '\u0647\u064A',
                '\uFC55': '\u064A\u062C',
                '\uFC56': '\u064A\u062D',
                '\uFC57': '\u064A\u062E',
                '\uFC58': '\u064A\u0645',
                '\uFC59': '\u064A\u0649',
                '\uFC5A': '\u064A\u064A',
                '\uFC5B': '\u0630\u0670',
                '\uFC5C': '\u0631\u0670',
                '\uFC5D': '\u0649\u0670',
                '\uFC5E': '\u0020\u064C\u0651',
                '\uFC5F': '\u0020\u064D\u0651',
                '\uFC60': '\u0020\u064E\u0651',
                '\uFC61': '\u0020\u064F\u0651',
                '\uFC62': '\u0020\u0650\u0651',
                '\uFC63': '\u0020\u0651\u0670',
                '\uFC64': '\u0626\u0631',
                '\uFC65': '\u0626\u0632',
                '\uFC66': '\u0626\u0645',
                '\uFC67': '\u0626\u0646',
                '\uFC68': '\u0626\u0649',
                '\uFC69': '\u0626\u064A',
                '\uFC6A': '\u0628\u0631',
                '\uFC6B': '\u0628\u0632',
                '\uFC6C': '\u0628\u0645',
                '\uFC6D': '\u0628\u0646',
                '\uFC6E': '\u0628\u0649',
                '\uFC6F': '\u0628\u064A',
                '\uFC70': '\u062A\u0631',
                '\uFC71': '\u062A\u0632',
                '\uFC72': '\u062A\u0645',
                '\uFC73': '\u062A\u0646',
                '\uFC74': '\u062A\u0649',
                '\uFC75': '\u062A\u064A',
                '\uFC76': '\u062B\u0631',
                '\uFC77': '\u062B\u0632',
                '\uFC78': '\u062B\u0645',
                '\uFC79': '\u062B\u0646',
                '\uFC7A': '\u062B\u0649',
                '\uFC7B': '\u062B\u064A',
                '\uFC7C': '\u0641\u0649',
                '\uFC7D': '\u0641\u064A',
                '\uFC7E': '\u0642\u0649',
                '\uFC7F': '\u0642\u064A',
                '\uFC80': '\u0643\u0627',
                '\uFC81': '\u0643\u0644',
                '\uFC82': '\u0643\u0645',
                '\uFC83': '\u0643\u0649',
                '\uFC84': '\u0643\u064A',
                '\uFC85': '\u0644\u0645',
                '\uFC86': '\u0644\u0649',
                '\uFC87': '\u0644\u064A',
                '\uFC88': '\u0645\u0627',
                '\uFC89': '\u0645\u0645',
                '\uFC8A': '\u0646\u0631',
                '\uFC8B': '\u0646\u0632',
                '\uFC8C': '\u0646\u0645',
                '\uFC8D': '\u0646\u0646',
                '\uFC8E': '\u0646\u0649',
                '\uFC8F': '\u0646\u064A',
                '\uFC90': '\u0649\u0670',
                '\uFC91': '\u064A\u0631',
                '\uFC92': '\u064A\u0632',
                '\uFC93': '\u064A\u0645',
                '\uFC94': '\u064A\u0646',
                '\uFC95': '\u064A\u0649',
                '\uFC96': '\u064A\u064A',
                '\uFC97': '\u0626\u062C',
                '\uFC98': '\u0626\u062D',
                '\uFC99': '\u0626\u062E',
                '\uFC9A': '\u0626\u0645',
                '\uFC9B': '\u0626\u0647',
                '\uFC9C': '\u0628\u062C',
                '\uFC9D': '\u0628\u062D',
                '\uFC9E': '\u0628\u062E',
                '\uFC9F': '\u0628\u0645',
                '\uFCA0': '\u0628\u0647',
                '\uFCA1': '\u062A\u062C',
                '\uFCA2': '\u062A\u062D',
                '\uFCA3': '\u062A\u062E',
                '\uFCA4': '\u062A\u0645',
                '\uFCA5': '\u062A\u0647',
                '\uFCA6': '\u062B\u0645',
                '\uFCA7': '\u062C\u062D',
                '\uFCA8': '\u062C\u0645',
                '\uFCA9': '\u062D\u062C',
                '\uFCAA': '\u062D\u0645',
                '\uFCAB': '\u062E\u062C',
                '\uFCAC': '\u062E\u0645',
                '\uFCAD': '\u0633\u062C',
                '\uFCAE': '\u0633\u062D',
                '\uFCAF': '\u0633\u062E',
                '\uFCB0': '\u0633\u0645',
                '\uFCB1': '\u0635\u062D',
                '\uFCB2': '\u0635\u062E',
                '\uFCB3': '\u0635\u0645',
                '\uFCB4': '\u0636\u062C',
                '\uFCB5': '\u0636\u062D',
                '\uFCB6': '\u0636\u062E',
                '\uFCB7': '\u0636\u0645',
                '\uFCB8': '\u0637\u062D',
                '\uFCB9': '\u0638\u0645',
                '\uFCBA': '\u0639\u062C',
                '\uFCBB': '\u0639\u0645',
                '\uFCBC': '\u063A\u062C',
                '\uFCBD': '\u063A\u0645',
                '\uFCBE': '\u0641\u062C',
                '\uFCBF': '\u0641\u062D',
                '\uFCC0': '\u0641\u062E',
                '\uFCC1': '\u0641\u0645',
                '\uFCC2': '\u0642\u062D',
                '\uFCC3': '\u0642\u0645',
                '\uFCC4': '\u0643\u062C',
                '\uFCC5': '\u0643\u062D',
                '\uFCC6': '\u0643\u062E',
                '\uFCC7': '\u0643\u0644',
                '\uFCC8': '\u0643\u0645',
                '\uFCC9': '\u0644\u062C',
                '\uFCCA': '\u0644\u062D',
                '\uFCCB': '\u0644\u062E',
                '\uFCCC': '\u0644\u0645',
                '\uFCCD': '\u0644\u0647',
                '\uFCCE': '\u0645\u062C',
                '\uFCCF': '\u0645\u062D',
                '\uFCD0': '\u0645\u062E',
                '\uFCD1': '\u0645\u0645',
                '\uFCD2': '\u0646\u062C',
                '\uFCD3': '\u0646\u062D',
                '\uFCD4': '\u0646\u062E',
                '\uFCD5': '\u0646\u0645',
                '\uFCD6': '\u0646\u0647',
                '\uFCD7': '\u0647\u062C',
                '\uFCD8': '\u0647\u0645',
                '\uFCD9': '\u0647\u0670',
                '\uFCDA': '\u064A\u062C',
                '\uFCDB': '\u064A\u062D',
                '\uFCDC': '\u064A\u062E',
                '\uFCDD': '\u064A\u0645',
                '\uFCDE': '\u064A\u0647',
                '\uFCDF': '\u0626\u0645',
                '\uFCE0': '\u0626\u0647',
                '\uFCE1': '\u0628\u0645',
                '\uFCE2': '\u0628\u0647',
                '\uFCE3': '\u062A\u0645',
                '\uFCE4': '\u062A\u0647',
                '\uFCE5': '\u062B\u0645',
                '\uFCE6': '\u062B\u0647',
                '\uFCE7': '\u0633\u0645',
                '\uFCE8': '\u0633\u0647',
                '\uFCE9': '\u0634\u0645',
                '\uFCEA': '\u0634\u0647',
                '\uFCEB': '\u0643\u0644',
                '\uFCEC': '\u0643\u0645',
                '\uFCED': '\u0644\u0645',
                '\uFCEE': '\u0646\u0645',
                '\uFCEF': '\u0646\u0647',
                '\uFCF0': '\u064A\u0645',
                '\uFCF1': '\u064A\u0647',
                '\uFCF2': '\u0640\u064E\u0651',
                '\uFCF3': '\u0640\u064F\u0651',
                '\uFCF4': '\u0640\u0650\u0651',
                '\uFCF5': '\u0637\u0649',
                '\uFCF6': '\u0637\u064A',
                '\uFCF7': '\u0639\u0649',
                '\uFCF8': '\u0639\u064A',
                '\uFCF9': '\u063A\u0649',
                '\uFCFA': '\u063A\u064A',
                '\uFCFB': '\u0633\u0649',
                '\uFCFC': '\u0633\u064A',
                '\uFCFD': '\u0634\u0649',
                '\uFCFE': '\u0634\u064A',
                '\uFCFF': '\u062D\u0649',
                '\uFD00': '\u062D\u064A',
                '\uFD01': '\u062C\u0649',
                '\uFD02': '\u062C\u064A',
                '\uFD03': '\u062E\u0649',
                '\uFD04': '\u062E\u064A',
                '\uFD05': '\u0635\u0649',
                '\uFD06': '\u0635\u064A',
                '\uFD07': '\u0636\u0649',
                '\uFD08': '\u0636\u064A',
                '\uFD09': '\u0634\u062C',
                '\uFD0A': '\u0634\u062D',
                '\uFD0B': '\u0634\u062E',
                '\uFD0C': '\u0634\u0645',
                '\uFD0D': '\u0634\u0631',
                '\uFD0E': '\u0633\u0631',
                '\uFD0F': '\u0635\u0631',
                '\uFD10': '\u0636\u0631',
                '\uFD11': '\u0637\u0649',
                '\uFD12': '\u0637\u064A',
                '\uFD13': '\u0639\u0649',
                '\uFD14': '\u0639\u064A',
                '\uFD15': '\u063A\u0649',
                '\uFD16': '\u063A\u064A',
                '\uFD17': '\u0633\u0649',
                '\uFD18': '\u0633\u064A',
                '\uFD19': '\u0634\u0649',
                '\uFD1A': '\u0634\u064A',
                '\uFD1B': '\u062D\u0649',
                '\uFD1C': '\u062D\u064A',
                '\uFD1D': '\u062C\u0649',
                '\uFD1E': '\u062C\u064A',
                '\uFD1F': '\u062E\u0649',
                '\uFD20': '\u062E\u064A',
                '\uFD21': '\u0635\u0649',
                '\uFD22': '\u0635\u064A',
                '\uFD23': '\u0636\u0649',
                '\uFD24': '\u0636\u064A',
                '\uFD25': '\u0634\u062C',
                '\uFD26': '\u0634\u062D',
                '\uFD27': '\u0634\u062E',
                '\uFD28': '\u0634\u0645',
                '\uFD29': '\u0634\u0631',
                '\uFD2A': '\u0633\u0631',
                '\uFD2B': '\u0635\u0631',
                '\uFD2C': '\u0636\u0631',
                '\uFD2D': '\u0634\u062C',
                '\uFD2E': '\u0634\u062D',
                '\uFD2F': '\u0634\u062E',
                '\uFD30': '\u0634\u0645',
                '\uFD31': '\u0633\u0647',
                '\uFD32': '\u0634\u0647',
                '\uFD33': '\u0637\u0645',
                '\uFD34': '\u0633\u062C',
                '\uFD35': '\u0633\u062D',
                '\uFD36': '\u0633\u062E',
                '\uFD37': '\u0634\u062C',
                '\uFD38': '\u0634\u062D',
                '\uFD39': '\u0634\u062E',
                '\uFD3A': '\u0637\u0645',
                '\uFD3B': '\u0638\u0645',
                '\uFD3C': '\u0627\u064B',
                '\uFD3D': '\u0627\u064B',
                '\uFD50': '\u062A\u062C\u0645',
                '\uFD51': '\u062A\u062D\u062C',
                '\uFD52': '\u062A\u062D\u062C',
                '\uFD53': '\u062A\u062D\u0645',
                '\uFD54': '\u062A\u062E\u0645',
                '\uFD55': '\u062A\u0645\u062C',
                '\uFD56': '\u062A\u0645\u062D',
                '\uFD57': '\u062A\u0645\u062E',
                '\uFD58': '\u062C\u0645\u062D',
                '\uFD59': '\u062C\u0645\u062D',
                '\uFD5A': '\u062D\u0645\u064A',
                '\uFD5B': '\u062D\u0645\u0649',
                '\uFD5C': '\u0633\u062D\u062C',
                '\uFD5D': '\u0633\u062C\u062D',
                '\uFD5E': '\u0633\u062C\u0649',
                '\uFD5F': '\u0633\u0645\u062D',
                '\uFD60': '\u0633\u0645\u062D',
                '\uFD61': '\u0633\u0645\u062C',
                '\uFD62': '\u0633\u0645\u0645',
                '\uFD63': '\u0633\u0645\u0645',
                '\uFD64': '\u0635\u062D\u062D',
                '\uFD65': '\u0635\u062D\u062D',
                '\uFD66': '\u0635\u0645\u0645',
                '\uFD67': '\u0634\u062D\u0645',
                '\uFD68': '\u0634\u062D\u0645',
                '\uFD69': '\u0634\u062C\u064A',
                '\uFD6A': '\u0634\u0645\u062E',
                '\uFD6B': '\u0634\u0645\u062E',
                '\uFD6C': '\u0634\u0645\u0645',
                '\uFD6D': '\u0634\u0645\u0645',
                '\uFD6E': '\u0636\u062D\u0649',
                '\uFD6F': '\u0636\u062E\u0645',
                '\uFD70': '\u0636\u062E\u0645',
                '\uFD71': '\u0637\u0645\u062D',
                '\uFD72': '\u0637\u0645\u062D',
                '\uFD73': '\u0637\u0645\u0645',
                '\uFD74': '\u0637\u0645\u064A',
                '\uFD75': '\u0639\u062C\u0645',
                '\uFD76': '\u0639\u0645\u0645',
                '\uFD77': '\u0639\u0645\u0645',
                '\uFD78': '\u0639\u0645\u0649',
                '\uFD79': '\u063A\u0645\u0645',
                '\uFD7A': '\u063A\u0645\u064A',
                '\uFD7B': '\u063A\u0645\u0649',
                '\uFD7C': '\u0641\u062E\u0645',
                '\uFD7D': '\u0641\u062E\u0645',
                '\uFD7E': '\u0642\u0645\u062D',
                '\uFD7F': '\u0642\u0645\u0645',
                '\uFD80': '\u0644\u062D\u0645',
                '\uFD81': '\u0644\u062D\u064A',
                '\uFD82': '\u0644\u062D\u0649',
                '\uFD83': '\u0644\u062C\u062C',
                '\uFD84': '\u0644\u062C\u062C',
                '\uFD85': '\u0644\u062E\u0645',
                '\uFD86': '\u0644\u062E\u0645',
                '\uFD87': '\u0644\u0645\u062D',
                '\uFD88': '\u0644\u0645\u062D',
                '\uFD89': '\u0645\u062D\u062C',
                '\uFD8A': '\u0645\u062D\u0645',
                '\uFD8B': '\u0645\u062D\u064A',
                '\uFD8C': '\u0645\u062C\u062D',
                '\uFD8D': '\u0645\u062C\u0645',
                '\uFD8E': '\u0645\u062E\u062C',
                '\uFD8F': '\u0645\u062E\u0645',
                '\uFD92': '\u0645\u062C\u062E',
                '\uFD93': '\u0647\u0645\u062C',
                '\uFD94': '\u0647\u0645\u0645',
                '\uFD95': '\u0646\u062D\u0645',
                '\uFD96': '\u0646\u062D\u0649',
                '\uFD97': '\u0646\u062C\u0645',
                '\uFD98': '\u0646\u062C\u0645',
                '\uFD99': '\u0646\u062C\u0649',
                '\uFD9A': '\u0646\u0645\u064A',
                '\uFD9B': '\u0646\u0645\u0649',
                '\uFD9C': '\u064A\u0645\u0645',
                '\uFD9D': '\u064A\u0645\u0645',
                '\uFD9E': '\u0628\u062E\u064A',
                '\uFD9F': '\u062A\u062C\u064A',
                '\uFDA0': '\u062A\u062C\u0649',
                '\uFDA1': '\u062A\u062E\u064A',
                '\uFDA2': '\u062A\u062E\u0649',
                '\uFDA3': '\u062A\u0645\u064A',
                '\uFDA4': '\u062A\u0645\u0649',
                '\uFDA5': '\u062C\u0645\u064A',
                '\uFDA6': '\u062C\u062D\u0649',
                '\uFDA7': '\u062C\u0645\u0649',
                '\uFDA8': '\u0633\u062E\u0649',
                '\uFDA9': '\u0635\u062D\u064A',
                '\uFDAA': '\u0634\u062D\u064A',
                '\uFDAB': '\u0636\u062D\u064A',
                '\uFDAC': '\u0644\u062C\u064A',
                '\uFDAD': '\u0644\u0645\u064A',
                '\uFDAE': '\u064A\u062D\u064A',
                '\uFDAF': '\u064A\u062C\u064A',
                '\uFDB0': '\u064A\u0645\u064A',
                '\uFDB1': '\u0645\u0645\u064A',
                '\uFDB2': '\u0642\u0645\u064A',
                '\uFDB3': '\u0646\u062D\u064A',
                '\uFDB4': '\u0642\u0645\u062D',
                '\uFDB5': '\u0644\u062D\u0645',
                '\uFDB6': '\u0639\u0645\u064A',
                '\uFDB7': '\u0643\u0645\u064A',
                '\uFDB8': '\u0646\u062C\u062D',
                '\uFDB9': '\u0645\u062E\u064A',
                '\uFDBA': '\u0644\u062C\u0645',
                '\uFDBB': '\u0643\u0645\u0645',
                '\uFDBC': '\u0644\u062C\u0645',
                '\uFDBD': '\u0646\u062C\u062D',
                '\uFDBE': '\u062C\u062D\u064A',
                '\uFDBF': '\u062D\u062C\u064A',
                '\uFDC0': '\u0645\u062C\u064A',
                '\uFDC1': '\u0641\u0645\u064A',
                '\uFDC2': '\u0628\u062D\u064A',
                '\uFDC3': '\u0643\u0645\u0645',
                '\uFDC4': '\u0639\u062C\u0645',
                '\uFDC5': '\u0635\u0645\u0645',
                '\uFDC6': '\u0633\u062E\u064A',
                '\uFDC7': '\u0646\u062C\u064A',
                '\uFE49': '\u203E',
                '\uFE4A': '\u203E',
                '\uFE4B': '\u203E',
                '\uFE4C': '\u203E',
                '\uFE4D': '\u005F',
                '\uFE4E': '\u005F',
                '\uFE4F': '\u005F',
                '\uFE80': '\u0621',
                '\uFE81': '\u0622',
                '\uFE82': '\u0622',
                '\uFE83': '\u0623',
                '\uFE84': '\u0623',
                '\uFE85': '\u0624',
                '\uFE86': '\u0624',
                '\uFE87': '\u0625',
                '\uFE88': '\u0625',
                '\uFE89': '\u0626',
                '\uFE8A': '\u0626',
                '\uFE8B': '\u0626',
                '\uFE8C': '\u0626',
                '\uFE8D': '\u0627',
                '\uFE8E': '\u0627',
                '\uFE8F': '\u0628',
                '\uFE90': '\u0628',
                '\uFE91': '\u0628',
                '\uFE92': '\u0628',
                '\uFE93': '\u0629',
                '\uFE94': '\u0629',
                '\uFE95': '\u062A',
                '\uFE96': '\u062A',
                '\uFE97': '\u062A',
                '\uFE98': '\u062A',
                '\uFE99': '\u062B',
                '\uFE9A': '\u062B',
                '\uFE9B': '\u062B',
                '\uFE9C': '\u062B',
                '\uFE9D': '\u062C',
                '\uFE9E': '\u062C',
                '\uFE9F': '\u062C',
                '\uFEA0': '\u062C',
                '\uFEA1': '\u062D',
                '\uFEA2': '\u062D',
                '\uFEA3': '\u062D',
                '\uFEA4': '\u062D',
                '\uFEA5': '\u062E',
                '\uFEA6': '\u062E',
                '\uFEA7': '\u062E',
                '\uFEA8': '\u062E',
                '\uFEA9': '\u062F',
                '\uFEAA': '\u062F',
                '\uFEAB': '\u0630',
                '\uFEAC': '\u0630',
                '\uFEAD': '\u0631',
                '\uFEAE': '\u0631',
                '\uFEAF': '\u0632',
                '\uFEB0': '\u0632',
                '\uFEB1': '\u0633',
                '\uFEB2': '\u0633',
                '\uFEB3': '\u0633',
                '\uFEB4': '\u0633',
                '\uFEB5': '\u0634',
                '\uFEB6': '\u0634',
                '\uFEB7': '\u0634',
                '\uFEB8': '\u0634',
                '\uFEB9': '\u0635',
                '\uFEBA': '\u0635',
                '\uFEBB': '\u0635',
                '\uFEBC': '\u0635',
                '\uFEBD': '\u0636',
                '\uFEBE': '\u0636',
                '\uFEBF': '\u0636',
                '\uFEC0': '\u0636',
                '\uFEC1': '\u0637',
                '\uFEC2': '\u0637',
                '\uFEC3': '\u0637',
                '\uFEC4': '\u0637',
                '\uFEC5': '\u0638',
                '\uFEC6': '\u0638',
                '\uFEC7': '\u0638',
                '\uFEC8': '\u0638',
                '\uFEC9': '\u0639',
                '\uFECA': '\u0639',
                '\uFECB': '\u0639',
                '\uFECC': '\u0639',
                '\uFECD': '\u063A',
                '\uFECE': '\u063A',
                '\uFECF': '\u063A',
                '\uFED0': '\u063A',
                '\uFED1': '\u0641',
                '\uFED2': '\u0641',
                '\uFED3': '\u0641',
                '\uFED4': '\u0641',
                '\uFED5': '\u0642',
                '\uFED6': '\u0642',
                '\uFED7': '\u0642',
                '\uFED8': '\u0642',
                '\uFED9': '\u0643',
                '\uFEDA': '\u0643',
                '\uFEDB': '\u0643',
                '\uFEDC': '\u0643',
                '\uFEDD': '\u0644',
                '\uFEDE': '\u0644',
                '\uFEDF': '\u0644',
                '\uFEE0': '\u0644',
                '\uFEE1': '\u0645',
                '\uFEE2': '\u0645',
                '\uFEE3': '\u0645',
                '\uFEE4': '\u0645',
                '\uFEE5': '\u0646',
                '\uFEE6': '\u0646',
                '\uFEE7': '\u0646',
                '\uFEE8': '\u0646',
                '\uFEE9': '\u0647',
                '\uFEEA': '\u0647',
                '\uFEEB': '\u0647',
                '\uFEEC': '\u0647',
                '\uFEED': '\u0648',
                '\uFEEE': '\u0648',
                '\uFEEF': '\u0649',
                '\uFEF0': '\u0649',
                '\uFEF1': '\u064A',
                '\uFEF2': '\u064A',
                '\uFEF3': '\u064A',
                '\uFEF4': '\u064A',
                '\uFEF5': '\u0644\u0622',
                '\uFEF6': '\u0644\u0622',
                '\uFEF7': '\u0644\u0623',
                '\uFEF8': '\u0644\u0623',
                '\uFEF9': '\u0644\u0625',
                '\uFEFA': '\u0644\u0625',
                '\uFEFB': '\u0644\u0627',
                '\uFEFC': '\u0644\u0627'
            };

            function reverseIfRtl(chars) {
                var charsLength = chars.length;
                if (charsLength <= 1 || !isRTLRangeFor(chars.charCodeAt(0))) {
                    return chars;
                }
                var s = '';
                for (var ii = charsLength - 1; ii >= 0; ii--) {
                    s += chars[ii];
                }
                return s;
            }

            function adjustWidths(properties) {
                if (!properties.fontMatrix) {
                    return;
                }
                if (properties.fontMatrix[0] === FONT_IDENTITY_MATRIX[0]) {
                    return;
                }
                var scale = 0.001 / properties.fontMatrix[0];
                var glyphsWidths = properties.widths;
                for (var glyph in glyphsWidths) {
                    glyphsWidths[glyph] *= scale;
                }
                properties.defaultWidth *= scale;
            }

            function getFontType(type, subtype) {
                switch (type) {
                    case 'Type1':
                        return subtype === 'Type1C' ? FontType.TYPE1C : FontType.TYPE1;
                    case 'CIDFontType0':
                        return subtype === 'CIDFontType0C' ? FontType.CIDFONTTYPE0C : FontType.CIDFONTTYPE0;
                    case 'OpenType':
                        return FontType.OPENTYPE;
                    case 'TrueType':
                        return FontType.TRUETYPE;
                    case 'CIDFontType2':
                        return FontType.CIDFONTTYPE2;
                    case 'MMType1':
                        return FontType.MMTYPE1;
                    case 'Type0':
                        return FontType.TYPE0;
                    default:
                        return FontType.UNKNOWN;
                }
            }
            var Glyph = (function GlyphClosure() {
                function Glyph(fontChar, unicode, accent, width, vmetric, operatorListId, isSpace) {
                    this.fontChar = fontChar;
                    this.unicode = unicode;
                    this.accent = accent;
                    this.width = width;
                    this.vmetric = vmetric;
                    this.operatorListId = operatorListId;
                    this.isSpace = isSpace;
                }
                Glyph.prototype.matchesForCache = function(fontChar, unicode, accent, width, vmetric, operatorListId, isSpace) {
                    return this.fontChar === fontChar && this.unicode === unicode && this.accent === accent && this.width === width && this.vmetric === vmetric && this.operatorListId === operatorListId && this.isSpace === isSpace;
                };
                return Glyph;
            })();
            var ToUnicodeMap = (function ToUnicodeMapClosure() {
                function ToUnicodeMap(cmap) {
                    this._map = cmap;
                }
                ToUnicodeMap.prototype = {
                    get length() {
                        return this._map.length;
                    },
                    forEach: function(callback) {
                        for (var charCode in this._map) {
                            callback(charCode, this._map[charCode].charCodeAt(0));
                        }
                    },
                    has: function(i) {
                        return this._map[i] !== undefined;
                    },
                    get: function(i) {
                        return this._map[i];
                    },
                    charCodeOf: function(v) {
                        return this._map.indexOf(v);
                    }
                };
                return ToUnicodeMap;
            })();
            var IdentityToUnicodeMap = (function IdentityToUnicodeMapClosure() {
                function IdentityToUnicodeMap(firstChar, lastChar) {
                    this.firstChar = firstChar;
                    this.lastChar = lastChar;
                }
                IdentityToUnicodeMap.prototype = {
                    get length() {
                        return (this.lastChar + 1) - this.firstChar;
                    },
                    forEach: function(callback) {
                        for (var i = this.firstChar, ii = this.lastChar; i <= ii; i++) {
                            callback(i, i);
                        }
                    },
                    has: function(i) {
                        return this.firstChar <= i && i <= this.lastChar;
                    },
                    get: function(i) {
                        if (this.firstChar <= i && i <= this.lastChar) {
                            return String.fromCharCode(i);
                        }
                        return undefined;
                    },
                    charCodeOf: function(v) {
                        return (isInt(v) && v >= this.firstChar && v <= this.lastChar) ? v : -1;
                    }
                };
                return IdentityToUnicodeMap;
            })();
            var OpenTypeFileBuilder = (function OpenTypeFileBuilderClosure() {
                function writeInt16(dest, offset, num) {
                    dest[offset] = (num >> 8) & 0xFF;
                    dest[offset + 1] = num & 0xFF;
                }

                function writeInt32(dest, offset, num) {
                    dest[offset] = (num >> 24) & 0xFF;
                    dest[offset + 1] = (num >> 16) & 0xFF;
                    dest[offset + 2] = (num >> 8) & 0xFF;
                    dest[offset + 3] = num & 0xFF;
                }

                function writeData(dest, offset, data) {
                    var i, ii;
                    if (data instanceof Uint8Array) {
                        dest.set(data, offset);
                    } else if (typeof data === 'string') {
                        for (i = 0, ii = data.length; i < ii; i++) {
                            dest[offset++] = data.charCodeAt(i) & 0xFF;
                        }
                    } else {
                        for (i = 0, ii = data.length; i < ii; i++) {
                            dest[offset++] = data[i] & 0xFF;
                        }
                    }
                }

                function OpenTypeFileBuilder(sfnt) {
                    this.sfnt = sfnt;
                    this.tables = Object.create(null);
                }
                OpenTypeFileBuilder.getSearchParams = function OpenTypeFileBuilder_getSearchParams(entriesCount, entrySize) {
                    var maxPower2 = 1,
                        log2 = 0;
                    while ((maxPower2 ^ entriesCount) > maxPower2) {
                        maxPower2 <<= 1;
                        log2++;
                    }
                    var searchRange = maxPower2 * entrySize;
                    return {
                        range: searchRange,
                        entry: log2,
                        rangeShift: entrySize * entriesCount - searchRange
                    };
                };
                var OTF_HEADER_SIZE = 12;
                var OTF_TABLE_ENTRY_SIZE = 16;
                OpenTypeFileBuilder.prototype = {
                    toArray: function OpenTypeFileBuilder_toArray() {
                        var sfnt = this.sfnt;
                        var tables = this.tables;
                        var tablesNames = Object.keys(tables);
                        tablesNames.sort();
                        var numTables = tablesNames.length;
                        var i, j, jj, table, tableName;
                        var offset = OTF_HEADER_SIZE + numTables * OTF_TABLE_ENTRY_SIZE;
                        var tableOffsets = [offset];
                        for (i = 0; i < numTables; i++) {
                            table = tables[tablesNames[i]];
                            var paddedLength = ((table.length + 3) & ~3) >>> 0;
                            offset += paddedLength;
                            tableOffsets.push(offset);
                        }
                        var file = new Uint8Array(offset);
                        for (i = 0; i < numTables; i++) {
                            table = tables[tablesNames[i]];
                            writeData(file, tableOffsets[i], table);
                        }
                        if (sfnt === 'true') {
                            sfnt = string32(0x00010000);
                        }
                        file[0] = sfnt.charCodeAt(0) & 0xFF;
                        file[1] = sfnt.charCodeAt(1) & 0xFF;
                        file[2] = sfnt.charCodeAt(2) & 0xFF;
                        file[3] = sfnt.charCodeAt(3) & 0xFF;
                        writeInt16(file, 4, numTables);
                        var searchParams = OpenTypeFileBuilder.getSearchParams(numTables, 16);
                        writeInt16(file, 6, searchParams.range);
                        writeInt16(file, 8, searchParams.entry);
                        writeInt16(file, 10, searchParams.rangeShift);
                        offset = OTF_HEADER_SIZE;
                        for (i = 0; i < numTables; i++) {
                            tableName = tablesNames[i];
                            file[offset] = tableName.charCodeAt(0) & 0xFF;
                            file[offset + 1] = tableName.charCodeAt(1) & 0xFF;
                            file[offset + 2] = tableName.charCodeAt(2) & 0xFF;
                            file[offset + 3] = tableName.charCodeAt(3) & 0xFF;
                            var checksum = 0;
                            for (j = tableOffsets[i], jj = tableOffsets[i + 1]; j < jj; j += 4) {
                                var quad = (file[j] << 24) + (file[j + 1] << 16) +
                                    (file[j + 2] << 8) + file[j + 3];
                                checksum = (checksum + quad) | 0;
                            }
                            writeInt32(file, offset + 4, checksum);
                            writeInt32(file, offset + 8, tableOffsets[i]);
                            writeInt32(file, offset + 12, tables[tableName].length);
                            offset += OTF_TABLE_ENTRY_SIZE;
                        }
                        return file;
                    },
                    addTable: function OpenTypeFileBuilder_addTable(tag, data) {
                        if (tag in this.tables) {
                            throw new Error('Table ' + tag + ' already exists');
                        }
                        this.tables[tag] = data;
                    }
                };
                return OpenTypeFileBuilder;
            })();
            var ProblematicCharRanges = new Int32Array([0x0000, 0x0020, 0x007F, 0x00A1, 0x00AD, 0x00AE, 0x0600, 0x0780, 0x08A0, 0x10A0, 0x1780, 0x1800, 0x2000, 0x2010, 0x2011, 0x2012, 0x2028, 0x2030, 0x205F, 0x2070, 0x25CC, 0x25CD, 0xAA60, 0xAA80, 0xFFF0, 0x10000]);
            var Font = (function FontClosure() {
                function Font(name, file, properties) {
                    var charCode, glyphName, fontChar;
                    this.name = name;
                    this.loadedName = properties.loadedName;
                    this.isType3Font = properties.isType3Font;
                    this.sizes = [];
                    this.glyphCache = {};
                    var names = name.split('+');
                    names = names.length > 1 ? names[1] : names[0];
                    names = names.split(/[-,_]/g)[0];
                    this.isSerifFont = !!(properties.flags & FontFlags.Serif);
                    this.isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
                    this.isMonospace = !!(properties.flags & FontFlags.FixedPitch);
                    var type = properties.type;
                    var subtype = properties.subtype;
                    this.type = type;
                    this.fallbackName = (this.isMonospace ? 'monospace' : (this.isSerifFont ? 'serif' : 'sans-serif'));
                    this.differences = properties.differences;
                    this.widths = properties.widths;
                    this.defaultWidth = properties.defaultWidth;
                    this.composite = properties.composite;
                    this.wideChars = properties.wideChars;
                    this.cMap = properties.cMap;
                    this.ascent = properties.ascent / PDF_GLYPH_SPACE_UNITS;
                    this.descent = properties.descent / PDF_GLYPH_SPACE_UNITS;
                    this.fontMatrix = properties.fontMatrix;
                    this.bbox = properties.bbox;
                    this.toUnicode = properties.toUnicode = this.buildToUnicode(properties);
                    this.toFontChar = [];
                    if (properties.type === 'Type3') {
                        for (charCode = 0; charCode < 256; charCode++) {
                            this.toFontChar[charCode] = (this.differences[charCode] || properties.defaultEncoding[charCode]);
                        }
                        this.fontType = FontType.TYPE3;
                        return;
                    }
                    this.cidEncoding = properties.cidEncoding;
                    this.vertical = properties.vertical;
                    if (this.vertical) {
                        this.vmetrics = properties.vmetrics;
                        this.defaultVMetrics = properties.defaultVMetrics;
                    }
                    if (!file || file.isEmpty) {
                        if (file) {
                            warn('Font file is empty in "' + name + '" (' + this.loadedName + ')');
                        }
                        this.missingFile = true;
                        var fontName = name.replace(/[,_]/g, '-');
                        var isStandardFont = !!stdFontMap[fontName] || !!(nonStdFontMap[fontName] && stdFontMap[nonStdFontMap[fontName]]);
                        fontName = stdFontMap[fontName] || nonStdFontMap[fontName] || fontName;
                        this.bold = (fontName.search(/bold/gi) !== -1);
                        this.italic = ((fontName.search(/oblique/gi) !== -1) || (fontName.search(/italic/gi) !== -1));
                        this.black = (name.search(/Black/g) !== -1);
                        this.remeasure = Object.keys(this.widths).length > 0;
                        if (isStandardFont && type === 'CIDFontType2' && properties.cidEncoding.indexOf('Identity-') === 0) {
                            var map = [];
                            for (charCode in GlyphMapForStandardFonts) {
                                map[+charCode] = GlyphMapForStandardFonts[charCode];
                            }
                            if (/ArialBlack/i.test(name)) {
                                for (charCode in SupplementalGlyphMapForArialBlack) {
                                    map[+charCode] = SupplementalGlyphMapForArialBlack[charCode];
                                }
                            }
                            var isIdentityUnicode = this.toUnicode instanceof IdentityToUnicodeMap;
                            if (!isIdentityUnicode) {
                                this.toUnicode.forEach(function(charCode, unicodeCharCode) {
                                    map[+charCode] = unicodeCharCode;
                                });
                            }
                            this.toFontChar = map;
                            this.toUnicode = new ToUnicodeMap(map);
                        } else if (/Symbol/i.test(fontName)) {
                            var symbols = Encodings.SymbolSetEncoding;
                            for (charCode in symbols) {
                                fontChar = GlyphsUnicode[symbols[charCode]];
                                if (!fontChar) {
                                    continue;
                                }
                                this.toFontChar[charCode] = fontChar;
                            }
                            for (charCode in properties.differences) {
                                fontChar = GlyphsUnicode[properties.differences[charCode]];
                                if (!fontChar) {
                                    continue;
                                }
                                this.toFontChar[charCode] = fontChar;
                            }
                        } else if (/Dingbats/i.test(fontName)) {
                            if (/Wingdings/i.test(name)) {
                                warn('Wingdings font without embedded font file, ' + 'falling back to the ZapfDingbats encoding.');
                            }
                            var dingbats = Encodings.ZapfDingbatsEncoding;
                            for (charCode in dingbats) {
                                fontChar = DingbatsGlyphsUnicode[dingbats[charCode]];
                                if (!fontChar) {
                                    continue;
                                }
                                this.toFontChar[charCode] = fontChar;
                            }
                            for (charCode in properties.differences) {
                                fontChar = DingbatsGlyphsUnicode[properties.differences[charCode]];
                                if (!fontChar) {
                                    continue;
                                }
                                this.toFontChar[charCode] = fontChar;
                            }
                        } else if (isStandardFont) {
                            this.toFontChar = [];
                            for (charCode in properties.defaultEncoding) {
                                glyphName = (properties.differences[charCode] || properties.defaultEncoding[charCode]);
                                this.toFontChar[charCode] = GlyphsUnicode[glyphName];
                            }
                        } else {
                            var unicodeCharCode, notCidFont = (type.indexOf('CIDFontType') === -1);
                            this.toUnicode.forEach(function(charCode, unicodeCharCode) {
                                if (notCidFont) {
                                    glyphName = (properties.differences[charCode] || properties.defaultEncoding[charCode]);
                                    unicodeCharCode = (GlyphsUnicode[glyphName] || unicodeCharCode);
                                }
                                this.toFontChar[charCode] = unicodeCharCode;
                            }.bind(this));
                        }
                        this.loadedName = fontName.split('-')[0];
                        this.loading = false;
                        this.fontType = getFontType(type, subtype);
                        return;
                    }
                    if (subtype === 'Type1C' && (type !== 'Type1' && type !== 'MMType1')) {
                        if (isTrueTypeFile(file)) {
                            subtype = 'TrueType';
                        } else {
                            type = 'Type1';
                        }
                    }
                    if (subtype === 'CIDFontType0C' && type !== 'CIDFontType0') {
                        type = 'CIDFontType0';
                    }
                    if (subtype === 'OpenType') {
                        type = 'OpenType';
                    }
                    if (type === 'CIDFontType0') {
                        if (isType1File(file)) {
                            subtype = 'CIDFontType0';
                        } else if (isOpenTypeFile(file)) {
                            type = subtype = 'OpenType';
                        } else {
                            subtype = 'CIDFontType0C';
                        }
                    }
                    var data;
                    switch (type) {
                        case 'MMType1':
                            info('MMType1 font (' + name + '), falling back to Type1.');
                        case 'Type1':
                        case 'CIDFontType0':
                            this.mimetype = 'font/opentype';
                            var cff = (subtype === 'Type1C' || subtype === 'CIDFontType0C') ? new CFFFont(file, properties) : new Type1Font(name, file, properties);
                            adjustWidths(properties);
                            data = this.convert(name, cff, properties);
                            break;
                        case 'OpenType':
                        case 'TrueType':
                        case 'CIDFontType2':
                            this.mimetype = 'font/opentype';
                            data = this.checkAndRepair(name, file, properties);
                            if (this.isOpenType) {
                                adjustWidths(properties);
                                type = 'OpenType';
                            }
                            break;
                        default:
                            error('Font ' + type + ' is not supported');
                            break;
                    }
                    this.data = data;
                    this.fontType = getFontType(type, subtype);
                    this.fontMatrix = properties.fontMatrix;
                    this.widths = properties.widths;
                    this.defaultWidth = properties.defaultWidth;
                    this.encoding = properties.baseEncoding;
                    this.seacMap = properties.seacMap;
                    this.loading = true;
                }
                Font.getFontID = (function() {
                    var ID = 1;
                    return function Font_getFontID() {
                        return String(ID++);
                    };
                })();

                function int16(b0, b1) {
                    return (b0 << 8) + b1;
                }

                function int32(b0, b1, b2, b3) {
                    return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
                }

                function string16(value) {
                    return String.fromCharCode((value >> 8) & 0xff, value & 0xff);
                }

                function safeString16(value) {
                    value = (value > 0x7FFF ? 0x7FFF : (value < -0x8000 ? -0x8000 : value));
                    return String.fromCharCode((value >> 8) & 0xff, value & 0xff);
                }

                function isTrueTypeFile(file) {
                    var header = file.peekBytes(4);
                    return readUint32(header, 0) === 0x00010000;
                }

                function isOpenTypeFile(file) {
                    var header = file.peekBytes(4);
                    return bytesToString(header) === 'OTTO';
                }

                function isType1File(file) {
                    var header = file.peekBytes(2);
                    if (header[0] === 0x25 && header[1] === 0x21) {
                        return true;
                    }
                    if (header[0] === 0x80 && header[1] === 0x01) {
                        return true;
                    }
                    return false;
                }

                function isProblematicUnicodeLocation(code) {
                    var i = 0,
                        j = ProblematicCharRanges.length - 1;
                    while (i < j) {
                        var c = (i + j + 1) >> 1;
                        if (code < ProblematicCharRanges[c]) {
                            j = c - 1;
                        } else {
                            i = c;
                        }
                    }
                    return !(i & 1);
                }

                function adjustMapping(charCodeToGlyphId, properties) {
                    var toUnicode = properties.toUnicode;
                    var isSymbolic = !!(properties.flags & FontFlags.Symbolic);
                    var isIdentityUnicode = properties.toUnicode instanceof IdentityToUnicodeMap;
                    var newMap = Object.create(null);
                    var toFontChar = [];
                    var usedFontCharCodes = [];
                    var nextAvailableFontCharCode = PRIVATE_USE_OFFSET_START;
                    for (var originalCharCode in charCodeToGlyphId) {
                        originalCharCode |= 0;
                        var glyphId = charCodeToGlyphId[originalCharCode];
                        var fontCharCode = originalCharCode;
                        if (!isIdentityUnicode && toUnicode.has(originalCharCode)) {
                            var unicode = toUnicode.get(fontCharCode);
                            if (unicode.length === 1) {
                                fontCharCode = unicode.charCodeAt(0);
                            }
                        }
                        if ((usedFontCharCodes[fontCharCode] !== undefined || isProblematicUnicodeLocation(fontCharCode) || (isSymbolic && isIdentityUnicode)) && nextAvailableFontCharCode <= PRIVATE_USE_OFFSET_END) {
                            do {
                                fontCharCode = nextAvailableFontCharCode++;
                                if (SKIP_PRIVATE_USE_RANGE_F000_TO_F01F && fontCharCode === 0xF000) {
                                    fontCharCode = 0xF020;
                                    nextAvailableFontCharCode = fontCharCode + 1;
                                }
                            } while (usedFontCharCodes[fontCharCode] !== undefined && nextAvailableFontCharCode <= PRIVATE_USE_OFFSET_END);
                        }
                        newMap[fontCharCode] = glyphId;
                        toFontChar[originalCharCode] = fontCharCode;
                        usedFontCharCodes[fontCharCode] = true;
                    }
                    return {
                        toFontChar: toFontChar,
                        charCodeToGlyphId: newMap,
                        nextAvailableFontCharCode: nextAvailableFontCharCode
                    };
                }

                function getRanges(glyphs, numGlyphs) {
                    var codes = [];
                    for (var charCode in glyphs) {
                        if (glyphs[charCode] >= numGlyphs) {
                            continue;
                        }
                        codes.push({
                            fontCharCode: charCode | 0,
                            glyphId: glyphs[charCode]
                        });
                    }
                    codes.sort(function fontGetRangesSort(a, b) {
                        return a.fontCharCode - b.fontCharCode;
                    });
                    var ranges = [];
                    var length = codes.length;
                    for (var n = 0; n < length;) {
                        var start = codes[n].fontCharCode;
                        var codeIndices = [codes[n].glyphId];
                        ++n;
                        var end = start;
                        while (n < length && end + 1 === codes[n].fontCharCode) {
                            codeIndices.push(codes[n].glyphId);
                            ++end;
                            ++n;
                            if (end === 0xFFFF) {
                                break;
                            }
                        }
                        ranges.push([start, end, codeIndices]);
                    }
                    return ranges;
                }

                function createCmapTable(glyphs, numGlyphs) {
                    var ranges = getRanges(glyphs, numGlyphs);
                    var numTables = ranges[ranges.length - 1][1] > 0xFFFF ? 2 : 1;
                    var cmap = '\x00\x00' +
                        string16(numTables) + '\x00\x03' + '\x00\x01' +
                        string32(4 + numTables * 8);
                    var i, ii, j, jj;
                    for (i = ranges.length - 1; i >= 0; --i) {
                        if (ranges[i][0] <= 0xFFFF) {
                            break;
                        }
                    }
                    var bmpLength = i + 1;
                    if (ranges[i][0] < 0xFFFF && ranges[i][1] === 0xFFFF) {
                        ranges[i][1] = 0xFFFE;
                    }
                    var trailingRangesCount = ranges[i][1] < 0xFFFF ? 1 : 0;
                    var segCount = bmpLength + trailingRangesCount;
                    var searchParams = OpenTypeFileBuilder.getSearchParams(segCount, 2);
                    var startCount = '';
                    var endCount = '';
                    var idDeltas = '';
                    var idRangeOffsets = '';
                    var glyphsIds = '';
                    var bias = 0;
                    var range, start, end, codes;
                    for (i = 0, ii = bmpLength; i < ii; i++) {
                        range = ranges[i];
                        start = range[0];
                        end = range[1];
                        startCount += string16(start);
                        endCount += string16(end);
                        codes = range[2];
                        var contiguous = true;
                        for (j = 1, jj = codes.length; j < jj; ++j) {
                            if (codes[j] !== codes[j - 1] + 1) {
                                contiguous = false;
                                break;
                            }
                        }
                        if (!contiguous) {
                            var offset = (segCount - i) * 2 + bias * 2;
                            bias += (end - start + 1);
                            idDeltas += string16(0);
                            idRangeOffsets += string16(offset);
                            for (j = 0, jj = codes.length; j < jj; ++j) {
                                glyphsIds += string16(codes[j]);
                            }
                        } else {
                            var startCode = codes[0];
                            idDeltas += string16((startCode - start) & 0xFFFF);
                            idRangeOffsets += string16(0);
                        }
                    }
                    if (trailingRangesCount > 0) {
                        endCount += '\xFF\xFF';
                        startCount += '\xFF\xFF';
                        idDeltas += '\x00\x01';
                        idRangeOffsets += '\x00\x00';
                    }
                    var format314 = '\x00\x00' +
                        string16(2 * segCount) +
                        string16(searchParams.range) +
                        string16(searchParams.entry) +
                        string16(searchParams.rangeShift) +
                        endCount + '\x00\x00' + startCount +
                        idDeltas + idRangeOffsets + glyphsIds;
                    var format31012 = '';
                    var header31012 = '';
                    if (numTables > 1) {
                        cmap += '\x00\x03' + '\x00\x0A' +
                            string32(4 + numTables * 8 +
                                4 + format314.length);
                        format31012 = '';
                        for (i = 0, ii = ranges.length; i < ii; i++) {
                            range = ranges[i];
                            start = range[0];
                            codes = range[2];
                            var code = codes[0];
                            for (j = 1, jj = codes.length; j < jj; ++j) {
                                if (codes[j] !== codes[j - 1] + 1) {
                                    end = range[0] + j - 1;
                                    format31012 += string32(start) +
                                        string32(end) +
                                        string32(code);
                                    start = end + 1;
                                    code = codes[j];
                                }
                            }
                            format31012 += string32(start) +
                                string32(range[1]) +
                                string32(code);
                        }
                        header31012 = '\x00\x0C' + '\x00\x00' +
                            string32(format31012.length + 16) + '\x00\x00\x00\x00' +
                            string32(format31012.length / 12);
                    }
                    return cmap + '\x00\x04' +
                        string16(format314.length + 4) +
                        format314 + header31012 + format31012;
                }

                function validateOS2Table(os2) {
                    var stream = new Stream(os2.data);
                    var version = stream.getUint16();
                    stream.getBytes(60);
                    var selection = stream.getUint16();
                    if (version < 4 && (selection & 0x0300)) {
                        return false;
                    }
                    var firstChar = stream.getUint16();
                    var lastChar = stream.getUint16();
                    if (firstChar > lastChar) {
                        return false;
                    }
                    stream.getBytes(6);
                    var usWinAscent = stream.getUint16();
                    if (usWinAscent === 0) {
                        return false;
                    }
                    os2.data[8] = os2.data[9] = 0;
                    return true;
                }

                function createOS2Table(properties, charstrings, override) {
                    override = override || {
                        unitsPerEm: 0,
                        yMax: 0,
                        yMin: 0,
                        ascent: 0,
                        descent: 0
                    };
                    var ulUnicodeRange1 = 0;
                    var ulUnicodeRange2 = 0;
                    var ulUnicodeRange3 = 0;
                    var ulUnicodeRange4 = 0;
                    var firstCharIndex = null;
                    var lastCharIndex = 0;
                    if (charstrings) {
                        for (var code in charstrings) {
                            code |= 0;
                            if (firstCharIndex > code || !firstCharIndex) {
                                firstCharIndex = code;
                            }
                            if (lastCharIndex < code) {
                                lastCharIndex = code;
                            }
                            var position = getUnicodeRangeFor(code);
                            if (position < 32) {
                                ulUnicodeRange1 |= 1 << position;
                            } else if (position < 64) {
                                ulUnicodeRange2 |= 1 << position - 32;
                            } else if (position < 96) {
                                ulUnicodeRange3 |= 1 << position - 64;
                            } else if (position < 123) {
                                ulUnicodeRange4 |= 1 << position - 96;
                            } else {
                                error('Unicode ranges Bits > 123 are reserved for internal usage');
                            }
                        }
                    } else {
                        firstCharIndex = 0;
                        lastCharIndex = 255;
                    }
                    var bbox = properties.bbox || [0, 0, 0, 0];
                    var unitsPerEm = (override.unitsPerEm || 1 / (properties.fontMatrix || FONT_IDENTITY_MATRIX)[0]);
                    var scale = (properties.ascentScaled ? 1.0 : unitsPerEm / PDF_GLYPH_SPACE_UNITS);
                    var typoAscent = (override.ascent || Math.round(scale * (properties.ascent || bbox[3])));
                    var typoDescent = (override.descent || Math.round(scale * (properties.descent || bbox[1])));
                    if (typoDescent > 0 && properties.descent > 0 && bbox[1] < 0) {
                        typoDescent = -typoDescent;
                    }
                    var winAscent = override.yMax || typoAscent;
                    var winDescent = -override.yMin || -typoDescent;
                    return '\x00\x03' + '\x02\x24' + '\x01\xF4' + '\x00\x05' + '\x00\x00' + '\x02\x8A' + '\x02\xBB' + '\x00\x00' + '\x00\x8C' + '\x02\x8A' + '\x02\xBB' + '\x00\x00' + '\x01\xDF' + '\x00\x31' + '\x01\x02' + '\x00\x00' + '\x00\x00\x06' +
                        String.fromCharCode(properties.fixedPitch ? 0x09 : 0x00) + '\x00\x00\x00\x00\x00\x00' +
                        string32(ulUnicodeRange1) +
                        string32(ulUnicodeRange2) +
                        string32(ulUnicodeRange3) +
                        string32(ulUnicodeRange4) + '\x2A\x32\x31\x2A' +
                        string16(properties.italicAngle ? 1 : 0) +
                        string16(firstCharIndex || properties.firstChar) +
                        string16(lastCharIndex || properties.lastChar) +
                        string16(typoAscent) +
                        string16(typoDescent) + '\x00\x64' +
                        string16(winAscent) +
                        string16(winDescent) + '\x00\x00\x00\x00' + '\x00\x00\x00\x00' +
                        string16(properties.xHeight) +
                        string16(properties.capHeight) +
                        string16(0) +
                        string16(firstCharIndex || properties.firstChar) + '\x00\x03';
                }

                function createPostTable(properties) {
                    var angle = Math.floor(properties.italicAngle * (Math.pow(2, 16)));
                    return ('\x00\x03\x00\x00' +
                        string32(angle) + '\x00\x00' + '\x00\x00' +
                        string32(properties.fixedPitch) + '\x00\x00\x00\x00' + '\x00\x00\x00\x00' + '\x00\x00\x00\x00' + '\x00\x00\x00\x00');
                }

                function createNameTable(name, proto) {
                    if (!proto) {
                        proto = [
                            [],
                            []
                        ];
                    }
                    var strings = [proto[0][0] || 'Original licence', proto[0][1] || name, proto[0][2] || 'Unknown', proto[0][3] || 'uniqueID', proto[0][4] || name, proto[0][5] || 'Version 0.11', proto[0][6] || '', proto[0][7] || 'Unknown', proto[0][8] || 'Unknown', proto[0][9] || 'Unknown'];
                    var stringsUnicode = [];
                    var i, ii, j, jj, str;
                    for (i = 0, ii = strings.length; i < ii; i++) {
                        str = proto[1][i] || strings[i];
                        var strBufUnicode = [];
                        for (j = 0, jj = str.length; j < jj; j++) {
                            strBufUnicode.push(string16(str.charCodeAt(j)));
                        }
                        stringsUnicode.push(strBufUnicode.join(''));
                    }
                    var names = [strings, stringsUnicode];
                    var platforms = ['\x00\x01', '\x00\x03'];
                    var encodings = ['\x00\x00', '\x00\x01'];
                    var languages = ['\x00\x00', '\x04\x09'];
                    var namesRecordCount = strings.length * platforms.length;
                    var nameTable = '\x00\x00' +
                        string16(namesRecordCount) +
                        string16(namesRecordCount * 12 + 6);
                    var strOffset = 0;
                    for (i = 0, ii = platforms.length; i < ii; i++) {
                        var strs = names[i];
                        for (j = 0, jj = strs.length; j < jj; j++) {
                            str = strs[j];
                            var nameRecord = platforms[i] +
                                encodings[i] +
                                languages[i] +
                                string16(j) +
                                string16(str.length) +
                                string16(strOffset);
                            nameTable += nameRecord;
                            strOffset += str.length;
                        }
                    }
                    nameTable += strings.join('') + stringsUnicode.join('');
                    return nameTable;
                }
                Font.prototype = {
                    name: null,
                    font: null,
                    mimetype: null,
                    encoding: null,
                    get renderer() {
                        var renderer = FontRendererFactory.create(this);
                        return shadow(this, 'renderer', renderer);
                    },
                    exportData: function Font_exportData() {
                        var data = {};
                        for (var i in this) {
                            if (this.hasOwnProperty(i)) {
                                data[i] = this[i];
                            }
                        }
                        return data;
                    },
                    checkAndRepair: function Font_checkAndRepair(name, font, properties) {
                        function readTableEntry(file) {
                            var tag = bytesToString(file.getBytes(4));
                            var checksum = file.getInt32();
                            var offset = file.getInt32() >>> 0;
                            var length = file.getInt32() >>> 0;
                            var previousPosition = file.pos;
                            file.pos = file.start ? file.start : 0;
                            file.skip(offset);
                            var data = file.getBytes(length);
                            file.pos = previousPosition;
                            if (tag === 'head') {
                                data[8] = data[9] = data[10] = data[11] = 0;
                                data[17] |= 0x20;
                            }
                            return {
                                tag: tag,
                                checksum: checksum,
                                length: length,
                                offset: offset,
                                data: data
                            };
                        }

                        function readOpenTypeHeader(ttf) {
                            return {
                                version: bytesToString(ttf.getBytes(4)),
                                numTables: ttf.getUint16(),
                                searchRange: ttf.getUint16(),
                                entrySelector: ttf.getUint16(),
                                rangeShift: ttf.getUint16()
                            };
                        }

                        function readCmapTable(cmap, font, isSymbolicFont, hasEncoding) {
                            if (!cmap) {
                                warn('No cmap table available.');
                                return {
                                    platformId: -1,
                                    encodingId: -1,
                                    mappings: [],
                                    hasShortCmap: false
                                };
                            }
                            var segment;
                            var start = (font.start ? font.start : 0) + cmap.offset;
                            font.pos = start;
                            var version = font.getUint16();
                            var numTables = font.getUint16();
                            var potentialTable;
                            var canBreak = false;
                            for (var i = 0; i < numTables; i++) {
                                var platformId = font.getUint16();
                                var encodingId = font.getUint16();
                                var offset = font.getInt32() >>> 0;
                                var useTable = false;
                                if (platformId === 0 && encodingId === 0) {
                                    useTable = true;
                                } else if (platformId === 1 && encodingId === 0) {
                                    useTable = true;
                                } else if (platformId === 3 && encodingId === 1 && ((!isSymbolicFont && hasEncoding) || !potentialTable)) {
                                    useTable = true;
                                    if (!isSymbolicFont) {
                                        canBreak = true;
                                    }
                                } else if (isSymbolicFont && platformId === 3 && encodingId === 0) {
                                    useTable = true;
                                    canBreak = true;
                                }
                                if (useTable) {
                                    potentialTable = {
                                        platformId: platformId,
                                        encodingId: encodingId,
                                        offset: offset
                                    };
                                }
                                if (canBreak) {
                                    break;
                                }
                            }
                            if (potentialTable) {
                                font.pos = start + potentialTable.offset;
                            }
                            if (!potentialTable || font.peekByte() === -1) {
                                warn('Could not find a preferred cmap table.');
                                return {
                                    platformId: -1,
                                    encodingId: -1,
                                    mappings: [],
                                    hasShortCmap: false
                                };
                            }
                            var format = font.getUint16();
                            var length = font.getUint16();
                            var language = font.getUint16();
                            var hasShortCmap = false;
                            var mappings = [];
                            var j, glyphId;
                            if (format === 0) {
                                for (j = 0; j < 256; j++) {
                                    var index = font.getByte();
                                    if (!index) {
                                        continue;
                                    }
                                    mappings.push({
                                        charCode: j,
                                        glyphId: index
                                    });
                                }
                                hasShortCmap = true;
                            } else if (format === 4) {
                                var segCount = (font.getUint16() >> 1);
                                font.getBytes(6);
                                var segIndex, segments = [];
                                for (segIndex = 0; segIndex < segCount; segIndex++) {
                                    segments.push({
                                        end: font.getUint16()
                                    });
                                }
                                font.getUint16();
                                for (segIndex = 0; segIndex < segCount; segIndex++) {
                                    segments[segIndex].start = font.getUint16();
                                }
                                for (segIndex = 0; segIndex < segCount; segIndex++) {
                                    segments[segIndex].delta = font.getUint16();
                                }
                                var offsetsCount = 0;
                                for (segIndex = 0; segIndex < segCount; segIndex++) {
                                    segment = segments[segIndex];
                                    var rangeOffset = font.getUint16();
                                    if (!rangeOffset) {
                                        segment.offsetIndex = -1;
                                        continue;
                                    }
                                    var offsetIndex = (rangeOffset >> 1) - (segCount - segIndex);
                                    segment.offsetIndex = offsetIndex;
                                    offsetsCount = Math.max(offsetsCount, offsetIndex +
                                        segment.end - segment.start + 1);
                                }
                                var offsets = [];
                                for (j = 0; j < offsetsCount; j++) {
                                    offsets.push(font.getUint16());
                                }
                                for (segIndex = 0; segIndex < segCount; segIndex++) {
                                    segment = segments[segIndex];
                                    start = segment.start;
                                    var end = segment.end;
                                    var delta = segment.delta;
                                    offsetIndex = segment.offsetIndex;
                                    for (j = start; j <= end; j++) {
                                        if (j === 0xFFFF) {
                                            continue;
                                        }
                                        glyphId = (offsetIndex < 0 ? j : offsets[offsetIndex + j - start]);
                                        glyphId = (glyphId + delta) & 0xFFFF;
                                        if (glyphId === 0) {
                                            continue;
                                        }
                                        mappings.push({
                                            charCode: j,
                                            glyphId: glyphId
                                        });
                                    }
                                }
                            } else if (format === 6) {
                                var firstCode = font.getUint16();
                                var entryCount = font.getUint16();
                                for (j = 0; j < entryCount; j++) {
                                    glyphId = font.getUint16();
                                    var charCode = firstCode + j;
                                    mappings.push({
                                        charCode: charCode,
                                        glyphId: glyphId
                                    });
                                }
                            } else {
                                warn('cmap table has unsupported format: ' + format);
                                return {
                                    platformId: -1,
                                    encodingId: -1,
                                    mappings: [],
                                    hasShortCmap: false
                                };
                            }
                            mappings.sort(function(a, b) {
                                return a.charCode - b.charCode;
                            });
                            for (i = 1; i < mappings.length; i++) {
                                if (mappings[i - 1].charCode === mappings[i].charCode) {
                                    mappings.splice(i, 1);
                                    i--;
                                }
                            }
                            return {
                                platformId: potentialTable.platformId,
                                encodingId: potentialTable.encodingId,
                                mappings: mappings,
                                hasShortCmap: hasShortCmap
                            };
                        }

                        function sanitizeMetrics(font, header, metrics, numGlyphs) {
                            if (!header) {
                                if (metrics) {
                                    metrics.data = null;
                                }
                                return;
                            }
                            font.pos = (font.start ? font.start : 0) + header.offset;
                            font.pos += header.length - 2;
                            var numOfMetrics = font.getUint16();
                            if (numOfMetrics > numGlyphs) {
                                info('The numOfMetrics (' + numOfMetrics + ') should not be ' + 'greater than the numGlyphs (' + numGlyphs + ')');
                                numOfMetrics = numGlyphs;
                                header.data[34] = (numOfMetrics & 0xff00) >> 8;
                                header.data[35] = numOfMetrics & 0x00ff;
                            }
                            var numOfSidebearings = numGlyphs - numOfMetrics;
                            var numMissing = numOfSidebearings -
                                ((metrics.length - numOfMetrics * 4) >> 1);
                            if (numMissing > 0) {
                                var entries = new Uint8Array(metrics.length + numMissing * 2);
                                entries.set(metrics.data);
                                metrics.data = entries;
                            }
                        }

                        function sanitizeGlyph(source, sourceStart, sourceEnd, dest, destStart, hintsValid) {
                            if (sourceEnd - sourceStart <= 12) {
                                return 0;
                            }
                            var glyf = source.subarray(sourceStart, sourceEnd);
                            var contoursCount = (glyf[0] << 8) | glyf[1];
                            if (contoursCount & 0x8000) {
                                dest.set(glyf, destStart);
                                return glyf.length;
                            }
                            var i, j = 10,
                                flagsCount = 0;
                            for (i = 0; i < contoursCount; i++) {
                                var endPoint = (glyf[j] << 8) | glyf[j + 1];
                                flagsCount = endPoint + 1;
                                j += 2;
                            }
                            var instructionsStart = j;
                            var instructionsLength = (glyf[j] << 8) | glyf[j + 1];
                            j += 2 + instructionsLength;
                            var instructionsEnd = j;
                            var coordinatesLength = 0;
                            for (i = 0; i < flagsCount; i++) {
                                var flag = glyf[j++];
                                if (flag & 0xC0) {
                                    glyf[j - 1] = flag & 0x3F;
                                }
                                var xyLength = ((flag & 2) ? 1 : (flag & 16) ? 0 : 2) +
                                    ((flag & 4) ? 1 : (flag & 32) ? 0 : 2);
                                coordinatesLength += xyLength;
                                if (flag & 8) {
                                    var repeat = glyf[j++];
                                    i += repeat;
                                    coordinatesLength += repeat * xyLength;
                                }
                            }
                            if (coordinatesLength === 0) {
                                return 0;
                            }
                            var glyphDataLength = j + coordinatesLength;
                            if (glyphDataLength > glyf.length) {
                                return 0;
                            }
                            if (!hintsValid && instructionsLength > 0) {
                                dest.set(glyf.subarray(0, instructionsStart), destStart);
                                dest.set([0, 0], destStart + instructionsStart);
                                dest.set(glyf.subarray(instructionsEnd, glyphDataLength), destStart + instructionsStart + 2);
                                glyphDataLength -= instructionsLength;
                                if (glyf.length - glyphDataLength > 3) {
                                    glyphDataLength = (glyphDataLength + 3) & ~3;
                                }
                                return glyphDataLength;
                            }
                            if (glyf.length - glyphDataLength > 3) {
                                glyphDataLength = (glyphDataLength + 3) & ~3;
                                dest.set(glyf.subarray(0, glyphDataLength), destStart);
                                return glyphDataLength;
                            }
                            dest.set(glyf, destStart);
                            return glyf.length;
                        }

                        function sanitizeHead(head, numGlyphs, locaLength) {
                            var data = head.data;
                            var version = int32(data[0], data[1], data[2], data[3]);
                            if (version >> 16 !== 1) {
                                info('Attempting to fix invalid version in head table: ' + version);
                                data[0] = 0;
                                data[1] = 1;
                                data[2] = 0;
                                data[3] = 0;
                            }
                            var indexToLocFormat = int16(data[50], data[51]);
                            if (indexToLocFormat < 0 || indexToLocFormat > 1) {
                                info('Attempting to fix invalid indexToLocFormat in head table: ' +
                                    indexToLocFormat);
                                var numGlyphsPlusOne = numGlyphs + 1;
                                if (locaLength === numGlyphsPlusOne << 1) {
                                    data[50] = 0;
                                    data[51] = 0;
                                } else if (locaLength === numGlyphsPlusOne << 2) {
                                    data[50] = 0;
                                    data[51] = 1;
                                } else {
                                    warn('Could not fix indexToLocFormat: ' + indexToLocFormat);
                                }
                            }
                        }

                        function sanitizeGlyphLocations(loca, glyf, numGlyphs, isGlyphLocationsLong, hintsValid, dupFirstEntry) {
                            var itemSize, itemDecode, itemEncode;
                            if (isGlyphLocationsLong) {
                                itemSize = 4;
                                itemDecode = function fontItemDecodeLong(data, offset) {
                                    return (data[offset] << 24) | (data[offset + 1] << 16) | (data[offset + 2] << 8) | data[offset + 3];
                                };
                                itemEncode = function fontItemEncodeLong(data, offset, value) {
                                    data[offset] = (value >>> 24) & 0xFF;
                                    data[offset + 1] = (value >> 16) & 0xFF;
                                    data[offset + 2] = (value >> 8) & 0xFF;
                                    data[offset + 3] = value & 0xFF;
                                };
                            } else {
                                itemSize = 2;
                                itemDecode = function fontItemDecode(data, offset) {
                                    return (data[offset] << 9) | (data[offset + 1] << 1);
                                };
                                itemEncode = function fontItemEncode(data, offset, value) {
                                    data[offset] = (value >> 9) & 0xFF;
                                    data[offset + 1] = (value >> 1) & 0xFF;
                                };
                            }
                            var locaData = loca.data;
                            var locaDataSize = itemSize * (1 + numGlyphs);
                            if (locaData.length !== locaDataSize) {
                                locaData = new Uint8Array(locaDataSize);
                                locaData.set(loca.data.subarray(0, locaDataSize));
                                loca.data = locaData;
                            }
                            var oldGlyfData = glyf.data;
                            var oldGlyfDataLength = oldGlyfData.length;
                            var newGlyfData = new Uint8Array(oldGlyfDataLength);
                            var startOffset = itemDecode(locaData, 0);
                            var writeOffset = 0;
                            var missingGlyphData = {};
                            itemEncode(locaData, 0, writeOffset);
                            var i, j;
                            for (i = 0, j = itemSize; i < numGlyphs; i++, j += itemSize) {
                                var endOffset = itemDecode(locaData, j);
                                if (endOffset > oldGlyfDataLength && ((oldGlyfDataLength + 3) & ~3) === endOffset) {
                                    endOffset = oldGlyfDataLength;
                                }
                                if (endOffset > oldGlyfDataLength) {
                                    itemEncode(locaData, j, writeOffset);
                                    startOffset = endOffset;
                                    continue;
                                }
                                if (startOffset === endOffset) {
                                    missingGlyphData[i] = true;
                                }
                                var newLength = sanitizeGlyph(oldGlyfData, startOffset, endOffset, newGlyfData, writeOffset, hintsValid);
                                writeOffset += newLength;
                                itemEncode(locaData, j, writeOffset);
                                startOffset = endOffset;
                            }
                            if (writeOffset === 0) {
                                var simpleGlyph = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);
                                for (i = 0, j = itemSize; i < numGlyphs; i++, j += itemSize) {
                                    itemEncode(locaData, j, simpleGlyph.length);
                                }
                                glyf.data = simpleGlyph;
                                return missingGlyphData;
                            }
                            if (dupFirstEntry) {
                                var firstEntryLength = itemDecode(locaData, itemSize);
                                if (newGlyfData.length > firstEntryLength + writeOffset) {
                                    glyf.data = newGlyfData.subarray(0, firstEntryLength + writeOffset);
                                } else {
                                    glyf.data = new Uint8Array(firstEntryLength + writeOffset);
                                    glyf.data.set(newGlyfData.subarray(0, writeOffset));
                                }
                                glyf.data.set(newGlyfData.subarray(0, firstEntryLength), writeOffset);
                                itemEncode(loca.data, locaData.length - itemSize, writeOffset + firstEntryLength);
                            } else {
                                glyf.data = newGlyfData.subarray(0, writeOffset);
                            }
                            return missingGlyphData;
                        }

                        function readPostScriptTable(post, properties, maxpNumGlyphs) {
                            var start = (font.start ? font.start : 0) + post.offset;
                            font.pos = start;
                            var length = post.length,
                                end = start + length;
                            var version = font.getInt32();
                            font.getBytes(28);
                            var glyphNames;
                            var valid = true;
                            var i;
                            switch (version) {
                                case 0x00010000:
                                    glyphNames = MacStandardGlyphOrdering;
                                    break;
                                case 0x00020000:
                                    var numGlyphs = font.getUint16();
                                    if (numGlyphs !== maxpNumGlyphs) {
                                        valid = false;
                                        break;
                                    }
                                    var glyphNameIndexes = [];
                                    for (i = 0; i < numGlyphs; ++i) {
                                        var index = font.getUint16();
                                        if (index >= 32768) {
                                            valid = false;
                                            break;
                                        }
                                        glyphNameIndexes.push(index);
                                    }
                                    if (!valid) {
                                        break;
                                    }
                                    var customNames = [];
                                    var strBuf = [];
                                    while (font.pos < end) {
                                        var stringLength = font.getByte();
                                        strBuf.length = stringLength;
                                        for (i = 0; i < stringLength; ++i) {
                                            strBuf[i] = String.fromCharCode(font.getByte());
                                        }
                                        customNames.push(strBuf.join(''));
                                    }
                                    glyphNames = [];
                                    for (i = 0; i < numGlyphs; ++i) {
                                        var j = glyphNameIndexes[i];
                                        if (j < 258) {
                                            glyphNames.push(MacStandardGlyphOrdering[j]);
                                            continue;
                                        }
                                        glyphNames.push(customNames[j - 258]);
                                    }
                                    break;
                                case 0x00030000:
                                    break;
                                default:
                                    warn('Unknown/unsupported post table version ' + version);
                                    valid = false;
                                    if (properties.defaultEncoding) {
                                        glyphNames = properties.defaultEncoding;
                                    }
                                    break;
                            }
                            properties.glyphNames = glyphNames;
                            return valid;
                        }

                        function readNameTable(nameTable) {
                            var start = (font.start ? font.start : 0) + nameTable.offset;
                            font.pos = start;
                            var names = [
                                [],
                                []
                            ];
                            var length = nameTable.length,
                                end = start + length;
                            var format = font.getUint16();
                            var FORMAT_0_HEADER_LENGTH = 6;
                            if (format !== 0 || length < FORMAT_0_HEADER_LENGTH) {
                                return names;
                            }
                            var numRecords = font.getUint16();
                            var stringsStart = font.getUint16();
                            var records = [];
                            var NAME_RECORD_LENGTH = 12;
                            var i, ii;
                            for (i = 0; i < numRecords && font.pos + NAME_RECORD_LENGTH <= end; i++) {
                                var r = {
                                    platform: font.getUint16(),
                                    encoding: font.getUint16(),
                                    language: font.getUint16(),
                                    name: font.getUint16(),
                                    length: font.getUint16(),
                                    offset: font.getUint16()
                                };
                                if ((r.platform === 1 && r.encoding === 0 && r.language === 0) || (r.platform === 3 && r.encoding === 1 && r.language === 0x409)) {
                                    records.push(r);
                                }
                            }
                            for (i = 0, ii = records.length; i < ii; i++) {
                                var record = records[i];
                                var pos = start + stringsStart + record.offset;
                                if (pos + record.length > end) {
                                    continue;
                                }
                                font.pos = pos;
                                var nameIndex = record.name;
                                if (record.encoding) {
                                    var str = '';
                                    for (var j = 0, jj = record.length; j < jj; j += 2) {
                                        str += String.fromCharCode(font.getUint16());
                                    }
                                    names[1][nameIndex] = str;
                                } else {
                                    names[0][nameIndex] = bytesToString(font.getBytes(record.length));
                                }
                            }
                            return names;
                        }
                        var TTOpsStackDeltas = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];

                        function sanitizeTTProgram(table, ttContext) {
                            var data = table.data;
                            var i = 0,
                                j, n, b, funcId, pc, lastEndf = 0,
                                lastDeff = 0;
                            var stack = [];
                            var callstack = [];
                            var functionsCalled = [];
                            var tooComplexToFollowFunctions = ttContext.tooComplexToFollowFunctions;
                            var inFDEF = false,
                                ifLevel = 0,
                                inELSE = 0;
                            for (var ii = data.length; i < ii;) {
                                var op = data[i++];
                                if (op === 0x40) {
                                    n = data[i++];
                                    if (inFDEF || inELSE) {
                                        i += n;
                                    } else {
                                        for (j = 0; j < n; j++) {
                                            stack.push(data[i++]);
                                        }
                                    }
                                } else if (op === 0x41) {
                                    n = data[i++];
                                    if (inFDEF || inELSE) {
                                        i += n * 2;
                                    } else {
                                        for (j = 0; j < n; j++) {
                                            b = data[i++];
                                            stack.push((b << 8) | data[i++]);
                                        }
                                    }
                                } else if ((op & 0xF8) === 0xB0) {
                                    n = op - 0xB0 + 1;
                                    if (inFDEF || inELSE) {
                                        i += n;
                                    } else {
                                        for (j = 0; j < n; j++) {
                                            stack.push(data[i++]);
                                        }
                                    }
                                } else if ((op & 0xF8) === 0xB8) {
                                    n = op - 0xB8 + 1;
                                    if (inFDEF || inELSE) {
                                        i += n * 2;
                                    } else {
                                        for (j = 0; j < n; j++) {
                                            b = data[i++];
                                            stack.push((b << 8) | data[i++]);
                                        }
                                    }
                                } else if (op === 0x2B && !tooComplexToFollowFunctions) {
                                    if (!inFDEF && !inELSE) {
                                        funcId = stack[stack.length - 1];
                                        ttContext.functionsUsed[funcId] = true;
                                        if (funcId in ttContext.functionsStackDeltas) {
                                            stack.length += ttContext.functionsStackDeltas[funcId];
                                        } else if (funcId in ttContext.functionsDefined && functionsCalled.indexOf(funcId) < 0) {
                                            callstack.push({
                                                data: data,
                                                i: i,
                                                stackTop: stack.length - 1
                                            });
                                            functionsCalled.push(funcId);
                                            pc = ttContext.functionsDefined[funcId];
                                            if (!pc) {
                                                warn('TT: CALL non-existent function');
                                                ttContext.hintsValid = false;
                                                return;
                                            }
                                            data = pc.data;
                                            i = pc.i;
                                        }
                                    }
                                } else if (op === 0x2C && !tooComplexToFollowFunctions) {
                                    if (inFDEF || inELSE) {
                                        warn('TT: nested FDEFs not allowed');
                                        tooComplexToFollowFunctions = true;
                                    }
                                    inFDEF = true;
                                    lastDeff = i;
                                    funcId = stack.pop();
                                    ttContext.functionsDefined[funcId] = {
                                        data: data,
                                        i: i
                                    };
                                } else if (op === 0x2D) {
                                    if (inFDEF) {
                                        inFDEF = false;
                                        lastEndf = i;
                                    } else {
                                        pc = callstack.pop();
                                        if (!pc) {
                                            warn('TT: ENDF bad stack');
                                            ttContext.hintsValid = false;
                                            return;
                                        }
                                        funcId = functionsCalled.pop();
                                        data = pc.data;
                                        i = pc.i;
                                        ttContext.functionsStackDeltas[funcId] = stack.length - pc.stackTop;
                                    }
                                } else if (op === 0x89) {
                                    if (inFDEF || inELSE) {
                                        warn('TT: nested IDEFs not allowed');
                                        tooComplexToFollowFunctions = true;
                                    }
                                    inFDEF = true;
                                    lastDeff = i;
                                } else if (op === 0x58) {
                                    ++ifLevel;
                                } else if (op === 0x1B) {
                                    inELSE = ifLevel;
                                } else if (op === 0x59) {
                                    if (inELSE === ifLevel) {
                                        inELSE = 0;
                                    }
                                    --ifLevel;
                                } else if (op === 0x1C) {
                                    if (!inFDEF && !inELSE) {
                                        var offset = stack[stack.length - 1];
                                        if (offset > 0) {
                                            i += offset - 1;
                                        }
                                    }
                                }
                                if (!inFDEF && !inELSE) {
                                    var stackDelta = op <= 0x8E ? TTOpsStackDeltas[op] : op >= 0xC0 && op <= 0xDF ? -1 : op >= 0xE0 ? -2 : 0;
                                    if (op >= 0x71 && op <= 0x75) {
                                        n = stack.pop();
                                        if (n === n) {
                                            stackDelta = -n * 2;
                                        }
                                    }
                                    while (stackDelta < 0 && stack.length > 0) {
                                        stack.pop();
                                        stackDelta++;
                                    }
                                    while (stackDelta > 0) {
                                        stack.push(NaN);
                                        stackDelta--;
                                    }
                                }
                            }
                            ttContext.tooComplexToFollowFunctions = tooComplexToFollowFunctions;
                            var content = [data];
                            if (i > data.length) {
                                content.push(new Uint8Array(i - data.length));
                            }
                            if (lastDeff > lastEndf) {
                                warn('TT: complementing a missing function tail');
                                content.push(new Uint8Array([0x22, 0x2D]));
                            }
                            foldTTTable(table, content);
                        }

                        function checkInvalidFunctions(ttContext, maxFunctionDefs) {
                            if (ttContext.tooComplexToFollowFunctions) {
                                return;
                            }
                            if (ttContext.functionsDefined.length > maxFunctionDefs) {
                                warn('TT: more functions defined than expected');
                                ttContext.hintsValid = false;
                                return;
                            }
                            for (var j = 0, jj = ttContext.functionsUsed.length; j < jj; j++) {
                                if (j > maxFunctionDefs) {
                                    warn('TT: invalid function id: ' + j);
                                    ttContext.hintsValid = false;
                                    return;
                                }
                                if (ttContext.functionsUsed[j] && !ttContext.functionsDefined[j]) {
                                    warn('TT: undefined function: ' + j);
                                    ttContext.hintsValid = false;
                                    return;
                                }
                            }
                        }

                        function foldTTTable(table, content) {
                            if (content.length > 1) {
                                var newLength = 0;
                                var j, jj;
                                for (j = 0, jj = content.length; j < jj; j++) {
                                    newLength += content[j].length;
                                }
                                newLength = (newLength + 3) & ~3;
                                var result = new Uint8Array(newLength);
                                var pos = 0;
                                for (j = 0, jj = content.length; j < jj; j++) {
                                    result.set(content[j], pos);
                                    pos += content[j].length;
                                }
                                table.data = result;
                                table.length = newLength;
                            }
                        }

                        function sanitizeTTPrograms(fpgm, prep, cvt) {
                            var ttContext = {
                                functionsDefined: [],
                                functionsUsed: [],
                                functionsStackDeltas: [],
                                tooComplexToFollowFunctions: false,
                                hintsValid: true
                            };
                            if (fpgm) {
                                sanitizeTTProgram(fpgm, ttContext);
                            }
                            if (prep) {
                                sanitizeTTProgram(prep, ttContext);
                            }
                            if (fpgm) {
                                checkInvalidFunctions(ttContext, maxFunctionDefs);
                            }
                            if (cvt && (cvt.length & 1)) {
                                var cvtData = new Uint8Array(cvt.length + 1);
                                cvtData.set(cvt.data);
                                cvt.data = cvtData;
                            }
                            return ttContext.hintsValid;
                        }
                        font = new Stream(new Uint8Array(font.getBytes()));
                        var VALID_TABLES = ['OS/2', 'cmap', 'head', 'hhea', 'hmtx', 'maxp', 'name', 'post', 'loca', 'glyf', 'fpgm', 'prep', 'cvt ', 'CFF '];
                        var header = readOpenTypeHeader(font);
                        var numTables = header.numTables;
                        var cff, cffFile;
                        var tables = {
                            'OS/2': null,
                            cmap: null,
                            head: null,
                            hhea: null,
                            hmtx: null,
                            maxp: null,
                            name: null,
                            post: null
                        };
                        var table;
                        for (var i = 0; i < numTables; i++) {
                            table = readTableEntry(font);
                            if (VALID_TABLES.indexOf(table.tag) < 0) {
                                continue;
                            }
                            if (table.length === 0) {
                                continue;
                            }
                            tables[table.tag] = table;
                        }
                        var isTrueType = !tables['CFF '];
                        if (!isTrueType) {
                            if ((header.version === 'OTTO' && properties.type !== 'CIDFontType2') || !tables.head || !tables.hhea || !tables.maxp || !tables.post) {
                                cffFile = new Stream(tables['CFF '].data);
                                cff = new CFFFont(cffFile, properties);
                                adjustWidths(properties);
                                return this.convert(name, cff, properties);
                            }
                            delete tables.glyf;
                            delete tables.loca;
                            delete tables.fpgm;
                            delete tables.prep;
                            delete tables['cvt '];
                            this.isOpenType = true;
                        } else {
                            if (!tables.loca) {
                                error('Required "loca" table is not found');
                            }
                            if (!tables.glyf) {
                                warn('Required "glyf" table is not found -- trying to recover.');
                                tables.glyf = {
                                    tag: 'glyf',
                                    data: new Uint8Array(0),
                                };
                            }
                            this.isOpenType = false;
                        }
                        if (!tables.maxp) {
                            error('Required "maxp" table is not found');
                        }
                        font.pos = (font.start || 0) + tables.maxp.offset;
                        var version = font.getInt32();
                        var numGlyphs = font.getUint16();
                        var maxFunctionDefs = 0;
                        if (version >= 0x00010000 && tables.maxp.length >= 22) {
                            font.pos += 8;
                            var maxZones = font.getUint16();
                            if (maxZones > 2) {
                                tables.maxp.data[14] = 0;
                                tables.maxp.data[15] = 2;
                            }
                            font.pos += 4;
                            maxFunctionDefs = font.getUint16();
                        }
                        var dupFirstEntry = false;
                        if (properties.type === 'CIDFontType2' && properties.toUnicode && properties.toUnicode.get(0) > '\u0000') {
                            dupFirstEntry = true;
                            numGlyphs++;
                            tables.maxp.data[4] = numGlyphs >> 8;
                            tables.maxp.data[5] = numGlyphs & 255;
                        }
                        var hintsValid = sanitizeTTPrograms(tables.fpgm, tables.prep, tables['cvt '], maxFunctionDefs);
                        if (!hintsValid) {
                            delete tables.fpgm;
                            delete tables.prep;
                            delete tables['cvt '];
                        }
                        sanitizeMetrics(font, tables.hhea, tables.hmtx, numGlyphs);
                        if (!tables.head) {
                            error('Required "head" table is not found');
                        }
                        sanitizeHead(tables.head, numGlyphs, isTrueType ? tables.loca.length : 0);
                        var missingGlyphs = {};
                        if (isTrueType) {
                            var isGlyphLocationsLong = int16(tables.head.data[50], tables.head.data[51]);
                            missingGlyphs = sanitizeGlyphLocations(tables.loca, tables.glyf, numGlyphs, isGlyphLocationsLong, hintsValid, dupFirstEntry);
                        }
                        if (!tables.hhea) {
                            error('Required "hhea" table is not found');
                        }
                        if (tables.hhea.data[10] === 0 && tables.hhea.data[11] === 0) {
                            tables.hhea.data[10] = 0xFF;
                            tables.hhea.data[11] = 0xFF;
                        }
                        var metricsOverride = {
                            unitsPerEm: int16(tables.head.data[18], tables.head.data[19]),
                            yMax: int16(tables.head.data[42], tables.head.data[43]),
                            yMin: int16(tables.head.data[38], tables.head.data[39]) - 0x10000,
                            ascent: int16(tables.hhea.data[4], tables.hhea.data[5]),
                            descent: int16(tables.hhea.data[6], tables.hhea.data[7]) - 0x10000
                        };
                        this.ascent = metricsOverride.ascent / metricsOverride.unitsPerEm;
                        this.descent = metricsOverride.descent / metricsOverride.unitsPerEm;
                        if (tables.post) {
                            var valid = readPostScriptTable(tables.post, properties, numGlyphs);
                            if (!valid) {
                                tables.post = null;
                            }
                        }
                        var charCodeToGlyphId = [],
                            charCode;
                        var toUnicode = properties.toUnicode,
                            widths = properties.widths;
                        var skipToUnicode = (toUnicode instanceof IdentityToUnicodeMap || toUnicode.length === 0x10000);

                        function hasGlyph(glyphId, charCode, widthCode) {
                            if (!missingGlyphs[glyphId]) {
                                return true;
                            }
                            if (!skipToUnicode && charCode >= 0 && toUnicode.has(charCode)) {
                                return true;
                            }
                            if (widths && widthCode >= 0 && isNum(widths[widthCode])) {
                                return true;
                            }
                            return false;
                        }
                        if (properties.type === 'CIDFontType2') {
                            var cidToGidMap = properties.cidToGidMap || [];
                            var isCidToGidMapEmpty = cidToGidMap.length === 0;
                            properties.cMap.forEach(function(charCode, cid) {
                                assert(cid <= 0xffff, 'Max size of CID is 65,535');
                                var glyphId = -1;
                                if (isCidToGidMapEmpty) {
                                    glyphId = charCode;
                                } else if (cidToGidMap[cid] !== undefined) {
                                    glyphId = cidToGidMap[cid];
                                }
                                if (glyphId >= 0 && glyphId < numGlyphs && hasGlyph(glyphId, charCode, cid)) {
                                    charCodeToGlyphId[charCode] = glyphId;
                                }
                            });
                            if (dupFirstEntry) {
                                charCodeToGlyphId[0] = numGlyphs - 1;
                            }
                        } else {
                            var hasEncoding = properties.differences.length > 0 || !!properties.baseEncodingName;
                            var cmapTable = readCmapTable(tables.cmap, font, this.isSymbolicFont, hasEncoding);
                            var cmapPlatformId = cmapTable.platformId;
                            var cmapEncodingId = cmapTable.encodingId;
                            var cmapMappings = cmapTable.mappings;
                            var cmapMappingsLength = cmapMappings.length;
                            if (hasEncoding && (cmapPlatformId === 3 && cmapEncodingId === 1 || cmapPlatformId === 1 && cmapEncodingId === 0) || (cmapPlatformId === -1 && cmapEncodingId === -1 && !!Encodings[properties.baseEncodingName])) {
                                var baseEncoding = [];
                                if (properties.baseEncodingName === 'MacRomanEncoding' || properties.baseEncodingName === 'WinAnsiEncoding') {
                                    baseEncoding = Encodings[properties.baseEncodingName];
                                }
                                for (charCode = 0; charCode < 256; charCode++) {
                                    var glyphName;
                                    if (this.differences && charCode in this.differences) {
                                        glyphName = this.differences[charCode];
                                    } else if (charCode in baseEncoding && baseEncoding[charCode] !== '') {
                                        glyphName = baseEncoding[charCode];
                                    } else {
                                        glyphName = Encodings.StandardEncoding[charCode];
                                    }
                                    if (!glyphName) {
                                        continue;
                                    }
                                    var unicodeOrCharCode, isUnicode = false;
                                    if (cmapPlatformId === 3 && cmapEncodingId === 1) {
                                        unicodeOrCharCode = GlyphsUnicode[glyphName];
                                        isUnicode = true;
                                    } else if (cmapPlatformId === 1 && cmapEncodingId === 0) {
                                        unicodeOrCharCode = Encodings.MacRomanEncoding.indexOf(glyphName);
                                    }
                                    var found = false;
                                    for (i = 0; i < cmapMappingsLength; ++i) {
                                        if (cmapMappings[i].charCode !== unicodeOrCharCode) {
                                            continue;
                                        }
                                        var code = isUnicode ? charCode : unicodeOrCharCode;
                                        if (hasGlyph(cmapMappings[i].glyphId, code, -1)) {
                                            charCodeToGlyphId[charCode] = cmapMappings[i].glyphId;
                                            found = true;
                                            break;
                                        }
                                    }
                                    if (!found && properties.glyphNames) {
                                        var glyphId = properties.glyphNames.indexOf(glyphName);
                                        if (glyphId > 0 && hasGlyph(glyphId, -1, -1)) {
                                            charCodeToGlyphId[charCode] = glyphId;
                                            found = true;
                                        }
                                    }
                                    if (!found) {
                                        charCodeToGlyphId[charCode] = 0;
                                    }
                                }
                            } else if (cmapPlatformId === 0 && cmapEncodingId === 0) {
                                for (i = 0; i < cmapMappingsLength; ++i) {
                                    charCodeToGlyphId[cmapMappings[i].charCode] = cmapMappings[i].glyphId;
                                }
                            } else {
                                for (i = 0; i < cmapMappingsLength; ++i) {
                                    charCode = cmapMappings[i].charCode & 0xFF;
                                    charCodeToGlyphId[charCode] = cmapMappings[i].glyphId;
                                }
                            }
                        }
                        if (charCodeToGlyphId.length === 0) {
                            charCodeToGlyphId[0] = 0;
                        }
                        var newMapping = adjustMapping(charCodeToGlyphId, properties);
                        this.toFontChar = newMapping.toFontChar;
                        tables.cmap = {
                            tag: 'cmap',
                            data: createCmapTable(newMapping.charCodeToGlyphId, numGlyphs)
                        };
                        if (!tables['OS/2'] || !validateOS2Table(tables['OS/2'])) {
                            tables['OS/2'] = {
                                tag: 'OS/2',
                                data: createOS2Table(properties, newMapping.charCodeToGlyphId, metricsOverride)
                            };
                        }
                        if (!tables.post) {
                            tables.post = {
                                tag: 'post',
                                data: createPostTable(properties)
                            };
                        }
                        if (!isTrueType) {
                            try {
                                cffFile = new Stream(tables['CFF '].data);
                                var parser = new CFFParser(cffFile, properties);
                                cff = parser.parse();
                                var compiler = new CFFCompiler(cff);
                                tables['CFF '].data = compiler.compile();
                            } catch (e) {
                                warn('Failed to compile font ' + properties.loadedName);
                            }
                        }
                        if (!tables.name) {
                            tables.name = {
                                tag: 'name',
                                data: createNameTable(this.name)
                            };
                        } else {
                            var namePrototype = readNameTable(tables.name);
                            tables.name.data = createNameTable(name, namePrototype);
                        }
                        var builder = new OpenTypeFileBuilder(header.version);
                        for (var tableTag in tables) {
                            builder.addTable(tableTag, tables[tableTag].data);
                        }
                        return builder.toArray();
                    },
                    convert: function Font_convert(fontName, font, properties) {
                        properties.fixedPitch = false;
                        var mapping = font.getGlyphMapping(properties);
                        var newMapping = adjustMapping(mapping, properties);
                        this.toFontChar = newMapping.toFontChar;
                        var numGlyphs = font.numGlyphs;

                        function getCharCodes(charCodeToGlyphId, glyphId) {
                            var charCodes = null;
                            for (var charCode in charCodeToGlyphId) {
                                if (glyphId === charCodeToGlyphId[charCode]) {
                                    if (!charCodes) {
                                        charCodes = [];
                                    }
                                    charCodes.push(charCode | 0);
                                }
                            }
                            return charCodes;
                        }

                        function createCharCode(charCodeToGlyphId, glyphId) {
                            for (var charCode in charCodeToGlyphId) {
                                if (glyphId === charCodeToGlyphId[charCode]) {
                                    return charCode | 0;
                                }
                            }
                            newMapping.charCodeToGlyphId[newMapping.nextAvailableFontCharCode] = glyphId;
                            return newMapping.nextAvailableFontCharCode++;
                        }
                        var seacs = font.seacs;
                        if (SEAC_ANALYSIS_ENABLED && seacs && seacs.length) {
                            var matrix = properties.fontMatrix || FONT_IDENTITY_MATRIX;
                            var charset = font.getCharset();
                            var seacMap = Object.create(null);
                            for (var glyphId in seacs) {
                                glyphId |= 0;
                                var seac = seacs[glyphId];
                                var baseGlyphName = Encodings.StandardEncoding[seac[2]];
                                var accentGlyphName = Encodings.StandardEncoding[seac[3]];
                                var baseGlyphId = charset.indexOf(baseGlyphName);
                                var accentGlyphId = charset.indexOf(accentGlyphName);
                                if (baseGlyphId < 0 || accentGlyphId < 0) {
                                    continue;
                                }
                                var accentOffset = {
                                    x: seac[0] * matrix[0] + seac[1] * matrix[2] + matrix[4],
                                    y: seac[0] * matrix[1] + seac[1] * matrix[3] + matrix[5]
                                };
                                var charCodes = getCharCodes(mapping, glyphId);
                                if (!charCodes) {
                                    continue;
                                }
                                for (var i = 0, ii = charCodes.length; i < ii; i++) {
                                    var charCode = charCodes[i];
                                    var charCodeToGlyphId = newMapping.charCodeToGlyphId;
                                    var baseFontCharCode = createCharCode(charCodeToGlyphId, baseGlyphId);
                                    var accentFontCharCode = createCharCode(charCodeToGlyphId, accentGlyphId);
                                    seacMap[charCode] = {
                                        baseFontCharCode: baseFontCharCode,
                                        accentFontCharCode: accentFontCharCode,
                                        accentOffset: accentOffset
                                    };
                                }
                            }
                            properties.seacMap = seacMap;
                        }
                        var unitsPerEm = 1 / (properties.fontMatrix || FONT_IDENTITY_MATRIX)[0];
                        var builder = new OpenTypeFileBuilder('\x4F\x54\x54\x4F');
                        builder.addTable('CFF ', font.data);
                        builder.addTable('OS/2', createOS2Table(properties, newMapping.charCodeToGlyphId));
                        builder.addTable('cmap', createCmapTable(newMapping.charCodeToGlyphId, numGlyphs));
                        builder.addTable('head', '\x00\x01\x00\x00' + '\x00\x00\x10\x00' + '\x00\x00\x00\x00' + '\x5F\x0F\x3C\xF5' + '\x00\x00' +
                            safeString16(unitsPerEm) + '\x00\x00\x00\x00\x9e\x0b\x7e\x27' + '\x00\x00\x00\x00\x9e\x0b\x7e\x27' + '\x00\x00' +
                            safeString16(properties.descent) + '\x0F\xFF' +
                            safeString16(properties.ascent) +
                            string16(properties.italicAngle ? 2 : 0) + '\x00\x11' + '\x00\x00' + '\x00\x00' + '\x00\x00');
                        builder.addTable('hhea', '\x00\x01\x00\x00' +
                            safeString16(properties.ascent) +
                            safeString16(properties.descent) + '\x00\x00' + '\xFF\xFF' + '\x00\x00' + '\x00\x00' + '\x00\x00' +
                            safeString16(properties.capHeight) +
                            safeString16(Math.tan(properties.italicAngle) * properties.xHeight) + '\x00\x00' + '\x00\x00' + '\x00\x00' + '\x00\x00' + '\x00\x00' + '\x00\x00' +
                            string16(numGlyphs));
                        builder.addTable('hmtx', (function fontFieldsHmtx() {
                            var charstrings = font.charstrings;
                            var cffWidths = font.cff ? font.cff.widths : null;
                            var hmtx = '\x00\x00\x00\x00';
                            for (var i = 1, ii = numGlyphs; i < ii; i++) {
                                var width = 0;
                                if (charstrings) {
                                    var charstring = charstrings[i - 1];
                                    width = 'width' in charstring ? charstring.width : 0;
                                } else if (cffWidths) {
                                    width = Math.ceil(cffWidths[i] || 0);
                                }
                                hmtx += string16(width) + string16(0);
                            }
                            return hmtx;
                        })());
                        builder.addTable('maxp', '\x00\x00\x50\x00' +
                            string16(numGlyphs));
                        builder.addTable('name', createNameTable(fontName));
                        builder.addTable('post', createPostTable(properties));
                        return builder.toArray();
                    },
                    buildToUnicode: function Font_buildToUnicode(properties) {
                        if (properties.toUnicode && properties.toUnicode.length !== 0) {
                            return properties.toUnicode;
                        }
                        var toUnicode, charcode;
                        if (!properties.composite) {
                            toUnicode = [];
                            var encoding = properties.defaultEncoding.slice();
                            var baseEncodingName = properties.baseEncodingName;
                            var differences = properties.differences;
                            for (charcode in differences) {
                                encoding[charcode] = differences[charcode];
                            }
                            for (charcode in encoding) {
                                var glyphName = encoding[charcode];
                                if (glyphName === '') {
                                    continue;
                                } else if (GlyphsUnicode[glyphName] === undefined) {
                                    var code = 0;
                                    switch (glyphName[0]) {
                                        case 'G':
                                            if (glyphName.length === 3) {
                                                code = parseInt(glyphName.substr(1), 16);
                                            }
                                            break;
                                        case 'g':
                                            if (glyphName.length === 5) {
                                                code = parseInt(glyphName.substr(1), 16);
                                            }
                                            break;
                                        case 'C':
                                        case 'c':
                                            if (glyphName.length >= 3) {
                                                code = +glyphName.substr(1);
                                            }
                                            break;
                                    }
                                    if (code) {
                                        if (baseEncodingName && code === +charcode) {
                                            var baseEncoding = Encodings[baseEncodingName];
                                            if (baseEncoding && (glyphName = baseEncoding[charcode])) {
                                                toUnicode[charcode] = String.fromCharCode(GlyphsUnicode[glyphName]);
                                                continue;
                                            }
                                        }
                                        toUnicode[charcode] = String.fromCharCode(code);
                                    }
                                    continue;
                                }
                                toUnicode[charcode] = String.fromCharCode(GlyphsUnicode[glyphName]);
                            }
                            return new ToUnicodeMap(toUnicode);
                        }
                        if (properties.composite && ((properties.cMap.builtInCMap && !(properties.cMap instanceof IdentityCMap)) || (properties.cidSystemInfo.registry === 'Adobe' && (properties.cidSystemInfo.ordering === 'GB1' || properties.cidSystemInfo.ordering === 'CNS1' || properties.cidSystemInfo.ordering === 'Japan1' || properties.cidSystemInfo.ordering === 'Korea1')))) {
                            var registry = properties.cidSystemInfo.registry;
                            var ordering = properties.cidSystemInfo.ordering;
                            var ucs2CMapName = new Name(registry + '-' + ordering + '-UCS2');
                            var ucs2CMap = CMapFactory.create(ucs2CMapName, {
                                url: PDFJS.cMapUrl,
                                packed: PDFJS.cMapPacked
                            }, null);
                            var cMap = properties.cMap;
                            toUnicode = [];
                            cMap.forEach(function(charcode, cid) {
                                assert(cid <= 0xffff, 'Max size of CID is 65,535');
                                var ucs2 = ucs2CMap.lookup(cid);
                                if (ucs2) {
                                    toUnicode[charcode] = String.fromCharCode((ucs2.charCodeAt(0) << 8) +
                                        ucs2.charCodeAt(1));
                                }
                            });
                            return new ToUnicodeMap(toUnicode);
                        }
                        return new IdentityToUnicodeMap(properties.firstChar, properties.lastChar);
                    },
                    get spaceWidth() {
                        if ('_shadowWidth' in this) {
                            return this._shadowWidth;
                        }
                        var possibleSpaceReplacements = ['space', 'minus', 'one', 'i'];
                        var width;
                        for (var i = 0, ii = possibleSpaceReplacements.length; i < ii; i++) {
                            var glyphName = possibleSpaceReplacements[i];
                            if (glyphName in this.widths) {
                                width = this.widths[glyphName];
                                break;
                            }
                            var glyphUnicode = GlyphsUnicode[glyphName];
                            var charcode = 0;
                            if (this.composite) {
                                if (this.cMap.contains(glyphUnicode)) {
                                    charcode = this.cMap.lookup(glyphUnicode);
                                }
                            }
                            if (!charcode && this.toUnicode) {
                                charcode = this.toUnicode.charCodeOf(glyphUnicode);
                            }
                            if (charcode <= 0) {
                                charcode = glyphUnicode;
                            }
                            width = this.widths[charcode];
                            if (width) {
                                break;
                            }
                        }
                        width = width || this.defaultWidth;
                        this._shadowWidth = width;
                        return width;
                    },
                    charToGlyph: function Font_charToGlyph(charcode, isSpace) {
                        var fontCharCode, width, operatorListId;
                        var widthCode = charcode;
                        if (this.cMap && this.cMap.contains(charcode)) {
                            widthCode = this.cMap.lookup(charcode);
                        }
                        width = this.widths[widthCode];
                        width = isNum(width) ? width : this.defaultWidth;
                        var vmetric = this.vmetrics && this.vmetrics[widthCode];
                        var unicode = this.toUnicode.get(charcode) || charcode;
                        if (typeof unicode === 'number') {
                            unicode = String.fromCharCode(unicode);
                        }
                        fontCharCode = this.toFontChar[charcode] || charcode;
                        if (this.missingFile) {
                            fontCharCode = mapSpecialUnicodeValues(fontCharCode);
                        }
                        if (this.isType3Font) {
                            operatorListId = fontCharCode;
                        }
                        var accent = null;
                        if (this.seacMap && this.seacMap[charcode]) {
                            var seac = this.seacMap[charcode];
                            fontCharCode = seac.baseFontCharCode;
                            accent = {
                                fontChar: String.fromCharCode(seac.accentFontCharCode),
                                offset: seac.accentOffset
                            };
                        }
                        var fontChar = String.fromCharCode(fontCharCode);
                        var glyph = this.glyphCache[charcode];
                        if (!glyph || !glyph.matchesForCache(fontChar, unicode, accent, width, vmetric, operatorListId, isSpace)) {
                            glyph = new Glyph(fontChar, unicode, accent, width, vmetric, operatorListId, isSpace);
                            this.glyphCache[charcode] = glyph;
                        }
                        return glyph;
                    },
                    charsToGlyphs: function Font_charsToGlyphs(chars) {
                        var charsCache = this.charsCache;
                        var glyphs, glyph, charcode;
                        if (charsCache) {
                            glyphs = charsCache[chars];
                            if (glyphs) {
                                return glyphs;
                            }
                        }
                        if (!charsCache) {
                            charsCache = this.charsCache = Object.create(null);
                        }
                        glyphs = [];
                        var charsCacheKey = chars;
                        var i = 0,
                            ii;
                        if (this.cMap) {
                            var c = {};
                            while (i < chars.length) {
                                this.cMap.readCharCode(chars, i, c);
                                charcode = c.charcode;
                                var length = c.length;
                                i += length;
                                var isSpace = length === 1 && chars.charCodeAt(i - 1) === 0x20;
                                glyph = this.charToGlyph(charcode, isSpace);
                                glyphs.push(glyph);
                            }
                        } else {
                            for (i = 0, ii = chars.length; i < ii; ++i) {
                                charcode = chars.charCodeAt(i);
                                glyph = this.charToGlyph(charcode, charcode === 0x20);
                                glyphs.push(glyph);
                            }
                        }
                        return (charsCache[charsCacheKey] = glyphs);
                    }
                };
                return Font;
            })();
            var ErrorFont = (function ErrorFontClosure() {
                function ErrorFont(error) {
                    this.error = error;
                    this.loadedName = 'g_font_error';
                    this.loading = false;
                }
                ErrorFont.prototype = {
                    charsToGlyphs: function ErrorFont_charsToGlyphs() {
                        return [];
                    },
                    exportData: function ErrorFont_exportData() {
                        return {
                            error: this.error
                        };
                    }
                };
                return ErrorFont;
            })();

            function type1FontGlyphMapping(properties, builtInEncoding, glyphNames) {
                var charCodeToGlyphId = Object.create(null);
                var glyphId, charCode, baseEncoding;
                if (properties.baseEncodingName) {
                    baseEncoding = Encodings[properties.baseEncodingName];
                    for (charCode = 0; charCode < baseEncoding.length; charCode++) {
                        glyphId = glyphNames.indexOf(baseEncoding[charCode]);
                        if (glyphId >= 0) {
                            charCodeToGlyphId[charCode] = glyphId;
                        } else {
                            charCodeToGlyphId[charCode] = 0;
                        }
                    }
                } else if (!!(properties.flags & FontFlags.Symbolic)) {
                    for (charCode in builtInEncoding) {
                        charCodeToGlyphId[charCode] = builtInEncoding[charCode];
                    }
                } else {
                    baseEncoding = Encodings.StandardEncoding;
                    for (charCode = 0; charCode < baseEncoding.length; charCode++) {
                        glyphId = glyphNames.indexOf(baseEncoding[charCode]);
                        if (glyphId >= 0) {
                            charCodeToGlyphId[charCode] = glyphId;
                        } else {
                            charCodeToGlyphId[charCode] = 0;
                        }
                    }
                }
                var differences = properties.differences;
                if (differences) {
                    for (charCode in differences) {
                        var glyphName = differences[charCode];
                        glyphId = glyphNames.indexOf(glyphName);
                        if (glyphId >= 0) {
                            charCodeToGlyphId[charCode] = glyphId;
                        } else {
                            charCodeToGlyphId[charCode] = 0;
                        }
                    }
                }
                return charCodeToGlyphId;
            }
            var Type1CharString = (function Type1CharStringClosure() {
                var COMMAND_MAP = {
                    'hstem': [1],
                    'vstem': [3],
                    'vmoveto': [4],
                    'rlineto': [5],
                    'hlineto': [6],
                    'vlineto': [7],
                    'rrcurveto': [8],
                    'callsubr': [10],
                    'flex': [12, 35],
                    'drop': [12, 18],
                    'endchar': [14],
                    'rmoveto': [21],
                    'hmoveto': [22],
                    'vhcurveto': [30],
                    'hvcurveto': [31]
                };

                function Type1CharString() {
                    this.width = 0;
                    this.lsb = 0;
                    this.flexing = false;
                    this.output = [];
                    this.stack = [];
                }
                Type1CharString.prototype = {
                    convert: function Type1CharString_convert(encoded, subrs) {
                        var count = encoded.length;
                        var error = false;
                        var wx, sbx, subrNumber;
                        for (var i = 0; i < count; i++) {
                            var value = encoded[i];
                            if (value < 32) {
                                if (value === 12) {
                                    value = (value << 8) + encoded[++i];
                                }
                                switch (value) {
                                    case 1:
                                        if (!HINTING_ENABLED) {
                                            this.stack = [];
                                            break;
                                        }
                                        error = this.executeCommand(2, COMMAND_MAP.hstem);
                                        break;
                                    case 3:
                                        if (!HINTING_ENABLED) {
                                            this.stack = [];
                                            break;
                                        }
                                        error = this.executeCommand(2, COMMAND_MAP.vstem);
                                        break;
                                    case 4:
                                        if (this.flexing) {
                                            if (this.stack.length < 1) {
                                                error = true;
                                                break;
                                            }
                                            var dy = this.stack.pop();
                                            this.stack.push(0, dy);
                                            break;
                                        }
                                        error = this.executeCommand(1, COMMAND_MAP.vmoveto);
                                        break;
                                    case 5:
                                        error = this.executeCommand(2, COMMAND_MAP.rlineto);
                                        break;
                                    case 6:
                                        error = this.executeCommand(1, COMMAND_MAP.hlineto);
                                        break;
                                    case 7:
                                        error = this.executeCommand(1, COMMAND_MAP.vlineto);
                                        break;
                                    case 8:
                                        error = this.executeCommand(6, COMMAND_MAP.rrcurveto);
                                        break;
                                    case 9:
                                        this.stack = [];
                                        break;
                                    case 10:
                                        if (this.stack.length < 1) {
                                            error = true;
                                            break;
                                        }
                                        subrNumber = this.stack.pop();
                                        error = this.convert(subrs[subrNumber], subrs);
                                        break;
                                    case 11:
                                        return error;
                                    case 13:
                                        if (this.stack.length < 2) {
                                            error = true;
                                            break;
                                        }
                                        wx = this.stack.pop();
                                        sbx = this.stack.pop();
                                        this.lsb = sbx;
                                        this.width = wx;
                                        this.stack.push(wx, sbx);
                                        error = this.executeCommand(2, COMMAND_MAP.hmoveto);
                                        break;
                                    case 14:
                                        this.output.push(COMMAND_MAP.endchar[0]);
                                        break;
                                    case 21:
                                        if (this.flexing) {
                                            break;
                                        }
                                        error = this.executeCommand(2, COMMAND_MAP.rmoveto);
                                        break;
                                    case 22:
                                        if (this.flexing) {
                                            this.stack.push(0);
                                            break;
                                        }
                                        error = this.executeCommand(1, COMMAND_MAP.hmoveto);
                                        break;
                                    case 30:
                                        error = this.executeCommand(4, COMMAND_MAP.vhcurveto);
                                        break;
                                    case 31:
                                        error = this.executeCommand(4, COMMAND_MAP.hvcurveto);
                                        break;
                                    case (12 << 8) + 0:
                                        this.stack = [];
                                        break;
                                    case (12 << 8) + 1:
                                        if (!HINTING_ENABLED) {
                                            this.stack = [];
                                            break;
                                        }
                                        error = this.executeCommand(2, COMMAND_MAP.vstem);
                                        break;
                                    case (12 << 8) + 2:
                                        if (!HINTING_ENABLED) {
                                            this.stack = [];
                                            break;
                                        }
                                        error = this.executeCommand(2, COMMAND_MAP.hstem);
                                        break;
                                    case (12 << 8) + 6:
                                        if (SEAC_ANALYSIS_ENABLED) {
                                            this.seac = this.stack.splice(-4, 4);
                                            error = this.executeCommand(0, COMMAND_MAP.endchar);
                                        } else {
                                            error = this.executeCommand(4, COMMAND_MAP.endchar);
                                        }
                                        break;
                                    case (12 << 8) + 7:
                                        if (this.stack.length < 4) {
                                            error = true;
                                            break;
                                        }
                                        var wy = this.stack.pop();
                                        wx = this.stack.pop();
                                        var sby = this.stack.pop();
                                        sbx = this.stack.pop();
                                        this.lsb = sbx;
                                        this.width = wx;
                                        this.stack.push(wx, sbx, sby);
                                        error = this.executeCommand(3, COMMAND_MAP.rmoveto);
                                        break;
                                    case (12 << 8) + 12:
                                        if (this.stack.length < 2) {
                                            error = true;
                                            break;
                                        }
                                        var num2 = this.stack.pop();
                                        var num1 = this.stack.pop();
                                        this.stack.push(num1 / num2);
                                        break;
                                    case (12 << 8) + 16:
                                        if (this.stack.length < 2) {
                                            error = true;
                                            break;
                                        }
                                        subrNumber = this.stack.pop();
                                        var numArgs = this.stack.pop();
                                        if (subrNumber === 0 && numArgs === 3) {
                                            var flexArgs = this.stack.splice(this.stack.length - 17, 17);
                                            this.stack.push(flexArgs[2] + flexArgs[0], flexArgs[3] + flexArgs[1], flexArgs[4], flexArgs[5], flexArgs[6], flexArgs[7], flexArgs[8], flexArgs[9], flexArgs[10], flexArgs[11], flexArgs[12], flexArgs[13], flexArgs[14]);
                                            error = this.executeCommand(13, COMMAND_MAP.flex, true);
                                            this.flexing = false;
                                            this.stack.push(flexArgs[15], flexArgs[16]);
                                        } else if (subrNumber === 1 && numArgs === 0) {
                                            this.flexing = true;
                                        }
                                        break;
                                    case (12 << 8) + 17:
                                        break;
                                    case (12 << 8) + 33:
                                        this.stack = [];
                                        break;
                                    default:
                                        warn('Unknown type 1 charstring command of "' + value + '"');
                                        break;
                                }
                                if (error) {
                                    break;
                                }
                                continue;
                            } else if (value <= 246) {
                                value = value - 139;
                            } else if (value <= 250) {
                                value = ((value - 247) * 256) + encoded[++i] + 108;
                            } else if (value <= 254) {
                                value = -((value - 251) * 256) - encoded[++i] - 108;
                            } else {
                                value = (encoded[++i] & 0xff) << 24 | (encoded[++i] & 0xff) << 16 | (encoded[++i] & 0xff) << 8 | (encoded[++i] & 0xff) << 0;
                            }
                            this.stack.push(value);
                        }
                        return error;
                    },
                    executeCommand: function(howManyArgs, command, keepStack) {
                        var stackLength = this.stack.length;
                        if (howManyArgs > stackLength) {
                            return true;
                        }
                        var start = stackLength - howManyArgs;
                        for (var i = start; i < stackLength; i++) {
                            var value = this.stack[i];
                            if (value === (value | 0)) {
                                this.output.push(28, (value >> 8) & 0xff, value & 0xff);
                            } else {
                                value = (65536 * value) | 0;
                                this.output.push(255, (value >> 24) & 0xFF, (value >> 16) & 0xFF, (value >> 8) & 0xFF, value & 0xFF);
                            }
                        }
                        this.output.push.apply(this.output, command);
                        if (keepStack) {
                            this.stack.splice(start, howManyArgs);
                        } else {
                            this.stack.length = 0;
                        }
                        return false;
                    }
                };
                return Type1CharString;
            })();
            var Type1Parser = (function Type1ParserClosure() {
                var EEXEC_ENCRYPT_KEY = 55665;
                var CHAR_STRS_ENCRYPT_KEY = 4330;

                function isHexDigit(code) {
                    return code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102;
                }

                function decrypt(data, key, discardNumber) {
                    var r = key | 0,
                        c1 = 52845,
                        c2 = 22719;
                    var count = data.length;
                    var decrypted = new Uint8Array(count);
                    for (var i = 0; i < count; i++) {
                        var value = data[i];
                        decrypted[i] = value ^ (r >> 8);
                        r = ((value + r) * c1 + c2) & ((1 << 16) - 1);
                    }
                    return Array.prototype.slice.call(decrypted, discardNumber);
                }

                function decryptAscii(data, key, discardNumber) {
                    var r = key | 0,
                        c1 = 52845,
                        c2 = 22719;
                    var count = data.length,
                        maybeLength = count >>> 1;
                    var decrypted = new Uint8Array(maybeLength);
                    var i, j;
                    for (i = 0, j = 0; i < count; i++) {
                        var digit1 = data[i];
                        if (!isHexDigit(digit1)) {
                            continue;
                        }
                        i++;
                        var digit2;
                        while (i < count && !isHexDigit(digit2 = data[i])) {
                            i++;
                        }
                        if (i < count) {
                            var value = parseInt(String.fromCharCode(digit1, digit2), 16);
                            decrypted[j++] = value ^ (r >> 8);
                            r = ((value + r) * c1 + c2) & ((1 << 16) - 1);
                        }
                    }
                    return Array.prototype.slice.call(decrypted, discardNumber, j);
                }

                function isSpecial(c) {
                    return c === 0x2F || c === 0x5B || c === 0x5D || c === 0x7B || c === 0x7D || c === 0x28 || c === 0x29;
                }

                function Type1Parser(stream, encrypted) {
                    if (encrypted) {
                        var data = stream.getBytes();
                        var isBinary = !(isHexDigit(data[0]) && isHexDigit(data[1]) && isHexDigit(data[2]) && isHexDigit(data[3]));
                        stream = new Stream(isBinary ? decrypt(data, EEXEC_ENCRYPT_KEY, 4) : decryptAscii(data, EEXEC_ENCRYPT_KEY, 4));
                    }
                    this.stream = stream;
                    this.nextChar();
                }
                Type1Parser.prototype = {
                    readNumberArray: function Type1Parser_readNumberArray() {
                        this.getToken();
                        var array = [];
                        while (true) {
                            var token = this.getToken();
                            if (token === null || token === ']' || token === '}') {
                                break;
                            }
                            array.push(parseFloat(token || 0));
                        }
                        return array;
                    },
                    readNumber: function Type1Parser_readNumber() {
                        var token = this.getToken();
                        return parseFloat(token || 0);
                    },
                    readInt: function Type1Parser_readInt() {
                        var token = this.getToken();
                        return parseInt(token || 0, 10) | 0;
                    },
                    readBoolean: function Type1Parser_readBoolean() {
                        var token = this.getToken();
                        return token === 'true' ? 1 : 0;
                    },
                    nextChar: function Type1_nextChar() {
                        return (this.currentChar = this.stream.getByte());
                    },
                    getToken: function Type1Parser_getToken() {
                        var comment = false;
                        var ch = this.currentChar;
                        while (true) {
                            if (ch === -1) {
                                return null;
                            }
                            if (comment) {
                                if (ch === 0x0A || ch === 0x0D) {
                                    comment = false;
                                }
                            } else if (ch === 0x25) {
                                comment = true;
                            } else if (!Lexer.isSpace(ch)) {
                                break;
                            }
                            ch = this.nextChar();
                        }
                        if (isSpecial(ch)) {
                            this.nextChar();
                            return String.fromCharCode(ch);
                        }
                        var token = '';
                        do {
                            token += String.fromCharCode(ch);
                            ch = this.nextChar();
                        } while (ch >= 0 && !Lexer.isSpace(ch) && !isSpecial(ch));
                        return token;
                    },
                    extractFontProgram: function Type1Parser_extractFontProgram() {
                        var stream = this.stream;
                        var subrs = [],
                            charstrings = [];
                        var program = {
                            subrs: [],
                            charstrings: [],
                            properties: {
                                'privateData': {
                                    'lenIV': 4
                                }
                            }
                        };
                        var token, length, data, lenIV, encoded;
                        while ((token = this.getToken()) !== null) {
                            if (token !== '/') {
                                continue;
                            }
                            token = this.getToken();
                            switch (token) {
                                case 'CharStrings':
                                    this.getToken();
                                    this.getToken();
                                    this.getToken();
                                    this.getToken();
                                    while (true) {
                                        token = this.getToken();
                                        if (token === null || token === 'end') {
                                            break;
                                        }
                                        if (token !== '/') {
                                            continue;
                                        }
                                        var glyph = this.getToken();
                                        length = this.readInt();
                                        this.getToken();
                                        data = stream.makeSubStream(stream.pos, length);
                                        lenIV = program.properties.privateData['lenIV'];
                                        encoded = decrypt(data.getBytes(), CHAR_STRS_ENCRYPT_KEY, lenIV);
                                        stream.skip(length);
                                        this.nextChar();
                                        token = this.getToken();
                                        if (token === 'noaccess') {
                                            this.getToken();
                                        }
                                        charstrings.push({
                                            glyph: glyph,
                                            encoded: encoded
                                        });
                                    }
                                    break;
                                case 'Subrs':
                                    var num = this.readInt();
                                    this.getToken();
                                    while ((token = this.getToken()) === 'dup') {
                                        var index = this.readInt();
                                        length = this.readInt();
                                        this.getToken();
                                        data = stream.makeSubStream(stream.pos, length);
                                        lenIV = program.properties.privateData['lenIV'];
                                        encoded = decrypt(data.getBytes(), CHAR_STRS_ENCRYPT_KEY, lenIV);
                                        stream.skip(length);
                                        this.nextChar();
                                        token = this.getToken();
                                        if (token === 'noaccess') {
                                            this.getToken();
                                        }
                                        subrs[index] = encoded;
                                    }
                                    break;
                                case 'BlueValues':
                                case 'OtherBlues':
                                case 'FamilyBlues':
                                case 'FamilyOtherBlues':
                                    var blueArray = this.readNumberArray();
                                    if (blueArray.length > 0 && (blueArray.length % 2) === 0 && HINTING_ENABLED) {
                                        program.properties.privateData[token] = blueArray;
                                    }
                                    break;
                                case 'StemSnapH':
                                case 'StemSnapV':
                                    program.properties.privateData[token] = this.readNumberArray();
                                    break;
                                case 'StdHW':
                                case 'StdVW':
                                    program.properties.privateData[token] = this.readNumberArray()[0];
                                    break;
                                case 'BlueShift':
                                case 'lenIV':
                                case 'BlueFuzz':
                                case 'BlueScale':
                                case 'LanguageGroup':
                                case 'ExpansionFactor':
                                    program.properties.privateData[token] = this.readNumber();
                                    break;
                                case 'ForceBold':
                                    program.properties.privateData[token] = this.readBoolean();
                                    break;
                            }
                        }
                        for (var i = 0; i < charstrings.length; i++) {
                            glyph = charstrings[i].glyph;
                            encoded = charstrings[i].encoded;
                            var charString = new Type1CharString();
                            var error = charString.convert(encoded, subrs);
                            var output = charString.output;
                            if (error) {
                                output = [14];
                            }
                            program.charstrings.push({
                                glyphName: glyph,
                                charstring: output,
                                width: charString.width,
                                lsb: charString.lsb,
                                seac: charString.seac
                            });
                        }
                        return program;
                    },
                    extractFontHeader: function Type1Parser_extractFontHeader(properties) {
                        var token;
                        while ((token = this.getToken()) !== null) {
                            if (token !== '/') {
                                continue;
                            }
                            token = this.getToken();
                            switch (token) {
                                case 'FontMatrix':
                                    var matrix = this.readNumberArray();
                                    properties.fontMatrix = matrix;
                                    break;
                                case 'Encoding':
                                    var encodingArg = this.getToken();
                                    var encoding;
                                    if (!/^\d+$/.test(encodingArg)) {
                                        encoding = Encodings[encodingArg];
                                    } else {
                                        encoding = [];
                                        var size = parseInt(encodingArg, 10) | 0;
                                        this.getToken();
                                        for (var j = 0; j < size; j++) {
                                            token = this.getToken();
                                            while (token !== 'dup' && token !== 'def') {
                                                token = this.getToken();
                                                if (token === null) {
                                                    return;
                                                }
                                            }
                                            if (token === 'def') {
                                                break;
                                            }
                                            var index = this.readInt();
                                            this.getToken();
                                            var glyph = this.getToken();
                                            encoding[index] = glyph;
                                            this.getToken();
                                        }
                                    }
                                    properties.builtInEncoding = encoding;
                                    break;
                                case 'FontBBox':
                                    var fontBBox = this.readNumberArray();
                                    properties.ascent = fontBBox[3];
                                    properties.descent = fontBBox[1];
                                    properties.ascentScaled = true;
                                    break;
                            }
                        }
                    }
                };
                return Type1Parser;
            })();
            var CFFStandardStrings = ['.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand', 'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring', 'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE', 'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu', 'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn', 'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright', 'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex', 'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex', 'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute', 'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute', 'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute', 'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave', 'yacute', 'ydieresis', 'zcaron', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior', 'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior', 'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'ffi', 'ffl', 'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall', 'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall', 'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall', 'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall', 'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall', 'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', 'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', 'zerosuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall', '001.000', '001.001', '001.002', '001.003', 'Black', 'Bold', 'Book', 'Light', 'Medium', 'Regular', 'Roman', 'Semibold'];
            var Type1Font = function Type1Font(name, file, properties) {
                var PFB_HEADER_SIZE = 6;
                var headerBlockLength = properties.length1;
                var eexecBlockLength = properties.length2;
                var pfbHeader = file.peekBytes(PFB_HEADER_SIZE);
                var pfbHeaderPresent = pfbHeader[0] === 0x80 && pfbHeader[1] === 0x01;
                if (pfbHeaderPresent) {
                    file.skip(PFB_HEADER_SIZE);
                    headerBlockLength = (pfbHeader[5] << 24) | (pfbHeader[4] << 16) | (pfbHeader[3] << 8) | pfbHeader[2];
                }
                var headerBlock = new Stream(file.getBytes(headerBlockLength));
                var headerBlockParser = new Type1Parser(headerBlock);
                headerBlockParser.extractFontHeader(properties);
                if (pfbHeaderPresent) {
                    pfbHeader = file.getBytes(PFB_HEADER_SIZE);
                    eexecBlockLength = (pfbHeader[5] << 24) | (pfbHeader[4] << 16) | (pfbHeader[3] << 8) | pfbHeader[2];
                }
                var eexecBlock = new Stream(file.getBytes(eexecBlockLength));
                var eexecBlockParser = new Type1Parser(eexecBlock, true);
                var data = eexecBlockParser.extractFontProgram();
                for (var info in data.properties) {
                    properties[info] = data.properties[info];
                }
                var charstrings = data.charstrings;
                var type2Charstrings = this.getType2Charstrings(charstrings);
                var subrs = this.getType2Subrs(data.subrs);
                this.charstrings = charstrings;
                this.data = this.wrap(name, type2Charstrings, this.charstrings, subrs, properties);
                this.seacs = this.getSeacs(data.charstrings);
            };
            Type1Font.prototype = {
                get numGlyphs() {
                    return this.charstrings.length + 1;
                },
                getCharset: function Type1Font_getCharset() {
                    var charset = ['.notdef'];
                    var charstrings = this.charstrings;
                    for (var glyphId = 0; glyphId < charstrings.length; glyphId++) {
                        charset.push(charstrings[glyphId].glyphName);
                    }
                    return charset;
                },
                getGlyphMapping: function Type1Font_getGlyphMapping(properties) {
                    var charstrings = this.charstrings;
                    var glyphNames = ['.notdef'],
                        glyphId;
                    for (glyphId = 0; glyphId < charstrings.length; glyphId++) {
                        glyphNames.push(charstrings[glyphId].glyphName);
                    }
                    var encoding = properties.builtInEncoding;
                    if (encoding) {
                        var builtInEncoding = {};
                        for (var charCode in encoding) {
                            glyphId = glyphNames.indexOf(encoding[charCode]);
                            if (glyphId >= 0) {
                                builtInEncoding[charCode] = glyphId;
                            }
                        }
                    }
                    return type1FontGlyphMapping(properties, builtInEncoding, glyphNames);
                },
                getSeacs: function Type1Font_getSeacs(charstrings) {
                    var i, ii;
                    var seacMap = [];
                    for (i = 0, ii = charstrings.length; i < ii; i++) {
                        var charstring = charstrings[i];
                        if (charstring.seac) {
                            seacMap[i + 1] = charstring.seac;
                        }
                    }
                    return seacMap;
                },
                getType2Charstrings: function Type1Font_getType2Charstrings(type1Charstrings) {
                    var type2Charstrings = [];
                    for (var i = 0, ii = type1Charstrings.length; i < ii; i++) {
                        type2Charstrings.push(type1Charstrings[i].charstring);
                    }
                    return type2Charstrings;
                },
                getType2Subrs: function Type1Font_getType2Subrs(type1Subrs) {
                    var bias = 0;
                    var count = type1Subrs.length;
                    if (count < 1133) {
                        bias = 107;
                    } else if (count < 33769) {
                        bias = 1131;
                    } else {
                        bias = 32768;
                    }
                    var type2Subrs = [];
                    var i;
                    for (i = 0; i < bias; i++) {
                        type2Subrs.push([0x0B]);
                    }
                    for (i = 0; i < count; i++) {
                        type2Subrs.push(type1Subrs[i]);
                    }
                    return type2Subrs;
                },
                wrap: function Type1Font_wrap(name, glyphs, charstrings, subrs, properties) {
                    var cff = new CFF();
                    cff.header = new CFFHeader(1, 0, 4, 4);
                    cff.names = [name];
                    var topDict = new CFFTopDict();
                    topDict.setByName('version', 391);
                    topDict.setByName('Notice', 392);
                    topDict.setByName('FullName', 393);
                    topDict.setByName('FamilyName', 394);
                    topDict.setByName('Weight', 395);
                    topDict.setByName('Encoding', null);
                    topDict.setByName('FontMatrix', properties.fontMatrix);
                    topDict.setByName('FontBBox', properties.bbox);
                    topDict.setByName('charset', null);
                    topDict.setByName('CharStrings', null);
                    topDict.setByName('Private', null);
                    cff.topDict = topDict;
                    var strings = new CFFStrings();
                    strings.add('Version 0.11');
                    strings.add('See original notice');
                    strings.add(name);
                    strings.add(name);
                    strings.add('Medium');
                    cff.strings = strings;
                    cff.globalSubrIndex = new CFFIndex();
                    var count = glyphs.length;
                    var charsetArray = [0];
                    var i, ii;
                    for (i = 0; i < count; i++) {
                        var index = CFFStandardStrings.indexOf(charstrings[i].glyphName);
                        if (index === -1) {
                            index = 0;
                        }
                        charsetArray.push((index >> 8) & 0xff, index & 0xff);
                    }
                    cff.charset = new CFFCharset(false, 0, [], charsetArray);
                    var charStringsIndex = new CFFIndex();
                    charStringsIndex.add([0x8B, 0x0E]);
                    for (i = 0; i < count; i++) {
                        charStringsIndex.add(glyphs[i]);
                    }
                    cff.charStrings = charStringsIndex;
                    var privateDict = new CFFPrivateDict();
                    privateDict.setByName('Subrs', null);
                    var fields = ['BlueValues', 'OtherBlues', 'FamilyBlues', 'FamilyOtherBlues', 'StemSnapH', 'StemSnapV', 'BlueShift', 'BlueFuzz', 'BlueScale', 'LanguageGroup', 'ExpansionFactor', 'ForceBold', 'StdHW', 'StdVW'];
                    for (i = 0, ii = fields.length; i < ii; i++) {
                        var field = fields[i];
                        if (!properties.privateData.hasOwnProperty(field)) {
                            continue;
                        }
                        var value = properties.privateData[field];
                        if (isArray(value)) {
                            for (var j = value.length - 1; j > 0; j--) {
                                value[j] -= value[j - 1];
                            }
                        }
                        privateDict.setByName(field, value);
                    }
                    cff.topDict.privateDict = privateDict;
                    var subrIndex = new CFFIndex();
                    for (i = 0, ii = subrs.length; i < ii; i++) {
                        subrIndex.add(subrs[i]);
                    }
                    privateDict.subrsIndex = subrIndex;
                    var compiler = new CFFCompiler(cff);
                    return compiler.compile();
                }
            };
            var CFFFont = (function CFFFontClosure() {
                function CFFFont(file, properties) {
                    this.properties = properties;
                    var parser = new CFFParser(file, properties);
                    this.cff = parser.parse();
                    var compiler = new CFFCompiler(this.cff);
                    this.seacs = this.cff.seacs;
                    try {
                        this.data = compiler.compile();
                    } catch (e) {
                        warn('Failed to compile font ' + properties.loadedName);
                        this.data = file;
                    }
                }
                CFFFont.prototype = {
                    get numGlyphs() {
                        return this.cff.charStrings.count;
                    },
                    getCharset: function CFFFont_getCharset() {
                        return this.cff.charset.charset;
                    },
                    getGlyphMapping: function CFFFont_getGlyphMapping() {
                        var cff = this.cff;
                        var properties = this.properties;
                        var charsets = cff.charset.charset;
                        var charCodeToGlyphId;
                        var glyphId;
                        if (properties.composite) {
                            charCodeToGlyphId = Object.create(null);
                            if (cff.isCIDFont) {
                                for (glyphId = 0; glyphId < charsets.length; glyphId++) {
                                    var cid = charsets[glyphId];
                                    var charCode = properties.cMap.charCodeOf(cid);
                                    charCodeToGlyphId[charCode] = glyphId;
                                }
                            } else {
                                for (glyphId = 0; glyphId < cff.charStrings.count; glyphId++) {
                                    charCodeToGlyphId[glyphId] = glyphId;
                                }
                            }
                            return charCodeToGlyphId;
                        }
                        var encoding = cff.encoding ? cff.encoding.encoding : null;
                        charCodeToGlyphId = type1FontGlyphMapping(properties, encoding, charsets);
                        return charCodeToGlyphId;
                    }
                };
                return CFFFont;
            })();
            var CFFParser = (function CFFParserClosure() {
                var CharstringValidationData = [null, {
                    id: 'hstem',
                    min: 2,
                    stackClearing: true,
                    stem: true
                }, null, {
                    id: 'vstem',
                    min: 2,
                    stackClearing: true,
                    stem: true
                }, {
                    id: 'vmoveto',
                    min: 1,
                    stackClearing: true
                }, {
                    id: 'rlineto',
                    min: 2,
                    resetStack: true
                }, {
                    id: 'hlineto',
                    min: 1,
                    resetStack: true
                }, {
                    id: 'vlineto',
                    min: 1,
                    resetStack: true
                }, {
                    id: 'rrcurveto',
                    min: 6,
                    resetStack: true
                }, null, {
                    id: 'callsubr',
                    min: 1,
                    undefStack: true
                }, {
                    id: 'return',
                    min: 0,
                    undefStack: true
                }, null, null, {
                    id: 'endchar',
                    min: 0,
                    stackClearing: true
                }, null, null, null, {
                    id: 'hstemhm',
                    min: 2,
                    stackClearing: true,
                    stem: true
                }, {
                    id: 'hintmask',
                    min: 0,
                    stackClearing: true
                }, {
                    id: 'cntrmask',
                    min: 0,
                    stackClearing: true
                }, {
                    id: 'rmoveto',
                    min: 2,
                    stackClearing: true
                }, {
                    id: 'hmoveto',
                    min: 1,
                    stackClearing: true
                }, {
                    id: 'vstemhm',
                    min: 2,
                    stackClearing: true,
                    stem: true
                }, {
                    id: 'rcurveline',
                    min: 8,
                    resetStack: true
                }, {
                    id: 'rlinecurve',
                    min: 8,
                    resetStack: true
                }, {
                    id: 'vvcurveto',
                    min: 4,
                    resetStack: true
                }, {
                    id: 'hhcurveto',
                    min: 4,
                    resetStack: true
                }, null, {
                    id: 'callgsubr',
                    min: 1,
                    undefStack: true
                }, {
                    id: 'vhcurveto',
                    min: 4,
                    resetStack: true
                }, {
                    id: 'hvcurveto',
                    min: 4,
                    resetStack: true
                }];
                var CharstringValidationData12 = [null, null, null, {
                    id: 'and',
                    min: 2,
                    stackDelta: -1
                }, {
                    id: 'or',
                    min: 2,
                    stackDelta: -1
                }, {
                    id: 'not',
                    min: 1,
                    stackDelta: 0
                }, null, null, null, {
                    id: 'abs',
                    min: 1,
                    stackDelta: 0
                }, {
                    id: 'add',
                    min: 2,
                    stackDelta: -1,
                    stackFn: function stack_div(stack, index) {
                        stack[index - 2] = stack[index - 2] + stack[index - 1];
                    }
                }, {
                    id: 'sub',
                    min: 2,
                    stackDelta: -1,
                    stackFn: function stack_div(stack, index) {
                        stack[index - 2] = stack[index - 2] - stack[index - 1];
                    }
                }, {
                    id: 'div',
                    min: 2,
                    stackDelta: -1,
                    stackFn: function stack_div(stack, index) {
                        stack[index - 2] = stack[index - 2] / stack[index - 1];
                    }
                }, null, {
                    id: 'neg',
                    min: 1,
                    stackDelta: 0,
                    stackFn: function stack_div(stack, index) {
                        stack[index - 1] = -stack[index - 1];
                    }
                }, {
                    id: 'eq',
                    min: 2,
                    stackDelta: -1
                }, null, null, {
                    id: 'drop',
                    min: 1,
                    stackDelta: -1
                }, null, {
                    id: 'put',
                    min: 2,
                    stackDelta: -2
                }, {
                    id: 'get',
                    min: 1,
                    stackDelta: 0
                }, {
                    id: 'ifelse',
                    min: 4,
                    stackDelta: -3
                }, {
                    id: 'random',
                    min: 0,
                    stackDelta: 1
                }, {
                    id: 'mul',
                    min: 2,
                    stackDelta: -1,
                    stackFn: function stack_div(stack, index) {
                        stack[index - 2] = stack[index - 2] * stack[index - 1];
                    }
                }, null, {
                    id: 'sqrt',
                    min: 1,
                    stackDelta: 0
                }, {
                    id: 'dup',
                    min: 1,
                    stackDelta: 1
                }, {
                    id: 'exch',
                    min: 2,
                    stackDelta: 0
                }, {
                    id: 'index',
                    min: 2,
                    stackDelta: 0
                }, {
                    id: 'roll',
                    min: 3,
                    stackDelta: -2
                }, null, null, null, {
                    id: 'hflex',
                    min: 7,
                    resetStack: true
                }, {
                    id: 'flex',
                    min: 13,
                    resetStack: true
                }, {
                    id: 'hflex1',
                    min: 9,
                    resetStack: true
                }, {
                    id: 'flex1',
                    min: 11,
                    resetStack: true
                }];

                function CFFParser(file, properties) {
                    this.bytes = file.getBytes();
                    this.properties = properties;
                }
                CFFParser.prototype = {
                    parse: function CFFParser_parse() {
                        var properties = this.properties;
                        var cff = new CFF();
                        this.cff = cff;
                        var header = this.parseHeader();
                        var nameIndex = this.parseIndex(header.endPos);
                        var topDictIndex = this.parseIndex(nameIndex.endPos);
                        var stringIndex = this.parseIndex(topDictIndex.endPos);
                        var globalSubrIndex = this.parseIndex(stringIndex.endPos);
                        var topDictParsed = this.parseDict(topDictIndex.obj.get(0));
                        var topDict = this.createDict(CFFTopDict, topDictParsed, cff.strings);
                        cff.header = header.obj;
                        cff.names = this.parseNameIndex(nameIndex.obj);
                        cff.strings = this.parseStringIndex(stringIndex.obj);
                        cff.topDict = topDict;
                        cff.globalSubrIndex = globalSubrIndex.obj;
                        this.parsePrivateDict(cff.topDict);
                        cff.isCIDFont = topDict.hasName('ROS');
                        var charStringOffset = topDict.getByName('CharStrings');
                        var charStringIndex = this.parseIndex(charStringOffset).obj;
                        var fontMatrix = topDict.getByName('FontMatrix');
                        if (fontMatrix) {
                            properties.fontMatrix = fontMatrix;
                        }
                        var fontBBox = topDict.getByName('FontBBox');
                        if (fontBBox) {
                            properties.ascent = fontBBox[3];
                            properties.descent = fontBBox[1];
                            properties.ascentScaled = true;
                        }
                        var charset, encoding;
                        if (cff.isCIDFont) {
                            var fdArrayIndex = this.parseIndex(topDict.getByName('FDArray')).obj;
                            for (var i = 0, ii = fdArrayIndex.count; i < ii; ++i) {
                                var dictRaw = fdArrayIndex.get(i);
                                var fontDict = this.createDict(CFFTopDict, this.parseDict(dictRaw), cff.strings);
                                this.parsePrivateDict(fontDict);
                                cff.fdArray.push(fontDict);
                            }
                            encoding = null;
                            charset = this.parseCharsets(topDict.getByName('charset'), charStringIndex.count, cff.strings, true);
                            cff.fdSelect = this.parseFDSelect(topDict.getByName('FDSelect'), charStringIndex.count);
                        } else {
                            charset = this.parseCharsets(topDict.getByName('charset'), charStringIndex.count, cff.strings, false);
                            encoding = this.parseEncoding(topDict.getByName('Encoding'), properties, cff.strings, charset.charset);
                        }
                        cff.charset = charset;
                        cff.encoding = encoding;
                        var charStringsAndSeacs = this.parseCharStrings(charStringIndex, topDict.privateDict.subrsIndex, globalSubrIndex.obj, cff.fdSelect, cff.fdArray);
                        cff.charStrings = charStringsAndSeacs.charStrings;
                        cff.seacs = charStringsAndSeacs.seacs;
                        cff.widths = charStringsAndSeacs.widths;
                        return cff;
                    },
                    parseHeader: function CFFParser_parseHeader() {
                        var bytes = this.bytes;
                        var bytesLength = bytes.length;
                        var offset = 0;
                        while (offset < bytesLength && bytes[offset] !== 1) {
                            ++offset;
                        }
                        if (offset >= bytesLength) {
                            error('Invalid CFF header');
                        } else if (offset !== 0) {
                            info('cff data is shifted');
                            bytes = bytes.subarray(offset);
                            this.bytes = bytes;
                        }
                        var major = bytes[0];
                        var minor = bytes[1];
                        var hdrSize = bytes[2];
                        var offSize = bytes[3];
                        var header = new CFFHeader(major, minor, hdrSize, offSize);
                        return {
                            obj: header,
                            endPos: hdrSize
                        };
                    },
                    parseDict: function CFFParser_parseDict(dict) {
                        var pos = 0;

                        function parseOperand() {
                            var value = dict[pos++];
                            if (value === 30) {
                                return parseFloatOperand(pos);
                            } else if (value === 28) {
                                value = dict[pos++];
                                value = ((value << 24) | (dict[pos++] << 16)) >> 16;
                                return value;
                            } else if (value === 29) {
                                value = dict[pos++];
                                value = (value << 8) | dict[pos++];
                                value = (value << 8) | dict[pos++];
                                value = (value << 8) | dict[pos++];
                                return value;
                            } else if (value >= 32 && value <= 246) {
                                return value - 139;
                            } else if (value >= 247 && value <= 250) {
                                return ((value - 247) * 256) + dict[pos++] + 108;
                            } else if (value >= 251 && value <= 254) {
                                return -((value - 251) * 256) - dict[pos++] - 108;
                            } else {
                                error('255 is not a valid DICT command');
                            }
                            return -1;
                        }

                        function parseFloatOperand() {
                            var str = '';
                            var eof = 15;
                            var lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];
                            var length = dict.length;
                            while (pos < length) {
                                var b = dict[pos++];
                                var b1 = b >> 4;
                                var b2 = b & 15;
                                if (b1 === eof) {
                                    break;
                                }
                                str += lookup[b1];
                                if (b2 === eof) {
                                    break;
                                }
                                str += lookup[b2];
                            }
                            return parseFloat(str);
                        }
                        var operands = [];
                        var entries = [];
                        pos = 0;
                        var end = dict.length;
                        while (pos < end) {
                            var b = dict[pos];
                            if (b <= 21) {
                                if (b === 12) {
                                    b = (b << 8) | dict[++pos];
                                }
                                entries.push([b, operands]);
                                operands = [];
                                ++pos;
                            } else {
                                operands.push(parseOperand());
                            }
                        }
                        return entries;
                    },
                    parseIndex: function CFFParser_parseIndex(pos) {
                        var cffIndex = new CFFIndex();
                        var bytes = this.bytes;
                        var count = (bytes[pos++] << 8) | bytes[pos++];
                        var offsets = [];
                        var end = pos;
                        var i, ii;
                        if (count !== 0) {
                            var offsetSize = bytes[pos++];
                            var startPos = pos + ((count + 1) * offsetSize) - 1;
                            for (i = 0, ii = count + 1; i < ii; ++i) {
                                var offset = 0;
                                for (var j = 0; j < offsetSize; ++j) {
                                    offset <<= 8;
                                    offset += bytes[pos++];
                                }
                                offsets.push(startPos + offset);
                            }
                            end = offsets[count];
                        }
                        for (i = 0, ii = offsets.length - 1; i < ii; ++i) {
                            var offsetStart = offsets[i];
                            var offsetEnd = offsets[i + 1];
                            cffIndex.add(bytes.subarray(offsetStart, offsetEnd));
                        }
                        return {
                            obj: cffIndex,
                            endPos: end
                        };
                    },
                    parseNameIndex: function CFFParser_parseNameIndex(index) {
                        var names = [];
                        for (var i = 0, ii = index.count; i < ii; ++i) {
                            var name = index.get(i);
                            var length = Math.min(name.length, 127);
                            var data = [];
                            for (var j = 0; j < length; ++j) {
                                var c = name[j];
                                if (j === 0 && c === 0) {
                                    data[j] = c;
                                    continue;
                                }
                                if ((c < 33 || c > 126) || c === 91 || c === 93 || c === 40 || c === 41 || c === 123 || c === 125 || c === 60 || c === 62 || c === 47 || c === 37 || c === 35) {
                                    data[j] = 95;
                                    continue;
                                }
                                data[j] = c;
                            }
                            names.push(bytesToString(data));
                        }
                        return names;
                    },
                    parseStringIndex: function CFFParser_parseStringIndex(index) {
                        var strings = new CFFStrings();
                        for (var i = 0, ii = index.count; i < ii; ++i) {
                            var data = index.get(i);
                            strings.add(bytesToString(data));
                        }
                        return strings;
                    },
                    createDict: function CFFParser_createDict(Type, dict, strings) {
                        var cffDict = new Type(strings);
                        for (var i = 0, ii = dict.length; i < ii; ++i) {
                            var pair = dict[i];
                            var key = pair[0];
                            var value = pair[1];
                            cffDict.setByKey(key, value);
                        }
                        return cffDict;
                    },
                    parseCharString: function CFFParser_parseCharString(state, data, localSubrIndex, globalSubrIndex) {
                        if (state.callDepth > MAX_SUBR_NESTING) {
                            return false;
                        }
                        var stackSize = state.stackSize;
                        var stack = state.stack;
                        var length = data.length;
                        for (var j = 0; j < length;) {
                            var value = data[j++];
                            var validationCommand = null;
                            if (value === 12) {
                                var q = data[j++];
                                if (q === 0) {
                                    data[j - 2] = 139;
                                    data[j - 1] = 22;
                                    stackSize = 0;
                                } else {
                                    validationCommand = CharstringValidationData12[q];
                                }
                            } else if (value === 28) {
                                stack[stackSize] = ((data[j] << 24) | (data[j + 1] << 16)) >> 16;
                                j += 2;
                                stackSize++;
                            } else if (value === 14) {
                                if (stackSize >= 4) {
                                    stackSize -= 4;
                                    if (SEAC_ANALYSIS_ENABLED) {
                                        state.seac = stack.slice(stackSize, stackSize + 4);
                                        return false;
                                    }
                                }
                                validationCommand = CharstringValidationData[value];
                            } else if (value >= 32 && value <= 246) {
                                stack[stackSize] = value - 139;
                                stackSize++;
                            } else if (value >= 247 && value <= 254) {
                                stack[stackSize] = (value < 251 ? ((value - 247) << 8) + data[j] + 108 : -((value - 251) << 8) - data[j] - 108);
                                j++;
                                stackSize++;
                            } else if (value === 255) {
                                stack[stackSize] = ((data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | data[j + 3]) / 65536;
                                j += 4;
                                stackSize++;
                            } else if (value === 19 || value === 20) {
                                state.hints += stackSize >> 1;
                                j += (state.hints + 7) >> 3;
                                stackSize %= 2;
                                validationCommand = CharstringValidationData[value];
                            } else if (value === 10 || value === 29) {
                                var subrsIndex;
                                if (value === 10) {
                                    subrsIndex = localSubrIndex;
                                } else {
                                    subrsIndex = globalSubrIndex;
                                }
                                if (!subrsIndex) {
                                    validationCommand = CharstringValidationData[value];
                                    warn('Missing subrsIndex for ' + validationCommand.id);
                                    return false;
                                }
                                var bias = 32768;
                                if (subrsIndex.count < 1240) {
                                    bias = 107;
                                } else if (subrsIndex.count < 33900) {
                                    bias = 1131;
                                }
                                var subrNumber = stack[--stackSize] + bias;
                                if (subrNumber < 0 || subrNumber >= subrsIndex.count) {
                                    validationCommand = CharstringValidationData[value];
                                    warn('Out of bounds subrIndex for ' + validationCommand.id);
                                    return false;
                                }
                                state.stackSize = stackSize;
                                state.callDepth++;
                                var valid = this.parseCharString(state, subrsIndex.get(subrNumber), localSubrIndex, globalSubrIndex);
                                if (!valid) {
                                    return false;
                                }
                                state.callDepth--;
                                stackSize = state.stackSize;
                                continue;
                            } else if (value === 11) {
                                state.stackSize = stackSize;
                                return true;
                            } else {
                                validationCommand = CharstringValidationData[value];
                            }
                            if (validationCommand) {
                                if (validationCommand.stem) {
                                    state.hints += stackSize >> 1;
                                }
                                if ('min' in validationCommand) {
                                    if (!state.undefStack && stackSize < validationCommand.min) {
                                        warn('Not enough parameters for ' + validationCommand.id + '; actual: ' + stackSize + ', expected: ' + validationCommand.min);
                                        return false;
                                    }
                                }
                                if (state.firstStackClearing && validationCommand.stackClearing) {
                                    state.firstStackClearing = false;
                                    stackSize -= validationCommand.min;
                                    if (stackSize >= 2 && validationCommand.stem) {
                                        stackSize %= 2;
                                    } else if (stackSize > 1) {
                                        warn('Found too many parameters for stack-clearing command');
                                    }
                                    if (stackSize > 0 && stack[stackSize - 1] >= 0) {
                                        state.width = stack[stackSize - 1];
                                    }
                                }
                                if ('stackDelta' in validationCommand) {
                                    if ('stackFn' in validationCommand) {
                                        validationCommand.stackFn(stack, stackSize);
                                    }
                                    stackSize += validationCommand.stackDelta;
                                } else if (validationCommand.stackClearing) {
                                    stackSize = 0;
                                } else if (validationCommand.resetStack) {
                                    stackSize = 0;
                                    state.undefStack = false;
                                } else if (validationCommand.undefStack) {
                                    stackSize = 0;
                                    state.undefStack = true;
                                    state.firstStackClearing = false;
                                }
                            }
                        }
                        state.stackSize = stackSize;
                        return true;
                    },
                    parseCharStrings: function CFFParser_parseCharStrings(charStrings, localSubrIndex, globalSubrIndex, fdSelect, fdArray) {
                        var seacs = [];
                        var widths = [];
                        var count = charStrings.count;
                        for (var i = 0; i < count; i++) {
                            var charstring = charStrings.get(i);
                            var state = {
                                callDepth: 0,
                                stackSize: 0,
                                stack: [],
                                undefStack: true,
                                hints: 0,
                                firstStackClearing: true,
                                seac: null,
                                width: null
                            };
                            var valid = true;
                            var localSubrToUse = null;
                            if (fdSelect && fdArray.length) {
                                var fdIndex = fdSelect.getFDIndex(i);
                                if (fdIndex === -1) {
                                    warn('Glyph index is not in fd select.');
                                    valid = false;
                                }
                                if (fdIndex >= fdArray.length) {
                                    warn('Invalid fd index for glyph index.');
                                    valid = false;
                                }
                                if (valid) {
                                    localSubrToUse = fdArray[fdIndex].privateDict.subrsIndex;
                                }
                            } else if (localSubrIndex) {
                                localSubrToUse = localSubrIndex;
                            }
                            if (valid) {
                                valid = this.parseCharString(state, charstring, localSubrToUse, globalSubrIndex);
                            }
                            if (state.width !== null) {
                                widths[i] = state.width;
                            }
                            if (state.seac !== null) {
                                seacs[i] = state.seac;
                            }
                            if (!valid) {
                                charStrings.set(i, new Uint8Array([14]));
                            }
                        }
                        return {
                            charStrings: charStrings,
                            seacs: seacs,
                            widths: widths
                        };
                    },
                    emptyPrivateDictionary: function CFFParser_emptyPrivateDictionary(parentDict) {
                        var privateDict = this.createDict(CFFPrivateDict, [], parentDict.strings);
                        parentDict.setByKey(18, [0, 0]);
                        parentDict.privateDict = privateDict;
                    },
                    parsePrivateDict: function CFFParser_parsePrivateDict(parentDict) {
                        if (!parentDict.hasName('Private')) {
                            this.emptyPrivateDictionary(parentDict);
                            return;
                        }
                        var privateOffset = parentDict.getByName('Private');
                        if (!isArray(privateOffset) || privateOffset.length !== 2) {
                            parentDict.removeByName('Private');
                            return;
                        }
                        var size = privateOffset[0];
                        var offset = privateOffset[1];
                        if (size === 0 || offset >= this.bytes.length) {
                            this.emptyPrivateDictionary(parentDict);
                            return;
                        }
                        var privateDictEnd = offset + size;
                        var dictData = this.bytes.subarray(offset, privateDictEnd);
                        var dict = this.parseDict(dictData);
                        var privateDict = this.createDict(CFFPrivateDict, dict, parentDict.strings);
                        parentDict.privateDict = privateDict;
                        if (!privateDict.getByName('Subrs')) {
                            return;
                        }
                        var subrsOffset = privateDict.getByName('Subrs');
                        var relativeOffset = offset + subrsOffset;
                        if (subrsOffset === 0 || relativeOffset >= this.bytes.length) {
                            this.emptyPrivateDictionary(parentDict);
                            return;
                        }
                        var subrsIndex = this.parseIndex(relativeOffset);
                        privateDict.subrsIndex = subrsIndex.obj;
                    },
                    parseCharsets: function CFFParser_parseCharsets(pos, length, strings, cid) {
                        if (pos === 0) {
                            return new CFFCharset(true, CFFCharsetPredefinedTypes.ISO_ADOBE, ISOAdobeCharset);
                        } else if (pos === 1) {
                            return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT, ExpertCharset);
                        } else if (pos === 2) {
                            return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT_SUBSET, ExpertSubsetCharset);
                        }
                        var bytes = this.bytes;
                        var start = pos;
                        var format = bytes[pos++];
                        var charset = ['.notdef'];
                        var id, count, i;
                        length -= 1;
                        switch (format) {
                            case 0:
                                for (i = 0; i < length; i++) {
                                    id = (bytes[pos++] << 8) | bytes[pos++];
                                    charset.push(cid ? id : strings.get(id));
                                }
                                break;
                            case 1:
                                while (charset.length <= length) {
                                    id = (bytes[pos++] << 8) | bytes[pos++];
                                    count = bytes[pos++];
                                    for (i = 0; i <= count; i++) {
                                        charset.push(cid ? id++ : strings.get(id++));
                                    }
                                }
                                break;
                            case 2:
                                while (charset.length <= length) {
                                    id = (bytes[pos++] << 8) | bytes[pos++];
                                    count = (bytes[pos++] << 8) | bytes[pos++];
                                    for (i = 0; i <= count; i++) {
                                        charset.push(cid ? id++ : strings.get(id++));
                                    }
                                }
                                break;
                            default:
                                error('Unknown charset format');
                        }
                        var end = pos;
                        var raw = bytes.subarray(start, end);
                        return new CFFCharset(false, format, charset, raw);
                    },
                    parseEncoding: function CFFParser_parseEncoding(pos, properties, strings, charset) {
                        var encoding = {};
                        var bytes = this.bytes;
                        var predefined = false;
                        var hasSupplement = false;
                        var format, i, ii;
                        var raw = null;

                        function readSupplement() {
                            var supplementsCount = bytes[pos++];
                            for (i = 0; i < supplementsCount; i++) {
                                var code = bytes[pos++];
                                var sid = (bytes[pos++] << 8) + (bytes[pos++] & 0xff);
                                encoding[code] = charset.indexOf(strings.get(sid));
                            }
                        }
                        if (pos === 0 || pos === 1) {
                            predefined = true;
                            format = pos;
                            var baseEncoding = pos ? Encodings.ExpertEncoding : Encodings.StandardEncoding;
                            for (i = 0, ii = charset.length; i < ii; i++) {
                                var index = baseEncoding.indexOf(charset[i]);
                                if (index !== -1) {
                                    encoding[index] = i;
                                }
                            }
                        } else {
                            var dataStart = pos;
                            format = bytes[pos++];
                            switch (format & 0x7f) {
                                case 0:
                                    var glyphsCount = bytes[pos++];
                                    for (i = 1; i <= glyphsCount; i++) {
                                        encoding[bytes[pos++]] = i;
                                    }
                                    break;
                                case 1:
                                    var rangesCount = bytes[pos++];
                                    var gid = 1;
                                    for (i = 0; i < rangesCount; i++) {
                                        var start = bytes[pos++];
                                        var left = bytes[pos++];
                                        for (var j = start; j <= start + left; j++) {
                                            encoding[j] = gid++;
                                        }
                                    }
                                    break;
                                default:
                                    error('Unknow encoding format: ' + format + ' in CFF');
                                    break;
                            }
                            var dataEnd = pos;
                            if (format & 0x80) {
                                bytes[dataStart] &= 0x7f;
                                readSupplement();
                                hasSupplement = true;
                            }
                            raw = bytes.subarray(dataStart, dataEnd);
                        }
                        format = format & 0x7f;
                        return new CFFEncoding(predefined, format, encoding, raw);
                    },
                    parseFDSelect: function CFFParser_parseFDSelect(pos, length) {
                        var start = pos;
                        var bytes = this.bytes;
                        var format = bytes[pos++];
                        var fdSelect = [];
                        var i;
                        switch (format) {
                            case 0:
                                for (i = 0; i < length; ++i) {
                                    var id = bytes[pos++];
                                    fdSelect.push(id);
                                }
                                break;
                            case 3:
                                var rangesCount = (bytes[pos++] << 8) | bytes[pos++];
                                for (i = 0; i < rangesCount; ++i) {
                                    var first = (bytes[pos++] << 8) | bytes[pos++];
                                    var fdIndex = bytes[pos++];
                                    var next = (bytes[pos] << 8) | bytes[pos + 1];
                                    for (var j = first; j < next; ++j) {
                                        fdSelect.push(fdIndex);
                                    }
                                }
                                pos += 2;
                                break;
                            default:
                                error('Unknown fdselect format ' + format);
                                break;
                        }
                        var end = pos;
                        return new CFFFDSelect(fdSelect, bytes.subarray(start, end));
                    }
                };
                return CFFParser;
            })();
            var CFF = (function CFFClosure() {
                function CFF() {
                    this.header = null;
                    this.names = [];
                    this.topDict = null;
                    this.strings = new CFFStrings();
                    this.globalSubrIndex = null;
                    this.encoding = null;
                    this.charset = null;
                    this.charStrings = null;
                    this.fdArray = [];
                    this.fdSelect = null;
                    this.isCIDFont = false;
                }
                return CFF;
            })();
            var CFFHeader = (function CFFHeaderClosure() {
                function CFFHeader(major, minor, hdrSize, offSize) {
                    this.major = major;
                    this.minor = minor;
                    this.hdrSize = hdrSize;
                    this.offSize = offSize;
                }
                return CFFHeader;
            })();
            var CFFStrings = (function CFFStringsClosure() {
                function CFFStrings() {
                    this.strings = [];
                }
                CFFStrings.prototype = {
                    get: function CFFStrings_get(index) {
                        if (index >= 0 && index <= 390) {
                            return CFFStandardStrings[index];
                        }
                        if (index - 391 <= this.strings.length) {
                            return this.strings[index - 391];
                        }
                        return CFFStandardStrings[0];
                    },
                    add: function CFFStrings_add(value) {
                        this.strings.push(value);
                    },
                    get count() {
                        return this.strings.length;
                    }
                };
                return CFFStrings;
            })();
            var CFFIndex = (function CFFIndexClosure() {
                function CFFIndex() {
                    this.objects = [];
                    this.length = 0;
                }
                CFFIndex.prototype = {
                    add: function CFFIndex_add(data) {
                        this.length += data.length;
                        this.objects.push(data);
                    },
                    set: function CFFIndex_set(index, data) {
                        this.length += data.length - this.objects[index].length;
                        this.objects[index] = data;
                    },
                    get: function CFFIndex_get(index) {
                        return this.objects[index];
                    },
                    get count() {
                        return this.objects.length;
                    }
                };
                return CFFIndex;
            })();
            var CFFDict = (function CFFDictClosure() {
                function CFFDict(tables, strings) {
                    this.keyToNameMap = tables.keyToNameMap;
                    this.nameToKeyMap = tables.nameToKeyMap;
                    this.defaults = tables.defaults;
                    this.types = tables.types;
                    this.opcodes = tables.opcodes;
                    this.order = tables.order;
                    this.strings = strings;
                    this.values = {};
                }
                CFFDict.prototype = {
                    setByKey: function CFFDict_setByKey(key, value) {
                        if (!(key in this.keyToNameMap)) {
                            return false;
                        }
                        if (value.length === 0) {
                            return true;
                        }
                        var type = this.types[key];
                        if (type === 'num' || type === 'sid' || type === 'offset') {
                            value = value[0];
                        }
                        this.values[key] = value;
                        return true;
                    },
                    setByName: function CFFDict_setByName(name, value) {
                        if (!(name in this.nameToKeyMap)) {
                            error('Invalid dictionary name "' + name + '"');
                        }
                        this.values[this.nameToKeyMap[name]] = value;
                    },
                    hasName: function CFFDict_hasName(name) {
                        return this.nameToKeyMap[name] in this.values;
                    },
                    getByName: function CFFDict_getByName(name) {
                        if (!(name in this.nameToKeyMap)) {
                            error('Invalid dictionary name "' + name + '"');
                        }
                        var key = this.nameToKeyMap[name];
                        if (!(key in this.values)) {
                            return this.defaults[key];
                        }
                        return this.values[key];
                    },
                    removeByName: function CFFDict_removeByName(name) {
                        delete this.values[this.nameToKeyMap[name]];
                    }
                };
                CFFDict.createTables = function CFFDict_createTables(layout) {
                    var tables = {
                        keyToNameMap: {},
                        nameToKeyMap: {},
                        defaults: {},
                        types: {},
                        opcodes: {},
                        order: []
                    };
                    for (var i = 0, ii = layout.length; i < ii; ++i) {
                        var entry = layout[i];
                        var key = isArray(entry[0]) ? (entry[0][0] << 8) + entry[0][1] : entry[0];
                        tables.keyToNameMap[key] = entry[1];
                        tables.nameToKeyMap[entry[1]] = key;
                        tables.types[key] = entry[2];
                        tables.defaults[key] = entry[3];
                        tables.opcodes[key] = isArray(entry[0]) ? entry[0] : [entry[0]];
                        tables.order.push(key);
                    }
                    return tables;
                };
                return CFFDict;
            })();
            var CFFTopDict = (function CFFTopDictClosure() {
                var layout = [
                    [
                        [12, 30], 'ROS', ['sid', 'sid', 'num'], null
                    ],
                    [
                        [12, 20], 'SyntheticBase', 'num', null
                    ],
                    [0, 'version', 'sid', null],
                    [1, 'Notice', 'sid', null],
                    [
                        [12, 0], 'Copyright', 'sid', null
                    ],
                    [2, 'FullName', 'sid', null],
                    [3, 'FamilyName', 'sid', null],
                    [4, 'Weight', 'sid', null],
                    [
                        [12, 1], 'isFixedPitch', 'num', 0
                    ],
                    [
                        [12, 2], 'ItalicAngle', 'num', 0
                    ],
                    [
                        [12, 3], 'UnderlinePosition', 'num', -100
                    ],
                    [
                        [12, 4], 'UnderlineThickness', 'num', 50
                    ],
                    [
                        [12, 5], 'PaintType', 'num', 0
                    ],
                    [
                        [12, 6], 'CharstringType', 'num', 2
                    ],
                    [
                        [12, 7], 'FontMatrix', ['num', 'num', 'num', 'num', 'num', 'num'],
                        [0.001, 0, 0, 0.001, 0, 0]
                    ],
                    [13, 'UniqueID', 'num', null],
                    [5, 'FontBBox', ['num', 'num', 'num', 'num'],
                        [0, 0, 0, 0]
                    ],
                    [
                        [12, 8], 'StrokeWidth', 'num', 0
                    ],
                    [14, 'XUID', 'array', null],
                    [15, 'charset', 'offset', 0],
                    [16, 'Encoding', 'offset', 0],
                    [17, 'CharStrings', 'offset', 0],
                    [18, 'Private', ['offset', 'offset'], null],
                    [
                        [12, 21], 'PostScript', 'sid', null
                    ],
                    [
                        [12, 22], 'BaseFontName', 'sid', null
                    ],
                    [
                        [12, 23], 'BaseFontBlend', 'delta', null
                    ],
                    [
                        [12, 31], 'CIDFontVersion', 'num', 0
                    ],
                    [
                        [12, 32], 'CIDFontRevision', 'num', 0
                    ],
                    [
                        [12, 33], 'CIDFontType', 'num', 0
                    ],
                    [
                        [12, 34], 'CIDCount', 'num', 8720
                    ],
                    [
                        [12, 35], 'UIDBase', 'num', null
                    ],
                    [
                        [12, 37], 'FDSelect', 'offset', null
                    ],
                    [
                        [12, 36], 'FDArray', 'offset', null
                    ],
                    [
                        [12, 38], 'FontName', 'sid', null
                    ]
                ];
                var tables = null;

                function CFFTopDict(strings) {
                    if (tables === null) {
                        tables = CFFDict.createTables(layout);
                    }
                    CFFDict.call(this, tables, strings);
                    this.privateDict = null;
                }
                CFFTopDict.prototype = Object.create(CFFDict.prototype);
                return CFFTopDict;
            })();
            var CFFPrivateDict = (function CFFPrivateDictClosure() {
                var layout = [
                    [6, 'BlueValues', 'delta', null],
                    [7, 'OtherBlues', 'delta', null],
                    [8, 'FamilyBlues', 'delta', null],
                    [9, 'FamilyOtherBlues', 'delta', null],
                    [
                        [12, 9], 'BlueScale', 'num', 0.039625
                    ],
                    [
                        [12, 10], 'BlueShift', 'num', 7
                    ],
                    [
                        [12, 11], 'BlueFuzz', 'num', 1
                    ],
                    [10, 'StdHW', 'num', null],
                    [11, 'StdVW', 'num', null],
                    [
                        [12, 12], 'StemSnapH', 'delta', null
                    ],
                    [
                        [12, 13], 'StemSnapV', 'delta', null
                    ],
                    [
                        [12, 14], 'ForceBold', 'num', 0
                    ],
                    [
                        [12, 17], 'LanguageGroup', 'num', 0
                    ],
                    [
                        [12, 18], 'ExpansionFactor', 'num', 0.06
                    ],
                    [
                        [12, 19], 'initialRandomSeed', 'num', 0
                    ],
                    [20, 'defaultWidthX', 'num', 0],
                    [21, 'nominalWidthX', 'num', 0],
                    [19, 'Subrs', 'offset', null]
                ];
                var tables = null;

                function CFFPrivateDict(strings) {
                    if (tables === null) {
                        tables = CFFDict.createTables(layout);
                    }
                    CFFDict.call(this, tables, strings);
                    this.subrsIndex = null;
                }
                CFFPrivateDict.prototype = Object.create(CFFDict.prototype);
                return CFFPrivateDict;
            })();
            var CFFCharsetPredefinedTypes = {
                ISO_ADOBE: 0,
                EXPERT: 1,
                EXPERT_SUBSET: 2
            };
            var CFFCharset = (function CFFCharsetClosure() {
                function CFFCharset(predefined, format, charset, raw) {
                    this.predefined = predefined;
                    this.format = format;
                    this.charset = charset;
                    this.raw = raw;
                }
                return CFFCharset;
            })();
            var CFFEncoding = (function CFFEncodingClosure() {
                function CFFEncoding(predefined, format, encoding, raw) {
                    this.predefined = predefined;
                    this.format = format;
                    this.encoding = encoding;
                    this.raw = raw;
                }
                return CFFEncoding;
            })();
            var CFFFDSelect = (function CFFFDSelectClosure() {
                function CFFFDSelect(fdSelect, raw) {
                    this.fdSelect = fdSelect;
                    this.raw = raw;
                }
                CFFFDSelect.prototype = {
                    getFDIndex: function CFFFDSelect_get(glyphIndex) {
                        if (glyphIndex < 0 || glyphIndex >= this.fdSelect.length) {
                            return -1;
                        }
                        return this.fdSelect[glyphIndex];
                    }
                };
                return CFFFDSelect;
            })();
            var CFFOffsetTracker = (function CFFOffsetTrackerClosure() {
                function CFFOffsetTracker() {
                    this.offsets = {};
                }
                CFFOffsetTracker.prototype = {
                    isTracking: function CFFOffsetTracker_isTracking(key) {
                        return key in this.offsets;
                    },
                    track: function CFFOffsetTracker_track(key, location) {
                        if (key in this.offsets) {
                            error('Already tracking location of ' + key);
                        }
                        this.offsets[key] = location;
                    },
                    offset: function CFFOffsetTracker_offset(value) {
                        for (var key in this.offsets) {
                            this.offsets[key] += value;
                        }
                    },
                    setEntryLocation: function CFFOffsetTracker_setEntryLocation(key, values, output) {
                        if (!(key in this.offsets)) {
                            error('Not tracking location of ' + key);
                        }
                        var data = output.data;
                        var dataOffset = this.offsets[key];
                        var size = 5;
                        for (var i = 0, ii = values.length; i < ii; ++i) {
                            var offset0 = i * size + dataOffset;
                            var offset1 = offset0 + 1;
                            var offset2 = offset0 + 2;
                            var offset3 = offset0 + 3;
                            var offset4 = offset0 + 4;
                            if (data[offset0] !== 0x1d || data[offset1] !== 0 || data[offset2] !== 0 || data[offset3] !== 0 || data[offset4] !== 0) {
                                error('writing to an offset that is not empty');
                            }
                            var value = values[i];
                            data[offset0] = 0x1d;
                            data[offset1] = (value >> 24) & 0xFF;
                            data[offset2] = (value >> 16) & 0xFF;
                            data[offset3] = (value >> 8) & 0xFF;
                            data[offset4] = value & 0xFF;
                        }
                    }
                };
                return CFFOffsetTracker;
            })();
            var CFFCompiler = (function CFFCompilerClosure() {
                function CFFCompiler(cff) {
                    this.cff = cff;
                }
                CFFCompiler.prototype = {
                    compile: function CFFCompiler_compile() {
                        var cff = this.cff;
                        var output = {
                            data: [],
                            length: 0,
                            add: function CFFCompiler_add(data) {
                                this.data = this.data.concat(data);
                                this.length = this.data.length;
                            }
                        };
                        var header = this.compileHeader(cff.header);
                        output.add(header);
                        var nameIndex = this.compileNameIndex(cff.names);
                        output.add(nameIndex);
                        if (cff.isCIDFont) {
                            if (cff.topDict.hasName('FontMatrix')) {
                                var base = cff.topDict.getByName('FontMatrix');
                                cff.topDict.removeByName('FontMatrix');
                                for (var i = 0, ii = cff.fdArray.length; i < ii; i++) {
                                    var subDict = cff.fdArray[i];
                                    var matrix = base.slice(0);
                                    if (subDict.hasName('FontMatrix')) {
                                        matrix = Util.transform(matrix, subDict.getByName('FontMatrix'));
                                    }
                                    subDict.setByName('FontMatrix', matrix);
                                }
                            }
                        }
                        var compiled = this.compileTopDicts([cff.topDict], output.length, cff.isCIDFont);
                        output.add(compiled.output);
                        var topDictTracker = compiled.trackers[0];
                        var stringIndex = this.compileStringIndex(cff.strings.strings);
                        output.add(stringIndex);
                        var globalSubrIndex = this.compileIndex(cff.globalSubrIndex);
                        output.add(globalSubrIndex);
                        if (cff.encoding && cff.topDict.hasName('Encoding')) {
                            if (cff.encoding.predefined) {
                                topDictTracker.setEntryLocation('Encoding', [cff.encoding.format], output);
                            } else {
                                var encoding = this.compileEncoding(cff.encoding);
                                topDictTracker.setEntryLocation('Encoding', [output.length], output);
                                output.add(encoding);
                            }
                        }
                        if (cff.charset && cff.topDict.hasName('charset')) {
                            if (cff.charset.predefined) {
                                topDictTracker.setEntryLocation('charset', [cff.charset.format], output);
                            } else {
                                var charset = this.compileCharset(cff.charset);
                                topDictTracker.setEntryLocation('charset', [output.length], output);
                                output.add(charset);
                            }
                        }
                        var charStrings = this.compileCharStrings(cff.charStrings);
                        topDictTracker.setEntryLocation('CharStrings', [output.length], output);
                        output.add(charStrings);
                        if (cff.isCIDFont) {
                            topDictTracker.setEntryLocation('FDSelect', [output.length], output);
                            var fdSelect = this.compileFDSelect(cff.fdSelect.raw);
                            output.add(fdSelect);
                            compiled = this.compileTopDicts(cff.fdArray, output.length, true);
                            topDictTracker.setEntryLocation('FDArray', [output.length], output);
                            output.add(compiled.output);
                            var fontDictTrackers = compiled.trackers;
                            this.compilePrivateDicts(cff.fdArray, fontDictTrackers, output);
                        }
                        this.compilePrivateDicts([cff.topDict], [topDictTracker], output);
                        output.add([0]);
                        return output.data;
                    },
                    encodeNumber: function CFFCompiler_encodeNumber(value) {
                        if (parseFloat(value) === parseInt(value, 10) && !isNaN(value)) {
                            return this.encodeInteger(value);
                        } else {
                            return this.encodeFloat(value);
                        }
                    },
                    encodeFloat: function CFFCompiler_encodeFloat(num) {
                        var value = num.toString();
                        var m = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(value);
                        if (m) {
                            var epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length));
                            value = (Math.round(num * epsilon) / epsilon).toString();
                        }
                        var nibbles = '';
                        var i, ii;
                        for (i = 0, ii = value.length; i < ii; ++i) {
                            var a = value[i];
                            if (a === 'e') {
                                nibbles += value[++i] === '-' ? 'c' : 'b';
                            } else if (a === '.') {
                                nibbles += 'a';
                            } else if (a === '-') {
                                nibbles += 'e';
                            } else {
                                nibbles += a;
                            }
                        }
                        nibbles += (nibbles.length & 1) ? 'f' : 'ff';
                        var out = [30];
                        for (i = 0, ii = nibbles.length; i < ii; i += 2) {
                            out.push(parseInt(nibbles.substr(i, 2), 16));
                        }
                        return out;
                    },
                    encodeInteger: function CFFCompiler_encodeInteger(value) {
                        var code;
                        if (value >= -107 && value <= 107) {
                            code = [value + 139];
                        } else if (value >= 108 && value <= 1131) {
                            value = [value - 108];
                            code = [(value >> 8) + 247, value & 0xFF];
                        } else if (value >= -1131 && value <= -108) {
                            value = -value - 108;
                            code = [(value >> 8) + 251, value & 0xFF];
                        } else if (value >= -32768 && value <= 32767) {
                            code = [0x1c, (value >> 8) & 0xFF, value & 0xFF];
                        } else {
                            code = [0x1d, (value >> 24) & 0xFF, (value >> 16) & 0xFF, (value >> 8) & 0xFF, value & 0xFF];
                        }
                        return code;
                    },
                    compileHeader: function CFFCompiler_compileHeader(header) {
                        return [header.major, header.minor, header.hdrSize, header.offSize];
                    },
                    compileNameIndex: function CFFCompiler_compileNameIndex(names) {
                        var nameIndex = new CFFIndex();
                        for (var i = 0, ii = names.length; i < ii; ++i) {
                            nameIndex.add(stringToBytes(names[i]));
                        }
                        return this.compileIndex(nameIndex);
                    },
                    compileTopDicts: function CFFCompiler_compileTopDicts(dicts, length, removeCidKeys) {
                        var fontDictTrackers = [];
                        var fdArrayIndex = new CFFIndex();
                        for (var i = 0, ii = dicts.length; i < ii; ++i) {
                            var fontDict = dicts[i];
                            if (removeCidKeys) {
                                fontDict.removeByName('CIDFontVersion');
                                fontDict.removeByName('CIDFontRevision');
                                fontDict.removeByName('CIDFontType');
                                fontDict.removeByName('CIDCount');
                                fontDict.removeByName('UIDBase');
                            }
                            var fontDictTracker = new CFFOffsetTracker();
                            var fontDictData = this.compileDict(fontDict, fontDictTracker);
                            fontDictTrackers.push(fontDictTracker);
                            fdArrayIndex.add(fontDictData);
                            fontDictTracker.offset(length);
                        }
                        fdArrayIndex = this.compileIndex(fdArrayIndex, fontDictTrackers);
                        return {
                            trackers: fontDictTrackers,
                            output: fdArrayIndex
                        };
                    },
                    compilePrivateDicts: function CFFCompiler_compilePrivateDicts(dicts, trackers, output) {
                        for (var i = 0, ii = dicts.length; i < ii; ++i) {
                            var fontDict = dicts[i];
                            assert(fontDict.privateDict && fontDict.hasName('Private'), 'There must be an private dictionary.');
                            var privateDict = fontDict.privateDict;
                            var privateDictTracker = new CFFOffsetTracker();
                            var privateDictData = this.compileDict(privateDict, privateDictTracker);
                            var outputLength = output.length;
                            privateDictTracker.offset(outputLength);
                            if (!privateDictData.length) {
                                outputLength = 0;
                            }
                            trackers[i].setEntryLocation('Private', [privateDictData.length, outputLength], output);
                            output.add(privateDictData);
                            if (privateDict.subrsIndex && privateDict.hasName('Subrs')) {
                                var subrs = this.compileIndex(privateDict.subrsIndex);
                                privateDictTracker.setEntryLocation('Subrs', [privateDictData.length], output);
                                output.add(subrs);
                            }
                        }
                    },
                    compileDict: function CFFCompiler_compileDict(dict, offsetTracker) {
                        var out = [];
                        var order = dict.order;
                        for (var i = 0; i < order.length; ++i) {
                            var key = order[i];
                            if (!(key in dict.values)) {
                                continue;
                            }
                            var values = dict.values[key];
                            var types = dict.types[key];
                            if (!isArray(types)) {
                                types = [types];
                            }
                            if (!isArray(values)) {
                                values = [values];
                            }
                            if (values.length === 0) {
                                continue;
                            }
                            for (var j = 0, jj = types.length; j < jj; ++j) {
                                var type = types[j];
                                var value = values[j];
                                switch (type) {
                                    case 'num':
                                    case 'sid':
                                        out = out.concat(this.encodeNumber(value));
                                        break;
                                    case 'offset':
                                        var name = dict.keyToNameMap[key];
                                        if (!offsetTracker.isTracking(name)) {
                                            offsetTracker.track(name, out.length);
                                        }
                                        out = out.concat([0x1d, 0, 0, 0, 0]);
                                        break;
                                    case 'array':
                                    case 'delta':
                                        out = out.concat(this.encodeNumber(value));
                                        for (var k = 1, kk = values.length; k < kk; ++k) {
                                            out = out.concat(this.encodeNumber(values[k]));
                                        }
                                        break;
                                    default:
                                        error('Unknown data type of ' + type);
                                        break;
                                }
                            }
                            out = out.concat(dict.opcodes[key]);
                        }
                        return out;
                    },
                    compileStringIndex: function CFFCompiler_compileStringIndex(strings) {
                        var stringIndex = new CFFIndex();
                        for (var i = 0, ii = strings.length; i < ii; ++i) {
                            stringIndex.add(stringToBytes(strings[i]));
                        }
                        return this.compileIndex(stringIndex);
                    },
                    compileGlobalSubrIndex: function CFFCompiler_compileGlobalSubrIndex() {
                        var globalSubrIndex = this.cff.globalSubrIndex;
                        this.out.writeByteArray(this.compileIndex(globalSubrIndex));
                    },
                    compileCharStrings: function CFFCompiler_compileCharStrings(charStrings) {
                        return this.compileIndex(charStrings);
                    },
                    compileCharset: function CFFCompiler_compileCharset(charset) {
                        return this.compileTypedArray(charset.raw);
                    },
                    compileEncoding: function CFFCompiler_compileEncoding(encoding) {
                        return this.compileTypedArray(encoding.raw);
                    },
                    compileFDSelect: function CFFCompiler_compileFDSelect(fdSelect) {
                        return this.compileTypedArray(fdSelect);
                    },
                    compileTypedArray: function CFFCompiler_compileTypedArray(data) {
                        var out = [];
                        for (var i = 0, ii = data.length; i < ii; ++i) {
                            out[i] = data[i];
                        }
                        return out;
                    },
                    compileIndex: function CFFCompiler_compileIndex(index, trackers) {
                        trackers = trackers || [];
                        var objects = index.objects;
                        var count = objects.length;
                        if (count === 0) {
                            return [0, 0, 0];
                        }
                        var data = [(count >> 8) & 0xFF, count & 0xff];
                        var lastOffset = 1,
                            i;
                        for (i = 0; i < count; ++i) {
                            lastOffset += objects[i].length;
                        }
                        var offsetSize;
                        if (lastOffset < 0x100) {
                            offsetSize = 1;
                        } else if (lastOffset < 0x10000) {
                            offsetSize = 2;
                        } else if (lastOffset < 0x1000000) {
                            offsetSize = 3;
                        } else {
                            offsetSize = 4;
                        }
                        data.push(offsetSize);
                        var relativeOffset = 1;
                        for (i = 0; i < count + 1; i++) {
                            if (offsetSize === 1) {
                                data.push(relativeOffset & 0xFF);
                            } else if (offsetSize === 2) {
                                data.push((relativeOffset >> 8) & 0xFF, relativeOffset & 0xFF);
                            } else if (offsetSize === 3) {
                                data.push((relativeOffset >> 16) & 0xFF, (relativeOffset >> 8) & 0xFF, relativeOffset & 0xFF);
                            } else {
                                data.push((relativeOffset >>> 24) & 0xFF, (relativeOffset >> 16) & 0xFF, (relativeOffset >> 8) & 0xFF, relativeOffset & 0xFF);
                            }
                            if (objects[i]) {
                                relativeOffset += objects[i].length;
                            }
                        }
                        for (i = 0; i < count; i++) {
                            if (trackers[i]) {
                                trackers[i].offset(data.length);
                            }
                            for (var j = 0, jj = objects[i].length; j < jj; j++) {
                                data.push(objects[i][j]);
                            }
                        }
                        return data;
                    }
                };
                return CFFCompiler;
            })();

            function _enableSeacAnalysis(enabled) {
                exports.SEAC_ANALYSIS_ENABLED = SEAC_ANALYSIS_ENABLED = enabled;
            }
            (function checkSeacSupport() {
                if (typeof navigator !== 'undefined' && /Windows/.test(navigator.userAgent)) {
                    SEAC_ANALYSIS_ENABLED = true;
                }
            })();
            (function checkChromeWindows() {
                if (typeof navigator !== 'undefined' && /Windows.*Chrome/.test(navigator.userAgent)) {
                    SKIP_PRIVATE_USE_RANGE_F000_TO_F01F = true;
                }
            })();
            exports.SEAC_ANALYSIS_ENABLED = SEAC_ANALYSIS_ENABLED;
            exports.CFFCompiler = CFFCompiler;
            exports.CFFIndex = CFFIndex;
            exports.CFFParser = CFFParser;
            exports.CFFStrings = CFFStrings;
            exports.Encodings = Encodings;
            exports.ErrorFont = ErrorFont;
            exports.FontFlags = FontFlags;
            exports.Font = Font;
            exports.IdentityToUnicodeMap = IdentityToUnicodeMap;
            exports.NormalizedUnicodes = NormalizedUnicodes;
            exports.ToUnicodeMap = ToUnicodeMap;
            exports.Type1Parser = Type1Parser;
            exports.getFontType = getFontType;
            exports.reverseIfRtl = reverseIfRtl;
            exports.serifFonts = serifFonts;
            exports.symbolsFonts = symbolsFonts;
            exports.stdFontMap = stdFontMap;
            exports._enableSeacAnalysis = _enableSeacAnalysis;
            coreFontRenderer._setCoreFonts(exports);
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsCoreFunction = {}), root.pdfjsSharedUtil, root.pdfjsCorePrimitives, root.pdfjsCorePsParser);
            }
        }(this, function(exports, sharedUtil, corePrimitives, corePsParser) {
            var error = sharedUtil.error;
            var info = sharedUtil.info;
            var isArray = sharedUtil.isArray;
            var isBool = sharedUtil.isBool;
            var isDict = corePrimitives.isDict;
            var isStream = corePrimitives.isStream;
            var PostScriptLexer = corePsParser.PostScriptLexer;
            var PostScriptParser = corePsParser.PostScriptParser;
            var PDFFunction = (function PDFFunctionClosure() {
                var CONSTRUCT_SAMPLED = 0;
                var CONSTRUCT_INTERPOLATED = 2;
                var CONSTRUCT_STICHED = 3;
                var CONSTRUCT_POSTSCRIPT = 4;
                return {
                    getSampleArray: function PDFFunction_getSampleArray(size, outputSize, bps, str) {
                        var i, ii;
                        var length = 1;
                        for (i = 0, ii = size.length; i < ii; i++) {
                            length *= size[i];
                        }
                        length *= outputSize;
                        var array = new Array(length);
                        var codeSize = 0;
                        var codeBuf = 0;
                        var sampleMul = 1.0 / (Math.pow(2.0, bps) - 1);
                        var strBytes = str.getBytes((length * bps + 7) / 8);
                        var strIdx = 0;
                        for (i = 0; i < length; i++) {
                            while (codeSize < bps) {
                                codeBuf <<= 8;
                                codeBuf |= strBytes[strIdx++];
                                codeSize += 8;
                            }
                            codeSize -= bps;
                            array[i] = (codeBuf >> codeSize) * sampleMul;
                            codeBuf &= (1 << codeSize) - 1;
                        }
                        return array;
                    },
                    getIR: function PDFFunction_getIR(xref, fn) {
                        var dict = fn.dict;
                        if (!dict) {
                            dict = fn;
                        }
                        var types = [this.constructSampled, null, this.constructInterpolated, this.constructStiched, this.constructPostScript];
                        var typeNum = dict.get('FunctionType');
                        var typeFn = types[typeNum];
                        if (!typeFn) {
                            error('Unknown type of function');
                        }
                        return typeFn.call(this, fn, dict, xref);
                    },
                    fromIR: function PDFFunction_fromIR(IR) {
                        var type = IR[0];
                        switch (type) {
                            case CONSTRUCT_SAMPLED:
                                return this.constructSampledFromIR(IR);
                            case CONSTRUCT_INTERPOLATED:
                                return this.constructInterpolatedFromIR(IR);
                            case CONSTRUCT_STICHED:
                                return this.constructStichedFromIR(IR);
                            default:
                                return this.constructPostScriptFromIR(IR);
                        }
                    },
                    parse: function PDFFunction_parse(xref, fn) {
                        var IR = this.getIR(xref, fn);
                        return this.fromIR(IR);
                    },
                    parseArray: function PDFFunction_parseArray(xref, fnObj) {
                        if (!isArray(fnObj)) {
                            return this.parse(xref, fnObj);
                        }
                        var fnArray = [];
                        for (var j = 0, jj = fnObj.length; j < jj; j++) {
                            var obj = xref.fetchIfRef(fnObj[j]);
                            fnArray.push(PDFFunction.parse(xref, obj));
                        }
                        return function(src, srcOffset, dest, destOffset) {
                            for (var i = 0, ii = fnArray.length; i < ii; i++) {
                                fnArray[i](src, srcOffset, dest, destOffset + i);
                            }
                        };
                    },
                    constructSampled: function PDFFunction_constructSampled(str, dict) {
                        function toMultiArray(arr) {
                            var inputLength = arr.length;
                            var out = [];
                            var index = 0;
                            for (var i = 0; i < inputLength; i += 2) {
                                out[index] = [arr[i], arr[i + 1]];
                                ++index;
                            }
                            return out;
                        }
                        var domain = dict.get('Domain');
                        var range = dict.get('Range');
                        if (!domain || !range) {
                            error('No domain or range');
                        }
                        var inputSize = domain.length / 2;
                        var outputSize = range.length / 2;
                        domain = toMultiArray(domain);
                        range = toMultiArray(range);
                        var size = dict.get('Size');
                        var bps = dict.get('BitsPerSample');
                        var order = dict.get('Order') || 1;
                        if (order !== 1) {
                            info('No support for cubic spline interpolation: ' + order);
                        }
                        var encode = dict.get('Encode');
                        if (!encode) {
                            encode = [];
                            for (var i = 0; i < inputSize; ++i) {
                                encode.push(0);
                                encode.push(size[i] - 1);
                            }
                        }
                        encode = toMultiArray(encode);
                        var decode = dict.get('Decode');
                        if (!decode) {
                            decode = range;
                        } else {
                            decode = toMultiArray(decode);
                        }
                        var samples = this.getSampleArray(size, outputSize, bps, str);
                        return [CONSTRUCT_SAMPLED, inputSize, domain, encode, decode, samples, size, outputSize, Math.pow(2, bps) - 1, range];
                    },
                    constructSampledFromIR: function PDFFunction_constructSampledFromIR(IR) {
                        function interpolate(x, xmin, xmax, ymin, ymax) {
                            return ymin + ((x - xmin) * ((ymax - ymin) / (xmax - xmin)));
                        }
                        return function constructSampledFromIRResult(src, srcOffset, dest, destOffset) {
                            var m = IR[1];
                            var domain = IR[2];
                            var encode = IR[3];
                            var decode = IR[4];
                            var samples = IR[5];
                            var size = IR[6];
                            var n = IR[7];
                            var range = IR[9];
                            var cubeVertices = 1 << m;
                            var cubeN = new Float64Array(cubeVertices);
                            var cubeVertex = new Uint32Array(cubeVertices);
                            var i, j;
                            for (j = 0; j < cubeVertices; j++) {
                                cubeN[j] = 1;
                            }
                            var k = n,
                                pos = 1;
                            for (i = 0; i < m; ++i) {
                                var domain_2i = domain[i][0];
                                var domain_2i_1 = domain[i][1];
                                var xi = Math.min(Math.max(src[srcOffset + i], domain_2i), domain_2i_1);
                                var e = interpolate(xi, domain_2i, domain_2i_1, encode[i][0], encode[i][1]);
                                var size_i = size[i];
                                e = Math.min(Math.max(e, 0), size_i - 1);
                                var e0 = e < size_i - 1 ? Math.floor(e) : e - 1;
                                var n0 = e0 + 1 - e;
                                var n1 = e - e0;
                                var offset0 = e0 * k;
                                var offset1 = offset0 + k;
                                for (j = 0; j < cubeVertices; j++) {
                                    if (j & pos) {
                                        cubeN[j] *= n1;
                                        cubeVertex[j] += offset1;
                                    } else {
                                        cubeN[j] *= n0;
                                        cubeVertex[j] += offset0;
                                    }
                                }
                                k *= size_i;
                                pos <<= 1;
                            }
                            for (j = 0; j < n; ++j) {
                                var rj = 0;
                                for (i = 0; i < cubeVertices; i++) {
                                    rj += samples[cubeVertex[i] + j] * cubeN[i];
                                }
                                rj = interpolate(rj, 0, 1, decode[j][0], decode[j][1]);
                                dest[destOffset + j] = Math.min(Math.max(rj, range[j][0]), range[j][1]);
                            }
                        };
                    },
                    constructInterpolated: function PDFFunction_constructInterpolated(str, dict) {
                        var c0 = dict.get('C0') || [0];
                        var c1 = dict.get('C1') || [1];
                        var n = dict.get('N');
                        if (!isArray(c0) || !isArray(c1)) {
                            error('Illegal dictionary for interpolated function');
                        }
                        var length = c0.length;
                        var diff = [];
                        for (var i = 0; i < length; ++i) {
                            diff.push(c1[i] - c0[i]);
                        }
                        return [CONSTRUCT_INTERPOLATED, c0, diff, n];
                    },
                    constructInterpolatedFromIR: function PDFFunction_constructInterpolatedFromIR(IR) {
                        var c0 = IR[1];
                        var diff = IR[2];
                        var n = IR[3];
                        var length = diff.length;
                        return function constructInterpolatedFromIRResult(src, srcOffset, dest, destOffset) {
                            var x = n === 1 ? src[srcOffset] : Math.pow(src[srcOffset], n);
                            for (var j = 0; j < length; ++j) {
                                dest[destOffset + j] = c0[j] + (x * diff[j]);
                            }
                        };
                    },
                    constructStiched: function PDFFunction_constructStiched(fn, dict, xref) {
                        var domain = dict.get('Domain');
                        if (!domain) {
                            error('No domain');
                        }
                        var inputSize = domain.length / 2;
                        if (inputSize !== 1) {
                            error('Bad domain for stiched function');
                        }
                        var fnRefs = dict.get('Functions');
                        var fns = [];
                        for (var i = 0, ii = fnRefs.length; i < ii; ++i) {
                            fns.push(PDFFunction.getIR(xref, xref.fetchIfRef(fnRefs[i])));
                        }
                        var bounds = dict.get('Bounds');
                        var encode = dict.get('Encode');
                        return [CONSTRUCT_STICHED, domain, bounds, encode, fns];
                    },
                    constructStichedFromIR: function PDFFunction_constructStichedFromIR(IR) {
                        var domain = IR[1];
                        var bounds = IR[2];
                        var encode = IR[3];
                        var fnsIR = IR[4];
                        var fns = [];
                        var tmpBuf = new Float32Array(1);
                        for (var i = 0, ii = fnsIR.length; i < ii; i++) {
                            fns.push(PDFFunction.fromIR(fnsIR[i]));
                        }
                        return function constructStichedFromIRResult(src, srcOffset, dest, destOffset) {
                            var clip = function constructStichedFromIRClip(v, min, max) {
                                if (v > max) {
                                    v = max;
                                } else if (v < min) {
                                    v = min;
                                }
                                return v;
                            };
                            var v = clip(src[srcOffset], domain[0], domain[1]);
                            for (var i = 0, ii = bounds.length; i < ii; ++i) {
                                if (v < bounds[i]) {
                                    break;
                                }
                            }
                            var dmin = domain[0];
                            if (i > 0) {
                                dmin = bounds[i - 1];
                            }
                            var dmax = domain[1];
                            if (i < bounds.length) {
                                dmax = bounds[i];
                            }
                            var rmin = encode[2 * i];
                            var rmax = encode[2 * i + 1];
                            tmpBuf[0] = dmin === dmax ? rmin : rmin + (v - dmin) * (rmax - rmin) / (dmax - dmin);
                            fns[i](tmpBuf, 0, dest, destOffset);
                        };
                    },
                    constructPostScript: function PDFFunction_constructPostScript(fn, dict, xref) {
                        var domain = dict.get('Domain');
                        var range = dict.get('Range');
                        if (!domain) {
                            error('No domain.');
                        }
                        if (!range) {
                            error('No range.');
                        }
                        var lexer = new PostScriptLexer(fn);
                        var parser = new PostScriptParser(lexer);
                        var code = parser.parse();
                        return [CONSTRUCT_POSTSCRIPT, domain, range, code];
                    },
                    constructPostScriptFromIR: function PDFFunction_constructPostScriptFromIR(IR) {
                        var domain = IR[1];
                        var range = IR[2];
                        var code = IR[3];
                        var compiled = (new PostScriptCompiler()).compile(code, domain, range);
                        if (compiled) {
                            return new Function('src', 'srcOffset', 'dest', 'destOffset', compiled);
                        }
                        info('Unable to compile PS function');
                        var numOutputs = range.length >> 1;
                        var numInputs = domain.length >> 1;
                        var evaluator = new PostScriptEvaluator(code);
                        var cache = {};
                        var MAX_CACHE_SIZE = 2048 * 4;
                        var cache_available = MAX_CACHE_SIZE;
                        var tmpBuf = new Float32Array(numInputs);
                        return function constructPostScriptFromIRResult(src, srcOffset, dest, destOffset) {
                            var i, value;
                            var key = '';
                            var input = tmpBuf;
                            for (i = 0; i < numInputs; i++) {
                                value = src[srcOffset + i];
                                input[i] = value;
                                key += value + '_';
                            }
                            var cachedValue = cache[key];
                            if (cachedValue !== undefined) {
                                dest.set(cachedValue, destOffset);
                                return;
                            }
                            var output = new Float32Array(numOutputs);
                            var stack = evaluator.execute(input);
                            var stackIndex = stack.length - numOutputs;
                            for (i = 0; i < numOutputs; i++) {
                                value = stack[stackIndex + i];
                                var bound = range[i * 2];
                                if (value < bound) {
                                    value = bound;
                                } else {
                                    bound = range[i * 2 + 1];
                                    if (value > bound) {
                                        value = bound;
                                    }
                                }
                                output[i] = value;
                            }
                            if (cache_available > 0) {
                                cache_available--;
                                cache[key] = output;
                            }
                            dest.set(output, destOffset);
                        };
                    }
                };
            })();

            function isPDFFunction(v) {
                var fnDict;
                if (typeof v !== 'object') {
                    return false;
                } else if (isDict(v)) {
                    fnDict = v;
                } else if (isStream(v)) {
                    fnDict = v.dict;
                } else {
                    return false;
                }
                return fnDict.has('FunctionType');
            }
            var PostScriptStack = (function PostScriptStackClosure() {
                var MAX_STACK_SIZE = 100;

                function PostScriptStack(initialStack) {
                    this.stack = !initialStack ? [] : Array.prototype.slice.call(initialStack, 0);
                }
                PostScriptStack.prototype = {
                    push: function PostScriptStack_push(value) {
                        if (this.stack.length >= MAX_STACK_SIZE) {
                            error('PostScript function stack overflow.');
                        }
                        this.stack.push(value);
                    },
                    pop: function PostScriptStack_pop() {
                        if (this.stack.length <= 0) {
                            error('PostScript function stack underflow.');
                        }
                        return this.stack.pop();
                    },
                    copy: function PostScriptStack_copy(n) {
                        if (this.stack.length + n >= MAX_STACK_SIZE) {
                            error('PostScript function stack overflow.');
                        }
                        var stack = this.stack;
                        for (var i = stack.length - n, j = n - 1; j >= 0; j--, i++) {
                            stack.push(stack[i]);
                        }
                    },
                    index: function PostScriptStack_index(n) {
                        this.push(this.stack[this.stack.length - n - 1]);
                    },
                    roll: function PostScriptStack_roll(n, p) {
                        var stack = this.stack;
                        var l = stack.length - n;
                        var r = stack.length - 1,
                            c = l + (p - Math.floor(p / n) * n),
                            i, j, t;
                        for (i = l, j = r; i < j; i++, j--) {
                            t = stack[i];
                            stack[i] = stack[j];
                            stack[j] = t;
                        }
                        for (i = l, j = c - 1; i < j; i++, j--) {
                            t = stack[i];
                            stack[i] = stack[j];
                            stack[j] = t;
                        }
                        for (i = c, j = r; i < j; i++, j--) {
                            t = stack[i];
                            stack[i] = stack[j];
                            stack[j] = t;
                        }
                    }
                };
                return PostScriptStack;
            })();
            var PostScriptEvaluator = (function PostScriptEvaluatorClosure() {
                function PostScriptEvaluator(operators) {
                    this.operators = operators;
                }
                PostScriptEvaluator.prototype = {
                    execute: function PostScriptEvaluator_execute(initialStack) {
                        var stack = new PostScriptStack(initialStack);
                        var counter = 0;
                        var operators = this.operators;
                        var length = operators.length;
                        var operator, a, b;
                        while (counter < length) {
                            operator = operators[counter++];
                            if (typeof operator === 'number') {
                                stack.push(operator);
                                continue;
                            }
                            switch (operator) {
                                case 'jz':
                                    b = stack.pop();
                                    a = stack.pop();
                                    if (!a) {
                                        counter = b;
                                    }
                                    break;
                                case 'j':
                                    a = stack.pop();
                                    counter = a;
                                    break;
                                case 'abs':
                                    a = stack.pop();
                                    stack.push(Math.abs(a));
                                    break;
                                case 'add':
                                    b = stack.pop();
                                    a = stack.pop();
                                    stack.push(a + b);
                                    break;
                                case 'and':
                                    b = stack.pop();
                                    a = stack.pop();
                                    if (isBool(a) && isBool(b)) {
                                        stack.push(a && b);
                                    } else {
                                        stack.push(a & b);
                                    }
                                    break;
                                case 'atan':
                                    a = stack.pop();
                                    stack.push(Math.atan(a));
                                    break;
                                case 'bitshift':
                                    b = stack.pop();
                                    a = stack.pop();
                                    if (a > 0) {
                                        stack.push(a << b);
                                    } else {
                                        stack.push(a >> b);
                                    }
                                    break;
                                case 'ceiling':
                                    a = stack.pop();
                                    stack.push(Math.ceil(a));
                                    break;
                                case 'copy':
                                    a = stack.pop();
                                    stack.copy(a);
                                    break;
                                case 'cos':
                                    a = stack.pop();
                                    stack.push(Math.cos(a));
                                    break;
                                case 'cvi':
                                    a = stack.pop() | 0;
                                    stack.push(a);
                                    break;
                                case 'cvr':
                                    break;
                                case 'div':
                                    b = stack.pop();
                                    a = stack.pop();
                                    stack.push(a / b);
                                    break;
                                case 'dup':
                                    stack.copy(1);
                                    break;
                                case 'eq':
                                    b = stack.pop();
                                    a = stack.pop();
                                    stack.push(a === b);
                                    break;
                                case 'exch':
                                    stack.roll(2, 1);
                                    break;
                                case 'exp':
                                    b = stack.pop();
                                    a = stack.pop();
                                    stack.push(Math.pow(a, b));
                                    break;
                                case 'false':
                                    stack.push(false);
                                    break;
                                case 'floor':
                                    a = stack.pop();
                                    stack.push(Math.floor(a));
                                    break;
                                case 'ge':
                                    b = stack.pop();
                                    a = stack.pop();
                                    stack.push(a >= b);
                                    break;
                                case 'gt':
                                    b = stack.pop();
                                    a = stack.pop();
                                    stack.push(a > b);
                                    break;
                                case 'idiv':
                                    b = stack.pop();
                                    a = stack.pop();
                                    stack.push((a / b) | 0);
                                    break;
                                case 'index':
                                    a = stack.pop();
                                    stack.index(a);
                                    break;
                                case 'le':
                                    b = stack.pop();
                                    a = stack.pop();
                                    stack.push(a <= b);
                                    break;
                                case 'ln':
                                    a = stack.pop();
                                    stack.push(Math.log(a));
                                    break;
                                case 'log':
                                    a = stack.pop();
                                    stack.push(Math.log(a) / Math.LN10);
                                    break;
                                case 'lt':
                                    b = stack.pop();
                                    a = stack.pop();
                                    stack.push(a < b);
                                    break;
                                case 'mod':
                                    b = stack.pop();
                                    a = stack.pop();
                                    stack.push(a % b);
                                    break;
                                case 'mul':
                                    b = stack.pop();
                                    a = stack.pop();
                                    stack.push(a * b);
                                    break;
                                case 'ne':
                                    b = stack.pop();
                                    a = stack.pop();
                                    stack.push(a !== b);
                                    break;
                                case 'neg':
                                    a = stack.pop();
                                    stack.push(-a);
                                    break;
                                case 'not':
                                    a = stack.pop();
                                    if (isBool(a)) {
                                        stack.push(!a);
                                    } else {
                                        stack.push(~a);
                                    }
                                    break;
                                case 'or':
                                    b = stack.pop();
                                    a = stack.pop();
                                    if (isBool(a) && isBool(b)) {
                                        stack.push(a || b);
                                    } else {
                                        stack.push(a | b);
                                    }
                                    break;
                                case 'pop':
                                    stack.pop();
                                    break;
                                case 'roll':
                                    b = stack.pop();
                                    a = stack.pop();
                                    stack.roll(a, b);
                                    break;
                                case 'round':
                                    a = stack.pop();
                                    stack.push(Math.round(a));
                                    break;
                                case 'sin':
                                    a = stack.pop();
                                    stack.push(Math.sin(a));
                                    break;
                                case 'sqrt':
                                    a = stack.pop();
                                    stack.push(Math.sqrt(a));
                                    break;
                                case 'sub':
                                    b = stack.pop();
                                    a = stack.pop();
                                    stack.push(a - b);
                                    break;
                                case 'true':
                                    stack.push(true);
                                    break;
                                case 'truncate':
                                    a = stack.pop();
                                    a = a < 0 ? Math.ceil(a) : Math.floor(a);
                                    stack.push(a);
                                    break;
                                case 'xor':
                                    b = stack.pop();
                                    a = stack.pop();
                                    if (isBool(a) && isBool(b)) {
                                        stack.push(a !== b);
                                    } else {
                                        stack.push(a ^ b);
                                    }
                                    break;
                                default:
                                    error('Unknown operator ' + operator);
                                    break;
                            }
                        }
                        return stack.stack;
                    }
                };
                return PostScriptEvaluator;
            })();
            var PostScriptCompiler = (function PostScriptCompilerClosure() {
                function AstNode(type) {
                    this.type = type;
                }
                AstNode.prototype.visit = function(visitor) {
                    throw new Error('abstract method');
                };

                function AstArgument(index, min, max) {
                    AstNode.call(this, 'args');
                    this.index = index;
                    this.min = min;
                    this.max = max;
                }
                AstArgument.prototype = Object.create(AstNode.prototype);
                AstArgument.prototype.visit = function(visitor) {
                    visitor.visitArgument(this);
                };

                function AstLiteral(number) {
                    AstNode.call(this, 'literal');
                    this.number = number;
                    this.min = number;
                    this.max = number;
                }
                AstLiteral.prototype = Object.create(AstNode.prototype);
                AstLiteral.prototype.visit = function(visitor) {
                    visitor.visitLiteral(this);
                };

                function AstBinaryOperation(op, arg1, arg2, min, max) {
                    AstNode.call(this, 'binary');
                    this.op = op;
                    this.arg1 = arg1;
                    this.arg2 = arg2;
                    this.min = min;
                    this.max = max;
                }
                AstBinaryOperation.prototype = Object.create(AstNode.prototype);
                AstBinaryOperation.prototype.visit = function(visitor) {
                    visitor.visitBinaryOperation(this);
                };

                function AstMin(arg, max) {
                    AstNode.call(this, 'max');
                    this.arg = arg;
                    this.min = arg.min;
                    this.max = max;
                }
                AstMin.prototype = Object.create(AstNode.prototype);
                AstMin.prototype.visit = function(visitor) {
                    visitor.visitMin(this);
                };

                function AstVariable(index, min, max) {
                    AstNode.call(this, 'var');
                    this.index = index;
                    this.min = min;
                    this.max = max;
                }
                AstVariable.prototype = Object.create(AstNode.prototype);
                AstVariable.prototype.visit = function(visitor) {
                    visitor.visitVariable(this);
                };

                function AstVariableDefinition(variable, arg) {
                    AstNode.call(this, 'definition');
                    this.variable = variable;
                    this.arg = arg;
                }
                AstVariableDefinition.prototype = Object.create(AstNode.prototype);
                AstVariableDefinition.prototype.visit = function(visitor) {
                    visitor.visitVariableDefinition(this);
                };

                function ExpressionBuilderVisitor() {
                    this.parts = [];
                }
                ExpressionBuilderVisitor.prototype = {
                    visitArgument: function(arg) {
                        this.parts.push('Math.max(', arg.min, ', Math.min(', arg.max, ', src[srcOffset + ', arg.index, ']))');
                    },
                    visitVariable: function(variable) {
                        this.parts.push('v', variable.index);
                    },
                    visitLiteral: function(literal) {
                        this.parts.push(literal.number);
                    },
                    visitBinaryOperation: function(operation) {
                        this.parts.push('(');
                        operation.arg1.visit(this);
                        this.parts.push(' ', operation.op, ' ');
                        operation.arg2.visit(this);
                        this.parts.push(')');
                    },
                    visitVariableDefinition: function(definition) {
                        this.parts.push('var ');
                        definition.variable.visit(this);
                        this.parts.push(' = ');
                        definition.arg.visit(this);
                        this.parts.push(';');
                    },
                    visitMin: function(max) {
                        this.parts.push('Math.min(');
                        max.arg.visit(this);
                        this.parts.push(', ', max.max, ')');
                    },
                    toString: function() {
                        return this.parts.join('');
                    }
                };

                function buildAddOperation(num1, num2) {
                    if (num2.type === 'literal' && num2.number === 0) {
                        return num1;
                    }
                    if (num1.type === 'literal' && num1.number === 0) {
                        return num2;
                    }
                    if (num2.type === 'literal' && num1.type === 'literal') {
                        return new AstLiteral(num1.number + num2.number);
                    }
                    return new AstBinaryOperation('+', num1, num2, num1.min + num2.min, num1.max + num2.max);
                }

                function buildMulOperation(num1, num2) {
                    if (num2.type === 'literal') {
                        if (num2.number === 0) {
                            return new AstLiteral(0);
                        } else if (num2.number === 1) {
                            return num1;
                        } else if (num1.type === 'literal') {
                            return new AstLiteral(num1.number * num2.number);
                        }
                    }
                    if (num1.type === 'literal') {
                        if (num1.number === 0) {
                            return new AstLiteral(0);
                        } else if (num1.number === 1) {
                            return num2;
                        }
                    }
                    var min = Math.min(num1.min * num2.min, num1.min * num2.max, num1.max * num2.min, num1.max * num2.max);
                    var max = Math.max(num1.min * num2.min, num1.min * num2.max, num1.max * num2.min, num1.max * num2.max);
                    return new AstBinaryOperation('*', num1, num2, min, max);
                }

                function buildSubOperation(num1, num2) {
                    if (num2.type === 'literal') {
                        if (num2.number === 0) {
                            return num1;
                        } else if (num1.type === 'literal') {
                            return new AstLiteral(num1.number - num2.number);
                        }
                    }
                    if (num2.type === 'binary' && num2.op === '-' && num1.type === 'literal' && num1.number === 1 && num2.arg1.type === 'literal' && num2.arg1.number === 1) {
                        return num2.arg2;
                    }
                    return new AstBinaryOperation('-', num1, num2, num1.min - num2.max, num1.max - num2.min);
                }

                function buildMinOperation(num1, max) {
                    if (num1.min >= max) {
                        return new AstLiteral(max);
                    } else if (num1.max <= max) {
                        return num1;
                    }
                    return new AstMin(num1, max);
                }

                function PostScriptCompiler() {}
                PostScriptCompiler.prototype = {
                    compile: function PostScriptCompiler_compile(code, domain, range) {
                        var stack = [];
                        var i, ii;
                        var instructions = [];
                        var inputSize = domain.length >> 1,
                            outputSize = range.length >> 1;
                        var lastRegister = 0;
                        var n, j;
                        var num1, num2, ast1, ast2, tmpVar, item;
                        for (i = 0; i < inputSize; i++) {
                            stack.push(new AstArgument(i, domain[i * 2], domain[i * 2 + 1]));
                        }
                        for (i = 0, ii = code.length; i < ii; i++) {
                            item = code[i];
                            if (typeof item === 'number') {
                                stack.push(new AstLiteral(item));
                                continue;
                            }
                            switch (item) {
                                case 'add':
                                    if (stack.length < 2) {
                                        return null;
                                    }
                                    num2 = stack.pop();
                                    num1 = stack.pop();
                                    stack.push(buildAddOperation(num1, num2));
                                    break;
                                case 'cvr':
                                    if (stack.length < 1) {
                                        return null;
                                    }
                                    break;
                                case 'mul':
                                    if (stack.length < 2) {
                                        return null;
                                    }
                                    num2 = stack.pop();
                                    num1 = stack.pop();
                                    stack.push(buildMulOperation(num1, num2));
                                    break;
                                case 'sub':
                                    if (stack.length < 2) {
                                        return null;
                                    }
                                    num2 = stack.pop();
                                    num1 = stack.pop();
                                    stack.push(buildSubOperation(num1, num2));
                                    break;
                                case 'exch':
                                    if (stack.length < 2) {
                                        return null;
                                    }
                                    ast1 = stack.pop();
                                    ast2 = stack.pop();
                                    stack.push(ast1, ast2);
                                    break;
                                case 'pop':
                                    if (stack.length < 1) {
                                        return null;
                                    }
                                    stack.pop();
                                    break;
                                case 'index':
                                    if (stack.length < 1) {
                                        return null;
                                    }
                                    num1 = stack.pop();
                                    if (num1.type !== 'literal') {
                                        return null;
                                    }
                                    n = num1.number;
                                    if (n < 0 || (n | 0) !== n || stack.length < n) {
                                        return null;
                                    }
                                    ast1 = stack[stack.length - n - 1];
                                    if (ast1.type === 'literal' || ast1.type === 'var') {
                                        stack.push(ast1);
                                        break;
                                    }
                                    tmpVar = new AstVariable(lastRegister++, ast1.min, ast1.max);
                                    stack[stack.length - n - 1] = tmpVar;
                                    stack.push(tmpVar);
                                    instructions.push(new AstVariableDefinition(tmpVar, ast1));
                                    break;
                                case 'dup':
                                    if (stack.length < 1) {
                                        return null;
                                    }
                                    if (typeof code[i + 1] === 'number' && code[i + 2] === 'gt' && code[i + 3] === i + 7 && code[i + 4] === 'jz' && code[i + 5] === 'pop' && code[i + 6] === code[i + 1]) {
                                        num1 = stack.pop();
                                        stack.push(buildMinOperation(num1, code[i + 1]));
                                        i += 6;
                                        break;
                                    }
                                    ast1 = stack[stack.length - 1];
                                    if (ast1.type === 'literal' || ast1.type === 'var') {
                                        stack.push(ast1);
                                        break;
                                    }
                                    tmpVar = new AstVariable(lastRegister++, ast1.min, ast1.max);
                                    stack[stack.length - 1] = tmpVar;
                                    stack.push(tmpVar);
                                    instructions.push(new AstVariableDefinition(tmpVar, ast1));
                                    break;
                                case 'roll':
                                    if (stack.length < 2) {
                                        return null;
                                    }
                                    num2 = stack.pop();
                                    num1 = stack.pop();
                                    if (num2.type !== 'literal' || num1.type !== 'literal') {
                                        return null;
                                    }
                                    j = num2.number;
                                    n = num1.number;
                                    if (n <= 0 || (n | 0) !== n || (j | 0) !== j || stack.length < n) {
                                        return null;
                                    }
                                    j = ((j % n) + n) % n;
                                    if (j === 0) {
                                        break;
                                    }
                                    Array.prototype.push.apply(stack, stack.splice(stack.length - n, n - j));
                                    break;
                                default:
                                    return null;
                            }
                        }
                        if (stack.length !== outputSize) {
                            return null;
                        }
                        var result = [];
                        instructions.forEach(function(instruction) {
                            var statementBuilder = new ExpressionBuilderVisitor();
                            instruction.visit(statementBuilder);
                            result.push(statementBuilder.toString());
                        });
                        stack.forEach(function(expr, i) {
                            var statementBuilder = new ExpressionBuilderVisitor();
                            expr.visit(statementBuilder);
                            var min = range[i * 2],
                                max = range[i * 2 + 1];
                            var out = [statementBuilder.toString()];
                            if (min > expr.min) {
                                out.unshift('Math.max(', min, ', ');
                                out.push(')');
                            }
                            if (max < expr.max) {
                                out.unshift('Math.min(', max, ', ');
                                out.push(')');
                            }
                            out.unshift('dest[destOffset + ', i, '] = ');
                            out.push(';');
                            result.push(out.join(''));
                        });
                        return result.join('\n');
                    }
                };
                return PostScriptCompiler;
            })();
            exports.isPDFFunction = isPDFFunction;
            exports.PDFFunction = PDFFunction;
            exports.PostScriptEvaluator = PostScriptEvaluator;
            exports.PostScriptCompiler = PostScriptCompiler;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsCoreColorSpace = {}), root.pdfjsSharedUtil, root.pdfjsCorePrimitives, root.pdfjsCoreFunction, root.pdfjsCoreStream);
            }
        }(this, function(exports, sharedUtil, corePrimitives, coreFunction, coreStream) {
            var error = sharedUtil.error;
            var info = sharedUtil.info;
            var isArray = sharedUtil.isArray;
            var isString = sharedUtil.isString;
            var shadow = sharedUtil.shadow;
            var warn = sharedUtil.warn;
            var isDict = corePrimitives.isDict;
            var isName = corePrimitives.isName;
            var isStream = corePrimitives.isStream;
            var PDFFunction = coreFunction.PDFFunction;
            var coreImage;
            var PDFImage;
            var ColorSpace = (function ColorSpaceClosure() {
                function ColorSpace() {
                    error('should not call ColorSpace constructor');
                }
                ColorSpace.prototype = {
                    getRgb: function ColorSpace_getRgb(src, srcOffset) {
                        var rgb = new Uint8Array(3);
                        this.getRgbItem(src, srcOffset, rgb, 0);
                        return rgb;
                    },
                    getRgbItem: function ColorSpace_getRgbItem(src, srcOffset, dest, destOffset) {
                        error('Should not call ColorSpace.getRgbItem');
                    },
                    getRgbBuffer: function ColorSpace_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                        error('Should not call ColorSpace.getRgbBuffer');
                    },
                    getOutputLength: function ColorSpace_getOutputLength(inputLength, alpha01) {
                        error('Should not call ColorSpace.getOutputLength');
                    },
                    isPassthrough: function ColorSpace_isPassthrough(bits) {
                        return false;
                    },
                    fillRgb: function ColorSpace_fillRgb(dest, originalWidth, originalHeight, width, height, actualHeight, bpc, comps, alpha01) {
                        var count = originalWidth * originalHeight;
                        var rgbBuf = null;
                        var numComponentColors = 1 << bpc;
                        var needsResizing = originalHeight !== height || originalWidth !== width;
                        var i, ii;
                        if (this.isPassthrough(bpc)) {
                            rgbBuf = comps;
                        } else if (this.numComps === 1 && count > numComponentColors && this.name !== 'DeviceGray' && this.name !== 'DeviceRGB') {
                            var allColors = bpc <= 8 ? new Uint8Array(numComponentColors) : new Uint16Array(numComponentColors);
                            var key;
                            for (i = 0; i < numComponentColors; i++) {
                                allColors[i] = i;
                            }
                            var colorMap = new Uint8Array(numComponentColors * 3);
                            this.getRgbBuffer(allColors, 0, numComponentColors, colorMap, 0, bpc, 0);
                            var destPos, rgbPos;
                            if (!needsResizing) {
                                destPos = 0;
                                for (i = 0; i < count; ++i) {
                                    key = comps[i] * 3;
                                    dest[destPos++] = colorMap[key];
                                    dest[destPos++] = colorMap[key + 1];
                                    dest[destPos++] = colorMap[key + 2];
                                    destPos += alpha01;
                                }
                            } else {
                                rgbBuf = new Uint8Array(count * 3);
                                rgbPos = 0;
                                for (i = 0; i < count; ++i) {
                                    key = comps[i] * 3;
                                    rgbBuf[rgbPos++] = colorMap[key];
                                    rgbBuf[rgbPos++] = colorMap[key + 1];
                                    rgbBuf[rgbPos++] = colorMap[key + 2];
                                }
                            }
                        } else {
                            if (!needsResizing) {
                                this.getRgbBuffer(comps, 0, width * actualHeight, dest, 0, bpc, alpha01);
                            } else {
                                rgbBuf = new Uint8Array(count * 3);
                                this.getRgbBuffer(comps, 0, count, rgbBuf, 0, bpc, 0);
                            }
                        }
                        if (rgbBuf) {
                            if (needsResizing) {
                                PDFImage.resize(rgbBuf, bpc, 3, originalWidth, originalHeight, width, height, dest, alpha01);
                            } else {
                                rgbPos = 0;
                                destPos = 0;
                                for (i = 0, ii = width * actualHeight; i < ii; i++) {
                                    dest[destPos++] = rgbBuf[rgbPos++];
                                    dest[destPos++] = rgbBuf[rgbPos++];
                                    dest[destPos++] = rgbBuf[rgbPos++];
                                    destPos += alpha01;
                                }
                            }
                        }
                    },
                    usesZeroToOneRange: true
                };
                ColorSpace.parse = function ColorSpace_parse(cs, xref, res) {
                    var IR = ColorSpace.parseToIR(cs, xref, res);
                    if (IR instanceof AlternateCS) {
                        return IR;
                    }
                    return ColorSpace.fromIR(IR);
                };
                ColorSpace.fromIR = function ColorSpace_fromIR(IR) {
                    var name = isArray(IR) ? IR[0] : IR;
                    var whitePoint, blackPoint, gamma;
                    switch (name) {
                        case 'DeviceGrayCS':
                            return this.singletons.gray;
                        case 'DeviceRgbCS':
                            return this.singletons.rgb;
                        case 'DeviceCmykCS':
                            return this.singletons.cmyk;
                        case 'CalGrayCS':
                            whitePoint = IR[1].WhitePoint;
                            blackPoint = IR[1].BlackPoint;
                            gamma = IR[1].Gamma;
                            return new CalGrayCS(whitePoint, blackPoint, gamma);
                        case 'CalRGBCS':
                            whitePoint = IR[1].WhitePoint;
                            blackPoint = IR[1].BlackPoint;
                            gamma = IR[1].Gamma;
                            var matrix = IR[1].Matrix;
                            return new CalRGBCS(whitePoint, blackPoint, gamma, matrix);
                        case 'PatternCS':
                            var basePatternCS = IR[1];
                            if (basePatternCS) {
                                basePatternCS = ColorSpace.fromIR(basePatternCS);
                            }
                            return new PatternCS(basePatternCS);
                        case 'IndexedCS':
                            var baseIndexedCS = IR[1];
                            var hiVal = IR[2];
                            var lookup = IR[3];
                            return new IndexedCS(ColorSpace.fromIR(baseIndexedCS), hiVal, lookup);
                        case 'AlternateCS':
                            var numComps = IR[1];
                            var alt = IR[2];
                            var tintFnIR = IR[3];
                            return new AlternateCS(numComps, ColorSpace.fromIR(alt), PDFFunction.fromIR(tintFnIR));
                        case 'LabCS':
                            whitePoint = IR[1].WhitePoint;
                            blackPoint = IR[1].BlackPoint;
                            var range = IR[1].Range;
                            return new LabCS(whitePoint, blackPoint, range);
                        default:
                            error('Unknown name ' + name);
                    }
                    return null;
                };
                ColorSpace.parseToIR = function ColorSpace_parseToIR(cs, xref, res) {
                    if (isName(cs)) {
                        var colorSpaces = res.get('ColorSpace');
                        if (isDict(colorSpaces)) {
                            var refcs = colorSpaces.get(cs.name);
                            if (refcs) {
                                cs = refcs;
                            }
                        }
                    }
                    cs = xref.fetchIfRef(cs);
                    var mode;
                    if (isName(cs)) {
                        mode = cs.name;
                        this.mode = mode;
                        switch (mode) {
                            case 'DeviceGray':
                            case 'G':
                                return 'DeviceGrayCS';
                            case 'DeviceRGB':
                            case 'RGB':
                                return 'DeviceRgbCS';
                            case 'DeviceCMYK':
                            case 'CMYK':
                                return 'DeviceCmykCS';
                            case 'Pattern':
                                return ['PatternCS', null];
                            default:
                                error('unrecognized colorspace ' + mode);
                        }
                    } else if (isArray(cs)) {
                        mode = xref.fetchIfRef(cs[0]).name;
                        this.mode = mode;
                        var numComps, params, alt;
                        switch (mode) {
                            case 'DeviceGray':
                            case 'G':
                                return 'DeviceGrayCS';
                            case 'DeviceRGB':
                            case 'RGB':
                                return 'DeviceRgbCS';
                            case 'DeviceCMYK':
                            case 'CMYK':
                                return 'DeviceCmykCS';
                            case 'CalGray':
                                params = xref.fetchIfRef(cs[1]).getAll();
                                return ['CalGrayCS', params];
                            case 'CalRGB':
                                params = xref.fetchIfRef(cs[1]).getAll();
                                return ['CalRGBCS', params];
                            case 'ICCBased':
                                var stream = xref.fetchIfRef(cs[1]);
                                var dict = stream.dict;
                                numComps = dict.get('N');
                                alt = dict.get('Alternate');
                                if (alt) {
                                    var altIR = ColorSpace.parseToIR(alt, xref, res);
                                    var altCS = ColorSpace.fromIR(altIR);
                                    if (altCS.numComps === numComps) {
                                        return altIR;
                                    }
                                    warn('ICCBased color space: Ignoring incorrect /Alternate entry.');
                                }
                                if (numComps === 1) {
                                    return 'DeviceGrayCS';
                                } else if (numComps === 3) {
                                    return 'DeviceRgbCS';
                                } else if (numComps === 4) {
                                    return 'DeviceCmykCS';
                                }
                                break;
                            case 'Pattern':
                                var basePatternCS = cs[1] || null;
                                if (basePatternCS) {
                                    basePatternCS = ColorSpace.parseToIR(basePatternCS, xref, res);
                                }
                                return ['PatternCS', basePatternCS];
                            case 'Indexed':
                            case 'I':
                                var baseIndexedCS = ColorSpace.parseToIR(cs[1], xref, res);
                                var hiVal = xref.fetchIfRef(cs[2]) + 1;
                                var lookup = xref.fetchIfRef(cs[3]);
                                if (isStream(lookup)) {
                                    lookup = lookup.getBytes();
                                }
                                return ['IndexedCS', baseIndexedCS, hiVal, lookup];
                            case 'Separation':
                            case 'DeviceN':
                                var name = xref.fetchIfRef(cs[1]);
                                numComps = 1;
                                if (isName(name)) {
                                    numComps = 1;
                                } else if (isArray(name)) {
                                    numComps = name.length;
                                }
                                alt = ColorSpace.parseToIR(cs[2], xref, res);
                                var tintFnIR = PDFFunction.getIR(xref, xref.fetchIfRef(cs[3]));
                                return ['AlternateCS', numComps, alt, tintFnIR];
                            case 'Lab':
                                params = xref.fetchIfRef(cs[1]).getAll();
                                return ['LabCS', params];
                            default:
                                error('unimplemented color space object "' + mode + '"');
                        }
                    } else {
                        error('unrecognized color space object: "' + cs + '"');
                    }
                    return null;
                };
                ColorSpace.isDefaultDecode = function ColorSpace_isDefaultDecode(decode, n) {
                    if (!isArray(decode)) {
                        return true;
                    }
                    if (n * 2 !== decode.length) {
                        warn('The decode map is not the correct length');
                        return true;
                    }
                    for (var i = 0, ii = decode.length; i < ii; i += 2) {
                        if (decode[i] !== 0 || decode[i + 1] !== 1) {
                            return false;
                        }
                    }
                    return true;
                };
                ColorSpace.singletons = {
                    get gray() {
                        return shadow(this, 'gray', new DeviceGrayCS());
                    },
                    get rgb() {
                        return shadow(this, 'rgb', new DeviceRgbCS());
                    },
                    get cmyk() {
                        return shadow(this, 'cmyk', new DeviceCmykCS());
                    }
                };
                return ColorSpace;
            })();
            var AlternateCS = (function AlternateCSClosure() {
                function AlternateCS(numComps, base, tintFn) {
                    this.name = 'Alternate';
                    this.numComps = numComps;
                    this.defaultColor = new Float32Array(numComps);
                    for (var i = 0; i < numComps; ++i) {
                        this.defaultColor[i] = 1;
                    }
                    this.base = base;
                    this.tintFn = tintFn;
                    this.tmpBuf = new Float32Array(base.numComps);
                }
                AlternateCS.prototype = {
                    getRgb: ColorSpace.prototype.getRgb,
                    getRgbItem: function AlternateCS_getRgbItem(src, srcOffset, dest, destOffset) {
                        var tmpBuf = this.tmpBuf;
                        this.tintFn(src, srcOffset, tmpBuf, 0);
                        this.base.getRgbItem(tmpBuf, 0, dest, destOffset);
                    },
                    getRgbBuffer: function AlternateCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                        var tintFn = this.tintFn;
                        var base = this.base;
                        var scale = 1 / ((1 << bits) - 1);
                        var baseNumComps = base.numComps;
                        var usesZeroToOneRange = base.usesZeroToOneRange;
                        var isPassthrough = (base.isPassthrough(8) || !usesZeroToOneRange) && alpha01 === 0;
                        var pos = isPassthrough ? destOffset : 0;
                        var baseBuf = isPassthrough ? dest : new Uint8Array(baseNumComps * count);
                        var numComps = this.numComps;
                        var scaled = new Float32Array(numComps);
                        var tinted = new Float32Array(baseNumComps);
                        var i, j;
                        if (usesZeroToOneRange) {
                            for (i = 0; i < count; i++) {
                                for (j = 0; j < numComps; j++) {
                                    scaled[j] = src[srcOffset++] * scale;
                                }
                                tintFn(scaled, 0, tinted, 0);
                                for (j = 0; j < baseNumComps; j++) {
                                    baseBuf[pos++] = tinted[j] * 255;
                                }
                            }
                        } else {
                            for (i = 0; i < count; i++) {
                                for (j = 0; j < numComps; j++) {
                                    scaled[j] = src[srcOffset++] * scale;
                                }
                                tintFn(scaled, 0, tinted, 0);
                                base.getRgbItem(tinted, 0, baseBuf, pos);
                                pos += baseNumComps;
                            }
                        }
                        if (!isPassthrough) {
                            base.getRgbBuffer(baseBuf, 0, count, dest, destOffset, 8, alpha01);
                        }
                    },
                    getOutputLength: function AlternateCS_getOutputLength(inputLength, alpha01) {
                        return this.base.getOutputLength(inputLength * this.base.numComps / this.numComps, alpha01);
                    },
                    isPassthrough: ColorSpace.prototype.isPassthrough,
                    fillRgb: ColorSpace.prototype.fillRgb,
                    isDefaultDecode: function AlternateCS_isDefaultDecode(decodeMap) {
                        return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
                    },
                    usesZeroToOneRange: true
                };
                return AlternateCS;
            })();
            var PatternCS = (function PatternCSClosure() {
                function PatternCS(baseCS) {
                    this.name = 'Pattern';
                    this.base = baseCS;
                }
                PatternCS.prototype = {};
                return PatternCS;
            })();
            var IndexedCS = (function IndexedCSClosure() {
                function IndexedCS(base, highVal, lookup) {
                    this.name = 'Indexed';
                    this.numComps = 1;
                    this.defaultColor = new Uint8Array([0]);
                    this.base = base;
                    this.highVal = highVal;
                    var baseNumComps = base.numComps;
                    var length = baseNumComps * highVal;
                    var lookupArray;
                    if (isStream(lookup)) {
                        lookupArray = new Uint8Array(length);
                        var bytes = lookup.getBytes(length);
                        lookupArray.set(bytes);
                    } else if (isString(lookup)) {
                        lookupArray = new Uint8Array(length);
                        for (var i = 0; i < length; ++i) {
                            lookupArray[i] = lookup.charCodeAt(i);
                        }
                    } else if (lookup instanceof Uint8Array || lookup instanceof Array) {
                        lookupArray = lookup;
                    } else {
                        error('Unrecognized lookup table: ' + lookup);
                    }
                    this.lookup = lookupArray;
                }
                IndexedCS.prototype = {
                    getRgb: ColorSpace.prototype.getRgb,
                    getRgbItem: function IndexedCS_getRgbItem(src, srcOffset, dest, destOffset) {
                        var numComps = this.base.numComps;
                        var start = src[srcOffset] * numComps;
                        this.base.getRgbItem(this.lookup, start, dest, destOffset);
                    },
                    getRgbBuffer: function IndexedCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                        var base = this.base;
                        var numComps = base.numComps;
                        var outputDelta = base.getOutputLength(numComps, alpha01);
                        var lookup = this.lookup;
                        for (var i = 0; i < count; ++i) {
                            var lookupPos = src[srcOffset++] * numComps;
                            base.getRgbBuffer(lookup, lookupPos, 1, dest, destOffset, 8, alpha01);
                            destOffset += outputDelta;
                        }
                    },
                    getOutputLength: function IndexedCS_getOutputLength(inputLength, alpha01) {
                        return this.base.getOutputLength(inputLength * this.base.numComps, alpha01);
                    },
                    isPassthrough: ColorSpace.prototype.isPassthrough,
                    fillRgb: ColorSpace.prototype.fillRgb,
                    isDefaultDecode: function IndexedCS_isDefaultDecode(decodeMap) {
                        return true;
                    },
                    usesZeroToOneRange: true
                };
                return IndexedCS;
            })();
            var DeviceGrayCS = (function DeviceGrayCSClosure() {
                function DeviceGrayCS() {
                    this.name = 'DeviceGray';
                    this.numComps = 1;
                    this.defaultColor = new Float32Array([0]);
                }
                DeviceGrayCS.prototype = {
                    getRgb: ColorSpace.prototype.getRgb,
                    getRgbItem: function DeviceGrayCS_getRgbItem(src, srcOffset, dest, destOffset) {
                        var c = (src[srcOffset] * 255) | 0;
                        c = c < 0 ? 0 : c > 255 ? 255 : c;
                        dest[destOffset] = dest[destOffset + 1] = dest[destOffset + 2] = c;
                    },
                    getRgbBuffer: function DeviceGrayCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                        var scale = 255 / ((1 << bits) - 1);
                        var j = srcOffset,
                            q = destOffset;
                        for (var i = 0; i < count; ++i) {
                            var c = (scale * src[j++]) | 0;
                            dest[q++] = c;
                            dest[q++] = c;
                            dest[q++] = c;
                            q += alpha01;
                        }
                    },
                    getOutputLength: function DeviceGrayCS_getOutputLength(inputLength, alpha01) {
                        return inputLength * (3 + alpha01);
                    },
                    isPassthrough: ColorSpace.prototype.isPassthrough,
                    fillRgb: ColorSpace.prototype.fillRgb,
                    isDefaultDecode: function DeviceGrayCS_isDefaultDecode(decodeMap) {
                        return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
                    },
                    usesZeroToOneRange: true
                };
                return DeviceGrayCS;
            })();
            var DeviceRgbCS = (function DeviceRgbCSClosure() {
                function DeviceRgbCS() {
                    this.name = 'DeviceRGB';
                    this.numComps = 3;
                    this.defaultColor = new Float32Array([0, 0, 0]);
                }
                DeviceRgbCS.prototype = {
                    getRgb: ColorSpace.prototype.getRgb,
                    getRgbItem: function DeviceRgbCS_getRgbItem(src, srcOffset, dest, destOffset) {
                        var r = (src[srcOffset] * 255) | 0;
                        var g = (src[srcOffset + 1] * 255) | 0;
                        var b = (src[srcOffset + 2] * 255) | 0;
                        dest[destOffset] = r < 0 ? 0 : r > 255 ? 255 : r;
                        dest[destOffset + 1] = g < 0 ? 0 : g > 255 ? 255 : g;
                        dest[destOffset + 2] = b < 0 ? 0 : b > 255 ? 255 : b;
                    },
                    getRgbBuffer: function DeviceRgbCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                        if (bits === 8 && alpha01 === 0) {
                            dest.set(src.subarray(srcOffset, srcOffset + count * 3), destOffset);
                            return;
                        }
                        var scale = 255 / ((1 << bits) - 1);
                        var j = srcOffset,
                            q = destOffset;
                        for (var i = 0; i < count; ++i) {
                            dest[q++] = (scale * src[j++]) | 0;
                            dest[q++] = (scale * src[j++]) | 0;
                            dest[q++] = (scale * src[j++]) | 0;
                            q += alpha01;
                        }
                    },
                    getOutputLength: function DeviceRgbCS_getOutputLength(inputLength, alpha01) {
                        return (inputLength * (3 + alpha01) / 3) | 0;
                    },
                    isPassthrough: function DeviceRgbCS_isPassthrough(bits) {
                        return bits === 8;
                    },
                    fillRgb: ColorSpace.prototype.fillRgb,
                    isDefaultDecode: function DeviceRgbCS_isDefaultDecode(decodeMap) {
                        return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
                    },
                    usesZeroToOneRange: true
                };
                return DeviceRgbCS;
            })();
            var DeviceCmykCS = (function DeviceCmykCSClosure() {
                function convertToRgb(src, srcOffset, srcScale, dest, destOffset) {
                    var c = src[srcOffset + 0] * srcScale;
                    var m = src[srcOffset + 1] * srcScale;
                    var y = src[srcOffset + 2] * srcScale;
                    var k = src[srcOffset + 3] * srcScale;
                    var r = (c * (-4.387332384609988 * c + 54.48615194189176 * m +
                            18.82290502165302 * y + 212.25662451639585 * k +
                            -285.2331026137004) +
                        m * (1.7149763477362134 * m - 5.6096736904047315 * y +
                            -17.873870861415444 * k - 5.497006427196366) +
                        y * (-2.5217340131683033 * y - 21.248923337353073 * k +
                            17.5119270841813) +
                        k * (-21.86122147463605 * k - 189.48180835922747) + 255) | 0;
                    var g = (c * (8.841041422036149 * c + 60.118027045597366 * m +
                            6.871425592049007 * y + 31.159100130055922 * k +
                            -79.2970844816548) +
                        m * (-15.310361306967817 * m + 17.575251261109482 * y +
                            131.35250912493976 * k - 190.9453302588951) +
                        y * (4.444339102852739 * y + 9.8632861493405 * k - 24.86741582555878) +
                        k * (-20.737325471181034 * k - 187.80453709719578) + 255) | 0;
                    var b = (c * (0.8842522430003296 * c + 8.078677503112928 * m +
                            30.89978309703729 * y - 0.23883238689178934 * k +
                            -14.183576799673286) +
                        m * (10.49593273432072 * m + 63.02378494754052 * y +
                            50.606957656360734 * k - 112.23884253719248) +
                        y * (0.03296041114873217 * y + 115.60384449646641 * k +
                            -193.58209356861505) +
                        k * (-22.33816807309886 * k - 180.12613974708367) + 255) | 0;
                    dest[destOffset] = r > 255 ? 255 : r < 0 ? 0 : r;
                    dest[destOffset + 1] = g > 255 ? 255 : g < 0 ? 0 : g;
                    dest[destOffset + 2] = b > 255 ? 255 : b < 0 ? 0 : b;
                }

                function DeviceCmykCS() {
                    this.name = 'DeviceCMYK';
                    this.numComps = 4;
                    this.defaultColor = new Float32Array([0, 0, 0, 1]);
                }
                DeviceCmykCS.prototype = {
                    getRgb: ColorSpace.prototype.getRgb,
                    getRgbItem: function DeviceCmykCS_getRgbItem(src, srcOffset, dest, destOffset) {
                        convertToRgb(src, srcOffset, 1, dest, destOffset);
                    },
                    getRgbBuffer: function DeviceCmykCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                        var scale = 1 / ((1 << bits) - 1);
                        for (var i = 0; i < count; i++) {
                            convertToRgb(src, srcOffset, scale, dest, destOffset);
                            srcOffset += 4;
                            destOffset += 3 + alpha01;
                        }
                    },
                    getOutputLength: function DeviceCmykCS_getOutputLength(inputLength, alpha01) {
                        return (inputLength / 4 * (3 + alpha01)) | 0;
                    },
                    isPassthrough: ColorSpace.prototype.isPassthrough,
                    fillRgb: ColorSpace.prototype.fillRgb,
                    isDefaultDecode: function DeviceCmykCS_isDefaultDecode(decodeMap) {
                        return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
                    },
                    usesZeroToOneRange: true
                };
                return DeviceCmykCS;
            })();
            var CalGrayCS = (function CalGrayCSClosure() {
                function CalGrayCS(whitePoint, blackPoint, gamma) {
                    this.name = 'CalGray';
                    this.numComps = 1;
                    this.defaultColor = new Float32Array([0]);
                    if (!whitePoint) {
                        error('WhitePoint missing - required for color space CalGray');
                    }
                    blackPoint = blackPoint || [0, 0, 0];
                    gamma = gamma || 1;
                    this.XW = whitePoint[0];
                    this.YW = whitePoint[1];
                    this.ZW = whitePoint[2];
                    this.XB = blackPoint[0];
                    this.YB = blackPoint[1];
                    this.ZB = blackPoint[2];
                    this.G = gamma;
                    if (this.XW < 0 || this.ZW < 0 || this.YW !== 1) {
                        error('Invalid WhitePoint components for ' + this.name + ', no fallback available');
                    }
                    if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
                        info('Invalid BlackPoint for ' + this.name + ', falling back to default');
                        this.XB = this.YB = this.ZB = 0;
                    }
                    if (this.XB !== 0 || this.YB !== 0 || this.ZB !== 0) {
                        warn(this.name + ', BlackPoint: XB: ' + this.XB + ', YB: ' + this.YB + ', ZB: ' + this.ZB + ', only default values are supported.');
                    }
                    if (this.G < 1) {
                        info('Invalid Gamma: ' + this.G + ' for ' + this.name + ', falling back to default');
                        this.G = 1;
                    }
                }

                function convertToRgb(cs, src, srcOffset, dest, destOffset, scale) {
                    var A = src[srcOffset] * scale;
                    var AG = Math.pow(A, cs.G);
                    var L = cs.YW * AG;
                    var val = Math.max(295.8 * Math.pow(L, 0.333333333333333333) - 40.8, 0) | 0;
                    dest[destOffset] = val;
                    dest[destOffset + 1] = val;
                    dest[destOffset + 2] = val;
                }
                CalGrayCS.prototype = {
                    getRgb: ColorSpace.prototype.getRgb,
                    getRgbItem: function CalGrayCS_getRgbItem(src, srcOffset, dest, destOffset) {
                        convertToRgb(this, src, srcOffset, dest, destOffset, 1);
                    },
                    getRgbBuffer: function CalGrayCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                        var scale = 1 / ((1 << bits) - 1);
                        for (var i = 0; i < count; ++i) {
                            convertToRgb(this, src, srcOffset, dest, destOffset, scale);
                            srcOffset += 1;
                            destOffset += 3 + alpha01;
                        }
                    },
                    getOutputLength: function CalGrayCS_getOutputLength(inputLength, alpha01) {
                        return inputLength * (3 + alpha01);
                    },
                    isPassthrough: ColorSpace.prototype.isPassthrough,
                    fillRgb: ColorSpace.prototype.fillRgb,
                    isDefaultDecode: function CalGrayCS_isDefaultDecode(decodeMap) {
                        return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
                    },
                    usesZeroToOneRange: true
                };
                return CalGrayCS;
            })();
            var CalRGBCS = (function CalRGBCSClosure() {
                var BRADFORD_SCALE_MATRIX = new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296]);
                var BRADFORD_SCALE_INVERSE_MATRIX = new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -0.0085287, 0.0400428, 0.9684867]);
                var SRGB_D65_XYZ_TO_RGB_MATRIX = new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.9692660, 1.8760108, 0.0415560, 0.0556434, -0.2040259, 1.0572252]);
                var FLAT_WHITEPOINT_MATRIX = new Float32Array([1, 1, 1]);
                var tempNormalizeMatrix = new Float32Array(3);
                var tempConvertMatrix1 = new Float32Array(3);
                var tempConvertMatrix2 = new Float32Array(3);
                var DECODE_L_CONSTANT = Math.pow(((8 + 16) / 116), 3) / 8.0;

                function CalRGBCS(whitePoint, blackPoint, gamma, matrix) {
                    this.name = 'CalRGB';
                    this.numComps = 3;
                    this.defaultColor = new Float32Array(3);
                    if (!whitePoint) {
                        error('WhitePoint missing - required for color space CalRGB');
                    }
                    blackPoint = blackPoint || new Float32Array(3);
                    gamma = gamma || new Float32Array([1, 1, 1]);
                    matrix = matrix || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
                    var XW = whitePoint[0];
                    var YW = whitePoint[1];
                    var ZW = whitePoint[2];
                    this.whitePoint = whitePoint;
                    var XB = blackPoint[0];
                    var YB = blackPoint[1];
                    var ZB = blackPoint[2];
                    this.blackPoint = blackPoint;
                    this.GR = gamma[0];
                    this.GG = gamma[1];
                    this.GB = gamma[2];
                    this.MXA = matrix[0];
                    this.MYA = matrix[1];
                    this.MZA = matrix[2];
                    this.MXB = matrix[3];
                    this.MYB = matrix[4];
                    this.MZB = matrix[5];
                    this.MXC = matrix[6];
                    this.MYC = matrix[7];
                    this.MZC = matrix[8];
                    if (XW < 0 || ZW < 0 || YW !== 1) {
                        error('Invalid WhitePoint components for ' + this.name + ', no fallback available');
                    }
                    if (XB < 0 || YB < 0 || ZB < 0) {
                        info('Invalid BlackPoint for ' + this.name + ' [' + XB + ', ' + YB + ', ' + ZB + '], falling back to default');
                        this.blackPoint = new Float32Array(3);
                    }
                    if (this.GR < 0 || this.GG < 0 || this.GB < 0) {
                        info('Invalid Gamma [' + this.GR + ', ' + this.GG + ', ' + this.GB + '] for ' + this.name + ', falling back to default');
                        this.GR = this.GG = this.GB = 1;
                    }
                    if (this.MXA < 0 || this.MYA < 0 || this.MZA < 0 || this.MXB < 0 || this.MYB < 0 || this.MZB < 0 || this.MXC < 0 || this.MYC < 0 || this.MZC < 0) {
                        info('Invalid Matrix for ' + this.name + ' [' +
                            this.MXA + ', ' + this.MYA + ', ' + this.MZA +
                            this.MXB + ', ' + this.MYB + ', ' + this.MZB +
                            this.MXC + ', ' + this.MYC + ', ' + this.MZC + '], falling back to default');
                        this.MXA = this.MYB = this.MZC = 1;
                        this.MXB = this.MYA = this.MZA = this.MXC = this.MYC = this.MZB = 0;
                    }
                }

                function matrixProduct(a, b, result) {
                    result[0] = a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
                    result[1] = a[3] * b[0] + a[4] * b[1] + a[5] * b[2];
                    result[2] = a[6] * b[0] + a[7] * b[1] + a[8] * b[2];
                }

                function convertToFlat(sourceWhitePoint, LMS, result) {
                    result[0] = LMS[0] * 1 / sourceWhitePoint[0];
                    result[1] = LMS[1] * 1 / sourceWhitePoint[1];
                    result[2] = LMS[2] * 1 / sourceWhitePoint[2];
                }

                function convertToD65(sourceWhitePoint, LMS, result) {
                    var D65X = 0.95047;
                    var D65Y = 1;
                    var D65Z = 1.08883;
                    result[0] = LMS[0] * D65X / sourceWhitePoint[0];
                    result[1] = LMS[1] * D65Y / sourceWhitePoint[1];
                    result[2] = LMS[2] * D65Z / sourceWhitePoint[2];
                }

                function sRGBTransferFunction(color) {
                    if (color <= 0.0031308) {
                        return adjustToRange(0, 1, 12.92 * color);
                    }
                    return adjustToRange(0, 1, (1 + 0.055) * Math.pow(color, 1 / 2.4) - 0.055);
                }

                function adjustToRange(min, max, value) {
                    return Math.max(min, Math.min(max, value));
                }

                function decodeL(L) {
                    if (L < 0) {
                        return -decodeL(-L);
                    }
                    if (L > 8.0) {
                        return Math.pow(((L + 16) / 116), 3);
                    }
                    return L * DECODE_L_CONSTANT;
                }

                function compensateBlackPoint(sourceBlackPoint, XYZ_Flat, result) {
                    if (sourceBlackPoint[0] === 0 && sourceBlackPoint[1] === 0 && sourceBlackPoint[2] === 0) {
                        result[0] = XYZ_Flat[0];
                        result[1] = XYZ_Flat[1];
                        result[2] = XYZ_Flat[2];
                        return;
                    }
                    var zeroDecodeL = decodeL(0);
                    var X_DST = zeroDecodeL;
                    var X_SRC = decodeL(sourceBlackPoint[0]);
                    var Y_DST = zeroDecodeL;
                    var Y_SRC = decodeL(sourceBlackPoint[1]);
                    var Z_DST = zeroDecodeL;
                    var Z_SRC = decodeL(sourceBlackPoint[2]);
                    var X_Scale = (1 - X_DST) / (1 - X_SRC);
                    var X_Offset = 1 - X_Scale;
                    var Y_Scale = (1 - Y_DST) / (1 - Y_SRC);
                    var Y_Offset = 1 - Y_Scale;
                    var Z_Scale = (1 - Z_DST) / (1 - Z_SRC);
                    var Z_Offset = 1 - Z_Scale;
                    result[0] = XYZ_Flat[0] * X_Scale + X_Offset;
                    result[1] = XYZ_Flat[1] * Y_Scale + Y_Offset;
                    result[2] = XYZ_Flat[2] * Z_Scale + Z_Offset;
                }

                function normalizeWhitePointToFlat(sourceWhitePoint, XYZ_In, result) {
                    if (sourceWhitePoint[0] === 1 && sourceWhitePoint[2] === 1) {
                        result[0] = XYZ_In[0];
                        result[1] = XYZ_In[1];
                        result[2] = XYZ_In[2];
                        return;
                    }
                    var LMS = result;
                    matrixProduct(BRADFORD_SCALE_MATRIX, XYZ_In, LMS);
                    var LMS_Flat = tempNormalizeMatrix;
                    convertToFlat(sourceWhitePoint, LMS, LMS_Flat);
                    matrixProduct(BRADFORD_SCALE_INVERSE_MATRIX, LMS_Flat, result);
                }

                function normalizeWhitePointToD65(sourceWhitePoint, XYZ_In, result) {
                    var LMS = result;
                    matrixProduct(BRADFORD_SCALE_MATRIX, XYZ_In, LMS);
                    var LMS_D65 = tempNormalizeMatrix;
                    convertToD65(sourceWhitePoint, LMS, LMS_D65);
                    matrixProduct(BRADFORD_SCALE_INVERSE_MATRIX, LMS_D65, result);
                }

                function convertToRgb(cs, src, srcOffset, dest, destOffset, scale) {
                    var A = adjustToRange(0, 1, src[srcOffset] * scale);
                    var B = adjustToRange(0, 1, src[srcOffset + 1] * scale);
                    var C = adjustToRange(0, 1, src[srcOffset + 2] * scale);
                    var AGR = Math.pow(A, cs.GR);
                    var BGG = Math.pow(B, cs.GG);
                    var CGB = Math.pow(C, cs.GB);
                    var X = cs.MXA * AGR + cs.MXB * BGG + cs.MXC * CGB;
                    var Y = cs.MYA * AGR + cs.MYB * BGG + cs.MYC * CGB;
                    var Z = cs.MZA * AGR + cs.MZB * BGG + cs.MZC * CGB;
                    var XYZ = tempConvertMatrix1;
                    XYZ[0] = X;
                    XYZ[1] = Y;
                    XYZ[2] = Z;
                    var XYZ_Flat = tempConvertMatrix2;
                    normalizeWhitePointToFlat(cs.whitePoint, XYZ, XYZ_Flat);
                    var XYZ_Black = tempConvertMatrix1;
                    compensateBlackPoint(cs.blackPoint, XYZ_Flat, XYZ_Black);
                    var XYZ_D65 = tempConvertMatrix2;
                    normalizeWhitePointToD65(FLAT_WHITEPOINT_MATRIX, XYZ_Black, XYZ_D65);
                    var SRGB = tempConvertMatrix1;
                    matrixProduct(SRGB_D65_XYZ_TO_RGB_MATRIX, XYZ_D65, SRGB);
                    var sR = sRGBTransferFunction(SRGB[0]);
                    var sG = sRGBTransferFunction(SRGB[1]);
                    var sB = sRGBTransferFunction(SRGB[2]);
                    dest[destOffset] = Math.round(sR * 255);
                    dest[destOffset + 1] = Math.round(sG * 255);
                    dest[destOffset + 2] = Math.round(sB * 255);
                }
                CalRGBCS.prototype = {
                    getRgb: function CalRGBCS_getRgb(src, srcOffset) {
                        var rgb = new Uint8Array(3);
                        this.getRgbItem(src, srcOffset, rgb, 0);
                        return rgb;
                    },
                    getRgbItem: function CalRGBCS_getRgbItem(src, srcOffset, dest, destOffset) {
                        convertToRgb(this, src, srcOffset, dest, destOffset, 1);
                    },
                    getRgbBuffer: function CalRGBCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                        var scale = 1 / ((1 << bits) - 1);
                        for (var i = 0; i < count; ++i) {
                            convertToRgb(this, src, srcOffset, dest, destOffset, scale);
                            srcOffset += 3;
                            destOffset += 3 + alpha01;
                        }
                    },
                    getOutputLength: function CalRGBCS_getOutputLength(inputLength, alpha01) {
                        return (inputLength * (3 + alpha01) / 3) | 0;
                    },
                    isPassthrough: ColorSpace.prototype.isPassthrough,
                    fillRgb: ColorSpace.prototype.fillRgb,
                    isDefaultDecode: function CalRGBCS_isDefaultDecode(decodeMap) {
                        return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
                    },
                    usesZeroToOneRange: true
                };
                return CalRGBCS;
            })();
            var LabCS = (function LabCSClosure() {
                function LabCS(whitePoint, blackPoint, range) {
                    this.name = 'Lab';
                    this.numComps = 3;
                    this.defaultColor = new Float32Array([0, 0, 0]);
                    if (!whitePoint) {
                        error('WhitePoint missing - required for color space Lab');
                    }
                    blackPoint = blackPoint || [0, 0, 0];
                    range = range || [-100, 100, -100, 100];
                    this.XW = whitePoint[0];
                    this.YW = whitePoint[1];
                    this.ZW = whitePoint[2];
                    this.amin = range[0];
                    this.amax = range[1];
                    this.bmin = range[2];
                    this.bmax = range[3];
                    this.XB = blackPoint[0];
                    this.YB = blackPoint[1];
                    this.ZB = blackPoint[2];
                    if (this.XW < 0 || this.ZW < 0 || this.YW !== 1) {
                        error('Invalid WhitePoint components, no fallback available');
                    }
                    if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
                        info('Invalid BlackPoint, falling back to default');
                        this.XB = this.YB = this.ZB = 0;
                    }
                    if (this.amin > this.amax || this.bmin > this.bmax) {
                        info('Invalid Range, falling back to defaults');
                        this.amin = -100;
                        this.amax = 100;
                        this.bmin = -100;
                        this.bmax = 100;
                    }
                }

                function fn_g(x) {
                    if (x >= 6 / 29) {
                        return x * x * x;
                    } else {
                        return (108 / 841) * (x - 4 / 29);
                    }
                }

                function decode(value, high1, low2, high2) {
                    return low2 + (value) * (high2 - low2) / (high1);
                }

                function convertToRgb(cs, src, srcOffset, maxVal, dest, destOffset) {
                    var Ls = src[srcOffset];
                    var as = src[srcOffset + 1];
                    var bs = src[srcOffset + 2];
                    if (maxVal !== false) {
                        Ls = decode(Ls, maxVal, 0, 100);
                        as = decode(as, maxVal, cs.amin, cs.amax);
                        bs = decode(bs, maxVal, cs.bmin, cs.bmax);
                    }
                    as = as > cs.amax ? cs.amax : as < cs.amin ? cs.amin : as;
                    bs = bs > cs.bmax ? cs.bmax : bs < cs.bmin ? cs.bmin : bs;
                    var M = (Ls + 16) / 116;
                    var L = M + (as / 500);
                    var N = M - (bs / 200);
                    var X = cs.XW * fn_g(L);
                    var Y = cs.YW * fn_g(M);
                    var Z = cs.ZW * fn_g(N);
                    var r, g, b;
                    if (cs.ZW < 1) {
                        r = X * 3.1339 + Y * -1.6170 + Z * -0.4906;
                        g = X * -0.9785 + Y * 1.9160 + Z * 0.0333;
                        b = X * 0.0720 + Y * -0.2290 + Z * 1.4057;
                    } else {
                        r = X * 3.2406 + Y * -1.5372 + Z * -0.4986;
                        g = X * -0.9689 + Y * 1.8758 + Z * 0.0415;
                        b = X * 0.0557 + Y * -0.2040 + Z * 1.0570;
                    }
                    dest[destOffset] = r <= 0 ? 0 : r >= 1 ? 255 : Math.sqrt(r) * 255 | 0;
                    dest[destOffset + 1] = g <= 0 ? 0 : g >= 1 ? 255 : Math.sqrt(g) * 255 | 0;
                    dest[destOffset + 2] = b <= 0 ? 0 : b >= 1 ? 255 : Math.sqrt(b) * 255 | 0;
                }
                LabCS.prototype = {
                    getRgb: ColorSpace.prototype.getRgb,
                    getRgbItem: function LabCS_getRgbItem(src, srcOffset, dest, destOffset) {
                        convertToRgb(this, src, srcOffset, false, dest, destOffset);
                    },
                    getRgbBuffer: function LabCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                        var maxVal = (1 << bits) - 1;
                        for (var i = 0; i < count; i++) {
                            convertToRgb(this, src, srcOffset, maxVal, dest, destOffset);
                            srcOffset += 3;
                            destOffset += 3 + alpha01;
                        }
                    },
                    getOutputLength: function LabCS_getOutputLength(inputLength, alpha01) {
                        return (inputLength * (3 + alpha01) / 3) | 0;
                    },
                    isPassthrough: ColorSpace.prototype.isPassthrough,
                    fillRgb: ColorSpace.prototype.fillRgb,
                    isDefaultDecode: function LabCS_isDefaultDecode(decodeMap) {
                        return true;
                    },
                    usesZeroToOneRange: false
                };
                return LabCS;
            })();

            function _setCoreImage(coreImage_) {
                coreImage = coreImage_;
                PDFImage = coreImage_.PDFImage;
            }
            exports._setCoreImage = _setCoreImage;
            exports.ColorSpace = ColorSpace;
            coreStream._setCoreColorSpace(exports);
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsCoreImage = {}), root.pdfjsSharedUtil, root.pdfjsCorePrimitives, root.pdfjsCoreColorSpace, root.pdfjsCoreStream, root.pdfjsCoreJpx);
            }
        }(this, function(exports, sharedUtil, corePrimitives, coreColorSpace, coreStream, coreJpx) {
            var ImageKind = sharedUtil.ImageKind;
            var assert = sharedUtil.assert;
            var error = sharedUtil.error;
            var info = sharedUtil.info;
            var isArray = sharedUtil.isArray;
            var warn = sharedUtil.warn;
            var Name = corePrimitives.Name;
            var isStream = corePrimitives.isStream;
            var ColorSpace = coreColorSpace.ColorSpace;
            var DecodeStream = coreStream.DecodeStream;
            var Stream = coreStream.Stream;
            var JpegStream = coreStream.JpegStream;
            var JpxImage = coreJpx.JpxImage;
            var PDFImage = (function PDFImageClosure() {
                function handleImageData(handler, xref, res, image) {
                    if (image instanceof JpegStream && image.isNativelyDecodable(xref, res)) {
                        var dict = image.dict;
                        var colorSpace = dict.get('ColorSpace', 'CS');
                        colorSpace = ColorSpace.parse(colorSpace, xref, res);
                        var numComps = colorSpace.numComps;
                        var decodePromise = handler.sendWithPromise('JpegDecode', [image.getIR(), numComps]);
                        return decodePromise.then(function(message) {
                            var data = message.data;
                            return new Stream(data, 0, data.length, image.dict);
                        });
                    } else {
                        return Promise.resolve(image);
                    }
                }

                function decodeAndClamp(value, addend, coefficient, max) {
                    value = addend + value * coefficient;
                    return (value < 0 ? 0 : (value > max ? max : value));
                }

                function PDFImage(xref, res, image, inline, smask, mask, isMask) {
                    this.image = image;
                    var dict = image.dict;
                    if (dict.has('Filter')) {
                        var filter = dict.get('Filter').name;
                        if (filter === 'JPXDecode') {
                            var jpxImage = new JpxImage();
                            jpxImage.parseImageProperties(image.stream);
                            image.stream.reset();
                            image.bitsPerComponent = jpxImage.bitsPerComponent;
                            image.numComps = jpxImage.componentsCount;
                        } else if (filter === 'JBIG2Decode') {
                            image.bitsPerComponent = 1;
                            image.numComps = 1;
                        }
                    }
                    this.width = dict.get('Width', 'W');
                    this.height = dict.get('Height', 'H');
                    if (this.width < 1 || this.height < 1) {
                        error('Invalid image width: ' + this.width + ' or height: ' +
                            this.height);
                    }
                    this.interpolate = dict.get('Interpolate', 'I') || false;
                    this.imageMask = dict.get('ImageMask', 'IM') || false;
                    this.matte = dict.get('Matte') || false;
                    var bitsPerComponent = image.bitsPerComponent;
                    if (!bitsPerComponent) {
                        bitsPerComponent = dict.get('BitsPerComponent', 'BPC');
                        if (!bitsPerComponent) {
                            if (this.imageMask) {
                                bitsPerComponent = 1;
                            } else {
                                error('Bits per component missing in image: ' + this.imageMask);
                            }
                        }
                    }
                    this.bpc = bitsPerComponent;
                    if (!this.imageMask) {
                        var colorSpace = dict.get('ColorSpace', 'CS');
                        if (!colorSpace) {
                            info('JPX images (which do not require color spaces)');
                            switch (image.numComps) {
                                case 1:
                                    colorSpace = Name.get('DeviceGray');
                                    break;
                                case 3:
                                    colorSpace = Name.get('DeviceRGB');
                                    break;
                                case 4:
                                    colorSpace = Name.get('DeviceCMYK');
                                    break;
                                default:
                                    error('JPX images with ' + this.numComps + ' color components not supported.');
                            }
                        }
                        this.colorSpace = ColorSpace.parse(colorSpace, xref, res);
                        this.numComps = this.colorSpace.numComps;
                    }
                    this.decode = dict.get('Decode', 'D');
                    this.needsDecode = false;
                    if (this.decode && ((this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode)) || (isMask && !ColorSpace.isDefaultDecode(this.decode, 1)))) {
                        this.needsDecode = true;
                        var max = (1 << bitsPerComponent) - 1;
                        this.decodeCoefficients = [];
                        this.decodeAddends = [];
                        for (var i = 0, j = 0; i < this.decode.length; i += 2, ++j) {
                            var dmin = this.decode[i];
                            var dmax = this.decode[i + 1];
                            this.decodeCoefficients[j] = dmax - dmin;
                            this.decodeAddends[j] = max * dmin;
                        }
                    }
                    if (smask) {
                        this.smask = new PDFImage(xref, res, smask, false);
                    } else if (mask) {
                        if (isStream(mask)) {
                            var maskDict = mask.dict,
                                imageMask = maskDict.get('ImageMask', 'IM');
                            if (!imageMask) {
                                warn('Ignoring /Mask in image without /ImageMask.');
                            } else {
                                this.mask = new PDFImage(xref, res, mask, false, null, null, true);
                            }
                        } else {
                            this.mask = mask;
                        }
                    }
                }
                PDFImage.buildImage = function PDFImage_buildImage(handler, xref, res, image, inline) {
                    var imagePromise = handleImageData(handler, xref, res, image);
                    var smaskPromise;
                    var maskPromise;
                    var smask = image.dict.get('SMask');
                    var mask = image.dict.get('Mask');
                    if (smask) {
                        smaskPromise = handleImageData(handler, xref, res, smask);
                        maskPromise = Promise.resolve(null);
                    } else {
                        smaskPromise = Promise.resolve(null);
                        if (mask) {
                            if (isStream(mask)) {
                                maskPromise = handleImageData(handler, xref, res, mask);
                            } else if (isArray(mask)) {
                                maskPromise = Promise.resolve(mask);
                            } else {
                                warn('Unsupported mask format.');
                                maskPromise = Promise.resolve(null);
                            }
                        } else {
                            maskPromise = Promise.resolve(null);
                        }
                    }
                    return Promise.all([imagePromise, smaskPromise, maskPromise]).then(function(results) {
                        var imageData = results[0];
                        var smaskData = results[1];
                        var maskData = results[2];
                        return new PDFImage(xref, res, imageData, inline, smaskData, maskData);
                    });
                };
                PDFImage.resize = function PDFImage_resize(pixels, bpc, components, w1, h1, w2, h2, dest, alpha01) {
                    if (components !== 1 && components !== 3) {
                        error('Unsupported component count for resizing.');
                    }
                    var length = w2 * h2 * components;
                    var temp = dest ? dest : (bpc <= 8 ? new Uint8Array(length) : (bpc <= 16 ? new Uint16Array(length) : new Uint32Array(length)));
                    var xRatio = w1 / w2;
                    var yRatio = h1 / h2;
                    var i, j, py, newIndex = 0,
                        oldIndex;
                    var xScaled = new Uint16Array(w2);
                    var w1Scanline = w1 * components;
                    if (alpha01 !== 1) {
                        alpha01 = 0;
                    }
                    for (j = 0; j < w2; j++) {
                        xScaled[j] = Math.floor(j * xRatio) * components;
                    }
                    if (components === 1) {
                        for (i = 0; i < h2; i++) {
                            py = Math.floor(i * yRatio) * w1Scanline;
                            for (j = 0; j < w2; j++) {
                                oldIndex = py + xScaled[j];
                                temp[newIndex++] = pixels[oldIndex];
                            }
                        }
                    } else if (components === 3) {
                        for (i = 0; i < h2; i++) {
                            py = Math.floor(i * yRatio) * w1Scanline;
                            for (j = 0; j < w2; j++) {
                                oldIndex = py + xScaled[j];
                                temp[newIndex++] = pixels[oldIndex++];
                                temp[newIndex++] = pixels[oldIndex++];
                                temp[newIndex++] = pixels[oldIndex++];
                                newIndex += alpha01;
                            }
                        }
                    }
                    return temp;
                };
                PDFImage.createMask = function PDFImage_createMask(imgArray, width, height, imageIsFromDecodeStream, inverseDecode) {
                    var computedLength = ((width + 7) >> 3) * height;
                    var actualLength = imgArray.byteLength;
                    var haveFullData = computedLength === actualLength;
                    var data, i;
                    if (imageIsFromDecodeStream && (!inverseDecode || haveFullData)) {
                        data = imgArray;
                    } else if (!inverseDecode) {
                        data = new Uint8Array(actualLength);
                        data.set(imgArray);
                    } else {
                        data = new Uint8Array(computedLength);
                        data.set(imgArray);
                        for (i = actualLength; i < computedLength; i++) {
                            data[i] = 0xff;
                        }
                    }
                    if (inverseDecode) {
                        for (i = 0; i < actualLength; i++) {
                            data[i] = ~data[i];
                        }
                    }
                    return {
                        data: data,
                        width: width,
                        height: height
                    };
                };
                PDFImage.prototype = {
                    get drawWidth() {
                        return Math.max(this.width, this.smask && this.smask.width || 0, this.mask && this.mask.width || 0);
                    },
                    get drawHeight() {
                        return Math.max(this.height, this.smask && this.smask.height || 0, this.mask && this.mask.height || 0);
                    },
                    decodeBuffer: function PDFImage_decodeBuffer(buffer) {
                        var bpc = this.bpc;
                        var numComps = this.numComps;
                        var decodeAddends = this.decodeAddends;
                        var decodeCoefficients = this.decodeCoefficients;
                        var max = (1 << bpc) - 1;
                        var i, ii;
                        if (bpc === 1) {
                            for (i = 0, ii = buffer.length; i < ii; i++) {
                                buffer[i] = +!(buffer[i]);
                            }
                            return;
                        }
                        var index = 0;
                        for (i = 0, ii = this.width * this.height; i < ii; i++) {
                            for (var j = 0; j < numComps; j++) {
                                buffer[index] = decodeAndClamp(buffer[index], decodeAddends[j], decodeCoefficients[j], max);
                                index++;
                            }
                        }
                    },
                    getComponents: function PDFImage_getComponents(buffer) {
                        var bpc = this.bpc;
                        if (bpc === 8) {
                            return buffer;
                        }
                        var width = this.width;
                        var height = this.height;
                        var numComps = this.numComps;
                        var length = width * height * numComps;
                        var bufferPos = 0;
                        var output = (bpc <= 8 ? new Uint8Array(length) : (bpc <= 16 ? new Uint16Array(length) : new Uint32Array(length)));
                        var rowComps = width * numComps;
                        var max = (1 << bpc) - 1;
                        var i = 0,
                            ii, buf;
                        if (bpc === 1) {
                            var mask, loop1End, loop2End;
                            for (var j = 0; j < height; j++) {
                                loop1End = i + (rowComps & ~7);
                                loop2End = i + rowComps;
                                while (i < loop1End) {
                                    buf = buffer[bufferPos++];
                                    output[i] = (buf >> 7) & 1;
                                    output[i + 1] = (buf >> 6) & 1;
                                    output[i + 2] = (buf >> 5) & 1;
                                    output[i + 3] = (buf >> 4) & 1;
                                    output[i + 4] = (buf >> 3) & 1;
                                    output[i + 5] = (buf >> 2) & 1;
                                    output[i + 6] = (buf >> 1) & 1;
                                    output[i + 7] = buf & 1;
                                    i += 8;
                                }
                                if (i < loop2End) {
                                    buf = buffer[bufferPos++];
                                    mask = 128;
                                    while (i < loop2End) {
                                        output[i++] = +!!(buf & mask);
                                        mask >>= 1;
                                    }
                                }
                            }
                        } else {
                            var bits = 0;
                            buf = 0;
                            for (i = 0, ii = length; i < ii; ++i) {
                                if (i % rowComps === 0) {
                                    buf = 0;
                                    bits = 0;
                                }
                                while (bits < bpc) {
                                    buf = (buf << 8) | buffer[bufferPos++];
                                    bits += 8;
                                }
                                var remainingBits = bits - bpc;
                                var value = buf >> remainingBits;
                                output[i] = (value < 0 ? 0 : (value > max ? max : value));
                                buf = buf & ((1 << remainingBits) - 1);
                                bits = remainingBits;
                            }
                        }
                        return output;
                    },
                    fillOpacity: function PDFImage_fillOpacity(rgbaBuf, width, height, actualHeight, image) {
                        var smask = this.smask;
                        var mask = this.mask;
                        var alphaBuf, sw, sh, i, ii, j;
                        if (smask) {
                            sw = smask.width;
                            sh = smask.height;
                            alphaBuf = new Uint8Array(sw * sh);
                            smask.fillGrayBuffer(alphaBuf);
                            if (sw !== width || sh !== height) {
                                alphaBuf = PDFImage.resize(alphaBuf, smask.bpc, 1, sw, sh, width, height);
                            }
                        } else if (mask) {
                            if (mask instanceof PDFImage) {
                                sw = mask.width;
                                sh = mask.height;
                                alphaBuf = new Uint8Array(sw * sh);
                                mask.numComps = 1;
                                mask.fillGrayBuffer(alphaBuf);
                                for (i = 0, ii = sw * sh; i < ii; ++i) {
                                    alphaBuf[i] = 255 - alphaBuf[i];
                                }
                                if (sw !== width || sh !== height) {
                                    alphaBuf = PDFImage.resize(alphaBuf, mask.bpc, 1, sw, sh, width, height);
                                }
                            } else if (isArray(mask)) {
                                alphaBuf = new Uint8Array(width * height);
                                var numComps = this.numComps;
                                for (i = 0, ii = width * height; i < ii; ++i) {
                                    var opacity = 0;
                                    var imageOffset = i * numComps;
                                    for (j = 0; j < numComps; ++j) {
                                        var color = image[imageOffset + j];
                                        var maskOffset = j * 2;
                                        if (color < mask[maskOffset] || color > mask[maskOffset + 1]) {
                                            opacity = 255;
                                            break;
                                        }
                                    }
                                    alphaBuf[i] = opacity;
                                }
                            } else {
                                error('Unknown mask format.');
                            }
                        }
                        if (alphaBuf) {
                            for (i = 0, j = 3, ii = width * actualHeight; i < ii; ++i, j += 4) {
                                rgbaBuf[j] = alphaBuf[i];
                            }
                        } else {
                            for (i = 0, j = 3, ii = width * actualHeight; i < ii; ++i, j += 4) {
                                rgbaBuf[j] = 255;
                            }
                        }
                    },
                    undoPreblend: function PDFImage_undoPreblend(buffer, width, height) {
                        var matte = this.smask && this.smask.matte;
                        if (!matte) {
                            return;
                        }
                        var matteRgb = this.colorSpace.getRgb(matte, 0);
                        var matteR = matteRgb[0];
                        var matteG = matteRgb[1];
                        var matteB = matteRgb[2];
                        var length = width * height * 4;
                        var r, g, b;
                        for (var i = 0; i < length; i += 4) {
                            var alpha = buffer[i + 3];
                            if (alpha === 0) {
                                buffer[i] = 255;
                                buffer[i + 1] = 255;
                                buffer[i + 2] = 255;
                                continue;
                            }
                            var k = 255 / alpha;
                            r = (buffer[i] - matteR) * k + matteR;
                            g = (buffer[i + 1] - matteG) * k + matteG;
                            b = (buffer[i + 2] - matteB) * k + matteB;
                            buffer[i] = r <= 0 ? 0 : r >= 255 ? 255 : r | 0;
                            buffer[i + 1] = g <= 0 ? 0 : g >= 255 ? 255 : g | 0;
                            buffer[i + 2] = b <= 0 ? 0 : b >= 255 ? 255 : b | 0;
                        }
                    },
                    createImageData: function PDFImage_createImageData(forceRGBA) {
                        var drawWidth = this.drawWidth;
                        var drawHeight = this.drawHeight;
                        var imgData = {
                            width: drawWidth,
                            height: drawHeight
                        };
                        var numComps = this.numComps;
                        var originalWidth = this.width;
                        var originalHeight = this.height;
                        var bpc = this.bpc;
                        var rowBytes = (originalWidth * numComps * bpc + 7) >> 3;
                        var imgArray;
                        if (!forceRGBA) {
                            var kind;
                            if (this.colorSpace.name === 'DeviceGray' && bpc === 1) {
                                kind = ImageKind.GRAYSCALE_1BPP;
                            } else if (this.colorSpace.name === 'DeviceRGB' && bpc === 8 && !this.needsDecode) {
                                kind = ImageKind.RGB_24BPP;
                            }
                            if (kind && !this.smask && !this.mask && drawWidth === originalWidth && drawHeight === originalHeight) {
                                imgData.kind = kind;
                                imgArray = this.getImageBytes(originalHeight * rowBytes);
                                if (this.image instanceof DecodeStream) {
                                    imgData.data = imgArray;
                                } else {
                                    var newArray = new Uint8Array(imgArray.length);
                                    newArray.set(imgArray);
                                    imgData.data = newArray;
                                }
                                if (this.needsDecode) {
                                    assert(kind === ImageKind.GRAYSCALE_1BPP);
                                    var buffer = imgData.data;
                                    for (var i = 0, ii = buffer.length; i < ii; i++) {
                                        buffer[i] ^= 0xff;
                                    }
                                }
                                return imgData;
                            }
                            if (this.image instanceof JpegStream && !this.smask && !this.mask && (this.colorSpace.name === 'DeviceGray' || this.colorSpace.name === 'DeviceRGB' || this.colorSpace.name === 'DeviceCMYK')) {
                                imgData.kind = ImageKind.RGB_24BPP;
                                imgData.data = this.getImageBytes(originalHeight * rowBytes, drawWidth, drawHeight, true);
                                return imgData;
                            }
                        }
                        imgArray = this.getImageBytes(originalHeight * rowBytes);
                        var actualHeight = 0 | (imgArray.length / rowBytes * drawHeight / originalHeight);
                        var comps = this.getComponents(imgArray);
                        var alpha01, maybeUndoPreblend;
                        if (!forceRGBA && !this.smask && !this.mask) {
                            imgData.kind = ImageKind.RGB_24BPP;
                            imgData.data = new Uint8Array(drawWidth * drawHeight * 3);
                            alpha01 = 0;
                            maybeUndoPreblend = false;
                        } else {
                            imgData.kind = ImageKind.RGBA_32BPP;
                            imgData.data = new Uint8Array(drawWidth * drawHeight * 4);
                            alpha01 = 1;
                            maybeUndoPreblend = true;
                            this.fillOpacity(imgData.data, drawWidth, drawHeight, actualHeight, comps);
                        }
                        if (this.needsDecode) {
                            this.decodeBuffer(comps);
                        }
                        this.colorSpace.fillRgb(imgData.data, originalWidth, originalHeight, drawWidth, drawHeight, actualHeight, bpc, comps, alpha01);
                        if (maybeUndoPreblend) {
                            this.undoPreblend(imgData.data, drawWidth, actualHeight);
                        }
                        return imgData;
                    },
                    fillGrayBuffer: function PDFImage_fillGrayBuffer(buffer) {
                        var numComps = this.numComps;
                        if (numComps !== 1) {
                            error('Reading gray scale from a color image: ' + numComps);
                        }
                        var width = this.width;
                        var height = this.height;
                        var bpc = this.bpc;
                        var rowBytes = (width * numComps * bpc + 7) >> 3;
                        var imgArray = this.getImageBytes(height * rowBytes);
                        var comps = this.getComponents(imgArray);
                        var i, length;
                        if (bpc === 1) {
                            length = width * height;
                            if (this.needsDecode) {
                                for (i = 0; i < length; ++i) {
                                    buffer[i] = (comps[i] - 1) & 255;
                                }
                            } else {
                                for (i = 0; i < length; ++i) {
                                    buffer[i] = (-comps[i]) & 255;
                                }
                            }
                            return;
                        }
                        if (this.needsDecode) {
                            this.decodeBuffer(comps);
                        }
                        length = width * height;
                        var scale = 255 / ((1 << bpc) - 1);
                        for (i = 0; i < length; ++i) {
                            buffer[i] = (scale * comps[i]) | 0;
                        }
                    },
                    getImageBytes: function PDFImage_getImageBytes(length, drawWidth, drawHeight, forceRGB) {
                        this.image.reset();
                        this.image.drawWidth = drawWidth || this.width;
                        this.image.drawHeight = drawHeight || this.height;
                        this.image.forceRGB = !!forceRGB;
                        return this.image.getBytes(length);
                    }
                };
                return PDFImage;
            })();
            exports.PDFImage = PDFImage;
            coreColorSpace._setCoreImage(exports);
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsCorePattern = {}), root.pdfjsSharedUtil, root.pdfjsCorePrimitives, root.pdfjsCoreFunction, root.pdfjsCoreColorSpace);
            }
        }(this, function(exports, sharedUtil, corePrimitives, coreFunction, coreColorSpace) {
            var UNSUPPORTED_FEATURES = sharedUtil.UNSUPPORTED_FEATURES;
            var MissingDataException = sharedUtil.MissingDataException;
            var Util = sharedUtil.Util;
            var assert = sharedUtil.assert;
            var error = sharedUtil.error;
            var info = sharedUtil.info;
            var warn = sharedUtil.warn;
            var isStream = corePrimitives.isStream;
            var PDFFunction = coreFunction.PDFFunction;
            var ColorSpace = coreColorSpace.ColorSpace;
            var ShadingType = {
                FUNCTION_BASED: 1,
                AXIAL: 2,
                RADIAL: 3,
                FREE_FORM_MESH: 4,
                LATTICE_FORM_MESH: 5,
                COONS_PATCH_MESH: 6,
                TENSOR_PATCH_MESH: 7
            };
            var Pattern = (function PatternClosure() {
                function Pattern() {
                    error('should not call Pattern constructor');
                }
                Pattern.prototype = {
                    getPattern: function Pattern_getPattern(ctx) {
                        error('Should not call Pattern.getStyle: ' + ctx);
                    }
                };
                Pattern.parseShading = function Pattern_parseShading(shading, matrix, xref, res, handler) {
                    var dict = isStream(shading) ? shading.dict : shading;
                    var type = dict.get('ShadingType');
                    try {
                        switch (type) {
                            case ShadingType.AXIAL:
                            case ShadingType.RADIAL:
                                return new Shadings.RadialAxial(dict, matrix, xref, res);
                            case ShadingType.FREE_FORM_MESH:
                            case ShadingType.LATTICE_FORM_MESH:
                            case ShadingType.COONS_PATCH_MESH:
                            case ShadingType.TENSOR_PATCH_MESH:
                                return new Shadings.Mesh(shading, matrix, xref, res);
                            default:
                                throw new Error('Unsupported ShadingType: ' + type);
                        }
                    } catch (ex) {
                        if (ex instanceof MissingDataException) {
                            throw ex;
                        }
                        handler.send('UnsupportedFeature', {
                            featureId: UNSUPPORTED_FEATURES.shadingPattern
                        });
                        warn(ex);
                        return new Shadings.Dummy();
                    }
                };
                return Pattern;
            })();
            var Shadings = {};
            Shadings.SMALL_NUMBER = 1e-6;
            Shadings.RadialAxial = (function RadialAxialClosure() {
                function RadialAxial(dict, matrix, xref, res) {
                    this.matrix = matrix;
                    this.coordsArr = dict.get('Coords');
                    this.shadingType = dict.get('ShadingType');
                    this.type = 'Pattern';
                    var cs = dict.get('ColorSpace', 'CS');
                    cs = ColorSpace.parse(cs, xref, res);
                    this.cs = cs;
                    var t0 = 0.0,
                        t1 = 1.0;
                    if (dict.has('Domain')) {
                        var domainArr = dict.get('Domain');
                        t0 = domainArr[0];
                        t1 = domainArr[1];
                    }
                    var extendStart = false,
                        extendEnd = false;
                    if (dict.has('Extend')) {
                        var extendArr = dict.get('Extend');
                        extendStart = extendArr[0];
                        extendEnd = extendArr[1];
                    }
                    if (this.shadingType === ShadingType.RADIAL && (!extendStart || !extendEnd)) {
                        var x1 = this.coordsArr[0];
                        var y1 = this.coordsArr[1];
                        var r1 = this.coordsArr[2];
                        var x2 = this.coordsArr[3];
                        var y2 = this.coordsArr[4];
                        var r2 = this.coordsArr[5];
                        var distance = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
                        if (r1 <= r2 + distance && r2 <= r1 + distance) {
                            warn('Unsupported radial gradient.');
                        }
                    }
                    this.extendStart = extendStart;
                    this.extendEnd = extendEnd;
                    var fnObj = dict.get('Function');
                    var fn = PDFFunction.parseArray(xref, fnObj);
                    var diff = t1 - t0;
                    var step = diff / 10;
                    var colorStops = this.colorStops = [];
                    if (t0 >= t1 || step <= 0) {
                        info('Bad shading domain.');
                        return;
                    }
                    var color = new Float32Array(cs.numComps),
                        ratio = new Float32Array(1);
                    var rgbColor;
                    for (var i = t0; i <= t1; i += step) {
                        ratio[0] = i;
                        fn(ratio, 0, color, 0);
                        rgbColor = cs.getRgb(color, 0);
                        var cssColor = Util.makeCssRgb(rgbColor[0], rgbColor[1], rgbColor[2]);
                        colorStops.push([(i - t0) / diff, cssColor]);
                    }
                    var background = 'transparent';
                    if (dict.has('Background')) {
                        rgbColor = cs.getRgb(dict.get('Background'), 0);
                        background = Util.makeCssRgb(rgbColor[0], rgbColor[1], rgbColor[2]);
                    }
                    if (!extendStart) {
                        colorStops.unshift([0, background]);
                        colorStops[1][0] += Shadings.SMALL_NUMBER;
                    }
                    if (!extendEnd) {
                        colorStops[colorStops.length - 1][0] -= Shadings.SMALL_NUMBER;
                        colorStops.push([1, background]);
                    }
                    this.colorStops = colorStops;
                }
                RadialAxial.prototype = {
                    getIR: function RadialAxial_getIR() {
                        var coordsArr = this.coordsArr;
                        var shadingType = this.shadingType;
                        var type, p0, p1, r0, r1;
                        if (shadingType === ShadingType.AXIAL) {
                            p0 = [coordsArr[0], coordsArr[1]];
                            p1 = [coordsArr[2], coordsArr[3]];
                            r0 = null;
                            r1 = null;
                            type = 'axial';
                        } else if (shadingType === ShadingType.RADIAL) {
                            p0 = [coordsArr[0], coordsArr[1]];
                            p1 = [coordsArr[3], coordsArr[4]];
                            r0 = coordsArr[2];
                            r1 = coordsArr[5];
                            type = 'radial';
                        } else {
                            error('getPattern type unknown: ' + shadingType);
                        }
                        var matrix = this.matrix;
                        if (matrix) {
                            p0 = Util.applyTransform(p0, matrix);
                            p1 = Util.applyTransform(p1, matrix);
                            if (shadingType === ShadingType.RADIAL) {
                                var scale = Util.singularValueDecompose2dScale(matrix);
                                r0 *= scale[0];
                                r1 *= scale[1];
                            }
                        }
                        return ['RadialAxial', type, this.colorStops, p0, p1, r0, r1];
                    }
                };
                return RadialAxial;
            })();
            Shadings.Mesh = (function MeshClosure() {
                function MeshStreamReader(stream, context) {
                    this.stream = stream;
                    this.context = context;
                    this.buffer = 0;
                    this.bufferLength = 0;
                    var numComps = context.numComps;
                    this.tmpCompsBuf = new Float32Array(numComps);
                    var csNumComps = context.colorSpace.numComps;
                    this.tmpCsCompsBuf = context.colorFn ? new Float32Array(csNumComps) : this.tmpCompsBuf;
                }
                MeshStreamReader.prototype = {
                    get hasData() {
                        if (this.stream.end) {
                            return this.stream.pos < this.stream.end;
                        }
                        if (this.bufferLength > 0) {
                            return true;
                        }
                        var nextByte = this.stream.getByte();
                        if (nextByte < 0) {
                            return false;
                        }
                        this.buffer = nextByte;
                        this.bufferLength = 8;
                        return true;
                    },
                    readBits: function MeshStreamReader_readBits(n) {
                        var buffer = this.buffer;
                        var bufferLength = this.bufferLength;
                        if (n === 32) {
                            if (bufferLength === 0) {
                                return ((this.stream.getByte() << 24) | (this.stream.getByte() << 16) | (this.stream.getByte() << 8) | this.stream.getByte()) >>> 0;
                            }
                            buffer = (buffer << 24) | (this.stream.getByte() << 16) | (this.stream.getByte() << 8) | this.stream.getByte();
                            var nextByte = this.stream.getByte();
                            this.buffer = nextByte & ((1 << bufferLength) - 1);
                            return ((buffer << (8 - bufferLength)) | ((nextByte & 0xFF) >> bufferLength)) >>> 0;
                        }
                        if (n === 8 && bufferLength === 0) {
                            return this.stream.getByte();
                        }
                        while (bufferLength < n) {
                            buffer = (buffer << 8) | this.stream.getByte();
                            bufferLength += 8;
                        }
                        bufferLength -= n;
                        this.bufferLength = bufferLength;
                        this.buffer = buffer & ((1 << bufferLength) - 1);
                        return buffer >> bufferLength;
                    },
                    align: function MeshStreamReader_align() {
                        this.buffer = 0;
                        this.bufferLength = 0;
                    },
                    readFlag: function MeshStreamReader_readFlag() {
                        return this.readBits(this.context.bitsPerFlag);
                    },
                    readCoordinate: function MeshStreamReader_readCoordinate() {
                        var bitsPerCoordinate = this.context.bitsPerCoordinate;
                        var xi = this.readBits(bitsPerCoordinate);
                        var yi = this.readBits(bitsPerCoordinate);
                        var decode = this.context.decode;
                        var scale = bitsPerCoordinate < 32 ? 1 / ((1 << bitsPerCoordinate) - 1) : 2.3283064365386963e-10;
                        return [xi * scale * (decode[1] - decode[0]) + decode[0], yi * scale * (decode[3] - decode[2]) + decode[2]];
                    },
                    readComponents: function MeshStreamReader_readComponents() {
                        var numComps = this.context.numComps;
                        var bitsPerComponent = this.context.bitsPerComponent;
                        var scale = bitsPerComponent < 32 ? 1 / ((1 << bitsPerComponent) - 1) : 2.3283064365386963e-10;
                        var decode = this.context.decode;
                        var components = this.tmpCompsBuf;
                        for (var i = 0, j = 4; i < numComps; i++, j += 2) {
                            var ci = this.readBits(bitsPerComponent);
                            components[i] = ci * scale * (decode[j + 1] - decode[j]) + decode[j];
                        }
                        var color = this.tmpCsCompsBuf;
                        if (this.context.colorFn) {
                            this.context.colorFn(components, 0, color, 0);
                        }
                        return this.context.colorSpace.getRgb(color, 0);
                    }
                };

                function decodeType4Shading(mesh, reader) {
                    var coords = mesh.coords;
                    var colors = mesh.colors;
                    var operators = [];
                    var ps = [];
                    var verticesLeft = 0;
                    while (reader.hasData) {
                        var f = reader.readFlag();
                        var coord = reader.readCoordinate();
                        var color = reader.readComponents();
                        if (verticesLeft === 0) {
                            assert(0 <= f && f <= 2, 'Unknown type4 flag');
                            switch (f) {
                                case 0:
                                    verticesLeft = 3;
                                    break;
                                case 1:
                                    ps.push(ps[ps.length - 2], ps[ps.length - 1]);
                                    verticesLeft = 1;
                                    break;
                                case 2:
                                    ps.push(ps[ps.length - 3], ps[ps.length - 1]);
                                    verticesLeft = 1;
                                    break;
                            }
                            operators.push(f);
                        }
                        ps.push(coords.length);
                        coords.push(coord);
                        colors.push(color);
                        verticesLeft--;
                        reader.align();
                    }
                    mesh.figures.push({
                        type: 'triangles',
                        coords: new Int32Array(ps),
                        colors: new Int32Array(ps),
                    });
                }

                function decodeType5Shading(mesh, reader, verticesPerRow) {
                    var coords = mesh.coords;
                    var colors = mesh.colors;
                    var ps = [];
                    while (reader.hasData) {
                        var coord = reader.readCoordinate();
                        var color = reader.readComponents();
                        ps.push(coords.length);
                        coords.push(coord);
                        colors.push(color);
                    }
                    mesh.figures.push({
                        type: 'lattice',
                        coords: new Int32Array(ps),
                        colors: new Int32Array(ps),
                        verticesPerRow: verticesPerRow
                    });
                }
                var MIN_SPLIT_PATCH_CHUNKS_AMOUNT = 3;
                var MAX_SPLIT_PATCH_CHUNKS_AMOUNT = 20;
                var TRIANGLE_DENSITY = 20;
                var getB = (function getBClosure() {
                    function buildB(count) {
                        var lut = [];
                        for (var i = 0; i <= count; i++) {
                            var t = i / count,
                                t_ = 1 - t;
                            lut.push(new Float32Array([t_ * t_ * t_, 3 * t * t_ * t_, 3 * t * t * t_, t * t * t]));
                        }
                        return lut;
                    }
                    var cache = [];
                    return function getB(count) {
                        if (!cache[count]) {
                            cache[count] = buildB(count);
                        }
                        return cache[count];
                    };
                })();

                function buildFigureFromPatch(mesh, index) {
                    var figure = mesh.figures[index];
                    assert(figure.type === 'patch', 'Unexpected patch mesh figure');
                    var coords = mesh.coords,
                        colors = mesh.colors;
                    var pi = figure.coords;
                    var ci = figure.colors;
                    var figureMinX = Math.min(coords[pi[0]][0], coords[pi[3]][0], coords[pi[12]][0], coords[pi[15]][0]);
                    var figureMinY = Math.min(coords[pi[0]][1], coords[pi[3]][1], coords[pi[12]][1], coords[pi[15]][1]);
                    var figureMaxX = Math.max(coords[pi[0]][0], coords[pi[3]][0], coords[pi[12]][0], coords[pi[15]][0]);
                    var figureMaxY = Math.max(coords[pi[0]][1], coords[pi[3]][1], coords[pi[12]][1], coords[pi[15]][1]);
                    var splitXBy = Math.ceil((figureMaxX - figureMinX) * TRIANGLE_DENSITY / (mesh.bounds[2] - mesh.bounds[0]));
                    splitXBy = Math.max(MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(MAX_SPLIT_PATCH_CHUNKS_AMOUNT, splitXBy));
                    var splitYBy = Math.ceil((figureMaxY - figureMinY) * TRIANGLE_DENSITY / (mesh.bounds[3] - mesh.bounds[1]));
                    splitYBy = Math.max(MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(MAX_SPLIT_PATCH_CHUNKS_AMOUNT, splitYBy));
                    var verticesPerRow = splitXBy + 1;
                    var figureCoords = new Int32Array((splitYBy + 1) * verticesPerRow);
                    var figureColors = new Int32Array((splitYBy + 1) * verticesPerRow);
                    var k = 0;
                    var cl = new Uint8Array(3),
                        cr = new Uint8Array(3);
                    var c0 = colors[ci[0]],
                        c1 = colors[ci[1]],
                        c2 = colors[ci[2]],
                        c3 = colors[ci[3]];
                    var bRow = getB(splitYBy),
                        bCol = getB(splitXBy);
                    for (var row = 0; row <= splitYBy; row++) {
                        cl[0] = ((c0[0] * (splitYBy - row) + c2[0] * row) / splitYBy) | 0;
                        cl[1] = ((c0[1] * (splitYBy - row) + c2[1] * row) / splitYBy) | 0;
                        cl[2] = ((c0[2] * (splitYBy - row) + c2[2] * row) / splitYBy) | 0;
                        cr[0] = ((c1[0] * (splitYBy - row) + c3[0] * row) / splitYBy) | 0;
                        cr[1] = ((c1[1] * (splitYBy - row) + c3[1] * row) / splitYBy) | 0;
                        cr[2] = ((c1[2] * (splitYBy - row) + c3[2] * row) / splitYBy) | 0;
                        for (var col = 0; col <= splitXBy; col++, k++) {
                            if ((row === 0 || row === splitYBy) && (col === 0 || col === splitXBy)) {
                                continue;
                            }
                            var x = 0,
                                y = 0;
                            var q = 0;
                            for (var i = 0; i <= 3; i++) {
                                for (var j = 0; j <= 3; j++, q++) {
                                    var m = bRow[row][i] * bCol[col][j];
                                    x += coords[pi[q]][0] * m;
                                    y += coords[pi[q]][1] * m;
                                }
                            }
                            figureCoords[k] = coords.length;
                            coords.push([x, y]);
                            figureColors[k] = colors.length;
                            var newColor = new Uint8Array(3);
                            newColor[0] = ((cl[0] * (splitXBy - col) + cr[0] * col) / splitXBy) | 0;
                            newColor[1] = ((cl[1] * (splitXBy - col) + cr[1] * col) / splitXBy) | 0;
                            newColor[2] = ((cl[2] * (splitXBy - col) + cr[2] * col) / splitXBy) | 0;
                            colors.push(newColor);
                        }
                    }
                    figureCoords[0] = pi[0];
                    figureColors[0] = ci[0];
                    figureCoords[splitXBy] = pi[3];
                    figureColors[splitXBy] = ci[1];
                    figureCoords[verticesPerRow * splitYBy] = pi[12];
                    figureColors[verticesPerRow * splitYBy] = ci[2];
                    figureCoords[verticesPerRow * splitYBy + splitXBy] = pi[15];
                    figureColors[verticesPerRow * splitYBy + splitXBy] = ci[3];
                    mesh.figures[index] = {
                        type: 'lattice',
                        coords: figureCoords,
                        colors: figureColors,
                        verticesPerRow: verticesPerRow
                    };
                }

                function decodeType6Shading(mesh, reader) {
                    var coords = mesh.coords;
                    var colors = mesh.colors;
                    var ps = new Int32Array(16);
                    var cs = new Int32Array(4);
                    while (reader.hasData) {
                        var f = reader.readFlag();
                        assert(0 <= f && f <= 3, 'Unknown type6 flag');
                        var i, ii;
                        var pi = coords.length;
                        for (i = 0, ii = (f !== 0 ? 8 : 12); i < ii; i++) {
                            coords.push(reader.readCoordinate());
                        }
                        var ci = colors.length;
                        for (i = 0, ii = (f !== 0 ? 2 : 4); i < ii; i++) {
                            colors.push(reader.readComponents());
                        }
                        var tmp1, tmp2, tmp3, tmp4;
                        switch (f) {
                            case 0:
                                ps[12] = pi + 3;
                                ps[13] = pi + 4;
                                ps[14] = pi + 5;
                                ps[15] = pi + 6;
                                ps[8] = pi + 2;
                                ps[11] = pi + 7;
                                ps[4] = pi + 1;
                                ps[7] = pi + 8;
                                ps[0] = pi;
                                ps[1] = pi + 11;
                                ps[2] = pi + 10;
                                ps[3] = pi + 9;
                                cs[2] = ci + 1;
                                cs[3] = ci + 2;
                                cs[0] = ci;
                                cs[1] = ci + 3;
                                break;
                            case 1:
                                tmp1 = ps[12];
                                tmp2 = ps[13];
                                tmp3 = ps[14];
                                tmp4 = ps[15];
                                ps[12] = tmp4;
                                ps[13] = pi + 0;
                                ps[14] = pi + 1;
                                ps[15] = pi + 2;
                                ps[8] = tmp3;
                                ps[11] = pi + 3;
                                ps[4] = tmp2;
                                ps[7] = pi + 4;
                                ps[0] = tmp1;
                                ps[1] = pi + 7;
                                ps[2] = pi + 6;
                                ps[3] = pi + 5;
                                tmp1 = cs[2];
                                tmp2 = cs[3];
                                cs[2] = tmp2;
                                cs[3] = ci;
                                cs[0] = tmp1;
                                cs[1] = ci + 1;
                                break;
                            case 2:
                                tmp1 = ps[15];
                                tmp2 = ps[11];
                                ps[12] = ps[3];
                                ps[13] = pi + 0;
                                ps[14] = pi + 1;
                                ps[15] = pi + 2;
                                ps[8] = ps[7];
                                ps[11] = pi + 3;
                                ps[4] = tmp2;
                                ps[7] = pi + 4;
                                ps[0] = tmp1;
                                ps[1] = pi + 7;
                                ps[2] = pi + 6;
                                ps[3] = pi + 5;
                                tmp1 = cs[3];
                                cs[2] = cs[1];
                                cs[3] = ci;
                                cs[0] = tmp1;
                                cs[1] = ci + 1;
                                break;
                            case 3:
                                ps[12] = ps[0];
                                ps[13] = pi + 0;
                                ps[14] = pi + 1;
                                ps[15] = pi + 2;
                                ps[8] = ps[1];
                                ps[11] = pi + 3;
                                ps[4] = ps[2];
                                ps[7] = pi + 4;
                                ps[0] = ps[3];
                                ps[1] = pi + 7;
                                ps[2] = pi + 6;
                                ps[3] = pi + 5;
                                cs[2] = cs[0];
                                cs[3] = ci;
                                cs[0] = cs[1];
                                cs[1] = ci + 1;
                                break;
                        }
                        ps[5] = coords.length;
                        coords.push([(-4 * coords[ps[0]][0] - coords[ps[15]][0] +
                            6 * (coords[ps[4]][0] + coords[ps[1]][0]) -
                            2 * (coords[ps[12]][0] + coords[ps[3]][0]) +
                            3 * (coords[ps[13]][0] + coords[ps[7]][0])) / 9, (-4 * coords[ps[0]][1] - coords[ps[15]][1] +
                            6 * (coords[ps[4]][1] + coords[ps[1]][1]) -
                            2 * (coords[ps[12]][1] + coords[ps[3]][1]) +
                            3 * (coords[ps[13]][1] + coords[ps[7]][1])) / 9]);
                        ps[6] = coords.length;
                        coords.push([(-4 * coords[ps[3]][0] - coords[ps[12]][0] +
                            6 * (coords[ps[2]][0] + coords[ps[7]][0]) -
                            2 * (coords[ps[0]][0] + coords[ps[15]][0]) +
                            3 * (coords[ps[4]][0] + coords[ps[14]][0])) / 9, (-4 * coords[ps[3]][1] - coords[ps[12]][1] +
                            6 * (coords[ps[2]][1] + coords[ps[7]][1]) -
                            2 * (coords[ps[0]][1] + coords[ps[15]][1]) +
                            3 * (coords[ps[4]][1] + coords[ps[14]][1])) / 9]);
                        ps[9] = coords.length;
                        coords.push([(-4 * coords[ps[12]][0] - coords[ps[3]][0] +
                            6 * (coords[ps[8]][0] + coords[ps[13]][0]) -
                            2 * (coords[ps[0]][0] + coords[ps[15]][0]) +
                            3 * (coords[ps[11]][0] + coords[ps[1]][0])) / 9, (-4 * coords[ps[12]][1] - coords[ps[3]][1] +
                            6 * (coords[ps[8]][1] + coords[ps[13]][1]) -
                            2 * (coords[ps[0]][1] + coords[ps[15]][1]) +
                            3 * (coords[ps[11]][1] + coords[ps[1]][1])) / 9]);
                        ps[10] = coords.length;
                        coords.push([(-4 * coords[ps[15]][0] - coords[ps[0]][0] +
                            6 * (coords[ps[11]][0] + coords[ps[14]][0]) -
                            2 * (coords[ps[12]][0] + coords[ps[3]][0]) +
                            3 * (coords[ps[2]][0] + coords[ps[8]][0])) / 9, (-4 * coords[ps[15]][1] - coords[ps[0]][1] +
                            6 * (coords[ps[11]][1] + coords[ps[14]][1]) -
                            2 * (coords[ps[12]][1] + coords[ps[3]][1]) +
                            3 * (coords[ps[2]][1] + coords[ps[8]][1])) / 9]);
                        mesh.figures.push({
                            type: 'patch',
                            coords: new Int32Array(ps),
                            colors: new Int32Array(cs)
                        });
                    }
                }

                function decodeType7Shading(mesh, reader) {
                    var coords = mesh.coords;
                    var colors = mesh.colors;
                    var ps = new Int32Array(16);
                    var cs = new Int32Array(4);
                    while (reader.hasData) {
                        var f = reader.readFlag();
                        assert(0 <= f && f <= 3, 'Unknown type7 flag');
                        var i, ii;
                        var pi = coords.length;
                        for (i = 0, ii = (f !== 0 ? 12 : 16); i < ii; i++) {
                            coords.push(reader.readCoordinate());
                        }
                        var ci = colors.length;
                        for (i = 0, ii = (f !== 0 ? 2 : 4); i < ii; i++) {
                            colors.push(reader.readComponents());
                        }
                        var tmp1, tmp2, tmp3, tmp4;
                        switch (f) {
                            case 0:
                                ps[12] = pi + 3;
                                ps[13] = pi + 4;
                                ps[14] = pi + 5;
                                ps[15] = pi + 6;
                                ps[8] = pi + 2;
                                ps[9] = pi + 13;
                                ps[10] = pi + 14;
                                ps[11] = pi + 7;
                                ps[4] = pi + 1;
                                ps[5] = pi + 12;
                                ps[6] = pi + 15;
                                ps[7] = pi + 8;
                                ps[0] = pi;
                                ps[1] = pi + 11;
                                ps[2] = pi + 10;
                                ps[3] = pi + 9;
                                cs[2] = ci + 1;
                                cs[3] = ci + 2;
                                cs[0] = ci;
                                cs[1] = ci + 3;
                                break;
                            case 1:
                                tmp1 = ps[12];
                                tmp2 = ps[13];
                                tmp3 = ps[14];
                                tmp4 = ps[15];
                                ps[12] = tmp4;
                                ps[13] = pi + 0;
                                ps[14] = pi + 1;
                                ps[15] = pi + 2;
                                ps[8] = tmp3;
                                ps[9] = pi + 9;
                                ps[10] = pi + 10;
                                ps[11] = pi + 3;
                                ps[4] = tmp2;
                                ps[5] = pi + 8;
                                ps[6] = pi + 11;
                                ps[7] = pi + 4;
                                ps[0] = tmp1;
                                ps[1] = pi + 7;
                                ps[2] = pi + 6;
                                ps[3] = pi + 5;
                                tmp1 = cs[2];
                                tmp2 = cs[3];
                                cs[2] = tmp2;
                                cs[3] = ci;
                                cs[0] = tmp1;
                                cs[1] = ci + 1;
                                break;
                            case 2:
                                tmp1 = ps[15];
                                tmp2 = ps[11];
                                ps[12] = ps[3];
                                ps[13] = pi + 0;
                                ps[14] = pi + 1;
                                ps[15] = pi + 2;
                                ps[8] = ps[7];
                                ps[9] = pi + 9;
                                ps[10] = pi + 10;
                                ps[11] = pi + 3;
                                ps[4] = tmp2;
                                ps[5] = pi + 8;
                                ps[6] = pi + 11;
                                ps[7] = pi + 4;
                                ps[0] = tmp1;
                                ps[1] = pi + 7;
                                ps[2] = pi + 6;
                                ps[3] = pi + 5;
                                tmp1 = cs[3];
                                cs[2] = cs[1];
                                cs[3] = ci;
                                cs[0] = tmp1;
                                cs[1] = ci + 1;
                                break;
                            case 3:
                                ps[12] = ps[0];
                                ps[13] = pi + 0;
                                ps[14] = pi + 1;
                                ps[15] = pi + 2;
                                ps[8] = ps[1];
                                ps[9] = pi + 9;
                                ps[10] = pi + 10;
                                ps[11] = pi + 3;
                                ps[4] = ps[2];
                                ps[5] = pi + 8;
                                ps[6] = pi + 11;
                                ps[7] = pi + 4;
                                ps[0] = ps[3];
                                ps[1] = pi + 7;
                                ps[2] = pi + 6;
                                ps[3] = pi + 5;
                                cs[2] = cs[0];
                                cs[3] = ci;
                                cs[0] = cs[1];
                                cs[1] = ci + 1;
                                break;
                        }
                        mesh.figures.push({
                            type: 'patch',
                            coords: new Int32Array(ps),
                            colors: new Int32Array(cs)
                        });
                    }
                }

                function updateBounds(mesh) {
                    var minX = mesh.coords[0][0],
                        minY = mesh.coords[0][1],
                        maxX = minX,
                        maxY = minY;
                    for (var i = 1, ii = mesh.coords.length; i < ii; i++) {
                        var x = mesh.coords[i][0],
                            y = mesh.coords[i][1];
                        minX = minX > x ? x : minX;
                        minY = minY > y ? y : minY;
                        maxX = maxX < x ? x : maxX;
                        maxY = maxY < y ? y : maxY;
                    }
                    mesh.bounds = [minX, minY, maxX, maxY];
                }

                function packData(mesh) {
                    var i, ii, j, jj;
                    var coords = mesh.coords;
                    var coordsPacked = new Float32Array(coords.length * 2);
                    for (i = 0, j = 0, ii = coords.length; i < ii; i++) {
                        var xy = coords[i];
                        coordsPacked[j++] = xy[0];
                        coordsPacked[j++] = xy[1];
                    }
                    mesh.coords = coordsPacked;
                    var colors = mesh.colors;
                    var colorsPacked = new Uint8Array(colors.length * 3);
                    for (i = 0, j = 0, ii = colors.length; i < ii; i++) {
                        var c = colors[i];
                        colorsPacked[j++] = c[0];
                        colorsPacked[j++] = c[1];
                        colorsPacked[j++] = c[2];
                    }
                    mesh.colors = colorsPacked;
                    var figures = mesh.figures;
                    for (i = 0, ii = figures.length; i < ii; i++) {
                        var figure = figures[i],
                            ps = figure.coords,
                            cs = figure.colors;
                        for (j = 0, jj = ps.length; j < jj; j++) {
                            ps[j] *= 2;
                            cs[j] *= 3;
                        }
                    }
                }

                function Mesh(stream, matrix, xref, res) {
                    assert(isStream(stream), 'Mesh data is not a stream');
                    var dict = stream.dict;
                    this.matrix = matrix;
                    this.shadingType = dict.get('ShadingType');
                    this.type = 'Pattern';
                    this.bbox = dict.get('BBox');
                    var cs = dict.get('ColorSpace', 'CS');
                    cs = ColorSpace.parse(cs, xref, res);
                    this.cs = cs;
                    this.background = dict.has('Background') ? cs.getRgb(dict.get('Background'), 0) : null;
                    var fnObj = dict.get('Function');
                    var fn = fnObj ? PDFFunction.parseArray(xref, fnObj) : null;
                    this.coords = [];
                    this.colors = [];
                    this.figures = [];
                    var decodeContext = {
                        bitsPerCoordinate: dict.get('BitsPerCoordinate'),
                        bitsPerComponent: dict.get('BitsPerComponent'),
                        bitsPerFlag: dict.get('BitsPerFlag'),
                        decode: dict.get('Decode'),
                        colorFn: fn,
                        colorSpace: cs,
                        numComps: fn ? 1 : cs.numComps
                    };
                    var reader = new MeshStreamReader(stream, decodeContext);
                    var patchMesh = false;
                    switch (this.shadingType) {
                        case ShadingType.FREE_FORM_MESH:
                            decodeType4Shading(this, reader);
                            break;
                        case ShadingType.LATTICE_FORM_MESH:
                            var verticesPerRow = dict.get('VerticesPerRow') | 0;
                            assert(verticesPerRow >= 2, 'Invalid VerticesPerRow');
                            decodeType5Shading(this, reader, verticesPerRow);
                            break;
                        case ShadingType.COONS_PATCH_MESH:
                            decodeType6Shading(this, reader);
                            patchMesh = true;
                            break;
                        case ShadingType.TENSOR_PATCH_MESH:
                            decodeType7Shading(this, reader);
                            patchMesh = true;
                            break;
                        default:
                            error('Unsupported mesh type.');
                            break;
                    }
                    if (patchMesh) {
                        updateBounds(this);
                        for (var i = 0, ii = this.figures.length; i < ii; i++) {
                            buildFigureFromPatch(this, i);
                        }
                    }
                    updateBounds(this);
                    packData(this);
                }
                Mesh.prototype = {
                    getIR: function Mesh_getIR() {
                        return ['Mesh', this.shadingType, this.coords, this.colors, this.figures, this.bounds, this.matrix, this.bbox, this.background];
                    }
                };
                return Mesh;
            })();
            Shadings.Dummy = (function DummyClosure() {
                function Dummy() {
                    this.type = 'Pattern';
                }
                Dummy.prototype = {
                    getIR: function Dummy_getIR() {
                        return ['Dummy'];
                    }
                };
                return Dummy;
            })();

            function getTilingPatternIR(operatorList, dict, args) {
                var matrix = dict.get('Matrix');
                var bbox = dict.get('BBox');
                var xstep = dict.get('XStep');
                var ystep = dict.get('YStep');
                var paintType = dict.get('PaintType');
                var tilingType = dict.get('TilingType');
                return ['TilingPattern', args, operatorList, matrix, bbox, xstep, ystep, paintType, tilingType];
            }
            exports.Pattern = Pattern;
            exports.getTilingPatternIR = getTilingPatternIR;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsCoreEvaluator = {}), root.pdfjsSharedUtil, root.pdfjsCorePrimitives, root.pdfjsCoreStream, root.pdfjsCoreParser, root.pdfjsCoreImage, root.pdfjsCoreColorSpace, root.pdfjsCoreMurmurHash3, root.pdfjsCoreFonts, root.pdfjsCoreFunction, root.pdfjsCorePattern, root.pdfjsCoreCMap, root.pdfjsCoreMetrics, root.pdfjsCoreBidi);
            }
        }(this, function(exports, sharedUtil, corePrimitives, coreStream, coreParser, coreImage, coreColorSpace, coreMurmurHash3, coreFonts, coreFunction, corePattern, coreCMap, coreMetrics, coreBidi) {
            var FONT_IDENTITY_MATRIX = sharedUtil.FONT_IDENTITY_MATRIX;
            var IDENTITY_MATRIX = sharedUtil.IDENTITY_MATRIX;
            var UNSUPPORTED_FEATURES = sharedUtil.UNSUPPORTED_FEATURES;
            var ImageKind = sharedUtil.ImageKind;
            var OPS = sharedUtil.OPS;
            var TextRenderingMode = sharedUtil.TextRenderingMode;
            var Util = sharedUtil.Util;
            var assert = sharedUtil.assert;
            var createPromiseCapability = sharedUtil.createPromiseCapability;
            var error = sharedUtil.error;
            var info = sharedUtil.info;
            var isArray = sharedUtil.isArray;
            var isNum = sharedUtil.isNum;
            var isString = sharedUtil.isString;
            var warn = sharedUtil.warn;
            var Dict = corePrimitives.Dict;
            var Name = corePrimitives.Name;
            var isCmd = corePrimitives.isCmd;
            var isDict = corePrimitives.isDict;
            var isName = corePrimitives.isName;
            var isRef = corePrimitives.isRef;
            var isStream = corePrimitives.isStream;
            var DecodeStream = coreStream.DecodeStream;
            var JpegStream = coreStream.JpegStream;
            var Lexer = coreParser.Lexer;
            var Parser = coreParser.Parser;
            var isEOF = coreParser.isEOF;
            var PDFImage = coreImage.PDFImage;
            var ColorSpace = coreColorSpace.ColorSpace;
            var MurmurHash3_64 = coreMurmurHash3.MurmurHash3_64;
            var Encodings = coreFonts.Encodings;
            var ErrorFont = coreFonts.ErrorFont;
            var FontFlags = coreFonts.FontFlags;
            var Font = coreFonts.Font;
            var IdentityToUnicodeMap = coreFonts.IdentityToUnicodeMap;
            var NormalizedUnicodes = coreFonts.NormalizedUnicodes;
            var ToUnicodeMap = coreFonts.ToUnicodeMap;
            var getFontType = coreFonts.getFontType;
            var reverseIfRtl = coreFonts.reverseIfRtl;
            var serifFonts = coreFonts.serifFonts;
            var symbolsFonts = coreFonts.symbolsFonts;
            var stdFontMap = coreFonts.stdFontMap;
            var isPDFFunction = coreFunction.isPDFFunction;
            var PDFFunction = coreFunction.PDFFunction;
            var Pattern = corePattern.Pattern;
            var getTilingPatternIR = corePattern.getTilingPatternIR;
            var CMapFactory = coreCMap.CMapFactory;
            var IdentityCMap = coreCMap.IdentityCMap;
            var Metrics = coreMetrics.Metrics;
            var bidi = coreBidi.bidi;
            var PartialEvaluator = (function PartialEvaluatorClosure() {
                function PartialEvaluator(pdfManager, xref, handler, pageIndex, uniquePrefix, idCounters, fontCache) {
                    this.pdfManager = pdfManager;
                    this.xref = xref;
                    this.handler = handler;
                    this.pageIndex = pageIndex;
                    this.uniquePrefix = uniquePrefix;
                    this.idCounters = idCounters;
                    this.fontCache = fontCache;
                }
                var TIME_SLOT_DURATION_MS = 20;
                var CHECK_TIME_EVERY = 100;

                function TimeSlotManager() {
                    this.reset();
                }
                TimeSlotManager.prototype = {
                    check: function TimeSlotManager_check() {
                        if (++this.checked < CHECK_TIME_EVERY) {
                            return false;
                        }
                        this.checked = 0;
                        return this.endTime <= Date.now();
                    },
                    reset: function TimeSlotManager_reset() {
                        this.endTime = Date.now() + TIME_SLOT_DURATION_MS;
                        this.checked = 0;
                    }
                };
                var deferred = Promise.resolve();
                var TILING_PATTERN = 1,
                    SHADING_PATTERN = 2;
                PartialEvaluator.prototype = {
                    hasBlendModes: function PartialEvaluator_hasBlendModes(resources) {
                        if (!isDict(resources)) {
                            return false;
                        }
                        var processed = Object.create(null);
                        if (resources.objId) {
                            processed[resources.objId] = true;
                        }
                        var nodes = [resources];
                        while (nodes.length) {
                            var key;
                            var node = nodes.shift();
                            var graphicStates = node.get('ExtGState');
                            if (isDict(graphicStates)) {
                                graphicStates = graphicStates.getAll();
                                for (key in graphicStates) {
                                    var graphicState = graphicStates[key];
                                    var bm = graphicState['BM'];
                                    if (isName(bm) && bm.name !== 'Normal') {
                                        return true;
                                    }
                                }
                            }
                            var xObjects = node.get('XObject');
                            if (!isDict(xObjects)) {
                                continue;
                            }
                            xObjects = xObjects.getAll();
                            for (key in xObjects) {
                                var xObject = xObjects[key];
                                if (!isStream(xObject)) {
                                    continue;
                                }
                                if (xObject.dict.objId) {
                                    if (processed[xObject.dict.objId]) {
                                        continue;
                                    }
                                    processed[xObject.dict.objId] = true;
                                }
                                var xResources = xObject.dict.get('Resources');
                                if (isDict(xResources) && (!xResources.objId || !processed[xResources.objId])) {
                                    nodes.push(xResources);
                                    if (xResources.objId) {
                                        processed[xResources.objId] = true;
                                    }
                                }
                            }
                        }
                        return false;
                    },
                    buildFormXObject: function PartialEvaluator_buildFormXObject(resources, xobj, smask, operatorList, task, initialState) {
                        var matrix = xobj.dict.getArray('Matrix');
                        var bbox = xobj.dict.getArray('BBox');
                        var group = xobj.dict.get('Group');
                        if (group) {
                            var groupOptions = {
                                matrix: matrix,
                                bbox: bbox,
                                smask: smask,
                                isolated: false,
                                knockout: false
                            };
                            var groupSubtype = group.get('S');
                            var colorSpace;
                            if (isName(groupSubtype) && groupSubtype.name === 'Transparency') {
                                groupOptions.isolated = (group.get('I') || false);
                                groupOptions.knockout = (group.get('K') || false);
                                colorSpace = (group.has('CS') ? ColorSpace.parse(group.get('CS'), this.xref, resources) : null);
                            }
                            if (smask && smask.backdrop) {
                                colorSpace = colorSpace || ColorSpace.singletons.rgb;
                                smask.backdrop = colorSpace.getRgb(smask.backdrop, 0);
                            }
                            operatorList.addOp(OPS.beginGroup, [groupOptions]);
                        }
                        operatorList.addOp(OPS.paintFormXObjectBegin, [matrix, bbox]);
                        return this.getOperatorList(xobj, task, (xobj.dict.get('Resources') || resources), operatorList, initialState).then(function() {
                            operatorList.addOp(OPS.paintFormXObjectEnd, []);
                            if (group) {
                                operatorList.addOp(OPS.endGroup, [groupOptions]);
                            }
                        });
                    },
                    buildPaintImageXObject: function PartialEvaluator_buildPaintImageXObject(resources, image, inline, operatorList, cacheKey, imageCache) {
                        var self = this;
                        var dict = image.dict;
                        var w = dict.get('Width', 'W');
                        var h = dict.get('Height', 'H');
                        if (!(w && isNum(w)) || !(h && isNum(h))) {
                            warn('Image dimensions are missing, or not numbers.');
                            return;
                        }
                        if (PDFJS.maxImageSize !== -1 && w * h > PDFJS.maxImageSize) {
                            warn('Image exceeded maximum allowed size and was removed.');
                            return;
                        }
                        var imageMask = (dict.get('ImageMask', 'IM') || false);
                        var imgData, args;
                        if (imageMask) {
                            var width = dict.get('Width', 'W');
                            var height = dict.get('Height', 'H');
                            var bitStrideLength = (width + 7) >> 3;
                            var imgArray = image.getBytes(bitStrideLength * height);
                            var decode = dict.get('Decode', 'D');
                            var inverseDecode = (!!decode && decode[0] > 0);
                            imgData = PDFImage.createMask(imgArray, width, height, image instanceof DecodeStream, inverseDecode);
                            imgData.cached = true;
                            args = [imgData];
                            operatorList.addOp(OPS.paintImageMaskXObject, args);
                            if (cacheKey) {
                                imageCache[cacheKey] = {
                                    fn: OPS.paintImageMaskXObject,
                                    args: args
                                };
                            }
                            return;
                        }
                        var softMask = (dict.get('SMask', 'SM') || false);
                        var mask = (dict.get('Mask') || false);
                        var SMALL_IMAGE_DIMENSIONS = 200;
                        if (inline && !softMask && !mask && !(image instanceof JpegStream) && (w + h) < SMALL_IMAGE_DIMENSIONS) {
                            var imageObj = new PDFImage(this.xref, resources, image, inline, null, null);
                            imgData = imageObj.createImageData(true);
                            operatorList.addOp(OPS.paintInlineImageXObject, [imgData]);
                            return;
                        }
                        var uniquePrefix = (this.uniquePrefix || '');
                        var objId = 'img_' + uniquePrefix + (++this.idCounters.obj);
                        operatorList.addDependency(objId);
                        args = [objId, w, h];
                        if (!softMask && !mask && image instanceof JpegStream && image.isNativelySupported(this.xref, resources)) {
                            operatorList.addOp(OPS.paintJpegXObject, args);
                            this.handler.send('obj', [objId, this.pageIndex, 'JpegStream', image.getIR()]);
                            return;
                        }
                        PDFImage.buildImage(self.handler, self.xref, resources, image, inline).then(function(imageObj) {
                            var imgData = imageObj.createImageData(false);
                            self.handler.send('obj', [objId, self.pageIndex, 'Image', imgData], [imgData.data.buffer]);
                        }).then(undefined, function(reason) {
                            warn('Unable to decode image: ' + reason);
                            self.handler.send('obj', [objId, self.pageIndex, 'Image', null]);
                        });
                        operatorList.addOp(OPS.paintImageXObject, args);
                        if (cacheKey) {
                            imageCache[cacheKey] = {
                                fn: OPS.paintImageXObject,
                                args: args
                            };
                        }
                    },
                    handleSMask: function PartialEvaluator_handleSmask(smask, resources, operatorList, task, stateManager) {
                        var smaskContent = smask.get('G');
                        var smaskOptions = {
                            subtype: smask.get('S').name,
                            backdrop: smask.get('BC')
                        };
                        var transferObj = smask.get('TR');
                        if (isPDFFunction(transferObj)) {
                            var transferFn = PDFFunction.parse(this.xref, transferObj);
                            var transferMap = new Uint8Array(256);
                            var tmp = new Float32Array(1);
                            for (var i = 0; i < 255; i++) {
                                tmp[0] = i / 255;
                                transferFn(tmp, 0, tmp, 0);
                                transferMap[i] = (tmp[0] * 255) | 0;
                            }
                            smaskOptions.transferMap = transferMap;
                        }
                        return this.buildFormXObject(resources, smaskContent, smaskOptions, operatorList, task, stateManager.state.clone());
                    },
                    handleTilingType: function PartialEvaluator_handleTilingType(fn, args, resources, pattern, patternDict, operatorList, task) {
                        var tilingOpList = new OperatorList();
                        var resourcesArray = [patternDict.get('Resources'), resources];
                        var patternResources = Dict.merge(this.xref, resourcesArray);
                        return this.getOperatorList(pattern, task, patternResources, tilingOpList).then(function() {
                            operatorList.addDependencies(tilingOpList.dependencies);
                            operatorList.addOp(fn, getTilingPatternIR({
                                fnArray: tilingOpList.fnArray,
                                argsArray: tilingOpList.argsArray
                            }, patternDict, args));
                        });
                    },
                    handleSetFont: function PartialEvaluator_handleSetFont(resources, fontArgs, fontRef, operatorList, task, state) {
                        var fontName;
                        if (fontArgs) {
                            fontArgs = fontArgs.slice();
                            fontName = fontArgs[0].name;
                        }
                        var self = this;
                        return this.loadFont(fontName, fontRef, this.xref, resources).then(function(translated) {
                            if (!translated.font.isType3Font) {
                                return translated;
                            }
                            return translated.loadType3Data(self, resources, operatorList, task).then(function() {
                                return translated;
                            }, function(reason) {
                                self.handler.send('UnsupportedFeature', {
                                    featureId: UNSUPPORTED_FEATURES.font
                                });
                                return new TranslatedFont('g_font_error', new ErrorFont('Type3 font load error: ' + reason), translated.font);
                            });
                        }).then(function(translated) {
                            state.font = translated.font;
                            translated.send(self.handler);
                            return translated.loadedName;
                        });
                    },
                    handleText: function PartialEvaluator_handleText(chars, state) {
                        var font = state.font;
                        var glyphs = font.charsToGlyphs(chars);
                        var isAddToPathSet = !!(state.textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG);
                        if (font.data && (isAddToPathSet || PDFJS.disableFontFace)) {
                            var buildPath = function(fontChar) {
                                if (!font.renderer.hasBuiltPath(fontChar)) {
                                    var path = font.renderer.getPathJs(fontChar);
                                    this.handler.send('commonobj', [font.loadedName + '_path_' + fontChar, 'FontPath', path]);
                                }
                            }.bind(this);
                            for (var i = 0, ii = glyphs.length; i < ii; i++) {
                                var glyph = glyphs[i];
                                buildPath(glyph.fontChar);
                                var accent = glyph.accent;
                                if (accent && accent.fontChar) {
                                    buildPath(accent.fontChar);
                                }
                            }
                        }
                        return glyphs;
                    },
                    setGState: function PartialEvaluator_setGState(resources, gState, operatorList, task, xref, stateManager) {
                        var gStateObj = [];
                        var gStateMap = gState.map;
                        var self = this;
                        var promise = Promise.resolve();
                        for (var key in gStateMap) {
                            var value = gStateMap[key];
                            switch (key) {
                                case 'Type':
                                    break;
                                case 'LW':
                                case 'LC':
                                case 'LJ':
                                case 'ML':
                                case 'D':
                                case 'RI':
                                case 'FL':
                                case 'CA':
                                case 'ca':
                                    gStateObj.push([key, value]);
                                    break;
                                case 'Font':
                                    promise = promise.then(function() {
                                        return self.handleSetFont(resources, null, value[0], operatorList, task, stateManager.state).then(function(loadedName) {
                                            operatorList.addDependency(loadedName);
                                            gStateObj.push([key, [loadedName, value[1]]]);
                                        });
                                    });
                                    break;
                                case 'BM':
                                    gStateObj.push([key, value]);
                                    break;
                                case 'SMask':
                                    if (isName(value) && value.name === 'None') {
                                        gStateObj.push([key, false]);
                                        break;
                                    }
                                    var dict = xref.fetchIfRef(value);
                                    if (isDict(dict)) {
                                        promise = promise.then(function() {
                                            return self.handleSMask(dict, resources, operatorList, task, stateManager);
                                        });
                                        gStateObj.push([key, true]);
                                    } else {
                                        warn('Unsupported SMask type');
                                    }
                                    break;
                                case 'OP':
                                case 'op':
                                case 'OPM':
                                case 'BG':
                                case 'BG2':
                                case 'UCR':
                                case 'UCR2':
                                case 'TR':
                                case 'TR2':
                                case 'HT':
                                case 'SM':
                                case 'SA':
                                case 'AIS':
                                case 'TK':
                                    info('graphic state operator ' + key);
                                    break;
                                default:
                                    info('Unknown graphic state operator ' + key);
                                    break;
                            }
                        }
                        return promise.then(function() {
                            if (gStateObj.length >= 0) {
                                operatorList.addOp(OPS.setGState, [gStateObj]);
                            }
                        });
                    },
                    loadFont: function PartialEvaluator_loadFont(fontName, font, xref, resources) {
                        function errorFont() {
                            return Promise.resolve(new TranslatedFont('g_font_error', new ErrorFont('Font ' + fontName + ' is not available'), font));
                        }
                        var fontRef;
                        if (font) {
                            assert(isRef(font));
                            fontRef = font;
                        } else {
                            var fontRes = resources.get('Font');
                            if (fontRes) {
                                fontRef = fontRes.getRaw(fontName);
                            } else {
                                warn('fontRes not available');
                                return errorFont();
                            }
                        }
                        if (!fontRef) {
                            warn('fontRef not available');
                            return errorFont();
                        }
                        if (this.fontCache.has(fontRef)) {
                            return this.fontCache.get(fontRef);
                        }
                        font = xref.fetchIfRef(fontRef);
                        if (!isDict(font)) {
                            return errorFont();
                        }
                        if (font.translated) {
                            return font.translated;
                        }
                        var fontCapability = createPromiseCapability();
                        var preEvaluatedFont = this.preEvaluateFont(font, xref);
                        var descriptor = preEvaluatedFont.descriptor;
                        var fontID = fontRef.num + '_' + fontRef.gen;
                        if (isDict(descriptor)) {
                            if (!descriptor.fontAliases) {
                                descriptor.fontAliases = Object.create(null);
                            }
                            var fontAliases = descriptor.fontAliases;
                            var hash = preEvaluatedFont.hash;
                            if (fontAliases[hash]) {
                                var aliasFontRef = fontAliases[hash].aliasRef;
                                if (aliasFontRef && this.fontCache.has(aliasFontRef)) {
                                    this.fontCache.putAlias(fontRef, aliasFontRef);
                                    return this.fontCache.get(fontRef);
                                }
                            }
                            if (!fontAliases[hash]) {
                                fontAliases[hash] = {
                                    fontID: Font.getFontID()
                                };
                            }
                            fontAliases[hash].aliasRef = fontRef;
                            fontID = fontAliases[hash].fontID;
                        }
                        var fontRefIsDict = isDict(fontRef);
                        if (!fontRefIsDict) {
                            this.fontCache.put(fontRef, fontCapability.promise);
                        }
                        font.loadedName = 'g_' + this.pdfManager.docId + '_f' + (fontRefIsDict ? fontName.replace(/\W/g, '') : fontID);
                        font.translated = fontCapability.promise;
                        var translatedPromise;
                        try {
                            translatedPromise = Promise.resolve(this.translateFont(preEvaluatedFont, xref));
                        } catch (e) {
                            translatedPromise = Promise.reject(e);
                        }
                        var self = this;
                        translatedPromise.then(function(translatedFont) {
                            if (translatedFont.fontType !== undefined) {
                                var xrefFontStats = xref.stats.fontTypes;
                                xrefFontStats[translatedFont.fontType] = true;
                            }
                            fontCapability.resolve(new TranslatedFont(font.loadedName, translatedFont, font));
                        }, function(reason) {
                            self.handler.send('UnsupportedFeature', {
                                featureId: UNSUPPORTED_FEATURES.font
                            });
                            try {
                                var descriptor = preEvaluatedFont.descriptor;
                                var fontFile3 = descriptor && descriptor.get('FontFile3');
                                var subtype = fontFile3 && fontFile3.get('Subtype');
                                var fontType = getFontType(preEvaluatedFont.type, subtype && subtype.name);
                                var xrefFontStats = xref.stats.fontTypes;
                                xrefFontStats[fontType] = true;
                            } catch (ex) {}
                            fontCapability.resolve(new TranslatedFont(font.loadedName, new ErrorFont(reason instanceof Error ? reason.message : reason), font));
                        });
                        return fontCapability.promise;
                    },
                    buildPath: function PartialEvaluator_buildPath(operatorList, fn, args) {
                        var lastIndex = operatorList.length - 1;
                        if (!args) {
                            args = [];
                        }
                        if (lastIndex < 0 || operatorList.fnArray[lastIndex] !== OPS.constructPath) {
                            operatorList.addOp(OPS.constructPath, [
                                [fn], args
                            ]);
                        } else {
                            var opArgs = operatorList.argsArray[lastIndex];
                            opArgs[0].push(fn);
                            Array.prototype.push.apply(opArgs[1], args);
                        }
                    },
                    handleColorN: function PartialEvaluator_handleColorN(operatorList, fn, args, cs, patterns, resources, task, xref) {
                        var patternName = args[args.length - 1];
                        var pattern;
                        if (isName(patternName) && (pattern = patterns.get(patternName.name))) {
                            var dict = (isStream(pattern) ? pattern.dict : pattern);
                            var typeNum = dict.get('PatternType');
                            if (typeNum === TILING_PATTERN) {
                                var color = cs.base ? cs.base.getRgb(args, 0) : null;
                                return this.handleTilingType(fn, color, resources, pattern, dict, operatorList, task);
                            } else if (typeNum === SHADING_PATTERN) {
                                var shading = dict.get('Shading');
                                var matrix = dict.get('Matrix');
                                pattern = Pattern.parseShading(shading, matrix, xref, resources, this.handler);
                                operatorList.addOp(fn, pattern.getIR());
                                return Promise.resolve();
                            } else {
                                return Promise.reject('Unknown PatternType: ' + typeNum);
                            }
                        }
                        operatorList.addOp(fn, args);
                        return Promise.resolve();
                    },
                    getOperatorList: function PartialEvaluator_getOperatorList(stream, task, resources, operatorList, initialState) {
                        var self = this;
                        var xref = this.xref;
                        var imageCache = {};
                        assert(operatorList);
                        resources = (resources || Dict.empty);
                        var xobjs = (resources.get('XObject') || Dict.empty);
                        var patterns = (resources.get('Pattern') || Dict.empty);
                        var stateManager = new StateManager(initialState || new EvalState());
                        var preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
                        var timeSlotManager = new TimeSlotManager();
                        return new Promise(function next(resolve, reject) {
                            task.ensureNotTerminated();
                            timeSlotManager.reset();
                            var stop, operation = {},
                                i, ii, cs;
                            while (!(stop = timeSlotManager.check())) {
                                operation.args = null;
                                if (!(preprocessor.read(operation))) {
                                    break;
                                }
                                var args = operation.args;
                                var fn = operation.fn;
                                switch (fn | 0) {
                                    case OPS.paintXObject:
                                        if (args[0].code) {
                                            break;
                                        }
                                        var name = args[0].name;
                                        if (!name) {
                                            warn('XObject must be referred to by name.');
                                            continue;
                                        }
                                        if (imageCache[name] !== undefined) {
                                            operatorList.addOp(imageCache[name].fn, imageCache[name].args);
                                            args = null;
                                            continue;
                                        }
                                        var xobj = xobjs.get(name);
                                        if (xobj) {
                                            assert(isStream(xobj), 'XObject should be a stream');
                                            var type = xobj.dict.get('Subtype');
                                            assert(isName(type), 'XObject should have a Name subtype');
                                            if (type.name === 'Form') {
                                                stateManager.save();
                                                return self.buildFormXObject(resources, xobj, null, operatorList, task, stateManager.state.clone()).then(function() {
                                                    stateManager.restore();
                                                    next(resolve, reject);
                                                }, reject);
                                            } else if (type.name === 'Image') {
                                                self.buildPaintImageXObject(resources, xobj, false, operatorList, name, imageCache);
                                                args = null;
                                                continue;
                                            } else if (type.name === 'PS') {
                                                info('Ignored XObject subtype PS');
                                                continue;
                                            } else {
                                                error('Unhandled XObject subtype ' + type.name);
                                            }
                                        }
                                        break;
                                    case OPS.setFont:
                                        var fontSize = args[1];
                                        return self.handleSetFont(resources, args, null, operatorList, task, stateManager.state).then(function(loadedName) {
                                            operatorList.addDependency(loadedName);
                                            operatorList.addOp(OPS.setFont, [loadedName, fontSize]);
                                            next(resolve, reject);
                                        }, reject);
                                    case OPS.endInlineImage:
                                        var cacheKey = args[0].cacheKey;
                                        if (cacheKey) {
                                            var cacheEntry = imageCache[cacheKey];
                                            if (cacheEntry !== undefined) {
                                                operatorList.addOp(cacheEntry.fn, cacheEntry.args);
                                                args = null;
                                                continue;
                                            }
                                        }
                                        self.buildPaintImageXObject(resources, args[0], true, operatorList, cacheKey, imageCache);
                                        args = null;
                                        continue;
                                    case OPS.showText:
                                        args[0] = self.handleText(args[0], stateManager.state);
                                        break;
                                    case OPS.showSpacedText:
                                        var arr = args[0];
                                        var combinedGlyphs = [];
                                        var arrLength = arr.length;
                                        var state = stateManager.state;
                                        for (i = 0; i < arrLength; ++i) {
                                            var arrItem = arr[i];
                                            if (isString(arrItem)) {
                                                Array.prototype.push.apply(combinedGlyphs, self.handleText(arrItem, state));
                                            } else if (isNum(arrItem)) {
                                                combinedGlyphs.push(arrItem);
                                            }
                                        }
                                        args[0] = combinedGlyphs;
                                        fn = OPS.showText;
                                        break;
                                    case OPS.nextLineShowText:
                                        operatorList.addOp(OPS.nextLine);
                                        args[0] = self.handleText(args[0], stateManager.state);
                                        fn = OPS.showText;
                                        break;
                                    case OPS.nextLineSetSpacingShowText:
                                        operatorList.addOp(OPS.nextLine);
                                        operatorList.addOp(OPS.setWordSpacing, [args.shift()]);
                                        operatorList.addOp(OPS.setCharSpacing, [args.shift()]);
                                        args[0] = self.handleText(args[0], stateManager.state);
                                        fn = OPS.showText;
                                        break;
                                    case OPS.setTextRenderingMode:
                                        stateManager.state.textRenderingMode = args[0];
                                        break;
                                    case OPS.setFillColorSpace:
                                        stateManager.state.fillColorSpace = ColorSpace.parse(args[0], xref, resources);
                                        continue;
                                    case OPS.setStrokeColorSpace:
                                        stateManager.state.strokeColorSpace = ColorSpace.parse(args[0], xref, resources);
                                        continue;
                                    case OPS.setFillColor:
                                        cs = stateManager.state.fillColorSpace;
                                        args = cs.getRgb(args, 0);
                                        fn = OPS.setFillRGBColor;
                                        break;
                                    case OPS.setStrokeColor:
                                        cs = stateManager.state.strokeColorSpace;
                                        args = cs.getRgb(args, 0);
                                        fn = OPS.setStrokeRGBColor;
                                        break;
                                    case OPS.setFillGray:
                                        stateManager.state.fillColorSpace = ColorSpace.singletons.gray;
                                        args = ColorSpace.singletons.gray.getRgb(args, 0);
                                        fn = OPS.setFillRGBColor;
                                        break;
                                    case OPS.setStrokeGray:
                                        stateManager.state.strokeColorSpace = ColorSpace.singletons.gray;
                                        args = ColorSpace.singletons.gray.getRgb(args, 0);
                                        fn = OPS.setStrokeRGBColor;
                                        break;
                                    case OPS.setFillCMYKColor:
                                        stateManager.state.fillColorSpace = ColorSpace.singletons.cmyk;
                                        args = ColorSpace.singletons.cmyk.getRgb(args, 0);
                                        fn = OPS.setFillRGBColor;
                                        break;
                                    case OPS.setStrokeCMYKColor:
                                        stateManager.state.strokeColorSpace = ColorSpace.singletons.cmyk;
                                        args = ColorSpace.singletons.cmyk.getRgb(args, 0);
                                        fn = OPS.setStrokeRGBColor;
                                        break;
                                    case OPS.setFillRGBColor:
                                        stateManager.state.fillColorSpace = ColorSpace.singletons.rgb;
                                        args = ColorSpace.singletons.rgb.getRgb(args, 0);
                                        break;
                                    case OPS.setStrokeRGBColor:
                                        stateManager.state.strokeColorSpace = ColorSpace.singletons.rgb;
                                        args = ColorSpace.singletons.rgb.getRgb(args, 0);
                                        break;
                                    case OPS.setFillColorN:
                                        cs = stateManager.state.fillColorSpace;
                                        if (cs.name === 'Pattern') {
                                            return self.handleColorN(operatorList, OPS.setFillColorN, args, cs, patterns, resources, task, xref).then(function() {
                                                next(resolve, reject);
                                            }, reject);
                                        }
                                        args = cs.getRgb(args, 0);
                                        fn = OPS.setFillRGBColor;
                                        break;
                                    case OPS.setStrokeColorN:
                                        cs = stateManager.state.strokeColorSpace;
                                        if (cs.name === 'Pattern') {
                                            return self.handleColorN(operatorList, OPS.setStrokeColorN, args, cs, patterns, resources, task, xref).then(function() {
                                                next(resolve, reject);
                                            }, reject);
                                        }
                                        args = cs.getRgb(args, 0);
                                        fn = OPS.setStrokeRGBColor;
                                        break;
                                    case OPS.shadingFill:
                                        var shadingRes = resources.get('Shading');
                                        if (!shadingRes) {
                                            error('No shading resource found');
                                        }
                                        var shading = shadingRes.get(args[0].name);
                                        if (!shading) {
                                            error('No shading object found');
                                        }
                                        var shadingFill = Pattern.parseShading(shading, null, xref, resources, self.handler);
                                        var patternIR = shadingFill.getIR();
                                        args = [patternIR];
                                        fn = OPS.shadingFill;
                                        break;
                                    case OPS.setGState:
                                        var dictName = args[0];
                                        var extGState = resources.get('ExtGState');
                                        if (!isDict(extGState) || !extGState.has(dictName.name)) {
                                            break;
                                        }
                                        var gState = extGState.get(dictName.name);
                                        return self.setGState(resources, gState, operatorList, task, xref, stateManager).then(function() {
                                            next(resolve, reject);
                                        }, reject);
                                    case OPS.moveTo:
                                    case OPS.lineTo:
                                    case OPS.curveTo:
                                    case OPS.curveTo2:
                                    case OPS.curveTo3:
                                    case OPS.closePath:
                                        self.buildPath(operatorList, fn, args);
                                        continue;
                                    case OPS.rectangle:
                                        self.buildPath(operatorList, fn, args);
                                        continue;
                                    case OPS.markPoint:
                                    case OPS.markPointProps:
                                    case OPS.beginMarkedContent:
                                    case OPS.beginMarkedContentProps:
                                    case OPS.endMarkedContent:
                                    case OPS.beginCompat:
                                    case OPS.endCompat:
                                        continue;
                                    default:
                                }
                                operatorList.addOp(fn, args);
                            }
                            if (stop) {
                                deferred.then(function() {
                                    next(resolve, reject);
                                }, reject);
                                return;
                            }
                            for (i = 0, ii = preprocessor.savedStatesDepth; i < ii; i++) {
                                operatorList.addOp(OPS.restore, []);
                            }
                            resolve();
                        });
                    },
                    getTextContent: function PartialEvaluator_getTextContent(stream, task, resources, stateManager, normalizeWhitespace) {
                        stateManager = (stateManager || new StateManager(new TextState()));
                        var WhitespaceRegexp = /\s/g;
                        var textContent = {
                            items: [],
                            styles: Object.create(null)
                        };
                        var textContentItem = {
                            initialized: false,
                            str: [],
                            width: 0,
                            height: 0,
                            vertical: false,
                            lastAdvanceWidth: 0,
                            lastAdvanceHeight: 0,
                            textAdvanceScale: 0,
                            spaceWidth: 0,
                            fakeSpaceMin: Infinity,
                            fakeMultiSpaceMin: Infinity,
                            fakeMultiSpaceMax: -0,
                            textRunBreakAllowed: false,
                            transform: null,
                            fontName: null
                        };
                        var SPACE_FACTOR = 0.3;
                        var MULTI_SPACE_FACTOR = 1.5;
                        var MULTI_SPACE_FACTOR_MAX = 4;
                        var self = this;
                        var xref = this.xref;
                        resources = (xref.fetchIfRef(resources) || Dict.empty);
                        var xobjs = null;
                        var xobjsCache = {};
                        var preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
                        var textState;

                        function ensureTextContentItem() {
                            if (textContentItem.initialized) {
                                return textContentItem;
                            }
                            var font = textState.font;
                            if (!(font.loadedName in textContent.styles)) {
                                textContent.styles[font.loadedName] = {
                                    fontFamily: font.fallbackName,
                                    ascent: font.ascent,
                                    descent: font.descent,
                                    vertical: font.vertical
                                };
                            }
                            textContentItem.fontName = font.loadedName;
                            var tsm = [textState.fontSize * textState.textHScale, 0, 0, textState.fontSize, 0, textState.textRise];
                            if (font.isType3Font && textState.fontMatrix !== FONT_IDENTITY_MATRIX && textState.fontSize === 1) {
                                var glyphHeight = font.bbox[3] - font.bbox[1];
                                if (glyphHeight > 0) {
                                    glyphHeight = glyphHeight * textState.fontMatrix[3];
                                    tsm[3] *= glyphHeight;
                                }
                            }
                            var trm = Util.transform(textState.ctm, Util.transform(textState.textMatrix, tsm));
                            textContentItem.transform = trm;
                            if (!font.vertical) {
                                textContentItem.width = 0;
                                textContentItem.height = Math.sqrt(trm[2] * trm[2] + trm[3] * trm[3]);
                                textContentItem.vertical = false;
                            } else {
                                textContentItem.width = Math.sqrt(trm[0] * trm[0] + trm[1] * trm[1]);
                                textContentItem.height = 0;
                                textContentItem.vertical = true;
                            }
                            var a = textState.textLineMatrix[0];
                            var b = textState.textLineMatrix[1];
                            var scaleLineX = Math.sqrt(a * a + b * b);
                            a = textState.ctm[0];
                            b = textState.ctm[1];
                            var scaleCtmX = Math.sqrt(a * a + b * b);
                            textContentItem.textAdvanceScale = scaleCtmX * scaleLineX;
                            textContentItem.lastAdvanceWidth = 0;
                            textContentItem.lastAdvanceHeight = 0;
                            var spaceWidth = font.spaceWidth / 1000 * textState.fontSize;
                            if (spaceWidth) {
                                textContentItem.spaceWidth = spaceWidth;
                                textContentItem.fakeSpaceMin = spaceWidth * SPACE_FACTOR;
                                textContentItem.fakeMultiSpaceMin = spaceWidth * MULTI_SPACE_FACTOR;
                                textContentItem.fakeMultiSpaceMax = spaceWidth * MULTI_SPACE_FACTOR_MAX;
                                textContentItem.textRunBreakAllowed = !font.isMonospace;
                            } else {
                                textContentItem.spaceWidth = 0;
                                textContentItem.fakeSpaceMin = Infinity;
                                textContentItem.fakeMultiSpaceMin = Infinity;
                                textContentItem.fakeMultiSpaceMax = 0;
                                textContentItem.textRunBreakAllowed = false;
                            }
                            textContentItem.initialized = true;
                            return textContentItem;
                        }

                        function replaceWhitespace(str) {
                            var i = 0,
                                ii = str.length,
                                code;
                            while (i < ii && (code = str.charCodeAt(i)) >= 0x20 && code <= 0x7F) {
                                i++;
                            }
                            return (i < ii ? str.replace(WhitespaceRegexp, ' ') : str);
                        }

                        function runBidiTransform(textChunk) {
                            var str = textChunk.str.join('');
                            var bidiResult = PDFJS.bidi(str, -1, textChunk.vertical);
                            return {
                                str: (normalizeWhitespace ? replaceWhitespace(bidiResult.str) : bidiResult.str),
                                dir: bidiResult.dir,
                                width: textChunk.width,
                                height: textChunk.height,
                                transform: textChunk.transform,
                                fontName: textChunk.fontName
                            };
                        }

                        function handleSetFont(fontName, fontRef) {
                            return self.loadFont(fontName, fontRef, xref, resources).then(function(translated) {
                                textState.font = translated.font;
                                textState.fontMatrix = translated.font.fontMatrix || FONT_IDENTITY_MATRIX;
                            });
                        }

                        function buildTextContentItem(chars) {
                            var font = textState.font;
                            var textChunk = ensureTextContentItem();
                            var width = 0;
                            var height = 0;
                            var glyphs = font.charsToGlyphs(chars);
                            var defaultVMetrics = font.defaultVMetrics;
                            for (var i = 0; i < glyphs.length; i++) {
                                var glyph = glyphs[i];
                                var vMetricX = null;
                                var vMetricY = null;
                                var glyphWidth = null;
                                if (font.vertical) {
                                    if (glyph.vmetric) {
                                        glyphWidth = glyph.vmetric[0];
                                        vMetricX = glyph.vmetric[1];
                                        vMetricY = glyph.vmetric[2];
                                    } else {
                                        glyphWidth = glyph.width;
                                        vMetricX = glyph.width * 0.5;
                                        vMetricY = defaultVMetrics[2];
                                    }
                                } else {
                                    glyphWidth = glyph.width;
                                }
                                var glyphUnicode = glyph.unicode;
                                if (NormalizedUnicodes[glyphUnicode] !== undefined) {
                                    glyphUnicode = NormalizedUnicodes[glyphUnicode];
                                }
                                glyphUnicode = reverseIfRtl(glyphUnicode);
                                var charSpacing = textState.charSpacing;
                                if (glyph.isSpace) {
                                    var wordSpacing = textState.wordSpacing;
                                    charSpacing += wordSpacing;
                                    if (wordSpacing > 0) {
                                        addFakeSpaces(wordSpacing, textChunk.str);
                                    }
                                }
                                var tx = 0;
                                var ty = 0;
                                if (!font.vertical) {
                                    var w0 = glyphWidth * textState.fontMatrix[0];
                                    tx = (w0 * textState.fontSize + charSpacing) * textState.textHScale;
                                    width += tx;
                                } else {
                                    var w1 = glyphWidth * textState.fontMatrix[0];
                                    ty = w1 * textState.fontSize + charSpacing;
                                    height += ty;
                                }
                                textState.translateTextMatrix(tx, ty);
                                textChunk.str.push(glyphUnicode);
                            }
                            if (!font.vertical) {
                                textChunk.lastAdvanceWidth = width;
                                textChunk.width += width * textChunk.textAdvanceScale;
                            } else {
                                textChunk.lastAdvanceHeight = height;
                                textChunk.height += Math.abs(height * textChunk.textAdvanceScale);
                            }
                            return textChunk;
                        }

                        function addFakeSpaces(width, strBuf) {
                            if (width < textContentItem.fakeSpaceMin) {
                                return;
                            }
                            if (width < textContentItem.fakeMultiSpaceMin) {
                                strBuf.push(' ');
                                return;
                            }
                            var fakeSpaces = Math.round(width / textContentItem.spaceWidth);
                            while (fakeSpaces-- > 0) {
                                strBuf.push(' ');
                            }
                        }

                        function flushTextContentItem() {
                            if (!textContentItem.initialized) {
                                return;
                            }
                            textContent.items.push(runBidiTransform(textContentItem));
                            textContentItem.initialized = false;
                            textContentItem.str.length = 0;
                        }
                        var timeSlotManager = new TimeSlotManager();
                        return new Promise(function next(resolve, reject) {
                            task.ensureNotTerminated();
                            timeSlotManager.reset();
                            var stop, operation = {},
                                args = [];
                            while (!(stop = timeSlotManager.check())) {
                                args.length = 0;
                                operation.args = args;
                                if (!(preprocessor.read(operation))) {
                                    break;
                                }
                                textState = stateManager.state;
                                var fn = operation.fn;
                                args = operation.args;
                                var advance;
                                switch (fn | 0) {
                                    case OPS.setFont:
                                        flushTextContentItem();
                                        textState.fontSize = args[1];
                                        return handleSetFont(args[0].name).then(function() {
                                            next(resolve, reject);
                                        }, reject);
                                    case OPS.setTextRise:
                                        flushTextContentItem();
                                        textState.textRise = args[0];
                                        break;
                                    case OPS.setHScale:
                                        flushTextContentItem();
                                        textState.textHScale = args[0] / 100;
                                        break;
                                    case OPS.setLeading:
                                        flushTextContentItem();
                                        textState.leading = args[0];
                                        break;
                                    case OPS.moveText:
                                        var isSameTextLine = !textState.font ? false : ((textState.font.vertical ? args[0] : args[1]) === 0);
                                        advance = args[0] - args[1];
                                        if (isSameTextLine && textContentItem.initialized && advance > 0 && advance <= textContentItem.fakeMultiSpaceMax) {
                                            textState.translateTextLineMatrix(args[0], args[1]);
                                            textContentItem.width += (args[0] - textContentItem.lastAdvanceWidth);
                                            textContentItem.height += (args[1] - textContentItem.lastAdvanceHeight);
                                            var diff = (args[0] - textContentItem.lastAdvanceWidth) -
                                                (args[1] - textContentItem.lastAdvanceHeight);
                                            addFakeSpaces(diff, textContentItem.str);
                                            break;
                                        }
                                        flushTextContentItem();
                                        textState.translateTextLineMatrix(args[0], args[1]);
                                        textState.textMatrix = textState.textLineMatrix.slice();
                                        break;
                                    case OPS.setLeadingMoveText:
                                        flushTextContentItem();
                                        textState.leading = -args[1];
                                        textState.translateTextLineMatrix(args[0], args[1]);
                                        textState.textMatrix = textState.textLineMatrix.slice();
                                        break;
                                    case OPS.nextLine:
                                        flushTextContentItem();
                                        textState.carriageReturn();
                                        break;
                                    case OPS.setTextMatrix:
                                        flushTextContentItem();
                                        textState.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                                        textState.setTextLineMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                                        break;
                                    case OPS.setCharSpacing:
                                        textState.charSpacing = args[0];
                                        break;
                                    case OPS.setWordSpacing:
                                        textState.wordSpacing = args[0];
                                        break;
                                    case OPS.beginText:
                                        flushTextContentItem();
                                        textState.textMatrix = IDENTITY_MATRIX.slice();
                                        textState.textLineMatrix = IDENTITY_MATRIX.slice();
                                        break;
                                    case OPS.showSpacedText:
                                        var items = args[0];
                                        var offset;
                                        for (var j = 0, jj = items.length; j < jj; j++) {
                                            if (typeof items[j] === 'string') {
                                                buildTextContentItem(items[j]);
                                            } else {
                                                ensureTextContentItem();
                                                advance = items[j] * textState.fontSize / 1000;
                                                var breakTextRun = false;
                                                if (textState.font.vertical) {
                                                    offset = advance * (textState.textHScale * textState.textMatrix[2] +
                                                        textState.textMatrix[3]);
                                                    textState.translateTextMatrix(0, advance);
                                                    breakTextRun = textContentItem.textRunBreakAllowed && advance > textContentItem.fakeMultiSpaceMax;
                                                    if (!breakTextRun) {
                                                        textContentItem.height += offset;
                                                    }
                                                } else {
                                                    advance = -advance;
                                                    offset = advance * (textState.textHScale * textState.textMatrix[0] +
                                                        textState.textMatrix[1]);
                                                    textState.translateTextMatrix(advance, 0);
                                                    breakTextRun = textContentItem.textRunBreakAllowed && advance > textContentItem.fakeMultiSpaceMax;
                                                    if (!breakTextRun) {
                                                        textContentItem.width += offset;
                                                    }
                                                }
                                                if (breakTextRun) {
                                                    flushTextContentItem();
                                                } else if (advance > 0) {
                                                    addFakeSpaces(advance, textContentItem.str);
                                                }
                                            }
                                        }
                                        break;
                                    case OPS.showText:
                                        buildTextContentItem(args[0]);
                                        break;
                                    case OPS.nextLineShowText:
                                        flushTextContentItem();
                                        textState.carriageReturn();
                                        buildTextContentItem(args[0]);
                                        break;
                                    case OPS.nextLineSetSpacingShowText:
                                        flushTextContentItem();
                                        textState.wordSpacing = args[0];
                                        textState.charSpacing = args[1];
                                        textState.carriageReturn();
                                        buildTextContentItem(args[2]);
                                        break;
                                    case OPS.paintXObject:
                                        flushTextContentItem();
                                        if (args[0].code) {
                                            break;
                                        }
                                        if (!xobjs) {
                                            xobjs = (resources.get('XObject') || Dict.empty);
                                        }
                                        var name = args[0].name;
                                        if (xobjsCache.key === name) {
                                            if (xobjsCache.texts) {
                                                Util.appendToArray(textContent.items, xobjsCache.texts.items);
                                                Util.extendObj(textContent.styles, xobjsCache.texts.styles);
                                            }
                                            break;
                                        }
                                        var xobj = xobjs.get(name);
                                        if (!xobj) {
                                            break;
                                        }
                                        assert(isStream(xobj), 'XObject should be a stream');
                                        var type = xobj.dict.get('Subtype');
                                        assert(isName(type), 'XObject should have a Name subtype');
                                        if ('Form' !== type.name) {
                                            xobjsCache.key = name;
                                            xobjsCache.texts = null;
                                            break;
                                        }
                                        stateManager.save();
                                        var matrix = xobj.dict.get('Matrix');
                                        if (isArray(matrix) && matrix.length === 6) {
                                            stateManager.transform(matrix);
                                        }
                                        return self.getTextContent(xobj, task, xobj.dict.get('Resources') || resources, stateManager, normalizeWhitespace).then(function(formTextContent) {
                                            Util.appendToArray(textContent.items, formTextContent.items);
                                            Util.extendObj(textContent.styles, formTextContent.styles);
                                            stateManager.restore();
                                            xobjsCache.key = name;
                                            xobjsCache.texts = formTextContent;
                                            next(resolve, reject);
                                        }, reject);
                                    case OPS.setGState:
                                        flushTextContentItem();
                                        var dictName = args[0];
                                        var extGState = resources.get('ExtGState');
                                        if (!isDict(extGState) || !extGState.has(dictName.name)) {
                                            break;
                                        }
                                        var gsStateMap = extGState.get(dictName.name);
                                        var gsStateFont = null;
                                        for (var key in gsStateMap) {
                                            if (key === 'Font') {
                                                assert(!gsStateFont);
                                                gsStateFont = gsStateMap[key];
                                            }
                                        }
                                        if (gsStateFont) {
                                            textState.fontSize = gsStateFont[1];
                                            return handleSetFont(gsStateFont[0]).then(function() {
                                                next(resolve, reject);
                                            }, reject);
                                        }
                                        break;
                                }
                            }
                            if (stop) {
                                deferred.then(function() {
                                    next(resolve, reject);
                                }, reject);
                                return;
                            }
                            flushTextContentItem();
                            resolve(textContent);
                        });
                    },
                    extractDataStructures: function
                    partialEvaluatorExtractDataStructures(dict, baseDict, xref, properties) {
                        var toUnicode = (dict.get('ToUnicode') || baseDict.get('ToUnicode'));
                        if (toUnicode) {
                            properties.toUnicode = this.readToUnicode(toUnicode);
                        }
                        if (properties.composite) {
                            var cidSystemInfo = dict.get('CIDSystemInfo');
                            if (isDict(cidSystemInfo)) {
                                properties.cidSystemInfo = {
                                    registry: cidSystemInfo.get('Registry'),
                                    ordering: cidSystemInfo.get('Ordering'),
                                    supplement: cidSystemInfo.get('Supplement')
                                };
                            }
                            var cidToGidMap = dict.get('CIDToGIDMap');
                            if (isStream(cidToGidMap)) {
                                properties.cidToGidMap = this.readCidToGidMap(cidToGidMap);
                            }
                        }
                        var differences = [];
                        var baseEncodingName = null;
                        var encoding;
                        if (dict.has('Encoding')) {
                            encoding = dict.get('Encoding');
                            if (isDict(encoding)) {
                                baseEncodingName = encoding.get('BaseEncoding');
                                baseEncodingName = (isName(baseEncodingName) ? baseEncodingName.name : null);
                                if (encoding.has('Differences')) {
                                    var diffEncoding = encoding.get('Differences');
                                    var index = 0;
                                    for (var j = 0, jj = diffEncoding.length; j < jj; j++) {
                                        var data = diffEncoding[j];
                                        if (isNum(data)) {
                                            index = data;
                                        } else if (isName(data)) {
                                            differences[index++] = data.name;
                                        } else if (isRef(data)) {
                                            diffEncoding[j--] = xref.fetch(data);
                                            continue;
                                        } else {
                                            error('Invalid entry in \'Differences\' array: ' + data);
                                        }
                                    }
                                }
                            } else if (isName(encoding)) {
                                baseEncodingName = encoding.name;
                            } else {
                                error('Encoding is not a Name nor a Dict');
                            }
                            if ((baseEncodingName !== 'MacRomanEncoding' && baseEncodingName !== 'MacExpertEncoding' && baseEncodingName !== 'WinAnsiEncoding')) {
                                baseEncodingName = null;
                            }
                        }
                        if (baseEncodingName) {
                            properties.defaultEncoding = Encodings[baseEncodingName].slice();
                        } else {
                            encoding = (properties.type === 'TrueType' ? Encodings.WinAnsiEncoding : Encodings.StandardEncoding);
                            if (!!(properties.flags & FontFlags.Symbolic)) {
                                encoding = Encodings.MacRomanEncoding;
                                if (!properties.file) {
                                    if (/Symbol/i.test(properties.name)) {
                                        encoding = Encodings.SymbolSetEncoding;
                                    } else if (/Dingbats/i.test(properties.name)) {
                                        encoding = Encodings.ZapfDingbatsEncoding;
                                    }
                                }
                            }
                            properties.defaultEncoding = encoding;
                        }
                        properties.differences = differences;
                        properties.baseEncodingName = baseEncodingName;
                        properties.dict = dict;
                    },
                    readToUnicode: function PartialEvaluator_readToUnicode(toUnicode) {
                        var cmap, cmapObj = toUnicode;
                        if (isName(cmapObj)) {
                            cmap = CMapFactory.create(cmapObj, {
                                url: PDFJS.cMapUrl,
                                packed: PDFJS.cMapPacked
                            }, null);
                            if (cmap instanceof IdentityCMap) {
                                return new IdentityToUnicodeMap(0, 0xFFFF);
                            }
                            return new ToUnicodeMap(cmap.getMap());
                        } else if (isStream(cmapObj)) {
                            cmap = CMapFactory.create(cmapObj, {
                                url: PDFJS.cMapUrl,
                                packed: PDFJS.cMapPacked
                            }, null);
                            if (cmap instanceof IdentityCMap) {
                                return new IdentityToUnicodeMap(0, 0xFFFF);
                            }
                            var map = new Array(cmap.length);
                            cmap.forEach(function(charCode, token) {
                                var str = [];
                                for (var k = 0; k < token.length; k += 2) {
                                    var w1 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);
                                    if ((w1 & 0xF800) !== 0xD800) {
                                        str.push(w1);
                                        continue;
                                    }
                                    k += 2;
                                    var w2 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);
                                    str.push(((w1 & 0x3ff) << 10) + (w2 & 0x3ff) + 0x10000);
                                }
                                map[charCode] = String.fromCharCode.apply(String, str);
                            });
                            return new ToUnicodeMap(map);
                        }
                        return null;
                    },
                    readCidToGidMap: function PartialEvaluator_readCidToGidMap(cidToGidStream) {
                        var glyphsData = cidToGidStream.getBytes();
                        var result = [];
                        for (var j = 0, jj = glyphsData.length; j < jj; j++) {
                            var glyphID = (glyphsData[j++] << 8) | glyphsData[j];
                            if (glyphID === 0) {
                                continue;
                            }
                            var code = j >> 1;
                            result[code] = glyphID;
                        }
                        return result;
                    },
                    extractWidths: function PartialEvaluator_extractWidths(dict, xref, descriptor, properties) {
                        var glyphsWidths = [];
                        var defaultWidth = 0;
                        var glyphsVMetrics = [];
                        var defaultVMetrics;
                        var i, ii, j, jj, start, code, widths;
                        if (properties.composite) {
                            defaultWidth = dict.get('DW') || 1000;
                            widths = dict.get('W');
                            if (widths) {
                                for (i = 0, ii = widths.length; i < ii; i++) {
                                    start = widths[i++];
                                    code = xref.fetchIfRef(widths[i]);
                                    if (isArray(code)) {
                                        for (j = 0, jj = code.length; j < jj; j++) {
                                            glyphsWidths[start++] = code[j];
                                        }
                                    } else {
                                        var width = widths[++i];
                                        for (j = start; j <= code; j++) {
                                            glyphsWidths[j] = width;
                                        }
                                    }
                                }
                            }
                            if (properties.vertical) {
                                var vmetrics = (dict.get('DW2') || [880, -1000]);
                                defaultVMetrics = [vmetrics[1], defaultWidth * 0.5, vmetrics[0]];
                                vmetrics = dict.get('W2');
                                if (vmetrics) {
                                    for (i = 0, ii = vmetrics.length; i < ii; i++) {
                                        start = vmetrics[i++];
                                        code = xref.fetchIfRef(vmetrics[i]);
                                        if (isArray(code)) {
                                            for (j = 0, jj = code.length; j < jj; j++) {
                                                glyphsVMetrics[start++] = [code[j++], code[j++], code[j]];
                                            }
                                        } else {
                                            var vmetric = [vmetrics[++i], vmetrics[++i], vmetrics[++i]];
                                            for (j = start; j <= code; j++) {
                                                glyphsVMetrics[j] = vmetric;
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            var firstChar = properties.firstChar;
                            widths = dict.get('Widths');
                            if (widths) {
                                j = firstChar;
                                for (i = 0, ii = widths.length; i < ii; i++) {
                                    glyphsWidths[j++] = widths[i];
                                }
                                defaultWidth = (parseFloat(descriptor.get('MissingWidth')) || 0);
                            } else {
                                var baseFontName = dict.get('BaseFont');
                                if (isName(baseFontName)) {
                                    var metrics = this.getBaseFontMetrics(baseFontName.name);
                                    glyphsWidths = this.buildCharCodeToWidth(metrics.widths, properties);
                                    defaultWidth = metrics.defaultWidth;
                                }
                            }
                        }
                        var isMonospace = true;
                        var firstWidth = defaultWidth;
                        for (var glyph in glyphsWidths) {
                            var glyphWidth = glyphsWidths[glyph];
                            if (!glyphWidth) {
                                continue;
                            }
                            if (!firstWidth) {
                                firstWidth = glyphWidth;
                                continue;
                            }
                            if (firstWidth !== glyphWidth) {
                                isMonospace = false;
                                break;
                            }
                        }
                        if (isMonospace) {
                            properties.flags |= FontFlags.FixedPitch;
                        }
                        properties.defaultWidth = defaultWidth;
                        properties.widths = glyphsWidths;
                        properties.defaultVMetrics = defaultVMetrics;
                        properties.vmetrics = glyphsVMetrics;
                    },
                    isSerifFont: function PartialEvaluator_isSerifFont(baseFontName) {
                        var fontNameWoStyle = baseFontName.split('-')[0];
                        return (fontNameWoStyle in serifFonts) || (fontNameWoStyle.search(/serif/gi) !== -1);
                    },
                    getBaseFontMetrics: function PartialEvaluator_getBaseFontMetrics(name) {
                        var defaultWidth = 0;
                        var widths = [];
                        var monospace = false;
                        var lookupName = (stdFontMap[name] || name);
                        if (!(lookupName in Metrics)) {
                            if (this.isSerifFont(name)) {
                                lookupName = 'Times-Roman';
                            } else {
                                lookupName = 'Helvetica';
                            }
                        }
                        var glyphWidths = Metrics[lookupName];
                        if (isNum(glyphWidths)) {
                            defaultWidth = glyphWidths;
                            monospace = true;
                        } else {
                            widths = glyphWidths;
                        }
                        return {
                            defaultWidth: defaultWidth,
                            monospace: monospace,
                            widths: widths
                        };
                    },
                    buildCharCodeToWidth: function PartialEvaluator_bulildCharCodeToWidth(widthsByGlyphName, properties) {
                        var widths = Object.create(null);
                        var differences = properties.differences;
                        var encoding = properties.defaultEncoding;
                        for (var charCode = 0; charCode < 256; charCode++) {
                            if (charCode in differences && widthsByGlyphName[differences[charCode]]) {
                                widths[charCode] = widthsByGlyphName[differences[charCode]];
                                continue;
                            }
                            if (charCode in encoding && widthsByGlyphName[encoding[charCode]]) {
                                widths[charCode] = widthsByGlyphName[encoding[charCode]];
                                continue;
                            }
                        }
                        return widths;
                    },
                    preEvaluateFont: function PartialEvaluator_preEvaluateFont(dict, xref) {
                        var baseDict = dict;
                        var type = dict.get('Subtype');
                        assert(isName(type), 'invalid font Subtype');
                        var composite = false;
                        var uint8array;
                        if (type.name === 'Type0') {
                            var df = dict.get('DescendantFonts');
                            if (!df) {
                                error('Descendant fonts are not specified');
                            }
                            dict = (isArray(df) ? xref.fetchIfRef(df[0]) : df);
                            type = dict.get('Subtype');
                            assert(isName(type), 'invalid font Subtype');
                            composite = true;
                        }
                        var descriptor = dict.get('FontDescriptor');
                        if (descriptor) {
                            var hash = new MurmurHash3_64();
                            var encoding = baseDict.getRaw('Encoding');
                            if (isName(encoding)) {
                                hash.update(encoding.name);
                            } else if (isRef(encoding)) {
                                hash.update(encoding.num + '_' + encoding.gen);
                            } else if (isDict(encoding)) {
                                var keys = encoding.getKeys();
                                for (var i = 0, ii = keys.length; i < ii; i++) {
                                    var entry = encoding.getRaw(keys[i]);
                                    if (isName(entry)) {
                                        hash.update(entry.name);
                                    } else if (isRef(entry)) {
                                        hash.update(entry.num + '_' + entry.gen);
                                    } else if (isArray(entry)) {
                                        hash.update(entry.length.toString());
                                    }
                                }
                            }
                            var toUnicode = dict.get('ToUnicode') || baseDict.get('ToUnicode');
                            if (isStream(toUnicode)) {
                                var stream = toUnicode.str || toUnicode;
                                uint8array = stream.buffer ? new Uint8Array(stream.buffer.buffer, 0, stream.bufferLength) : new Uint8Array(stream.bytes.buffer, stream.start, stream.end - stream.start);
                                hash.update(uint8array);
                            } else if (isName(toUnicode)) {
                                hash.update(toUnicode.name);
                            }
                            var widths = dict.get('Widths') || baseDict.get('Widths');
                            if (widths) {
                                uint8array = new Uint8Array(new Uint32Array(widths).buffer);
                                hash.update(uint8array);
                            }
                        }
                        return {
                            descriptor: descriptor,
                            dict: dict,
                            baseDict: baseDict,
                            composite: composite,
                            type: type.name,
                            hash: hash ? hash.hexdigest() : ''
                        };
                    },
                    translateFont: function PartialEvaluator_translateFont(preEvaluatedFont, xref) {
                        var baseDict = preEvaluatedFont.baseDict;
                        var dict = preEvaluatedFont.dict;
                        var composite = preEvaluatedFont.composite;
                        var descriptor = preEvaluatedFont.descriptor;
                        var type = preEvaluatedFont.type;
                        var maxCharIndex = (composite ? 0xFFFF : 0xFF);
                        var properties;
                        if (!descriptor) {
                            if (type === 'Type3') {
                                descriptor = new Dict(null);
                                descriptor.set('FontName', Name.get(type));
                                descriptor.set('FontBBox', dict.get('FontBBox'));
                            } else {
                                var baseFontName = dict.get('BaseFont');
                                if (!isName(baseFontName)) {
                                    error('Base font is not specified');
                                }
                                baseFontName = baseFontName.name.replace(/[,_]/g, '-');
                                var metrics = this.getBaseFontMetrics(baseFontName);
                                var fontNameWoStyle = baseFontName.split('-')[0];
                                var flags = (this.isSerifFont(fontNameWoStyle) ? FontFlags.Serif : 0) | (metrics.monospace ? FontFlags.FixedPitch : 0) | (symbolsFonts[fontNameWoStyle] ? FontFlags.Symbolic : FontFlags.Nonsymbolic);
                                properties = {
                                    type: type,
                                    name: baseFontName,
                                    widths: metrics.widths,
                                    defaultWidth: metrics.defaultWidth,
                                    flags: flags,
                                    firstChar: 0,
                                    lastChar: maxCharIndex
                                };
                                this.extractDataStructures(dict, dict, xref, properties);
                                properties.widths = this.buildCharCodeToWidth(metrics.widths, properties);
                                return new Font(baseFontName, null, properties);
                            }
                        }
                        var firstChar = (dict.get('FirstChar') || 0);
                        var lastChar = (dict.get('LastChar') || maxCharIndex);
                        var fontName = descriptor.get('FontName');
                        var baseFont = dict.get('BaseFont');
                        if (isString(fontName)) {
                            fontName = Name.get(fontName);
                        }
                        if (isString(baseFont)) {
                            baseFont = Name.get(baseFont);
                        }
                        if (type !== 'Type3') {
                            var fontNameStr = fontName && fontName.name;
                            var baseFontStr = baseFont && baseFont.name;
                            if (fontNameStr !== baseFontStr) {
                                info('The FontDescriptor\'s FontName is "' + fontNameStr + '" but should be the same as the Font\'s BaseFont "' +
                                    baseFontStr + '"');
                                if (fontNameStr && baseFontStr && baseFontStr.indexOf(fontNameStr) === 0) {
                                    fontName = baseFont;
                                }
                            }
                        }
                        fontName = (fontName || baseFont);
                        assert(isName(fontName), 'invalid font name');
                        var fontFile = descriptor.get('FontFile', 'FontFile2', 'FontFile3');
                        if (fontFile) {
                            if (fontFile.dict) {
                                var subtype = fontFile.dict.get('Subtype');
                                if (subtype) {
                                    subtype = subtype.name;
                                }
                                var length1 = fontFile.dict.get('Length1');
                                var length2 = fontFile.dict.get('Length2');
                            }
                        }
                        properties = {
                            type: type,
                            name: fontName.name,
                            subtype: subtype,
                            file: fontFile,
                            length1: length1,
                            length2: length2,
                            loadedName: baseDict.loadedName,
                            composite: composite,
                            wideChars: composite,
                            fixedPitch: false,
                            fontMatrix: (dict.get('FontMatrix') || FONT_IDENTITY_MATRIX),
                            firstChar: firstChar || 0,
                            lastChar: (lastChar || maxCharIndex),
                            bbox: descriptor.get('FontBBox'),
                            ascent: descriptor.get('Ascent'),
                            descent: descriptor.get('Descent'),
                            xHeight: descriptor.get('XHeight'),
                            capHeight: descriptor.get('CapHeight'),
                            flags: descriptor.get('Flags'),
                            italicAngle: descriptor.get('ItalicAngle'),
                            coded: false
                        };
                        if (composite) {
                            var cidEncoding = baseDict.get('Encoding');
                            if (isName(cidEncoding)) {
                                properties.cidEncoding = cidEncoding.name;
                            }
                            properties.cMap = CMapFactory.create(cidEncoding, {
                                url: PDFJS.cMapUrl,
                                packed: PDFJS.cMapPacked
                            }, null);
                            properties.vertical = properties.cMap.vertical;
                        }
                        this.extractDataStructures(dict, baseDict, xref, properties);
                        this.extractWidths(dict, xref, descriptor, properties);
                        if (type === 'Type3') {
                            properties.isType3Font = true;
                        }
                        return new Font(fontName.name, fontFile, properties);
                    }
                };
                return PartialEvaluator;
            })();
            var TranslatedFont = (function TranslatedFontClosure() {
                function TranslatedFont(loadedName, font, dict) {
                    this.loadedName = loadedName;
                    this.font = font;
                    this.dict = dict;
                    this.type3Loaded = null;
                    this.sent = false;
                }
                TranslatedFont.prototype = {
                    send: function(handler) {
                        if (this.sent) {
                            return;
                        }
                        var fontData = this.font.exportData();
                        handler.send('commonobj', [this.loadedName, 'Font', fontData]);
                        this.sent = true;
                    },
                    loadType3Data: function(evaluator, resources, parentOperatorList, task) {
                        assert(this.font.isType3Font);
                        if (this.type3Loaded) {
                            return this.type3Loaded;
                        }
                        var translatedFont = this.font;
                        var loadCharProcsPromise = Promise.resolve();
                        var charProcs = this.dict.get('CharProcs').getAll();
                        var fontResources = this.dict.get('Resources') || resources;
                        var charProcKeys = Object.keys(charProcs);
                        var charProcOperatorList = {};
                        for (var i = 0, n = charProcKeys.length; i < n; ++i) {
                            loadCharProcsPromise = loadCharProcsPromise.then(function(key) {
                                var glyphStream = charProcs[key];
                                var operatorList = new OperatorList();
                                return evaluator.getOperatorList(glyphStream, task, fontResources, operatorList).then(function() {
                                    charProcOperatorList[key] = operatorList.getIR();
                                    parentOperatorList.addDependencies(operatorList.dependencies);
                                }, function(reason) {
                                    warn('Type3 font resource \"' + key + '\" is not available');
                                    var operatorList = new OperatorList();
                                    charProcOperatorList[key] = operatorList.getIR();
                                });
                            }.bind(this, charProcKeys[i]));
                        }
                        this.type3Loaded = loadCharProcsPromise.then(function() {
                            translatedFont.charProcOperatorList = charProcOperatorList;
                        });
                        return this.type3Loaded;
                    }
                };
                return TranslatedFont;
            })();
            var OperatorList = (function OperatorListClosure() {
                var CHUNK_SIZE = 1000;
                var CHUNK_SIZE_ABOUT = CHUNK_SIZE - 5;

                function getTransfers(queue) {
                    var transfers = [];
                    var fnArray = queue.fnArray,
                        argsArray = queue.argsArray;
                    for (var i = 0, ii = queue.length; i < ii; i++) {
                        switch (fnArray[i]) {
                            case OPS.paintInlineImageXObject:
                            case OPS.paintInlineImageXObjectGroup:
                            case OPS.paintImageMaskXObject:
                                var arg = argsArray[i][0];
                                if (!arg.cached) {
                                    transfers.push(arg.data.buffer);
                                }
                                break;
                        }
                    }
                    return transfers;
                }

                function OperatorList(intent, messageHandler, pageIndex) {
                    this.messageHandler = messageHandler;
                    this.fnArray = [];
                    this.argsArray = [];
                    this.dependencies = {};
                    this._totalLength = 0;
                    this.pageIndex = pageIndex;
                    this.intent = intent;
                }
                OperatorList.prototype = {
                    get length() {
                        return this.argsArray.length;
                    },
                    get totalLength() {
                        return (this._totalLength + this.length);
                    },
                    addOp: function(fn, args) {
                        this.fnArray.push(fn);
                        this.argsArray.push(args);
                        if (this.messageHandler) {
                            if (this.fnArray.length >= CHUNK_SIZE) {
                                this.flush();
                            } else if (this.fnArray.length >= CHUNK_SIZE_ABOUT && (fn === OPS.restore || fn === OPS.endText)) {
                                this.flush();
                            }
                        }
                    },
                    addDependency: function(dependency) {
                        if (dependency in this.dependencies) {
                            return;
                        }
                        this.dependencies[dependency] = true;
                        this.addOp(OPS.dependency, [dependency]);
                    },
                    addDependencies: function(dependencies) {
                        for (var key in dependencies) {
                            this.addDependency(key);
                        }
                    },
                    addOpList: function(opList) {
                        Util.extendObj(this.dependencies, opList.dependencies);
                        for (var i = 0, ii = opList.length; i < ii; i++) {
                            this.addOp(opList.fnArray[i], opList.argsArray[i]);
                        }
                    },
                    getIR: function() {
                        return {
                            fnArray: this.fnArray,
                            argsArray: this.argsArray,
                            length: this.length
                        };
                    },
                    flush: function(lastChunk) {
                        if (this.intent !== 'oplist') {
                            new QueueOptimizer().optimize(this);
                        }
                        var transfers = getTransfers(this);
                        var length = this.length;
                        this._totalLength += length;
                        this.messageHandler.send('RenderPageChunk', {
                            operatorList: {
                                fnArray: this.fnArray,
                                argsArray: this.argsArray,
                                lastChunk: lastChunk,
                                length: length
                            },
                            pageIndex: this.pageIndex,
                            intent: this.intent
                        }, transfers);
                        this.dependencies = {};
                        this.fnArray.length = 0;
                        this.argsArray.length = 0;
                    }
                };
                return OperatorList;
            })();
            var StateManager = (function StateManagerClosure() {
                function StateManager(initialState) {
                    this.state = initialState;
                    this.stateStack = [];
                }
                StateManager.prototype = {
                    save: function() {
                        var old = this.state;
                        this.stateStack.push(this.state);
                        this.state = old.clone();
                    },
                    restore: function() {
                        var prev = this.stateStack.pop();
                        if (prev) {
                            this.state = prev;
                        }
                    },
                    transform: function(args) {
                        this.state.ctm = Util.transform(this.state.ctm, args);
                    }
                };
                return StateManager;
            })();
            var TextState = (function TextStateClosure() {
                function TextState() {
                    this.ctm = new Float32Array(IDENTITY_MATRIX);
                    this.fontSize = 0;
                    this.font = null;
                    this.fontMatrix = FONT_IDENTITY_MATRIX;
                    this.textMatrix = IDENTITY_MATRIX.slice();
                    this.textLineMatrix = IDENTITY_MATRIX.slice();
                    this.charSpacing = 0;
                    this.wordSpacing = 0;
                    this.leading = 0;
                    this.textHScale = 1;
                    this.textRise = 0;
                }
                TextState.prototype = {
                    setTextMatrix: function TextState_setTextMatrix(a, b, c, d, e, f) {
                        var m = this.textMatrix;
                        m[0] = a;
                        m[1] = b;
                        m[2] = c;
                        m[3] = d;
                        m[4] = e;
                        m[5] = f;
                    },
                    setTextLineMatrix: function TextState_setTextMatrix(a, b, c, d, e, f) {
                        var m = this.textLineMatrix;
                        m[0] = a;
                        m[1] = b;
                        m[2] = c;
                        m[3] = d;
                        m[4] = e;
                        m[5] = f;
                    },
                    translateTextMatrix: function TextState_translateTextMatrix(x, y) {
                        var m = this.textMatrix;
                        m[4] = m[0] * x + m[2] * y + m[4];
                        m[5] = m[1] * x + m[3] * y + m[5];
                    },
                    translateTextLineMatrix: function TextState_translateTextMatrix(x, y) {
                        var m = this.textLineMatrix;
                        m[4] = m[0] * x + m[2] * y + m[4];
                        m[5] = m[1] * x + m[3] * y + m[5];
                    },
                    calcRenderMatrix: function TextState_calcRendeMatrix(ctm) {
                        var tsm = [this.fontSize * this.textHScale, 0, 0, this.fontSize, 0, this.textRise];
                        return Util.transform(ctm, Util.transform(this.textMatrix, tsm));
                    },
                    carriageReturn: function TextState_carriageReturn() {
                        this.translateTextLineMatrix(0, -this.leading);
                        this.textMatrix = this.textLineMatrix.slice();
                    },
                    clone: function TextState_clone() {
                        var clone = Object.create(this);
                        clone.textMatrix = this.textMatrix.slice();
                        clone.textLineMatrix = this.textLineMatrix.slice();
                        clone.fontMatrix = this.fontMatrix.slice();
                        return clone;
                    }
                };
                return TextState;
            })();
            var EvalState = (function EvalStateClosure() {
                function EvalState() {
                    this.ctm = new Float32Array(IDENTITY_MATRIX);
                    this.font = null;
                    this.textRenderingMode = TextRenderingMode.FILL;
                    this.fillColorSpace = ColorSpace.singletons.gray;
                    this.strokeColorSpace = ColorSpace.singletons.gray;
                }
                EvalState.prototype = {
                    clone: function CanvasExtraState_clone() {
                        return Object.create(this);
                    },
                };
                return EvalState;
            })();
            var EvaluatorPreprocessor = (function EvaluatorPreprocessorClosure() {
                var OP_MAP = {
                    w: {
                        id: OPS.setLineWidth,
                        numArgs: 1,
                        variableArgs: false
                    },
                    J: {
                        id: OPS.setLineCap,
                        numArgs: 1,
                        variableArgs: false
                    },
                    j: {
                        id: OPS.setLineJoin,
                        numArgs: 1,
                        variableArgs: false
                    },
                    M: {
                        id: OPS.setMiterLimit,
                        numArgs: 1,
                        variableArgs: false
                    },
                    d: {
                        id: OPS.setDash,
                        numArgs: 2,
                        variableArgs: false
                    },
                    ri: {
                        id: OPS.setRenderingIntent,
                        numArgs: 1,
                        variableArgs: false
                    },
                    i: {
                        id: OPS.setFlatness,
                        numArgs: 1,
                        variableArgs: false
                    },
                    gs: {
                        id: OPS.setGState,
                        numArgs: 1,
                        variableArgs: false
                    },
                    q: {
                        id: OPS.save,
                        numArgs: 0,
                        variableArgs: false
                    },
                    Q: {
                        id: OPS.restore,
                        numArgs: 0,
                        variableArgs: false
                    },
                    cm: {
                        id: OPS.transform,
                        numArgs: 6,
                        variableArgs: false
                    },
                    m: {
                        id: OPS.moveTo,
                        numArgs: 2,
                        variableArgs: false
                    },
                    l: {
                        id: OPS.lineTo,
                        numArgs: 2,
                        variableArgs: false
                    },
                    c: {
                        id: OPS.curveTo,
                        numArgs: 6,
                        variableArgs: false
                    },
                    v: {
                        id: OPS.curveTo2,
                        numArgs: 4,
                        variableArgs: false
                    },
                    y: {
                        id: OPS.curveTo3,
                        numArgs: 4,
                        variableArgs: false
                    },
                    h: {
                        id: OPS.closePath,
                        numArgs: 0,
                        variableArgs: false
                    },
                    re: {
                        id: OPS.rectangle,
                        numArgs: 4,
                        variableArgs: false
                    },
                    S: {
                        id: OPS.stroke,
                        numArgs: 0,
                        variableArgs: false
                    },
                    s: {
                        id: OPS.closeStroke,
                        numArgs: 0,
                        variableArgs: false
                    },
                    f: {
                        id: OPS.fill,
                        numArgs: 0,
                        variableArgs: false
                    },
                    F: {
                        id: OPS.fill,
                        numArgs: 0,
                        variableArgs: false
                    },
                    'f*': {
                        id: OPS.eoFill,
                        numArgs: 0,
                        variableArgs: false
                    },
                    B: {
                        id: OPS.fillStroke,
                        numArgs: 0,
                        variableArgs: false
                    },
                    'B*': {
                        id: OPS.eoFillStroke,
                        numArgs: 0,
                        variableArgs: false
                    },
                    b: {
                        id: OPS.closeFillStroke,
                        numArgs: 0,
                        variableArgs: false
                    },
                    'b*': {
                        id: OPS.closeEOFillStroke,
                        numArgs: 0,
                        variableArgs: false
                    },
                    n: {
                        id: OPS.endPath,
                        numArgs: 0,
                        variableArgs: false
                    },
                    W: {
                        id: OPS.clip,
                        numArgs: 0,
                        variableArgs: false
                    },
                    'W*': {
                        id: OPS.eoClip,
                        numArgs: 0,
                        variableArgs: false
                    },
                    BT: {
                        id: OPS.beginText,
                        numArgs: 0,
                        variableArgs: false
                    },
                    ET: {
                        id: OPS.endText,
                        numArgs: 0,
                        variableArgs: false
                    },
                    Tc: {
                        id: OPS.setCharSpacing,
                        numArgs: 1,
                        variableArgs: false
                    },
                    Tw: {
                        id: OPS.setWordSpacing,
                        numArgs: 1,
                        variableArgs: false
                    },
                    Tz: {
                        id: OPS.setHScale,
                        numArgs: 1,
                        variableArgs: false
                    },
                    TL: {
                        id: OPS.setLeading,
                        numArgs: 1,
                        variableArgs: false
                    },
                    Tf: {
                        id: OPS.setFont,
                        numArgs: 2,
                        variableArgs: false
                    },
                    Tr: {
                        id: OPS.setTextRenderingMode,
                        numArgs: 1,
                        variableArgs: false
                    },
                    Ts: {
                        id: OPS.setTextRise,
                        numArgs: 1,
                        variableArgs: false
                    },
                    Td: {
                        id: OPS.moveText,
                        numArgs: 2,
                        variableArgs: false
                    },
                    TD: {
                        id: OPS.setLeadingMoveText,
                        numArgs: 2,
                        variableArgs: false
                    },
                    Tm: {
                        id: OPS.setTextMatrix,
                        numArgs: 6,
                        variableArgs: false
                    },
                    'T*': {
                        id: OPS.nextLine,
                        numArgs: 0,
                        variableArgs: false
                    },
                    Tj: {
                        id: OPS.showText,
                        numArgs: 1,
                        variableArgs: false
                    },
                    TJ: {
                        id: OPS.showSpacedText,
                        numArgs: 1,
                        variableArgs: false
                    },
                    '\'': {
                        id: OPS.nextLineShowText,
                        numArgs: 1,
                        variableArgs: false
                    },
                    '"': {
                        id: OPS.nextLineSetSpacingShowText,
                        numArgs: 3,
                        variableArgs: false
                    },
                    d0: {
                        id: OPS.setCharWidth,
                        numArgs: 2,
                        variableArgs: false
                    },
                    d1: {
                        id: OPS.setCharWidthAndBounds,
                        numArgs: 6,
                        variableArgs: false
                    },
                    CS: {
                        id: OPS.setStrokeColorSpace,
                        numArgs: 1,
                        variableArgs: false
                    },
                    cs: {
                        id: OPS.setFillColorSpace,
                        numArgs: 1,
                        variableArgs: false
                    },
                    SC: {
                        id: OPS.setStrokeColor,
                        numArgs: 4,
                        variableArgs: true
                    },
                    SCN: {
                        id: OPS.setStrokeColorN,
                        numArgs: 33,
                        variableArgs: true
                    },
                    sc: {
                        id: OPS.setFillColor,
                        numArgs: 4,
                        variableArgs: true
                    },
                    scn: {
                        id: OPS.setFillColorN,
                        numArgs: 33,
                        variableArgs: true
                    },
                    G: {
                        id: OPS.setStrokeGray,
                        numArgs: 1,
                        variableArgs: false
                    },
                    g: {
                        id: OPS.setFillGray,
                        numArgs: 1,
                        variableArgs: false
                    },
                    RG: {
                        id: OPS.setStrokeRGBColor,
                        numArgs: 3,
                        variableArgs: false
                    },
                    rg: {
                        id: OPS.setFillRGBColor,
                        numArgs: 3,
                        variableArgs: false
                    },
                    K: {
                        id: OPS.setStrokeCMYKColor,
                        numArgs: 4,
                        variableArgs: false
                    },
                    k: {
                        id: OPS.setFillCMYKColor,
                        numArgs: 4,
                        variableArgs: false
                    },
                    sh: {
                        id: OPS.shadingFill,
                        numArgs: 1,
                        variableArgs: false
                    },
                    BI: {
                        id: OPS.beginInlineImage,
                        numArgs: 0,
                        variableArgs: false
                    },
                    ID: {
                        id: OPS.beginImageData,
                        numArgs: 0,
                        variableArgs: false
                    },
                    EI: {
                        id: OPS.endInlineImage,
                        numArgs: 1,
                        variableArgs: false
                    },
                    Do: {
                        id: OPS.paintXObject,
                        numArgs: 1,
                        variableArgs: false
                    },
                    MP: {
                        id: OPS.markPoint,
                        numArgs: 1,
                        variableArgs: false
                    },
                    DP: {
                        id: OPS.markPointProps,
                        numArgs: 2,
                        variableArgs: false
                    },
                    BMC: {
                        id: OPS.beginMarkedContent,
                        numArgs: 1,
                        variableArgs: false
                    },
                    BDC: {
                        id: OPS.beginMarkedContentProps,
                        numArgs: 2,
                        variableArgs: false
                    },
                    EMC: {
                        id: OPS.endMarkedContent,
                        numArgs: 0,
                        variableArgs: false
                    },
                    BX: {
                        id: OPS.beginCompat,
                        numArgs: 0,
                        variableArgs: false
                    },
                    EX: {
                        id: OPS.endCompat,
                        numArgs: 0,
                        variableArgs: false
                    },
                    BM: null,
                    BD: null,
                    'true': null,
                    fa: null,
                    fal: null,
                    fals: null,
                    'false': null,
                    nu: null,
                    nul: null,
                    'null': null
                };

                function EvaluatorPreprocessor(stream, xref, stateManager) {
                    this.parser = new Parser(new Lexer(stream, OP_MAP), false, xref);
                    this.stateManager = stateManager;
                    this.nonProcessedArgs = [];
                }
                EvaluatorPreprocessor.prototype = {
                    get savedStatesDepth() {
                        return this.stateManager.stateStack.length;
                    },
                    read: function EvaluatorPreprocessor_read(operation) {
                        var args = operation.args;
                        while (true) {
                            var obj = this.parser.getObj();
                            if (isCmd(obj)) {
                                var cmd = obj.cmd;
                                var opSpec = OP_MAP[cmd];
                                if (!opSpec) {
                                    warn('Unknown command "' + cmd + '"');
                                    continue;
                                }
                                var fn = opSpec.id;
                                var numArgs = opSpec.numArgs;
                                var argsLength = args !== null ? args.length : 0;
                                if (!opSpec.variableArgs) {
                                    if (argsLength !== numArgs) {
                                        var nonProcessedArgs = this.nonProcessedArgs;
                                        while (argsLength > numArgs) {
                                            nonProcessedArgs.push(args.shift());
                                            argsLength--;
                                        }
                                        while (argsLength < numArgs && nonProcessedArgs.length !== 0) {
                                            if (!args) {
                                                args = [];
                                            }
                                            args.unshift(nonProcessedArgs.pop());
                                            argsLength++;
                                        }
                                    }
                                    if (argsLength < numArgs) {
                                        info('Command ' + fn + ': because expected ' +
                                            numArgs + ' args, but received ' + argsLength + ' args; skipping');
                                        args = null;
                                        continue;
                                    }
                                } else if (argsLength > numArgs) {
                                    info('Command ' + fn + ': expected [0,' + numArgs + '] args, but received ' + argsLength + ' args');
                                }
                                this.preprocessCommand(fn, args);
                                operation.fn = fn;
                                operation.args = args;
                                return true;
                            } else {
                                if (isEOF(obj)) {
                                    return false;
                                }
                                if (obj !== null) {
                                    if (!args) {
                                        args = [];
                                    }
                                    args.push((obj instanceof Dict ? obj.getAll() : obj));
                                    assert(args.length <= 33, 'Too many arguments');
                                }
                            }
                        }
                    },
                    preprocessCommand: function EvaluatorPreprocessor_preprocessCommand(fn, args) {
                        switch (fn | 0) {
                            case OPS.save:
                                this.stateManager.save();
                                break;
                            case OPS.restore:
                                this.stateManager.restore();
                                break;
                            case OPS.transform:
                                this.stateManager.transform(args);
                                break;
                        }
                    }
                };
                return EvaluatorPreprocessor;
            })();
            var QueueOptimizer = (function QueueOptimizerClosure() {
                function addState(parentState, pattern, fn) {
                    var state = parentState;
                    for (var i = 0, ii = pattern.length - 1; i < ii; i++) {
                        var item = pattern[i];
                        state = (state[item] || (state[item] = []));
                    }
                    state[pattern[pattern.length - 1]] = fn;
                }

                function handlePaintSolidColorImageMask(iFirstSave, count, fnArray, argsArray) {
                    var iFirstPIMXO = iFirstSave + 2;
                    for (var i = 0; i < count; i++) {
                        var arg = argsArray[iFirstPIMXO + 4 * i];
                        var imageMask = arg.length === 1 && arg[0];
                        if (imageMask && imageMask.width === 1 && imageMask.height === 1 && (!imageMask.data.length || (imageMask.data.length === 1 && imageMask.data[0] === 0))) {
                            fnArray[iFirstPIMXO + 4 * i] = OPS.paintSolidColorImageMask;
                            continue;
                        }
                        break;
                    }
                    return count - i;
                }
                var InitialState = [];
                addState(InitialState, [OPS.save, OPS.transform, OPS.paintInlineImageXObject, OPS.restore], function foundInlineImageGroup(context) {
                    var MIN_IMAGES_IN_INLINE_IMAGES_BLOCK = 10;
                    var MAX_IMAGES_IN_INLINE_IMAGES_BLOCK = 200;
                    var MAX_WIDTH = 1000;
                    var IMAGE_PADDING = 1;
                    var fnArray = context.fnArray,
                        argsArray = context.argsArray;
                    var curr = context.iCurr;
                    var iFirstSave = curr - 3;
                    var iFirstTransform = curr - 2;
                    var iFirstPIIXO = curr - 1;
                    var i = iFirstSave + 4;
                    var ii = fnArray.length;
                    while (i + 3 < ii) {
                        if (fnArray[i] !== OPS.save || fnArray[i + 1] !== OPS.transform || fnArray[i + 2] !== OPS.paintInlineImageXObject || fnArray[i + 3] !== OPS.restore) {
                            break;
                        }
                        i += 4;
                    }
                    var count = Math.min((i - iFirstSave) / 4, MAX_IMAGES_IN_INLINE_IMAGES_BLOCK);
                    if (count < MIN_IMAGES_IN_INLINE_IMAGES_BLOCK) {
                        return i;
                    }
                    var maxX = 0;
                    var map = [],
                        maxLineHeight = 0;
                    var currentX = IMAGE_PADDING,
                        currentY = IMAGE_PADDING;
                    var q;
                    for (q = 0; q < count; q++) {
                        var transform = argsArray[iFirstTransform + (q << 2)];
                        var img = argsArray[iFirstPIIXO + (q << 2)][0];
                        if (currentX + img.width > MAX_WIDTH) {
                            maxX = Math.max(maxX, currentX);
                            currentY += maxLineHeight + 2 * IMAGE_PADDING;
                            currentX = 0;
                            maxLineHeight = 0;
                        }
                        map.push({
                            transform: transform,
                            x: currentX,
                            y: currentY,
                            w: img.width,
                            h: img.height
                        });
                        currentX += img.width + 2 * IMAGE_PADDING;
                        maxLineHeight = Math.max(maxLineHeight, img.height);
                    }
                    var imgWidth = Math.max(maxX, currentX) + IMAGE_PADDING;
                    var imgHeight = currentY + maxLineHeight + IMAGE_PADDING;
                    var imgData = new Uint8Array(imgWidth * imgHeight * 4);
                    var imgRowSize = imgWidth << 2;
                    for (q = 0; q < count; q++) {
                        var data = argsArray[iFirstPIIXO + (q << 2)][0].data;
                        var rowSize = map[q].w << 2;
                        var dataOffset = 0;
                        var offset = (map[q].x + map[q].y * imgWidth) << 2;
                        imgData.set(data.subarray(0, rowSize), offset - imgRowSize);
                        for (var k = 0, kk = map[q].h; k < kk; k++) {
                            imgData.set(data.subarray(dataOffset, dataOffset + rowSize), offset);
                            dataOffset += rowSize;
                            offset += imgRowSize;
                        }
                        imgData.set(data.subarray(dataOffset - rowSize, dataOffset), offset);
                        while (offset >= 0) {
                            data[offset - 4] = data[offset];
                            data[offset - 3] = data[offset + 1];
                            data[offset - 2] = data[offset + 2];
                            data[offset - 1] = data[offset + 3];
                            data[offset + rowSize] = data[offset + rowSize - 4];
                            data[offset + rowSize + 1] = data[offset + rowSize - 3];
                            data[offset + rowSize + 2] = data[offset + rowSize - 2];
                            data[offset + rowSize + 3] = data[offset + rowSize - 1];
                            offset -= imgRowSize;
                        }
                    }
                    fnArray.splice(iFirstSave, count * 4, OPS.paintInlineImageXObjectGroup);
                    argsArray.splice(iFirstSave, count * 4, [{
                        width: imgWidth,
                        height: imgHeight,
                        kind: ImageKind.RGBA_32BPP,
                        data: imgData
                    }, map]);
                    return iFirstSave + 1;
                });
                addState(InitialState, [OPS.save, OPS.transform, OPS.paintImageMaskXObject, OPS.restore], function foundImageMaskGroup(context) {
                    var MIN_IMAGES_IN_MASKS_BLOCK = 10;
                    var MAX_IMAGES_IN_MASKS_BLOCK = 100;
                    var MAX_SAME_IMAGES_IN_MASKS_BLOCK = 1000;
                    var fnArray = context.fnArray,
                        argsArray = context.argsArray;
                    var curr = context.iCurr;
                    var iFirstSave = curr - 3;
                    var iFirstTransform = curr - 2;
                    var iFirstPIMXO = curr - 1;
                    var i = iFirstSave + 4;
                    var ii = fnArray.length;
                    while (i + 3 < ii) {
                        if (fnArray[i] !== OPS.save || fnArray[i + 1] !== OPS.transform || fnArray[i + 2] !== OPS.paintImageMaskXObject || fnArray[i + 3] !== OPS.restore) {
                            break;
                        }
                        i += 4;
                    }
                    var count = (i - iFirstSave) / 4;
                    count = handlePaintSolidColorImageMask(iFirstSave, count, fnArray, argsArray);
                    if (count < MIN_IMAGES_IN_MASKS_BLOCK) {
                        return i;
                    }
                    var q;
                    var isSameImage = false;
                    var iTransform, transformArgs;
                    var firstPIMXOArg0 = argsArray[iFirstPIMXO][0];
                    if (argsArray[iFirstTransform][1] === 0 && argsArray[iFirstTransform][2] === 0) {
                        isSameImage = true;
                        var firstTransformArg0 = argsArray[iFirstTransform][0];
                        var firstTransformArg3 = argsArray[iFirstTransform][3];
                        iTransform = iFirstTransform + 4;
                        var iPIMXO = iFirstPIMXO + 4;
                        for (q = 1; q < count; q++, iTransform += 4, iPIMXO += 4) {
                            transformArgs = argsArray[iTransform];
                            if (argsArray[iPIMXO][0] !== firstPIMXOArg0 || transformArgs[0] !== firstTransformArg0 || transformArgs[1] !== 0 || transformArgs[2] !== 0 || transformArgs[3] !== firstTransformArg3) {
                                if (q < MIN_IMAGES_IN_MASKS_BLOCK) {
                                    isSameImage = false;
                                } else {
                                    count = q;
                                }
                                break;
                            }
                        }
                    }
                    if (isSameImage) {
                        count = Math.min(count, MAX_SAME_IMAGES_IN_MASKS_BLOCK);
                        var positions = new Float32Array(count * 2);
                        iTransform = iFirstTransform;
                        for (q = 0; q < count; q++, iTransform += 4) {
                            transformArgs = argsArray[iTransform];
                            positions[(q << 1)] = transformArgs[4];
                            positions[(q << 1) + 1] = transformArgs[5];
                        }
                        fnArray.splice(iFirstSave, count * 4, OPS.paintImageMaskXObjectRepeat);
                        argsArray.splice(iFirstSave, count * 4, [firstPIMXOArg0, firstTransformArg0, firstTransformArg3, positions]);
                    } else {
                        count = Math.min(count, MAX_IMAGES_IN_MASKS_BLOCK);
                        var images = [];
                        for (q = 0; q < count; q++) {
                            transformArgs = argsArray[iFirstTransform + (q << 2)];
                            var maskParams = argsArray[iFirstPIMXO + (q << 2)][0];
                            images.push({
                                data: maskParams.data,
                                width: maskParams.width,
                                height: maskParams.height,
                                transform: transformArgs
                            });
                        }
                        fnArray.splice(iFirstSave, count * 4, OPS.paintImageMaskXObjectGroup);
                        argsArray.splice(iFirstSave, count * 4, [images]);
                    }
                    return iFirstSave + 1;
                });
                addState(InitialState, [OPS.save, OPS.transform, OPS.paintImageXObject, OPS.restore], function(context) {
                    var MIN_IMAGES_IN_BLOCK = 3;
                    var MAX_IMAGES_IN_BLOCK = 1000;
                    var fnArray = context.fnArray,
                        argsArray = context.argsArray;
                    var curr = context.iCurr;
                    var iFirstSave = curr - 3;
                    var iFirstTransform = curr - 2;
                    var iFirstPIXO = curr - 1;
                    var iFirstRestore = curr;
                    if (argsArray[iFirstTransform][1] !== 0 || argsArray[iFirstTransform][2] !== 0) {
                        return iFirstRestore + 1;
                    }
                    var firstPIXOArg0 = argsArray[iFirstPIXO][0];
                    var firstTransformArg0 = argsArray[iFirstTransform][0];
                    var firstTransformArg3 = argsArray[iFirstTransform][3];
                    var i = iFirstSave + 4;
                    var ii = fnArray.length;
                    while (i + 3 < ii) {
                        if (fnArray[i] !== OPS.save || fnArray[i + 1] !== OPS.transform || fnArray[i + 2] !== OPS.paintImageXObject || fnArray[i + 3] !== OPS.restore) {
                            break;
                        }
                        if (argsArray[i + 1][0] !== firstTransformArg0 || argsArray[i + 1][1] !== 0 || argsArray[i + 1][2] !== 0 || argsArray[i + 1][3] !== firstTransformArg3) {
                            break;
                        }
                        if (argsArray[i + 2][0] !== firstPIXOArg0) {
                            break;
                        }
                        i += 4;
                    }
                    var count = Math.min((i - iFirstSave) / 4, MAX_IMAGES_IN_BLOCK);
                    if (count < MIN_IMAGES_IN_BLOCK) {
                        return i;
                    }
                    var positions = new Float32Array(count * 2);
                    var iTransform = iFirstTransform;
                    for (var q = 0; q < count; q++, iTransform += 4) {
                        var transformArgs = argsArray[iTransform];
                        positions[(q << 1)] = transformArgs[4];
                        positions[(q << 1) + 1] = transformArgs[5];
                    }
                    var args = [firstPIXOArg0, firstTransformArg0, firstTransformArg3, positions];
                    fnArray.splice(iFirstSave, count * 4, OPS.paintImageXObjectRepeat);
                    argsArray.splice(iFirstSave, count * 4, args);
                    return iFirstSave + 1;
                });
                addState(InitialState, [OPS.beginText, OPS.setFont, OPS.setTextMatrix, OPS.showText, OPS.endText], function(context) {
                    var MIN_CHARS_IN_BLOCK = 3;
                    var MAX_CHARS_IN_BLOCK = 1000;
                    var fnArray = context.fnArray,
                        argsArray = context.argsArray;
                    var curr = context.iCurr;
                    var iFirstBeginText = curr - 4;
                    var iFirstSetFont = curr - 3;
                    var iFirstSetTextMatrix = curr - 2;
                    var iFirstShowText = curr - 1;
                    var iFirstEndText = curr;
                    var firstSetFontArg0 = argsArray[iFirstSetFont][0];
                    var firstSetFontArg1 = argsArray[iFirstSetFont][1];
                    var i = iFirstBeginText + 5;
                    var ii = fnArray.length;
                    while (i + 4 < ii) {
                        if (fnArray[i] !== OPS.beginText || fnArray[i + 1] !== OPS.setFont || fnArray[i + 2] !== OPS.setTextMatrix || fnArray[i + 3] !== OPS.showText || fnArray[i + 4] !== OPS.endText) {
                            break;
                        }
                        if (argsArray[i + 1][0] !== firstSetFontArg0 || argsArray[i + 1][1] !== firstSetFontArg1) {
                            break;
                        }
                        i += 5;
                    }
                    var count = Math.min(((i - iFirstBeginText) / 5), MAX_CHARS_IN_BLOCK);
                    if (count < MIN_CHARS_IN_BLOCK) {
                        return i;
                    }
                    var iFirst = iFirstBeginText;
                    if (iFirstBeginText >= 4 && fnArray[iFirstBeginText - 4] === fnArray[iFirstSetFont] && fnArray[iFirstBeginText - 3] === fnArray[iFirstSetTextMatrix] && fnArray[iFirstBeginText - 2] === fnArray[iFirstShowText] && fnArray[iFirstBeginText - 1] === fnArray[iFirstEndText] && argsArray[iFirstBeginText - 4][0] === firstSetFontArg0 && argsArray[iFirstBeginText - 4][1] === firstSetFontArg1) {
                        count++;
                        iFirst -= 5;
                    }
                    var iEndText = iFirst + 4;
                    for (var q = 1; q < count; q++) {
                        fnArray.splice(iEndText, 3);
                        argsArray.splice(iEndText, 3);
                        iEndText += 2;
                    }
                    return iEndText + 1;
                });

                function QueueOptimizer() {}
                QueueOptimizer.prototype = {
                    optimize: function QueueOptimizer_optimize(queue) {
                        var fnArray = queue.fnArray,
                            argsArray = queue.argsArray;
                        var context = {
                            iCurr: 0,
                            fnArray: fnArray,
                            argsArray: argsArray
                        };
                        var state;
                        var i = 0,
                            ii = fnArray.length;
                        while (i < ii) {
                            state = (state || InitialState)[fnArray[i]];
                            if (typeof state === 'function') {
                                context.iCurr = i;
                                i = state(context);
                                state = undefined;
                                ii = context.fnArray.length;
                            } else {
                                i++;
                            }
                        }
                    }
                };
                return QueueOptimizer;
            })();
            exports.OperatorList = OperatorList;
            exports.PartialEvaluator = PartialEvaluator;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsCoreAnnotation = {}), root.pdfjsSharedUtil, root.pdfjsCorePrimitives, root.pdfjsCoreStream, root.pdfjsCoreColorSpace, root.pdfjsCoreObj, root.pdfjsCoreEvaluator);
            }
        }(this, function(exports, sharedUtil, corePrimitives, coreStream, coreColorSpace, coreObj, coreEvaluator) {
            var AnnotationBorderStyleType = sharedUtil.AnnotationBorderStyleType;
            var AnnotationFlag = sharedUtil.AnnotationFlag;
            var AnnotationType = sharedUtil.AnnotationType;
            var OPS = sharedUtil.OPS;
            var Util = sharedUtil.Util;
            var isArray = sharedUtil.isArray;
            var isInt = sharedUtil.isInt;
            var isValidUrl = sharedUtil.isValidUrl;
            var stringToBytes = sharedUtil.stringToBytes;
            var stringToPDFString = sharedUtil.stringToPDFString;
            var stringToUTF8String = sharedUtil.stringToUTF8String;
            var warn = sharedUtil.warn;
            var Dict = corePrimitives.Dict;
            var isDict = corePrimitives.isDict;
            var isName = corePrimitives.isName;
            var Stream = coreStream.Stream;
            var ColorSpace = coreColorSpace.ColorSpace;
            var ObjectLoader = coreObj.ObjectLoader;
            var OperatorList = coreEvaluator.OperatorList;

            function AnnotationFactory() {}
            AnnotationFactory.prototype = {
                create: function AnnotationFactory_create(xref, ref) {
                    var dict = xref.fetchIfRef(ref);
                    if (!isDict(dict)) {
                        return;
                    }
                    var subtype = dict.get('Subtype');
                    subtype = isName(subtype) ? subtype.name : '';
                    var parameters = {
                        dict: dict,
                        ref: ref
                    };
                    switch (subtype) {
                        case 'Link':
                            return new LinkAnnotation(parameters);
                        case 'Text':
                            return new TextAnnotation(parameters);
                        case 'Widget':
                            var fieldType = Util.getInheritableProperty(dict, 'FT');
                            if (isName(fieldType) && fieldType.name === 'Tx') {
                                return new TextWidgetAnnotation(parameters);
                            }
                            return new WidgetAnnotation(parameters);
                        case 'Popup':
                            return new PopupAnnotation(parameters);
                        case 'Highlight':
                            return new HighlightAnnotation(parameters);
                        case 'Underline':
                            return new UnderlineAnnotation(parameters);
                        case 'Squiggly':
                            return new SquigglyAnnotation(parameters);
                        case 'StrikeOut':
                            return new StrikeOutAnnotation(parameters);
                        default:
                            warn('Unimplemented annotation type "' + subtype + '", ' + 'falling back to base annotation');
                            return new Annotation(parameters);
                    }
                }
            };
            var Annotation = (function AnnotationClosure() {
                function getTransformMatrix(rect, bbox, matrix) {
                    var bounds = Util.getAxialAlignedBoundingBox(bbox, matrix);
                    var minX = bounds[0];
                    var minY = bounds[1];
                    var maxX = bounds[2];
                    var maxY = bounds[3];
                    if (minX === maxX || minY === maxY) {
                        return [1, 0, 0, 1, rect[0], rect[1]];
                    }
                    var xRatio = (rect[2] - rect[0]) / (maxX - minX);
                    var yRatio = (rect[3] - rect[1]) / (maxY - minY);
                    return [xRatio, 0, 0, yRatio, rect[0] - minX * xRatio, rect[1] - minY * yRatio];
                }

                function getDefaultAppearance(dict) {
                    var appearanceState = dict.get('AP');
                    if (!isDict(appearanceState)) {
                        return;
                    }
                    var appearance;
                    var appearances = appearanceState.get('N');
                    if (isDict(appearances)) {
                        var as = dict.get('AS');
                        if (as && appearances.has(as.name)) {
                            appearance = appearances.get(as.name);
                        }
                    } else {
                        appearance = appearances;
                    }
                    return appearance;
                }

                function Annotation(params) {
                    var dict = params.dict;
                    this.setFlags(dict.get('F'));
                    this.setRectangle(dict.get('Rect'));
                    this.setColor(dict.get('C'));
                    this.setBorderStyle(dict);
                    this.appearance = getDefaultAppearance(dict);
                    this.data = {};
                    this.data.id = params.ref.toString();
                    this.data.subtype = dict.get('Subtype').name;
                    this.data.annotationFlags = this.flags;
                    this.data.rect = this.rectangle;
                    this.data.color = this.color;
                    this.data.borderStyle = this.borderStyle;
                    this.data.hasAppearance = !!this.appearance;
                }
                Annotation.prototype = {
                    get viewable() {
                        if (this.flags) {
                            return !this.hasFlag(AnnotationFlag.INVISIBLE) && !this.hasFlag(AnnotationFlag.HIDDEN) && !this.hasFlag(AnnotationFlag.NOVIEW);
                        }
                        return true;
                    },
                    get printable() {
                        if (this.flags) {
                            return this.hasFlag(AnnotationFlag.PRINT) && !this.hasFlag(AnnotationFlag.INVISIBLE) && !this.hasFlag(AnnotationFlag.HIDDEN);
                        }
                        return false;
                    },
                    setFlags: function Annotation_setFlags(flags) {
                        if (isInt(flags)) {
                            this.flags = flags;
                        } else {
                            this.flags = 0;
                        }
                    },
                    hasFlag: function Annotation_hasFlag(flag) {
                        if (this.flags) {
                            return (this.flags & flag) > 0;
                        }
                        return false;
                    },
                    setRectangle: function Annotation_setRectangle(rectangle) {
                        if (isArray(rectangle) && rectangle.length === 4) {
                            this.rectangle = Util.normalizeRect(rectangle);
                        } else {
                            this.rectangle = [0, 0, 0, 0];
                        }
                    },
                    setColor: function Annotation_setColor(color) {
                        var rgbColor = new Uint8Array(3);
                        if (!isArray(color)) {
                            this.color = rgbColor;
                            return;
                        }
                        switch (color.length) {
                            case 0:
                                this.color = null;
                                break;
                            case 1:
                                ColorSpace.singletons.gray.getRgbItem(color, 0, rgbColor, 0);
                                this.color = rgbColor;
                                break;
                            case 3:
                                ColorSpace.singletons.rgb.getRgbItem(color, 0, rgbColor, 0);
                                this.color = rgbColor;
                                break;
                            case 4:
                                ColorSpace.singletons.cmyk.getRgbItem(color, 0, rgbColor, 0);
                                this.color = rgbColor;
                                break;
                            default:
                                this.color = rgbColor;
                                break;
                        }
                    },
                    setBorderStyle: function Annotation_setBorderStyle(borderStyle) {
                        this.borderStyle = new AnnotationBorderStyle();
                        if (!isDict(borderStyle)) {
                            return;
                        }
                        if (borderStyle.has('BS')) {
                            var dict = borderStyle.get('BS');
                            var dictType;
                            if (!dict.has('Type') || (isName(dictType = dict.get('Type')) && dictType.name === 'Border')) {
                                this.borderStyle.setWidth(dict.get('W'));
                                this.borderStyle.setStyle(dict.get('S'));
                                this.borderStyle.setDashArray(dict.get('D'));
                            }
                        } else if (borderStyle.has('Border')) {
                            var array = borderStyle.get('Border');
                            if (isArray(array) && array.length >= 3) {
                                this.borderStyle.setHorizontalCornerRadius(array[0]);
                                this.borderStyle.setVerticalCornerRadius(array[1]);
                                this.borderStyle.setWidth(array[2]);
                                if (array.length === 4) {
                                    this.borderStyle.setDashArray(array[3]);
                                }
                            }
                        } else {
                            this.borderStyle.setWidth(0);
                        }
                    },
                    loadResources: function Annotation_loadResources(keys) {
                        return new Promise(function(resolve, reject) {
                            this.appearance.dict.getAsync('Resources').then(function(resources) {
                                if (!resources) {
                                    resolve();
                                    return;
                                }
                                var objectLoader = new ObjectLoader(resources.map, keys, resources.xref);
                                objectLoader.load().then(function() {
                                    resolve(resources);
                                }, reject);
                            }, reject);
                        }.bind(this));
                    },
                    getOperatorList: function Annotation_getOperatorList(evaluator, task) {
                        if (!this.appearance) {
                            return Promise.resolve(new OperatorList());
                        }
                        var data = this.data;
                        var appearanceDict = this.appearance.dict;
                        var resourcesPromise = this.loadResources(['ExtGState', 'ColorSpace', 'Pattern', 'Shading', 'XObject', 'Font']);
                        var bbox = appearanceDict.get('BBox') || [0, 0, 1, 1];
                        var matrix = appearanceDict.get('Matrix') || [1, 0, 0, 1, 0, 0];
                        var transform = getTransformMatrix(data.rect, bbox, matrix);
                        var self = this;
                        return resourcesPromise.then(function(resources) {
                            var opList = new OperatorList();
                            opList.addOp(OPS.beginAnnotation, [data.rect, transform, matrix]);
                            return evaluator.getOperatorList(self.appearance, task, resources, opList).then(function() {
                                opList.addOp(OPS.endAnnotation, []);
                                self.appearance.reset();
                                return opList;
                            });
                        });
                    }
                };
                Annotation.appendToOperatorList = function Annotation_appendToOperatorList(annotations, opList, partialEvaluator, task, intent) {
                    var annotationPromises = [];
                    for (var i = 0, n = annotations.length; i < n; ++i) {
                        if ((intent === 'display' && annotations[i].viewable) || (intent === 'print' && annotations[i].printable)) {
                            annotationPromises.push(annotations[i].getOperatorList(partialEvaluator, task));
                        }
                    }
                    return Promise.all(annotationPromises).then(function(operatorLists) {
                        opList.addOp(OPS.beginAnnotations, []);
                        for (var i = 0, n = operatorLists.length; i < n; ++i) {
                            opList.addOpList(operatorLists[i]);
                        }
                        opList.addOp(OPS.endAnnotations, []);
                    });
                };
                return Annotation;
            })();
            var AnnotationBorderStyle = (function AnnotationBorderStyleClosure() {
                function AnnotationBorderStyle() {
                    this.width = 1;
                    this.style = AnnotationBorderStyleType.SOLID;
                    this.dashArray = [3];
                    this.horizontalCornerRadius = 0;
                    this.verticalCornerRadius = 0;
                }
                AnnotationBorderStyle.prototype = {
                    setWidth: function AnnotationBorderStyle_setWidth(width) {
                        if (width === (width | 0)) {
                            this.width = width;
                        }
                    },
                    setStyle: function AnnotationBorderStyle_setStyle(style) {
                        if (!style) {
                            return;
                        }
                        switch (style.name) {
                            case 'S':
                                this.style = AnnotationBorderStyleType.SOLID;
                                break;
                            case 'D':
                                this.style = AnnotationBorderStyleType.DASHED;
                                break;
                            case 'B':
                                this.style = AnnotationBorderStyleType.BEVELED;
                                break;
                            case 'I':
                                this.style = AnnotationBorderStyleType.INSET;
                                break;
                            case 'U':
                                this.style = AnnotationBorderStyleType.UNDERLINE;
                                break;
                            default:
                                break;
                        }
                    },
                    setDashArray: function AnnotationBorderStyle_setDashArray(dashArray) {
                        if (isArray(dashArray) && dashArray.length > 0) {
                            var isValid = true;
                            var allZeros = true;
                            for (var i = 0, len = dashArray.length; i < len; i++) {
                                var element = dashArray[i];
                                var validNumber = (+element >= 0);
                                if (!validNumber) {
                                    isValid = false;
                                    break;
                                } else if (element > 0) {
                                    allZeros = false;
                                }
                            }
                            if (isValid && !allZeros) {
                                this.dashArray = dashArray;
                            } else {
                                this.width = 0;
                            }
                        } else if (dashArray) {
                            this.width = 0;
                        }
                    },
                    setHorizontalCornerRadius: function AnnotationBorderStyle_setHorizontalCornerRadius(radius) {
                        if (radius === (radius | 0)) {
                            this.horizontalCornerRadius = radius;
                        }
                    },
                    setVerticalCornerRadius: function AnnotationBorderStyle_setVerticalCornerRadius(radius) {
                        if (radius === (radius | 0)) {
                            this.verticalCornerRadius = radius;
                        }
                    }
                };
                return AnnotationBorderStyle;
            })();
            var WidgetAnnotation = (function WidgetAnnotationClosure() {
                function WidgetAnnotation(params) {
                    Annotation.call(this, params);
                    var dict = params.dict;
                    var data = this.data;
                    data.annotationType = AnnotationType.WIDGET;
                    data.fieldValue = stringToPDFString(Util.getInheritableProperty(dict, 'V') || '');
                    data.alternativeText = stringToPDFString(dict.get('TU') || '');
                    data.defaultAppearance = Util.getInheritableProperty(dict, 'DA') || '';
                    var fieldType = Util.getInheritableProperty(dict, 'FT');
                    data.fieldType = isName(fieldType) ? fieldType.name : '';
                    data.fieldFlags = Util.getInheritableProperty(dict, 'Ff') || 0;
                    this.fieldResources = Util.getInheritableProperty(dict, 'DR') || Dict.empty;
                    if (data.fieldType === 'Sig') {
                        warn('unimplemented annotation type: Widget signature');
                        this.setFlags(AnnotationFlag.HIDDEN);
                    }
                    var fieldName = [];
                    var namedItem = dict;
                    var ref = params.ref;
                    while (namedItem) {
                        var parent = namedItem.get('Parent');
                        var parentRef = namedItem.getRaw('Parent');
                        var name = namedItem.get('T');
                        if (name) {
                            fieldName.unshift(stringToPDFString(name));
                        } else if (parent && ref) {
                            var kids = parent.get('Kids');
                            var j, jj;
                            for (j = 0, jj = kids.length; j < jj; j++) {
                                var kidRef = kids[j];
                                if (kidRef.num === ref.num && kidRef.gen === ref.gen) {
                                    break;
                                }
                            }
                            fieldName.unshift('`' + j);
                        }
                        namedItem = parent;
                        ref = parentRef;
                    }
                    data.fullName = fieldName.join('.');
                }
                Util.inherit(WidgetAnnotation, Annotation, {});
                return WidgetAnnotation;
            })();
            var TextWidgetAnnotation = (function TextWidgetAnnotationClosure() {
                function TextWidgetAnnotation(params) {
                    WidgetAnnotation.call(this, params);
                    this.data.textAlignment = Util.getInheritableProperty(params.dict, 'Q');
                    this.data.hasHtml = !this.data.hasAppearance && !!this.data.fieldValue;
                }
                Util.inherit(TextWidgetAnnotation, WidgetAnnotation, {
                    getOperatorList: function TextWidgetAnnotation_getOperatorList(evaluator, task) {
                        if (this.appearance) {
                            return Annotation.prototype.getOperatorList.call(this, evaluator, task);
                        }
                        var opList = new OperatorList();
                        var data = this.data;
                        if (!data.defaultAppearance) {
                            return Promise.resolve(opList);
                        }
                        var stream = new Stream(stringToBytes(data.defaultAppearance));
                        return evaluator.getOperatorList(stream, task, this.fieldResources, opList).then(function() {
                            return opList;
                        });
                    }
                });
                return TextWidgetAnnotation;
            })();
            var TextAnnotation = (function TextAnnotationClosure() {
                var DEFAULT_ICON_SIZE = 22;

                function TextAnnotation(parameters) {
                    Annotation.call(this, parameters);
                    this.data.annotationType = AnnotationType.TEXT;
                    this.data.hasHtml = true;
                    var dict = parameters.dict;
                    if (this.data.hasAppearance) {
                        this.data.name = 'NoIcon';
                    } else {
                        this.data.rect[1] = this.data.rect[3] - DEFAULT_ICON_SIZE;
                        this.data.rect[2] = this.data.rect[0] + DEFAULT_ICON_SIZE;
                        this.data.name = dict.has('Name') ? dict.get('Name').name : 'Note';
                    }
                    if (!dict.has('C')) {
                        this.data.color = null;
                    }
                    this.data.hasPopup = dict.has('Popup');
                    if (!this.data.hasPopup) {
                        this.data.title = stringToPDFString(dict.get('T') || '');
                        this.data.contents = stringToPDFString(dict.get('Contents') || '');
                        this.data.hasHtml = (this.data.title || this.data.contents);
                    }
                }
                Util.inherit(TextAnnotation, Annotation, {});
                return TextAnnotation;
            })();
            var LinkAnnotation = (function LinkAnnotationClosure() {
                function LinkAnnotation(params) {
                    Annotation.call(this, params);
                    var dict = params.dict;
                    var data = this.data;
                    data.annotationType = AnnotationType.LINK;
                    data.hasHtml = true;
                    var action = dict.get('A');
                    if (action && isDict(action)) {
                        var linkType = action.get('S').name;
                        if (linkType === 'URI') {
                            var url = action.get('URI');
                            if (isName(url)) {
                                url = '/' + url.name;
                            } else if (url) {
                                url = addDefaultProtocolToUrl(url);
                            }
                            if (!isValidUrl(url, false)) {
                                url = '';
                            }
                            try {
                                data.url = stringToUTF8String(url);
                            } catch (e) {
                                data.url = url;
                            }
                        } else if (linkType === 'GoTo') {
                            data.dest = action.get('D');
                        } else if (linkType === 'GoToR') {
                            var urlDict = action.get('F');
                            if (isDict(urlDict)) {
                                url = urlDict.get('F') || '';
                            }
                            if (!isValidUrl(url, false)) {
                                url = '';
                            }
                            data.url = url;
                            data.dest = action.get('D');
                        } else if (linkType === 'Named') {
                            data.action = action.get('N').name;
                        } else {
                            warn('unrecognized link type: ' + linkType);
                        }
                    } else if (dict.has('Dest')) {
                        var dest = dict.get('Dest');
                        data.dest = isName(dest) ? dest.name : dest;
                    }
                }

                function addDefaultProtocolToUrl(url) {
                    if (url && url.indexOf('www.') === 0) {
                        return ('http://' + url);
                    }
                    return url;
                }
                Util.inherit(LinkAnnotation, Annotation, {});
                return LinkAnnotation;
            })();
            var PopupAnnotation = (function PopupAnnotationClosure() {
                function PopupAnnotation(parameters) {
                    Annotation.call(this, parameters);
                    this.data.annotationType = AnnotationType.POPUP;
                    var dict = parameters.dict;
                    var parentItem = dict.get('Parent');
                    if (!parentItem) {
                        warn('Popup annotation has a missing or invalid parent annotation.');
                        return;
                    }
                    this.data.parentId = dict.getRaw('Parent').toString();
                    this.data.title = stringToPDFString(parentItem.get('T') || '');
                    this.data.contents = stringToPDFString(parentItem.get('Contents') || '');
                    if (!parentItem.has('C')) {
                        this.data.color = null;
                    } else {
                        this.setColor(parentItem.get('C'));
                        this.data.color = this.color;
                    }
                    this.data.hasHtml = (this.data.title || this.data.contents);
                }
                Util.inherit(PopupAnnotation, Annotation, {});
                return PopupAnnotation;
            })();
            var HighlightAnnotation = (function HighlightAnnotationClosure() {
                function HighlightAnnotation(parameters) {
                    Annotation.call(this, parameters);
                    this.data.annotationType = AnnotationType.HIGHLIGHT;
                    this.data.hasHtml = true;
                    this.data.borderStyle.setWidth(0);
                }
                Util.inherit(HighlightAnnotation, Annotation, {});
                return HighlightAnnotation;
            })();
            var UnderlineAnnotation = (function UnderlineAnnotationClosure() {
                function UnderlineAnnotation(parameters) {
                    Annotation.call(this, parameters);
                    this.data.annotationType = AnnotationType.UNDERLINE;
                    this.data.hasHtml = true;
                    this.data.borderStyle.setWidth(0);
                }
                Util.inherit(UnderlineAnnotation, Annotation, {});
                return UnderlineAnnotation;
            })();
            var SquigglyAnnotation = (function SquigglyAnnotationClosure() {
                function SquigglyAnnotation(parameters) {
                    Annotation.call(this, parameters);
                    this.data.annotationType = AnnotationType.SQUIGGLY;
                    this.data.hasHtml = true;
                    this.data.borderStyle.setWidth(0);
                }
                Util.inherit(SquigglyAnnotation, Annotation, {});
                return SquigglyAnnotation;
            })();
            var StrikeOutAnnotation = (function StrikeOutAnnotationClosure() {
                function StrikeOutAnnotation(parameters) {
                    Annotation.call(this, parameters);
                    this.data.annotationType = AnnotationType.STRIKEOUT;
                    this.data.hasHtml = true;
                    this.data.borderStyle.setWidth(0);
                }
                Util.inherit(StrikeOutAnnotation, Annotation, {});
                return StrikeOutAnnotation;
            })();
            exports.Annotation = Annotation;
            exports.AnnotationBorderStyle = AnnotationBorderStyle;
            exports.AnnotationFactory = AnnotationFactory;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsCoreDocument = {}), root.pdfjsSharedUtil, root.pdfjsCorePrimitives, root.pdfjsCoreStream, root.pdfjsCoreObj, root.pdfjsCoreParser, root.pdfjsCoreCrypto, root.pdfjsCoreEvaluator, root.pdfjsCoreAnnotation);
            }
        }(this, function(exports, sharedUtil, corePrimitives, coreStream, coreObj, coreParser, coreCrypto, coreEvaluator, coreAnnotation) {
            var MissingDataException = sharedUtil.MissingDataException;
            var Util = sharedUtil.Util;
            var assert = sharedUtil.assert;
            var error = sharedUtil.error;
            var info = sharedUtil.info;
            var isArray = sharedUtil.isArray;
            var isArrayBuffer = sharedUtil.isArrayBuffer;
            var isString = sharedUtil.isString;
            var shadow = sharedUtil.shadow;
            var stringToBytes = sharedUtil.stringToBytes;
            var stringToPDFString = sharedUtil.stringToPDFString;
            var warn = sharedUtil.warn;
            var Dict = corePrimitives.Dict;
            var isDict = corePrimitives.isDict;
            var isName = corePrimitives.isName;
            var isStream = corePrimitives.isStream;
            var NullStream = coreStream.NullStream;
            var Stream = coreStream.Stream;
            var StreamsSequenceStream = coreStream.StreamsSequenceStream;
            var Catalog = coreObj.Catalog;
            var ObjectLoader = coreObj.ObjectLoader;
            var XRef = coreObj.XRef;
            var Lexer = coreParser.Lexer;
            var Linearization = coreParser.Linearization;
            var calculateMD5 = coreCrypto.calculateMD5;
            var OperatorList = coreEvaluator.OperatorList;
            var PartialEvaluator = coreEvaluator.PartialEvaluator;
            var Annotation = coreAnnotation.Annotation;
            var AnnotationFactory = coreAnnotation.AnnotationFactory;
            var Page = (function PageClosure() {
                var LETTER_SIZE_MEDIABOX = [0, 0, 612, 792];

                function Page(pdfManager, xref, pageIndex, pageDict, ref, fontCache) {
                    this.pdfManager = pdfManager;
                    this.pageIndex = pageIndex;
                    this.pageDict = pageDict;
                    this.xref = xref;
                    this.ref = ref;
                    this.fontCache = fontCache;
                    this.idCounters = {
                        obj: 0
                    };
                    this.resourcesPromise = null;
                }
                Page.prototype = {
                    getPageProp: function Page_getPageProp(key) {
                        return this.pageDict.get(key);
                    },
                    getInheritedPageProp: function Page_getInheritedPageProp(key) {
                        var dict = this.pageDict,
                            valueArray = null,
                            loopCount = 0;
                        var MAX_LOOP_COUNT = 100;
                        while (dict) {
                            var value = dict.get(key);
                            if (value) {
                                if (!valueArray) {
                                    valueArray = [];
                                }
                                valueArray.push(value);
                            }
                            if (++loopCount > MAX_LOOP_COUNT) {
                                warn('Page_getInheritedPageProp: maximum loop count exceeded.');
                                break;
                            }
                            dict = dict.get('Parent');
                        }
                        if (!valueArray) {
                            return Dict.empty;
                        }
                        if (valueArray.length === 1 || !isDict(valueArray[0]) || loopCount > MAX_LOOP_COUNT) {
                            return valueArray[0];
                        }
                        return Dict.merge(this.xref, valueArray);
                    },
                    get content() {
                        return this.getPageProp('Contents');
                    },
                    get resources() {
                        return shadow(this, 'resources', this.getInheritedPageProp('Resources'));
                    },
                    get mediaBox() {
                        var obj = this.getInheritedPageProp('MediaBox');
                        if (!isArray(obj) || obj.length !== 4) {
                            obj = LETTER_SIZE_MEDIABOX;
                        }
                        return shadow(this, 'mediaBox', obj);
                    },
                    get view() {
                        var mediaBox = this.mediaBox;
                        var cropBox = this.getInheritedPageProp('CropBox');
                        if (!isArray(cropBox) || cropBox.length !== 4) {
                            return shadow(this, 'view', mediaBox);
                        }
                        cropBox = Util.intersect(cropBox, mediaBox);
                        if (!cropBox) {
                            return shadow(this, 'view', mediaBox);
                        }
                        return shadow(this, 'view', cropBox);
                    },
                    get rotate() {
                        var rotate = this.getInheritedPageProp('Rotate') || 0;
                        if (rotate % 90 !== 0) {
                            rotate = 0;
                        } else if (rotate >= 360) {
                            rotate = rotate % 360;
                        } else if (rotate < 0) {
                            rotate = ((rotate % 360) + 360) % 360;
                        }
                        return shadow(this, 'rotate', rotate);
                    },
                    getContentStream: function Page_getContentStream() {
                        var content = this.content;
                        var stream;
                        if (isArray(content)) {
                            var xref = this.xref;
                            var i, n = content.length;
                            var streams = [];
                            for (i = 0; i < n; ++i) {
                                streams.push(xref.fetchIfRef(content[i]));
                            }
                            stream = new StreamsSequenceStream(streams);
                        } else if (isStream(content)) {
                            stream = content;
                        } else {
                            stream = new NullStream();
                        }
                        return stream;
                    },
                    loadResources: function Page_loadResources(keys) {
                        if (!this.resourcesPromise) {
                            this.resourcesPromise = this.pdfManager.ensure(this, 'resources');
                        }
                        return this.resourcesPromise.then(function resourceSuccess() {
                            var objectLoader = new ObjectLoader(this.resources.map, keys, this.xref);
                            return objectLoader.load();
                        }.bind(this));
                    },
                    getOperatorList: function Page_getOperatorList(handler, task, intent) {
                        var self = this;
                        var pdfManager = this.pdfManager;
                        var contentStreamPromise = pdfManager.ensure(this, 'getContentStream', []);
                        var resourcesPromise = this.loadResources(['ExtGState', 'ColorSpace', 'Pattern', 'Shading', 'XObject', 'Font']);
                        var partialEvaluator = new PartialEvaluator(pdfManager, this.xref, handler, this.pageIndex, 'p' + this.pageIndex + '_', this.idCounters, this.fontCache);
                        var dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);
                        var pageListPromise = dataPromises.then(function(data) {
                            var contentStream = data[0];
                            var opList = new OperatorList(intent, handler, self.pageIndex);
                            handler.send('StartRenderPage', {
                                transparency: partialEvaluator.hasBlendModes(self.resources),
                                pageIndex: self.pageIndex,
                                intent: intent
                            });
                            return partialEvaluator.getOperatorList(contentStream, task, self.resources, opList).then(function() {
                                return opList;
                            });
                        });
                        var annotationsPromise = pdfManager.ensure(this, 'annotations');
                        return Promise.all([pageListPromise, annotationsPromise]).then(function(datas) {
                            var pageOpList = datas[0];
                            var annotations = datas[1];
                            if (annotations.length === 0) {
                                pageOpList.flush(true);
                                return pageOpList;
                            }
                            var annotationsReadyPromise = Annotation.appendToOperatorList(annotations, pageOpList, partialEvaluator, task, intent);
                            return annotationsReadyPromise.then(function() {
                                pageOpList.flush(true);
                                return pageOpList;
                            });
                        });
                    },
                    extractTextContent: function Page_extractTextContent(task, normalizeWhitespace) {
                        var handler = {
                            on: function nullHandlerOn() {},
                            send: function nullHandlerSend() {}
                        };
                        var self = this;
                        var pdfManager = this.pdfManager;
                        var contentStreamPromise = pdfManager.ensure(this, 'getContentStream', []);
                        var resourcesPromise = this.loadResources(['ExtGState', 'XObject', 'Font']);
                        var dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);
                        return dataPromises.then(function(data) {
                            var contentStream = data[0];
                            var partialEvaluator = new PartialEvaluator(pdfManager, self.xref, handler, self.pageIndex, 'p' + self.pageIndex + '_', self.idCounters, self.fontCache);
                            return partialEvaluator.getTextContent(contentStream, task, self.resources, null, normalizeWhitespace);
                        });
                    },
                    getAnnotationsData: function Page_getAnnotationsData(intent) {
                        var annotations = this.annotations;
                        var annotationsData = [];
                        for (var i = 0, n = annotations.length; i < n; ++i) {
                            if (intent) {
                                if (!(intent === 'display' && annotations[i].viewable) && !(intent === 'print' && annotations[i].printable)) {
                                    continue;
                                }
                            }
                            annotationsData.push(annotations[i].data);
                        }
                        return annotationsData;
                    },
                    get annotations() {
                        var annotations = [];
                        var annotationRefs = this.getInheritedPageProp('Annots') || [];
                        var annotationFactory = new AnnotationFactory();
                        for (var i = 0, n = annotationRefs.length; i < n; ++i) {
                            var annotationRef = annotationRefs[i];
                            var annotation = annotationFactory.create(this.xref, annotationRef);
                            if (annotation) {
                                annotations.push(annotation);
                            }
                        }
                        return shadow(this, 'annotations', annotations);
                    }
                };
                return Page;
            })();
            var PDFDocument = (function PDFDocumentClosure() {
                var FINGERPRINT_FIRST_BYTES = 1024;
                var EMPTY_FINGERPRINT = '\x00\x00\x00\x00\x00\x00\x00' + '\x00\x00\x00\x00\x00\x00\x00\x00\x00';

                function PDFDocument(pdfManager, arg, password) {
                    if (isStream(arg)) {
                        init.call(this, pdfManager, arg, password);
                    } else if (isArrayBuffer(arg)) {
                        init.call(this, pdfManager, new Stream(arg), password);
                    } else {
                        error('PDFDocument: Unknown argument type');
                    }
                }

                function init(pdfManager, stream, password) {
                    assert(stream.length > 0, 'stream must have data');
                    this.pdfManager = pdfManager;
                    this.stream = stream;
                    var xref = new XRef(this.stream, password, pdfManager);
                    this.xref = xref;
                }

                function find(stream, needle, limit, backwards) {
                    var pos = stream.pos;
                    var end = stream.end;
                    var strBuf = [];
                    if (pos + limit > end) {
                        limit = end - pos;
                    }
                    for (var n = 0; n < limit; ++n) {
                        strBuf.push(String.fromCharCode(stream.getByte()));
                    }
                    var str = strBuf.join('');
                    stream.pos = pos;
                    var index = backwards ? str.lastIndexOf(needle) : str.indexOf(needle);
                    if (index === -1) {
                        return false;
                    }
                    stream.pos += index;
                    return true;
                }
                var DocumentInfoValidators = {
                    get entries() {
                        return shadow(this, 'entries', {
                            Title: isString,
                            Author: isString,
                            Subject: isString,
                            Keywords: isString,
                            Creator: isString,
                            Producer: isString,
                            CreationDate: isString,
                            ModDate: isString,
                            Trapped: isName
                        });
                    }
                };
                PDFDocument.prototype = {
                    parse: function PDFDocument_parse(recoveryMode) {
                        this.setup(recoveryMode);
                        var version = this.catalog.catDict.get('Version');
                        if (isName(version)) {
                            this.pdfFormatVersion = version.name;
                        }
                        try {
                            this.acroForm = this.catalog.catDict.get('AcroForm');
                            if (this.acroForm) {
                                this.xfa = this.acroForm.get('XFA');
                                var fields = this.acroForm.get('Fields');
                                if ((!fields || !isArray(fields) || fields.length === 0) && !this.xfa) {
                                    this.acroForm = null;
                                }
                            }
                        } catch (ex) {
                            info('Something wrong with AcroForm entry');
                            this.acroForm = null;
                        }
                    },
                    get linearization() {
                        var linearization = null;
                        if (this.stream.length) {
                            try {
                                linearization = Linearization.create(this.stream);
                            } catch (err) {
                                if (err instanceof MissingDataException) {
                                    throw err;
                                }
                                info(err);
                            }
                        }
                        return shadow(this, 'linearization', linearization);
                    },
                    get startXRef() {
                        var stream = this.stream;
                        var startXRef = 0;
                        var linearization = this.linearization;
                        if (linearization) {
                            stream.reset();
                            if (find(stream, 'endobj', 1024)) {
                                startXRef = stream.pos + 6;
                            }
                        } else {
                            var step = 1024;
                            var found = false,
                                pos = stream.end;
                            while (!found && pos > 0) {
                                pos -= step - 'startxref'.length;
                                if (pos < 0) {
                                    pos = 0;
                                }
                                stream.pos = pos;
                                found = find(stream, 'startxref', step, true);
                            }
                            if (found) {
                                stream.skip(9);
                                var ch;
                                do {
                                    ch = stream.getByte();
                                } while (Lexer.isSpace(ch));
                                var str = '';
                                while (ch >= 0x20 && ch <= 0x39) {
                                    str += String.fromCharCode(ch);
                                    ch = stream.getByte();
                                }
                                startXRef = parseInt(str, 10);
                                if (isNaN(startXRef)) {
                                    startXRef = 0;
                                }
                            }
                        }
                        return shadow(this, 'startXRef', startXRef);
                    },
                    get mainXRefEntriesOffset() {
                        var mainXRefEntriesOffset = 0;
                        var linearization = this.linearization;
                        if (linearization) {
                            mainXRefEntriesOffset = linearization.mainXRefEntriesOffset;
                        }
                        return shadow(this, 'mainXRefEntriesOffset', mainXRefEntriesOffset);
                    },
                    checkHeader: function PDFDocument_checkHeader() {
                        var stream = this.stream;
                        stream.reset();
                        if (find(stream, '%PDF-', 1024)) {
                            stream.moveStart();
                            var MAX_VERSION_LENGTH = 12;
                            var version = '',
                                ch;
                            while ((ch = stream.getByte()) > 0x20) {
                                if (version.length >= MAX_VERSION_LENGTH) {
                                    break;
                                }
                                version += String.fromCharCode(ch);
                            }
                            if (!this.pdfFormatVersion) {
                                this.pdfFormatVersion = version.substring(5);
                            }
                            return;
                        }
                    },
                    parseStartXRef: function PDFDocument_parseStartXRef() {
                        var startXRef = this.startXRef;
                        this.xref.setStartXRef(startXRef);
                    },
                    setup: function PDFDocument_setup(recoveryMode) {
                        this.xref.parse(recoveryMode);
                        var self = this;
                        var pageFactory = {
                            createPage: function(pageIndex, dict, ref, fontCache) {
                                return new Page(self.pdfManager, self.xref, pageIndex, dict, ref, fontCache);
                            }
                        };
                        this.catalog = new Catalog(this.pdfManager, this.xref, pageFactory);
                    },
                    get numPages() {
                        var linearization = this.linearization;
                        var num = linearization ? linearization.numPages : this.catalog.numPages;
                        return shadow(this, 'numPages', num);
                    },
                    get documentInfo() {
                        var docInfo = {
                            PDFFormatVersion: this.pdfFormatVersion,
                            IsAcroFormPresent: !!this.acroForm,
                            IsXFAPresent: !!this.xfa
                        };
                        var infoDict;
                        try {
                            infoDict = this.xref.trailer.get('Info');
                        } catch (err) {
                            info('The document information dictionary is invalid.');
                        }
                        if (infoDict) {
                            var validEntries = DocumentInfoValidators.entries;
                            for (var key in validEntries) {
                                if (infoDict.has(key)) {
                                    var value = infoDict.get(key);
                                    if (validEntries[key](value)) {
                                        docInfo[key] = (typeof value !== 'string' ? value : stringToPDFString(value));
                                    } else {
                                        info('Bad value in document info for "' + key + '"');
                                    }
                                }
                            }
                        }
                        return shadow(this, 'documentInfo', docInfo);
                    },
                    get fingerprint() {
                        var xref = this.xref,
                            hash, fileID = '';
                        var idArray = xref.trailer.get('ID');
                        if (idArray && isArray(idArray) && idArray[0] && isString(idArray[0]) && idArray[0] !== EMPTY_FINGERPRINT) {
                            hash = stringToBytes(idArray[0]);
                        } else {
                            if (this.stream.ensureRange) {
                                this.stream.ensureRange(0, Math.min(FINGERPRINT_FIRST_BYTES, this.stream.end));
                            }
                            hash = calculateMD5(this.stream.bytes.subarray(0, FINGERPRINT_FIRST_BYTES), 0, FINGERPRINT_FIRST_BYTES);
                        }
                        for (var i = 0, n = hash.length; i < n; i++) {
                            var hex = hash[i].toString(16);
                            fileID += hex.length === 1 ? '0' + hex : hex;
                        }
                        return shadow(this, 'fingerprint', fileID);
                    },
                    getPage: function PDFDocument_getPage(pageIndex) {
                        return this.catalog.getPage(pageIndex);
                    },
                    cleanup: function PDFDocument_cleanup() {
                        return this.catalog.cleanup();
                    }
                };
                return PDFDocument;
            })();
            exports.Page = Page;
            exports.PDFDocument = PDFDocument;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsCorePdfManager = {}), root.pdfjsSharedUtil, root.pdfjsCoreStream, root.pdfjsCoreChunkedStream, root.pdfjsCoreDocument);
            }
        }(this, function(exports, sharedUtil, coreStream, coreChunkedStream, coreDocument) {
            var NotImplementedException = sharedUtil.NotImplementedException;
            var MissingDataException = sharedUtil.MissingDataException;
            var createPromiseCapability = sharedUtil.createPromiseCapability;
            var Util = sharedUtil.Util;
            var Stream = coreStream.Stream;
            var ChunkedStreamManager = coreChunkedStream.ChunkedStreamManager;
            var PDFDocument = coreDocument.PDFDocument;
            var BasePdfManager = (function BasePdfManagerClosure() {
                function BasePdfManager() {
                    throw new Error('Cannot initialize BaseManagerManager');
                }
                BasePdfManager.prototype = {
                    get docId() {
                        return this._docId;
                    },
                    onLoadedStream: function BasePdfManager_onLoadedStream() {
                        throw new NotImplementedException();
                    },
                    ensureDoc: function BasePdfManager_ensureDoc(prop, args) {
                        return this.ensure(this.pdfDocument, prop, args);
                    },
                    ensureXRef: function BasePdfManager_ensureXRef(prop, args) {
                        return this.ensure(this.pdfDocument.xref, prop, args);
                    },
                    ensureCatalog: function BasePdfManager_ensureCatalog(prop, args) {
                        return this.ensure(this.pdfDocument.catalog, prop, args);
                    },
                    getPage: function BasePdfManager_getPage(pageIndex) {
                        return this.pdfDocument.getPage(pageIndex);
                    },
                    cleanup: function BasePdfManager_cleanup() {
                        return this.pdfDocument.cleanup();
                    },
                    ensure: function BasePdfManager_ensure(obj, prop, args) {
                        return new NotImplementedException();
                    },
                    requestRange: function BasePdfManager_requestRange(begin, end) {
                        return new NotImplementedException();
                    },
                    requestLoadedStream: function BasePdfManager_requestLoadedStream() {
                        return new NotImplementedException();
                    },
                    sendProgressiveData: function BasePdfManager_sendProgressiveData(chunk) {
                        return new NotImplementedException();
                    },
                    updatePassword: function BasePdfManager_updatePassword(password) {
                        this.pdfDocument.xref.password = this.password = password;
                        if (this._passwordChangedCapability) {
                            this._passwordChangedCapability.resolve();
                        }
                    },
                    passwordChanged: function BasePdfManager_passwordChanged() {
                        this._passwordChangedCapability = createPromiseCapability();
                        return this._passwordChangedCapability.promise;
                    },
                    terminate: function BasePdfManager_terminate() {
                        return new NotImplementedException();
                    }
                };
                return BasePdfManager;
            })();
            var LocalPdfManager = (function LocalPdfManagerClosure() {
                function LocalPdfManager(docId, data, password) {
                    this._docId = docId;
                    var stream = new Stream(data);
                    this.pdfDocument = new PDFDocument(this, stream, password);
                    this._loadedStreamCapability = createPromiseCapability();
                    this._loadedStreamCapability.resolve(stream);
                }
                Util.inherit(LocalPdfManager, BasePdfManager, {
                    ensure: function LocalPdfManager_ensure(obj, prop, args) {
                        return new Promise(function(resolve, reject) {
                            try {
                                var value = obj[prop];
                                var result;
                                if (typeof value === 'function') {
                                    result = value.apply(obj, args);
                                } else {
                                    result = value;
                                }
                                resolve(result);
                            } catch (e) {
                                reject(e);
                            }
                        });
                    },
                    requestRange: function LocalPdfManager_requestRange(begin, end) {
                        return Promise.resolve();
                    },
                    requestLoadedStream: function LocalPdfManager_requestLoadedStream() {
                        return;
                    },
                    onLoadedStream: function LocalPdfManager_onLoadedStream() {
                        return this._loadedStreamCapability.promise;
                    },
                    terminate: function LocalPdfManager_terminate() {
                        return;
                    }
                });
                return LocalPdfManager;
            })();
            var NetworkPdfManager = (function NetworkPdfManagerClosure() {
                function NetworkPdfManager(docId, args, msgHandler) {
                    this._docId = docId;
                    this.msgHandler = msgHandler;
                    var params = {
                        msgHandler: msgHandler,
                        httpHeaders: args.httpHeaders,
                        withCredentials: args.withCredentials,
                        chunkedViewerLoading: args.chunkedViewerLoading,
                        disableAutoFetch: args.disableAutoFetch,
                        initialData: args.initialData
                    };
                    this.streamManager = new ChunkedStreamManager(args.length, args.rangeChunkSize, args.url, params);
                    this.pdfDocument = new PDFDocument(this, this.streamManager.getStream(), args.password);
                }
                Util.inherit(NetworkPdfManager, BasePdfManager, {
                    ensure: function NetworkPdfManager_ensure(obj, prop, args) {
                        var pdfManager = this;
                        return new Promise(function(resolve, reject) {
                            function ensureHelper() {
                                try {
                                    var result;
                                    var value = obj[prop];
                                    if (typeof value === 'function') {
                                        result = value.apply(obj, args);
                                    } else {
                                        result = value;
                                    }
                                    resolve(result);
                                } catch (e) {
                                    if (!(e instanceof MissingDataException)) {
                                        reject(e);
                                        return;
                                    }
                                    pdfManager.streamManager.requestRange(e.begin, e.end).then(ensureHelper, reject);
                                }
                            }
                            ensureHelper();
                        });
                    },
                    requestRange: function NetworkPdfManager_requestRange(begin, end) {
                        return this.streamManager.requestRange(begin, end);
                    },
                    requestLoadedStream: function NetworkPdfManager_requestLoadedStream() {
                        this.streamManager.requestAllChunks();
                    },
                    sendProgressiveData: function NetworkPdfManager_sendProgressiveData(chunk) {
                        this.streamManager.onReceiveData({
                            chunk: chunk
                        });
                    },
                    onLoadedStream: function NetworkPdfManager_onLoadedStream() {
                        return this.streamManager.onLoadedStream();
                    },
                    terminate: function NetworkPdfManager_terminate() {
                        this.streamManager.abort();
                    }
                });
                return NetworkPdfManager;
            })();
            exports.LocalPdfManager = LocalPdfManager;
            exports.NetworkPdfManager = NetworkPdfManager;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsCoreWorker = {}), root.pdfjsSharedUtil, root.pdfjsCorePrimitives, root.pdfjsCorePdfManager, root.pdfjsSharedGlobal);
            }
        }(this, function(exports, sharedUtil, corePrimitives, corePdfManager, sharedGlobal) {
            var UNSUPPORTED_FEATURES = sharedUtil.UNSUPPORTED_FEATURES;
            var InvalidPDFException = sharedUtil.InvalidPDFException;
            var MessageHandler = sharedUtil.MessageHandler;
            var MissingPDFException = sharedUtil.MissingPDFException;
            var UnexpectedResponseException = sharedUtil.UnexpectedResponseException;
            var PasswordException = sharedUtil.PasswordException;
            var PasswordResponses = sharedUtil.PasswordResponses;
            var UnknownErrorException = sharedUtil.UnknownErrorException;
            var XRefParseException = sharedUtil.XRefParseException;
            var createPromiseCapability = sharedUtil.createPromiseCapability;
            var error = sharedUtil.error;
            var info = sharedUtil.info;
            var isInt = sharedUtil.isInt;
            var warn = sharedUtil.warn;
            var Ref = corePrimitives.Ref;
            var LocalPdfManager = corePdfManager.LocalPdfManager;
            var NetworkPdfManager = corePdfManager.NetworkPdfManager;
            var globalScope = sharedGlobal.globalScope;
            var PDFJS = sharedGlobal.PDFJS;
            var WorkerTask = (function WorkerTaskClosure() {
                function WorkerTask(name) {
                    this.name = name;
                    this.terminated = false;
                    this._capability = createPromiseCapability();
                }
                WorkerTask.prototype = {
                    get finished() {
                        return this._capability.promise;
                    },
                    finish: function() {
                        this._capability.resolve();
                    },
                    terminate: function() {
                        this.terminated = true;
                    },
                    ensureNotTerminated: function() {
                        if (this.terminated) {
                            throw new Error('Worker task was terminated');
                        }
                    }
                };
                return WorkerTask;
            })();
            var WorkerMessageHandler = PDFJS.WorkerMessageHandler = {
                setup: function wphSetup(handler, port) {
                    var testMessageProcessed = false;
                    handler.on('test', function wphSetupTest(data) {
                        if (testMessageProcessed) {
                            return;
                        }
                        testMessageProcessed = true;
                        if (!(data instanceof Uint8Array)) {
                            handler.send('test', 'main', false);
                            return;
                        }
                        var supportTransfers = data[0] === 255;
                        handler.postMessageTransfers = supportTransfers;
                        var xhr = new XMLHttpRequest();
                        var responseExists = 'response' in xhr;
                        try {
                            var dummy = xhr.responseType;
                        } catch (e) {
                            responseExists = false;
                        }
                        if (!responseExists) {
                            handler.send('test', false);
                            return;
                        }
                        handler.send('test', {
                            supportTypedArray: true,
                            supportTransfers: supportTransfers
                        });
                    });
                    handler.on('GetDocRequest', function wphSetupDoc(data) {
                        return WorkerMessageHandler.createDocumentHandler(data, port);
                    });
                },
                createDocumentHandler: function wphCreateDocumentHandler(docParams, port) {
                    var pdfManager;
                    var terminated = false;
                    var cancelXHRs = null;
                    var WorkerTasks = [];
                    var docId = docParams.docId;
                    var workerHandlerName = docParams.docId + '_worker';
                    var handler = new MessageHandler(workerHandlerName, docId, port);

                    function ensureNotTerminated() {
                        if (terminated) {
                            throw new Error('Worker was terminated');
                        }
                    }

                    function startWorkerTask(task) {
                        WorkerTasks.push(task);
                    }

                    function finishWorkerTask(task) {
                        task.finish();
                        var i = WorkerTasks.indexOf(task);
                        WorkerTasks.splice(i, 1);
                    }

                    function loadDocument(recoveryMode) {
                        var loadDocumentCapability = createPromiseCapability();
                        var parseSuccess = function parseSuccess() {
                            var numPagesPromise = pdfManager.ensureDoc('numPages');
                            var fingerprintPromise = pdfManager.ensureDoc('fingerprint');
                            var encryptedPromise = pdfManager.ensureXRef('encrypt');
                            Promise.all([numPagesPromise, fingerprintPromise, encryptedPromise]).then(function onDocReady(results) {
                                var doc = {
                                    numPages: results[0],
                                    fingerprint: results[1],
                                    encrypted: !!results[2],
                                };
                                loadDocumentCapability.resolve(doc);
                            }, parseFailure);
                        };
                        var parseFailure = function parseFailure(e) {
                            loadDocumentCapability.reject(e);
                        };
                        pdfManager.ensureDoc('checkHeader', []).then(function() {
                            pdfManager.ensureDoc('parseStartXRef', []).then(function() {
                                pdfManager.ensureDoc('parse', [recoveryMode]).then(parseSuccess, parseFailure);
                            }, parseFailure);
                        }, parseFailure);
                        return loadDocumentCapability.promise;
                    }

                    function getPdfManager(data) {
                        var pdfManagerCapability = createPromiseCapability();
                        var pdfManager;
                        var source = data.source;
                        var disableRange = data.disableRange;
                        if (source.data) {
                            try {
                                pdfManager = new LocalPdfManager(docId, source.data, source.password);
                                pdfManagerCapability.resolve(pdfManager);
                            } catch (ex) {
                                pdfManagerCapability.reject(ex);
                            }
                            return pdfManagerCapability.promise;
                        } else if (source.chunkedViewerLoading) {
                            try {
                                pdfManager = new NetworkPdfManager(docId, source, handler);
                                pdfManagerCapability.resolve(pdfManager);
                            } catch (ex) {
                                pdfManagerCapability.reject(ex);
                            }
                            return pdfManagerCapability.promise;
                        }
                        var networkManager = new NetworkManager(source.url, {
                            httpHeaders: source.httpHeaders,
                            withCredentials: source.withCredentials
                        });
                        var cachedChunks = [];
                        var fullRequestXhrId = networkManager.requestFull({
                            onHeadersReceived: function onHeadersReceived() {
                                if (disableRange) {
                                    return;
                                }
                                var fullRequestXhr = networkManager.getRequestXhr(fullRequestXhrId);
                                if (fullRequestXhr.getResponseHeader('Accept-Ranges') !== 'bytes') {
                                    return;
                                }
                                var contentEncoding = fullRequestXhr.getResponseHeader('Content-Encoding') || 'identity';
                                if (contentEncoding !== 'identity') {
                                    return;
                                }
                                var length = fullRequestXhr.getResponseHeader('Content-Length');
                                length = parseInt(length, 10);
                                if (!isInt(length)) {
                                    return;
                                }
                                source.length = length;
                                if (length <= 2 * source.rangeChunkSize) {
                                    return;
                                }
                                if (networkManager.isStreamingRequest(fullRequestXhrId)) {
                                    source.disableAutoFetch = true;
                                } else {
                                    networkManager.abortRequest(fullRequestXhrId);
                                }
                                try {
                                    pdfManager = new NetworkPdfManager(docId, source, handler);
                                    pdfManagerCapability.resolve(pdfManager);
                                } catch (ex) {
                                    pdfManagerCapability.reject(ex);
                                }
                                cancelXHRs = null;
                            },
                            onProgressiveData: source.disableStream ? null : function onProgressiveData(chunk) {
                                if (!pdfManager) {
                                    cachedChunks.push(chunk);
                                    return;
                                }
                                pdfManager.sendProgressiveData(chunk);
                            },
                            onDone: function onDone(args) {
                                if (pdfManager) {
                                    return;
                                }
                                var pdfFile;
                                if (args === null) {
                                    var pdfFileLength = 0,
                                        pos = 0;
                                    cachedChunks.forEach(function(chunk) {
                                        pdfFileLength += chunk.byteLength;
                                    });
                                    if (source.length && pdfFileLength !== source.length) {
                                        warn('reported HTTP length is different from actual');
                                    }
                                    var pdfFileArray = new Uint8Array(pdfFileLength);
                                    cachedChunks.forEach(function(chunk) {
                                        pdfFileArray.set(new Uint8Array(chunk), pos);
                                        pos += chunk.byteLength;
                                    });
                                    pdfFile = pdfFileArray.buffer;
                                } else {
                                    pdfFile = args.chunk;
                                }
                                try {
                                    pdfManager = new LocalPdfManager(docId, pdfFile, source.password);
                                    pdfManagerCapability.resolve(pdfManager);
                                } catch (ex) {
                                    pdfManagerCapability.reject(ex);
                                }
                                cancelXHRs = null;
                            },
                            onError: function onError(status) {
                                var exception;
                                if (status === 404 || status === 0 && /^file:/.test(source.url)) {
                                    exception = new MissingPDFException('Missing PDF "' +
                                        source.url + '".');
                                    handler.send('MissingPDF', exception);
                                } else {
                                    exception = new UnexpectedResponseException('Unexpected server response (' + status + ') while retrieving PDF "' + source.url + '".', status);
                                    handler.send('UnexpectedResponse', exception);
                                }
                                cancelXHRs = null;
                            },
                            onProgress: function onProgress(evt) {
                                handler.send('DocProgress', {
                                    loaded: evt.loaded,
                                    total: evt.lengthComputable ? evt.total : source.length
                                });
                            }
                        });
                        cancelXHRs = function() {
                            networkManager.abortRequest(fullRequestXhrId);
                        };
                        return pdfManagerCapability.promise;
                    }
                    var setupDoc = function(data) {
                        var onSuccess = function(doc) {
                            ensureNotTerminated();
                            handler.send('GetDoc', {
                                pdfInfo: doc
                            });
                        };
                        var onFailure = function(e) {
                            if (e instanceof PasswordException) {
                                if (e.code === PasswordResponses.NEED_PASSWORD) {
                                    handler.send('NeedPassword', e);
                                } else if (e.code === PasswordResponses.INCORRECT_PASSWORD) {
                                    handler.send('IncorrectPassword', e);
                                }
                            } else if (e instanceof InvalidPDFException) {
                                handler.send('InvalidPDF', e);
                            } else if (e instanceof MissingPDFException) {
                                handler.send('MissingPDF', e);
                            } else if (e instanceof UnexpectedResponseException) {
                                handler.send('UnexpectedResponse', e);
                            } else {
                                handler.send('UnknownError', new UnknownErrorException(e.message, e.toString()));
                            }
                        };
                        ensureNotTerminated();
                        PDFJS.maxImageSize = data.maxImageSize === undefined ? -1 : data.maxImageSize;
                        PDFJS.disableFontFace = data.disableFontFace;
                        PDFJS.disableCreateObjectURL = data.disableCreateObjectURL;
                        PDFJS.verbosity = data.verbosity;
                        PDFJS.cMapUrl = data.cMapUrl === undefined ? null : data.cMapUrl;
                        PDFJS.cMapPacked = data.cMapPacked === true;
                        getPdfManager(data).then(function(newPdfManager) {
                            if (terminated) {
                                newPdfManager.terminate();
                                throw new Error('Worker was terminated');
                            }
                            pdfManager = newPdfManager;
                            handler.send('PDFManagerReady', null);
                            pdfManager.onLoadedStream().then(function(stream) {
                                handler.send('DataLoaded', {
                                    length: stream.bytes.byteLength
                                });
                            });
                        }).then(function pdfManagerReady() {
                            ensureNotTerminated();
                            loadDocument(false).then(onSuccess, function loadFailure(ex) {
                                ensureNotTerminated();
                                if (!(ex instanceof XRefParseException)) {
                                    if (ex instanceof PasswordException) {
                                        pdfManager.passwordChanged().then(pdfManagerReady);
                                    }
                                    onFailure(ex);
                                    return;
                                }
                                pdfManager.requestLoadedStream();
                                pdfManager.onLoadedStream().then(function() {
                                    ensureNotTerminated();
                                    loadDocument(true).then(onSuccess, onFailure);
                                });
                            }, onFailure);
                        }, onFailure);
                    };
                    handler.on('GetPage', function wphSetupGetPage(data) {
                        return pdfManager.getPage(data.pageIndex).then(function(page) {
                            var rotatePromise = pdfManager.ensure(page, 'rotate');
                            var refPromise = pdfManager.ensure(page, 'ref');
                            var viewPromise = pdfManager.ensure(page, 'view');
                            return Promise.all([rotatePromise, refPromise, viewPromise]).then(function(results) {
                                return {
                                    rotate: results[0],
                                    ref: results[1],
                                    view: results[2]
                                };
                            });
                        });
                    });
                    handler.on('GetPageIndex', function wphSetupGetPageIndex(data) {
                        var ref = new Ref(data.ref.num, data.ref.gen);
                        var catalog = pdfManager.pdfDocument.catalog;
                        return catalog.getPageIndex(ref);
                    });
                    handler.on('GetDestinations', function wphSetupGetDestinations(data) {
                        return pdfManager.ensureCatalog('destinations');
                    });
                    handler.on('GetDestination', function wphSetupGetDestination(data) {
                        return pdfManager.ensureCatalog('getDestination', [data.id]);
                    });
                    handler.on('GetPageLabels', function wphSetupGetPageLabels(data) {
                        return pdfManager.ensureCatalog('pageLabels');
                    });
                    handler.on('GetAttachments', function wphSetupGetAttachments(data) {
                        return pdfManager.ensureCatalog('attachments');
                    });
                    handler.on('GetJavaScript', function wphSetupGetJavaScript(data) {
                        return pdfManager.ensureCatalog('javaScript');
                    });
                    handler.on('GetOutline', function wphSetupGetOutline(data) {
                        return pdfManager.ensureCatalog('documentOutline');
                    });
                    handler.on('GetMetadata', function wphSetupGetMetadata(data) {
                        return Promise.all([pdfManager.ensureDoc('documentInfo'), pdfManager.ensureCatalog('metadata')]);
                    });
                    handler.on('GetData', function wphSetupGetData(data) {
                        pdfManager.requestLoadedStream();
                        return pdfManager.onLoadedStream().then(function(stream) {
                            return stream.bytes;
                        });
                    });
                    handler.on('GetStats', function wphSetupGetStats(data) {
                        return pdfManager.pdfDocument.xref.stats;
                    });
                    handler.on('UpdatePassword', function wphSetupUpdatePassword(data) {
                        pdfManager.updatePassword(data);
                    });
                    handler.on('GetAnnotations', function wphSetupGetAnnotations(data) {
                        return pdfManager.getPage(data.pageIndex).then(function(page) {
                            return pdfManager.ensure(page, 'getAnnotationsData', [data.intent]);
                        });
                    });
                    handler.on('RenderPageRequest', function wphSetupRenderPage(data) {
                        var pageIndex = data.pageIndex;
                        pdfManager.getPage(pageIndex).then(function(page) {
                            var task = new WorkerTask('RenderPageRequest: page ' + pageIndex);
                            startWorkerTask(task);
                            var pageNum = pageIndex + 1;
                            var start = Date.now();
                            page.getOperatorList(handler, task, data.intent).then(function(operatorList) {
                                finishWorkerTask(task);
                                info('page=' + pageNum + ' - getOperatorList: time=' +
                                    (Date.now() - start) + 'ms, len=' + operatorList.totalLength);
                            }, function(e) {
                                finishWorkerTask(task);
                                if (task.terminated) {
                                    return;
                                }
                                handler.send('UnsupportedFeature', {
                                    featureId: UNSUPPORTED_FEATURES.unknown
                                });
                                var minimumStackMessage = 'worker.js: while trying to getPage() and getOperatorList()';
                                var wrappedException;
                                if (typeof e === 'string') {
                                    wrappedException = {
                                        message: e,
                                        stack: minimumStackMessage
                                    };
                                } else if (typeof e === 'object') {
                                    wrappedException = {
                                        message: e.message || e.toString(),
                                        stack: e.stack || minimumStackMessage
                                    };
                                } else {
                                    wrappedException = {
                                        message: 'Unknown exception type: ' + (typeof e),
                                        stack: minimumStackMessage
                                    };
                                }
                                handler.send('PageError', {
                                    pageNum: pageNum,
                                    error: wrappedException,
                                    intent: data.intent
                                });
                            });
                        });
                    }, this);
                    handler.on('GetTextContent', function wphExtractText(data) {
                        var pageIndex = data.pageIndex;
                        var normalizeWhitespace = data.normalizeWhitespace;
                        return pdfManager.getPage(pageIndex).then(function(page) {
                            var task = new WorkerTask('GetTextContent: page ' + pageIndex);
                            startWorkerTask(task);
                            var pageNum = pageIndex + 1;
                            var start = Date.now();
                            return page.extractTextContent(task, normalizeWhitespace).then(function(textContent) {
                                finishWorkerTask(task);
                                info('text indexing: page=' + pageNum + ' - time=' +
                                    (Date.now() - start) + 'ms');
                                return textContent;
                            }, function(reason) {
                                finishWorkerTask(task);
                                if (task.terminated) {
                                    return;
                                }
                                throw reason;
                            });
                        });
                    });
                    handler.on('Cleanup', function wphCleanup(data) {
                        return pdfManager.cleanup();
                    });
                    handler.on('Terminate', function wphTerminate(data) {
                        terminated = true;
                        if (pdfManager) {
                            pdfManager.terminate();
                            pdfManager = null;
                        }
                        if (cancelXHRs) {
                            cancelXHRs();
                        }
                        var waitOn = [];
                        WorkerTasks.forEach(function(task) {
                            waitOn.push(task.finished);
                            task.terminate();
                        });
                        return Promise.all(waitOn).then(function() {
                            handler.destroy();
                            handler = null;
                        });
                    });
                    handler.on('Ready', function wphReady(data) {
                        setupDoc(docParams);
                        docParams = null;
                    });
                    return workerHandlerName;
                }
            };

            function initializeWorker() {
                if (!('console' in globalScope)) {
                    var consoleTimer = {};
                    var workerConsole = {
                        log: function log() {
                            var args = Array.prototype.slice.call(arguments);
                            globalScope.postMessage({
                                targetName: 'main',
                                action: 'console_log',
                                data: args
                            });
                        },
                        error: function error() {
                            var args = Array.prototype.slice.call(arguments);
                            globalScope.postMessage({
                                targetName: 'main',
                                action: 'console_error',
                                data: args
                            });
                            throw 'pdf.js execution error';
                        },
                        time: function time(name) {
                            consoleTimer[name] = Date.now();
                        },
                        timeEnd: function timeEnd(name) {
                            var time = consoleTimer[name];
                            if (!time) {
                                error('Unknown timer name ' + name);
                            }
                            this.log('Timer:', name, Date.now() - time);
                        }
                    };
                    globalScope.console = workerConsole;
                }
                var handler = new MessageHandler('worker', 'main', self);
                WorkerMessageHandler.setup(handler, self);
                handler.send('ready', null);
            }
            if (typeof window === 'undefined' && !(typeof module !== 'undefined' && module.require)) {
                initializeWorker();
            }
            exports.WorkerTask = WorkerTask;
            exports.WorkerMessageHandler = WorkerMessageHandler;
        }));
    }).call(pdfjsLibs);
    exports.PDFJS = pdfjsLibs.pdfjsSharedGlobal.PDFJS;
}));

(function(root, factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        define('pdfjs-dist/build/pdf', ['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.pdfjsDistBuildPdf = {}));
    }
}(this, function(exports) {
    'use strict';
    var pdfjsVersion = '1.4.20';
    var pdfjsBuild = 'b15f335';
    var pdfjsFilePath = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : null;
    var pdfjsLibs = {};
    (function pdfjsWrapper() {
        (function(root, factory) {
            {
                factory((root.pdfjsSharedGlobal = {}));
            }
        }(this, function(exports) {
            var globalScope = (typeof window !== 'undefined') ? window : (typeof global !== 'undefined') ? global : (typeof self !== 'undefined') ? self : this;
            var isWorker = (typeof window === 'undefined');
            if (!globalScope.PDFJS) {
                globalScope.PDFJS = {};
            }
            if (typeof pdfjsVersion !== 'undefined') {
                globalScope.PDFJS.version = pdfjsVersion;
            }
            if (typeof pdfjsVersion !== 'undefined') {
                globalScope.PDFJS.build = pdfjsBuild;
            }
            globalScope.PDFJS.pdfBug = false;
            exports.globalScope = globalScope;
            exports.isWorker = isWorker;
            exports.PDFJS = globalScope.PDFJS;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsDisplayDOMUtils = {}), root.pdfjsSharedGlobal);
            }
        }(this, function(exports, sharedGlobal) {
            var PDFJS = sharedGlobal.PDFJS;
            var CustomStyle = (function CustomStyleClosure() {
                var prefixes = ['ms', 'Moz', 'Webkit', 'O'];
                var _cache = {};

                function CustomStyle() {}
                CustomStyle.getProp = function get(propName, element) {
                    if (arguments.length === 1 && typeof _cache[propName] === 'string') {
                        return _cache[propName];
                    }
                    element = element || document.documentElement;
                    var style = element.style,
                        prefixed, uPropName;
                    if (typeof style[propName] === 'string') {
                        return (_cache[propName] = propName);
                    }
                    uPropName = propName.charAt(0).toUpperCase() + propName.slice(1);
                    for (var i = 0, l = prefixes.length; i < l; i++) {
                        prefixed = prefixes[i] + uPropName;
                        if (typeof style[prefixed] === 'string') {
                            return (_cache[propName] = prefixed);
                        }
                    }
                    return (_cache[propName] = 'undefined');
                };
                CustomStyle.setProp = function set(propName, element, str) {
                    var prop = this.getProp(propName);
                    if (prop !== 'undefined') {
                        element.style[prop] = str;
                    }
                };
                return CustomStyle;
            })();
            PDFJS.CustomStyle = CustomStyle;
            exports.CustomStyle = CustomStyle;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsSharedUtil = {}), root.pdfjsSharedGlobal);
            }
        }(this, function(exports, sharedGlobal) {
            var PDFJS = sharedGlobal.PDFJS;
            var globalScope = sharedGlobal.globalScope;
            var FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];
            var TextRenderingMode = {
                FILL: 0,
                STROKE: 1,
                FILL_STROKE: 2,
                INVISIBLE: 3,
                FILL_ADD_TO_PATH: 4,
                STROKE_ADD_TO_PATH: 5,
                FILL_STROKE_ADD_TO_PATH: 6,
                ADD_TO_PATH: 7,
                FILL_STROKE_MASK: 3,
                ADD_TO_PATH_FLAG: 4
            };
            var ImageKind = {
                GRAYSCALE_1BPP: 1,
                RGB_24BPP: 2,
                RGBA_32BPP: 3
            };
            var AnnotationType = {
                TEXT: 1,
                LINK: 2,
                FREETEXT: 3,
                LINE: 4,
                SQUARE: 5,
                CIRCLE: 6,
                POLYGON: 7,
                POLYLINE: 8,
                HIGHLIGHT: 9,
                UNDERLINE: 10,
                SQUIGGLY: 11,
                STRIKEOUT: 12,
                STAMP: 13,
                CARET: 14,
                INK: 15,
                POPUP: 16,
                FILEATTACHMENT: 17,
                SOUND: 18,
                MOVIE: 19,
                WIDGET: 20,
                SCREEN: 21,
                PRINTERMARK: 22,
                TRAPNET: 23,
                WATERMARK: 24,
                THREED: 25,
                REDACT: 26
            };
            var AnnotationFlag = {
                INVISIBLE: 0x01,
                HIDDEN: 0x02,
                PRINT: 0x04,
                NOZOOM: 0x08,
                NOROTATE: 0x10,
                NOVIEW: 0x20,
                READONLY: 0x40,
                LOCKED: 0x80,
                TOGGLENOVIEW: 0x100,
                LOCKEDCONTENTS: 0x200
            };
            var AnnotationBorderStyleType = {
                SOLID: 1,
                DASHED: 2,
                BEVELED: 3,
                INSET: 4,
                UNDERLINE: 5
            };
            var StreamType = {
                UNKNOWN: 0,
                FLATE: 1,
                LZW: 2,
                DCT: 3,
                JPX: 4,
                JBIG: 5,
                A85: 6,
                AHX: 7,
                CCF: 8,
                RL: 9
            };
            var FontType = {
                UNKNOWN: 0,
                TYPE1: 1,
                TYPE1C: 2,
                CIDFONTTYPE0: 3,
                CIDFONTTYPE0C: 4,
                TRUETYPE: 5,
                CIDFONTTYPE2: 6,
                TYPE3: 7,
                OPENTYPE: 8,
                TYPE0: 9,
                MMTYPE1: 10
            };
            PDFJS.VERBOSITY_LEVELS = {
                errors: 0,
                warnings: 1,
                infos: 5
            };
            var OPS = PDFJS.OPS = {
                dependency: 1,
                setLineWidth: 2,
                setLineCap: 3,
                setLineJoin: 4,
                setMiterLimit: 5,
                setDash: 6,
                setRenderingIntent: 7,
                setFlatness: 8,
                setGState: 9,
                save: 10,
                restore: 11,
                transform: 12,
                moveTo: 13,
                lineTo: 14,
                curveTo: 15,
                curveTo2: 16,
                curveTo3: 17,
                closePath: 18,
                rectangle: 19,
                stroke: 20,
                closeStroke: 21,
                fill: 22,
                eoFill: 23,
                fillStroke: 24,
                eoFillStroke: 25,
                closeFillStroke: 26,
                closeEOFillStroke: 27,
                endPath: 28,
                clip: 29,
                eoClip: 30,
                beginText: 31,
                endText: 32,
                setCharSpacing: 33,
                setWordSpacing: 34,
                setHScale: 35,
                setLeading: 36,
                setFont: 37,
                setTextRenderingMode: 38,
                setTextRise: 39,
                moveText: 40,
                setLeadingMoveText: 41,
                setTextMatrix: 42,
                nextLine: 43,
                showText: 44,
                showSpacedText: 45,
                nextLineShowText: 46,
                nextLineSetSpacingShowText: 47,
                setCharWidth: 48,
                setCharWidthAndBounds: 49,
                setStrokeColorSpace: 50,
                setFillColorSpace: 51,
                setStrokeColor: 52,
                setStrokeColorN: 53,
                setFillColor: 54,
                setFillColorN: 55,
                setStrokeGray: 56,
                setFillGray: 57,
                setStrokeRGBColor: 58,
                setFillRGBColor: 59,
                setStrokeCMYKColor: 60,
                setFillCMYKColor: 61,
                shadingFill: 62,
                beginInlineImage: 63,
                beginImageData: 64,
                endInlineImage: 65,
                paintXObject: 66,
                markPoint: 67,
                markPointProps: 68,
                beginMarkedContent: 69,
                beginMarkedContentProps: 70,
                endMarkedContent: 71,
                beginCompat: 72,
                endCompat: 73,
                paintFormXObjectBegin: 74,
                paintFormXObjectEnd: 75,
                beginGroup: 76,
                endGroup: 77,
                beginAnnotations: 78,
                endAnnotations: 79,
                beginAnnotation: 80,
                endAnnotation: 81,
                paintJpegXObject: 82,
                paintImageMaskXObject: 83,
                paintImageMaskXObjectGroup: 84,
                paintImageXObject: 85,
                paintInlineImageXObject: 86,
                paintInlineImageXObjectGroup: 87,
                paintImageXObjectRepeat: 88,
                paintImageMaskXObjectRepeat: 89,
                paintSolidColorImageMask: 90,
                constructPath: 91
            };

            function info(msg) {
                if (PDFJS.verbosity >= PDFJS.VERBOSITY_LEVELS.infos) {
                    console.log('Info: ' + msg);
                }
            }

            function warn(msg) {
                if (PDFJS.verbosity >= PDFJS.VERBOSITY_LEVELS.warnings) {
                    console.log('Warning: ' + msg);
                }
            }

            function deprecated(details) {
                warn('Deprecated API usage: ' + details);
            }

            function error(msg) {
                if (PDFJS.verbosity >= PDFJS.VERBOSITY_LEVELS.errors) {
                    console.log('Error: ' + msg);
                    console.log(backtrace());
                }
                throw new Error(msg);
            }

            function backtrace() {
                try {
                    throw new Error();
                } catch (e) {
                    return e.stack ? e.stack.split('\n').slice(2).join('\n') : '';
                }
            }

            function assert(cond, msg) {
                if (!cond) {
                    error(msg);
                }
            }
            var UNSUPPORTED_FEATURES = PDFJS.UNSUPPORTED_FEATURES = {
                unknown: 'unknown',
                forms: 'forms',
                javaScript: 'javaScript',
                smask: 'smask',
                shadingPattern: 'shadingPattern',
                font: 'font'
            };

            function combineUrl(baseUrl, url) {
                if (!url) {
                    return baseUrl;
                }
                return new URL(url, baseUrl).href;
            }

            function isValidUrl(url, allowRelative) {
                if (!url) {
                    return false;
                }
                var protocol = /^[a-z][a-z0-9+\-.]*(?=:)/i.exec(url);
                if (!protocol) {
                    return allowRelative;
                }
                protocol = protocol[0].toLowerCase();
                switch (protocol) {
                    case 'http':
                    case 'https':
                    case 'ftp':
                    case 'mailto':
                    case 'tel':
                        return true;
                    default:
                        return false;
                }
            }
            PDFJS.isValidUrl = isValidUrl;

            function addLinkAttributes(link, params) {
                var url = params && params.url;
                link.href = link.title = (url ? removeNullCharacters(url) : '');
                if (url) {
                    if (isExternalLinkTargetSet()) {
                        link.target = LinkTargetStringMap[PDFJS.externalLinkTarget];
                    }
                    link.rel = PDFJS.externalLinkRel;
                }
            }
            PDFJS.addLinkAttributes = addLinkAttributes;

            function shadow(obj, prop, value) {
                Object.defineProperty(obj, prop, {
                    value: value,
                    enumerable: true,
                    configurable: true,
                    writable: false
                });
                return value;
            }
            PDFJS.shadow = shadow;
            var LinkTarget = PDFJS.LinkTarget = {
                NONE: 0,
                SELF: 1,
                BLANK: 2,
                PARENT: 3,
                TOP: 4,
            };
            var LinkTargetStringMap = ['', '_self', '_blank', '_parent', '_top'];

            function isExternalLinkTargetSet() {
                if (PDFJS.openExternalLinksInNewWindow) {
                    deprecated('PDFJS.openExternalLinksInNewWindow, please use ' + '"PDFJS.externalLinkTarget = PDFJS.LinkTarget.BLANK" instead.');
                    if (PDFJS.externalLinkTarget === LinkTarget.NONE) {
                        PDFJS.externalLinkTarget = LinkTarget.BLANK;
                    }
                    PDFJS.openExternalLinksInNewWindow = false;
                }
                switch (PDFJS.externalLinkTarget) {
                    case LinkTarget.NONE:
                        return false;
                    case LinkTarget.SELF:
                    case LinkTarget.BLANK:
                    case LinkTarget.PARENT:
                    case LinkTarget.TOP:
                        return true;
                }
                warn('PDFJS.externalLinkTarget is invalid: ' + PDFJS.externalLinkTarget);
                PDFJS.externalLinkTarget = LinkTarget.NONE;
                return false;
            }
            PDFJS.isExternalLinkTargetSet = isExternalLinkTargetSet;
            var PasswordResponses = PDFJS.PasswordResponses = {
                NEED_PASSWORD: 1,
                INCORRECT_PASSWORD: 2
            };
            var PasswordException = (function PasswordExceptionClosure() {
                function PasswordException(msg, code) {
                    this.name = 'PasswordException';
                    this.message = msg;
                    this.code = code;
                }
                PasswordException.prototype = new Error();
                PasswordException.constructor = PasswordException;
                return PasswordException;
            })();
            PDFJS.PasswordException = PasswordException;
            var UnknownErrorException = (function UnknownErrorExceptionClosure() {
                function UnknownErrorException(msg, details) {
                    this.name = 'UnknownErrorException';
                    this.message = msg;
                    this.details = details;
                }
                UnknownErrorException.prototype = new Error();
                UnknownErrorException.constructor = UnknownErrorException;
                return UnknownErrorException;
            })();
            PDFJS.UnknownErrorException = UnknownErrorException;
            var InvalidPDFException = (function InvalidPDFExceptionClosure() {
                function InvalidPDFException(msg) {
                    this.name = 'InvalidPDFException';
                    this.message = msg;
                }
                InvalidPDFException.prototype = new Error();
                InvalidPDFException.constructor = InvalidPDFException;
                return InvalidPDFException;
            })();
            PDFJS.InvalidPDFException = InvalidPDFException;
            var MissingPDFException = (function MissingPDFExceptionClosure() {
                function MissingPDFException(msg) {
                    this.name = 'MissingPDFException';
                    this.message = msg;
                }
                MissingPDFException.prototype = new Error();
                MissingPDFException.constructor = MissingPDFException;
                return MissingPDFException;
            })();
            PDFJS.MissingPDFException = MissingPDFException;
            var UnexpectedResponseException = (function UnexpectedResponseExceptionClosure() {
                function UnexpectedResponseException(msg, status) {
                    this.name = 'UnexpectedResponseException';
                    this.message = msg;
                    this.status = status;
                }
                UnexpectedResponseException.prototype = new Error();
                UnexpectedResponseException.constructor = UnexpectedResponseException;
                return UnexpectedResponseException;
            })();
            PDFJS.UnexpectedResponseException = UnexpectedResponseException;
            var NotImplementedException = (function NotImplementedExceptionClosure() {
                function NotImplementedException(msg) {
                    this.message = msg;
                }
                NotImplementedException.prototype = new Error();
                NotImplementedException.prototype.name = 'NotImplementedException';
                NotImplementedException.constructor = NotImplementedException;
                return NotImplementedException;
            })();
            var MissingDataException = (function MissingDataExceptionClosure() {
                function MissingDataException(begin, end) {
                    this.begin = begin;
                    this.end = end;
                    this.message = 'Missing data [' + begin + ', ' + end + ')';
                }
                MissingDataException.prototype = new Error();
                MissingDataException.prototype.name = 'MissingDataException';
                MissingDataException.constructor = MissingDataException;
                return MissingDataException;
            })();
            var XRefParseException = (function XRefParseExceptionClosure() {
                function XRefParseException(msg) {
                    this.message = msg;
                }
                XRefParseException.prototype = new Error();
                XRefParseException.prototype.name = 'XRefParseException';
                XRefParseException.constructor = XRefParseException;
                return XRefParseException;
            })();
            var NullCharactersRegExp = /\x00/g;

            function removeNullCharacters(str) {
                if (typeof str !== 'string') {
                    warn('The argument for removeNullCharacters must be a string.');
                    return str;
                }
                return str.replace(NullCharactersRegExp, '');
            }
            PDFJS.removeNullCharacters = removeNullCharacters;

            function bytesToString(bytes) {
                assert(bytes !== null && typeof bytes === 'object' && bytes.length !== undefined, 'Invalid argument for bytesToString');
                var length = bytes.length;
                var MAX_ARGUMENT_COUNT = 8192;
                if (length < MAX_ARGUMENT_COUNT) {
                    return String.fromCharCode.apply(null, bytes);
                }
                var strBuf = [];
                for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
                    var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
                    var chunk = bytes.subarray(i, chunkEnd);
                    strBuf.push(String.fromCharCode.apply(null, chunk));
                }
                return strBuf.join('');
            }

            function stringToBytes(str) {
                assert(typeof str === 'string', 'Invalid argument for stringToBytes');
                var length = str.length;
                var bytes = new Uint8Array(length);
                for (var i = 0; i < length; ++i) {
                    bytes[i] = str.charCodeAt(i) & 0xFF;
                }
                return bytes;
            }

            function string32(value) {
                return String.fromCharCode((value >> 24) & 0xff, (value >> 16) & 0xff, (value >> 8) & 0xff, value & 0xff);
            }

            function log2(x) {
                var n = 1,
                    i = 0;
                while (x > n) {
                    n <<= 1;
                    i++;
                }
                return i;
            }

            function readInt8(data, start) {
                return (data[start] << 24) >> 24;
            }

            function readUint16(data, offset) {
                return (data[offset] << 8) | data[offset + 1];
            }

            function readUint32(data, offset) {
                return ((data[offset] << 24) | (data[offset + 1] << 16) | (data[offset + 2] << 8) | data[offset + 3]) >>> 0;
            }

            function isLittleEndian() {
                var buffer8 = new Uint8Array(2);
                buffer8[0] = 1;
                var buffer16 = new Uint16Array(buffer8.buffer);
                return (buffer16[0] === 1);
            }
            Object.defineProperty(PDFJS, 'isLittleEndian', {
                configurable: true,
                get: function PDFJS_isLittleEndian() {
                    return shadow(PDFJS, 'isLittleEndian', isLittleEndian());
                }
            });

            function hasCanvasTypedArrays() {
                var canvas = document.createElement('canvas');
                canvas.width = canvas.height = 1;
                var ctx = canvas.getContext('2d');
                var imageData = ctx.createImageData(1, 1);
                return (typeof imageData.data.buffer !== 'undefined');
            }
            Object.defineProperty(PDFJS, 'hasCanvasTypedArrays', {
                configurable: true,
                get: function PDFJS_hasCanvasTypedArrays() {
                    return shadow(PDFJS, 'hasCanvasTypedArrays', hasCanvasTypedArrays());
                }
            });
            var Uint32ArrayView = (function Uint32ArrayViewClosure() {
                function Uint32ArrayView(buffer, length) {
                    this.buffer = buffer;
                    this.byteLength = buffer.length;
                    this.length = length === undefined ? (this.byteLength >> 2) : length;
                    ensureUint32ArrayViewProps(this.length);
                }
                Uint32ArrayView.prototype = Object.create(null);
                var uint32ArrayViewSetters = 0;

                function createUint32ArrayProp(index) {
                    return {
                        get: function() {
                            var buffer = this.buffer,
                                offset = index << 2;
                            return (buffer[offset] | (buffer[offset + 1] << 8) | (buffer[offset + 2] << 16) | (buffer[offset + 3] << 24)) >>> 0;
                        },
                        set: function(value) {
                            var buffer = this.buffer,
                                offset = index << 2;
                            buffer[offset] = value & 255;
                            buffer[offset + 1] = (value >> 8) & 255;
                            buffer[offset + 2] = (value >> 16) & 255;
                            buffer[offset + 3] = (value >>> 24) & 255;
                        }
                    };
                }

                function ensureUint32ArrayViewProps(length) {
                    while (uint32ArrayViewSetters < length) {
                        Object.defineProperty(Uint32ArrayView.prototype, uint32ArrayViewSetters, createUint32ArrayProp(uint32ArrayViewSetters));
                        uint32ArrayViewSetters++;
                    }
                }
                return Uint32ArrayView;
            })();
            exports.Uint32ArrayView = Uint32ArrayView;
            var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
            var Util = PDFJS.Util = (function UtilClosure() {
                function Util() {}
                var rgbBuf = ['rgb(', 0, ',', 0, ',', 0, ')'];
                Util.makeCssRgb = function Util_makeCssRgb(r, g, b) {
                    rgbBuf[1] = r;
                    rgbBuf[3] = g;
                    rgbBuf[5] = b;
                    return rgbBuf.join('');
                };
                Util.transform = function Util_transform(m1, m2) {
                    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
                };
                Util.applyTransform = function Util_applyTransform(p, m) {
                    var xt = p[0] * m[0] + p[1] * m[2] + m[4];
                    var yt = p[0] * m[1] + p[1] * m[3] + m[5];
                    return [xt, yt];
                };
                Util.applyInverseTransform = function Util_applyInverseTransform(p, m) {
                    var d = m[0] * m[3] - m[1] * m[2];
                    var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
                    var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
                    return [xt, yt];
                };
                Util.getAxialAlignedBoundingBox = function Util_getAxialAlignedBoundingBox(r, m) {
                    var p1 = Util.applyTransform(r, m);
                    var p2 = Util.applyTransform(r.slice(2, 4), m);
                    var p3 = Util.applyTransform([r[0], r[3]], m);
                    var p4 = Util.applyTransform([r[2], r[1]], m);
                    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
                };
                Util.inverseTransform = function Util_inverseTransform(m) {
                    var d = m[0] * m[3] - m[1] * m[2];
                    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
                };
                Util.apply3dTransform = function Util_apply3dTransform(m, v) {
                    return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
                };
                Util.singularValueDecompose2dScale = function Util_singularValueDecompose2dScale(m) {
                    var transpose = [m[0], m[2], m[1], m[3]];
                    var a = m[0] * transpose[0] + m[1] * transpose[2];
                    var b = m[0] * transpose[1] + m[1] * transpose[3];
                    var c = m[2] * transpose[0] + m[3] * transpose[2];
                    var d = m[2] * transpose[1] + m[3] * transpose[3];
                    var first = (a + d) / 2;
                    var second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;
                    var sx = first + second || 1;
                    var sy = first - second || 1;
                    return [Math.sqrt(sx), Math.sqrt(sy)];
                };
                Util.normalizeRect = function Util_normalizeRect(rect) {
                    var r = rect.slice(0);
                    if (rect[0] > rect[2]) {
                        r[0] = rect[2];
                        r[2] = rect[0];
                    }
                    if (rect[1] > rect[3]) {
                        r[1] = rect[3];
                        r[3] = rect[1];
                    }
                    return r;
                };
                Util.intersect = function Util_intersect(rect1, rect2) {
                    function compare(a, b) {
                        return a - b;
                    }
                    var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare),
                        orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare),
                        result = [];
                    rect1 = Util.normalizeRect(rect1);
                    rect2 = Util.normalizeRect(rect2);
                    if ((orderedX[0] === rect1[0] && orderedX[1] === rect2[0]) || (orderedX[0] === rect2[0] && orderedX[1] === rect1[0])) {
                        result[0] = orderedX[1];
                        result[2] = orderedX[2];
                    } else {
                        return false;
                    }
                    if ((orderedY[0] === rect1[1] && orderedY[1] === rect2[1]) || (orderedY[0] === rect2[1] && orderedY[1] === rect1[1])) {
                        result[1] = orderedY[1];
                        result[3] = orderedY[2];
                    } else {
                        return false;
                    }
                    return result;
                };
                Util.sign = function Util_sign(num) {
                    return num < 0 ? -1 : 1;
                };
                var ROMAN_NUMBER_MAP = ['', 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM', '', 'X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC', '', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX'];
                Util.toRoman = function Util_toRoman(number, lowerCase) {
                    assert(isInt(number) && number > 0, 'The number should be a positive integer.');
                    var pos, romanBuf = [];
                    while (number >= 1000) {
                        number -= 1000;
                        romanBuf.push('M');
                    }
                    pos = (number / 100) | 0;
                    number %= 100;
                    romanBuf.push(ROMAN_NUMBER_MAP[pos]);
                    pos = (number / 10) | 0;
                    number %= 10;
                    romanBuf.push(ROMAN_NUMBER_MAP[10 + pos]);
                    romanBuf.push(ROMAN_NUMBER_MAP[20 + number]);
                    var romanStr = romanBuf.join('');
                    return (lowerCase ? romanStr.toLowerCase() : romanStr);
                };
                Util.appendToArray = function Util_appendToArray(arr1, arr2) {
                    Array.prototype.push.apply(arr1, arr2);
                };
                Util.prependToArray = function Util_prependToArray(arr1, arr2) {
                    Array.prototype.unshift.apply(arr1, arr2);
                };
                Util.extendObj = function extendObj(obj1, obj2) {
                    for (var key in obj2) {
                        obj1[key] = obj2[key];
                    }
                };
                Util.getInheritableProperty = function Util_getInheritableProperty(dict, name) {
                    while (dict && !dict.has(name)) {
                        dict = dict.get('Parent');
                    }
                    if (!dict) {
                        return null;
                    }
                    return dict.get(name);
                };
                Util.inherit = function Util_inherit(sub, base, prototype) {
                    sub.prototype = Object.create(base.prototype);
                    sub.prototype.constructor = sub;
                    for (var prop in prototype) {
                        sub.prototype[prop] = prototype[prop];
                    }
                };
                Util.loadScript = function Util_loadScript(src, callback) {
                    var script = document.createElement('script');
                    var loaded = false;
                    script.setAttribute('src', src);
                    if (callback) {
                        script.onload = function() {
                            if (!loaded) {
                                callback();
                            }
                            loaded = true;
                        };
                    }
                    document.getElementsByTagName('head')[0].appendChild(script);
                };
                return Util;
            })();
            var PageViewport = PDFJS.PageViewport = (function PageViewportClosure() {
                function PageViewport(viewBox, scale, rotation, offsetX, offsetY, dontFlip) {
                    this.viewBox = viewBox;
                    this.scale = scale;
                    this.rotation = rotation;
                    this.offsetX = offsetX;
                    this.offsetY = offsetY;
                    var centerX = (viewBox[2] + viewBox[0]) / 2;
                    var centerY = (viewBox[3] + viewBox[1]) / 2;
                    var rotateA, rotateB, rotateC, rotateD;
                    rotation = rotation % 360;
                    rotation = rotation < 0 ? rotation + 360 : rotation;
                    switch (rotation) {
                        case 180:
                            rotateA = -1;
                            rotateB = 0;
                            rotateC = 0;
                            rotateD = 1;
                            break;
                        case 90:
                            rotateA = 0;
                            rotateB = 1;
                            rotateC = 1;
                            rotateD = 0;
                            break;
                        case 270:
                            rotateA = 0;
                            rotateB = -1;
                            rotateC = -1;
                            rotateD = 0;
                            break;
                        default:
                            rotateA = 1;
                            rotateB = 0;
                            rotateC = 0;
                            rotateD = -1;
                            break;
                    }
                    if (dontFlip) {
                        rotateC = -rotateC;
                        rotateD = -rotateD;
                    }
                    var offsetCanvasX, offsetCanvasY;
                    var width, height;
                    if (rotateA === 0) {
                        offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
                        offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
                        width = Math.abs(viewBox[3] - viewBox[1]) * scale;
                        height = Math.abs(viewBox[2] - viewBox[0]) * scale;
                    } else {
                        offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
                        offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
                        width = Math.abs(viewBox[2] - viewBox[0]) * scale;
                        height = Math.abs(viewBox[3] - viewBox[1]) * scale;
                    }
                    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
                    this.width = width;
                    this.height = height;
                    this.fontScale = scale;
                }
                PageViewport.prototype = {
                    clone: function PageViewPort_clone(args) {
                        args = args || {};
                        var scale = 'scale' in args ? args.scale : this.scale;
                        var rotation = 'rotation' in args ? args.rotation : this.rotation;
                        return new PageViewport(this.viewBox.slice(), scale, rotation, this.offsetX, this.offsetY, args.dontFlip);
                    },
                    convertToViewportPoint: function PageViewport_convertToViewportPoint(x, y) {
                        return Util.applyTransform([x, y], this.transform);
                    },
                    convertToViewportRectangle: function PageViewport_convertToViewportRectangle(rect) {
                        var tl = Util.applyTransform([rect[0], rect[1]], this.transform);
                        var br = Util.applyTransform([rect[2], rect[3]], this.transform);
                        return [tl[0], tl[1], br[0], br[1]];
                    },
                    convertToPdfPoint: function PageViewport_convertToPdfPoint(x, y) {
                        return Util.applyInverseTransform([x, y], this.transform);
                    }
                };
                return PageViewport;
            })();
            var PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2D8, 0x2C7, 0x2C6, 0x2D9, 0x2DD, 0x2DB, 0x2DA, 0x2DC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203A, 0x2212, 0x2030, 0x201E, 0x201C, 0x201D, 0x2018, 0x2019, 0x201A, 0x2122, 0xFB01, 0xFB02, 0x141, 0x152, 0x160, 0x178, 0x17D, 0x131, 0x142, 0x153, 0x161, 0x17E, 0, 0x20AC];

            function stringToPDFString(str) {
                var i, n = str.length,
                    strBuf = [];
                if (str[0] === '\xFE' && str[1] === '\xFF') {
                    for (i = 2; i < n; i += 2) {
                        strBuf.push(String.fromCharCode((str.charCodeAt(i) << 8) | str.charCodeAt(i + 1)));
                    }
                } else {
                    for (i = 0; i < n; ++i) {
                        var code = PDFStringTranslateTable[str.charCodeAt(i)];
                        strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
                    }
                }
                return strBuf.join('');
            }

            function stringToUTF8String(str) {
                return decodeURIComponent(escape(str));
            }

            function utf8StringToString(str) {
                return unescape(encodeURIComponent(str));
            }

            function isEmptyObj(obj) {
                for (var key in obj) {
                    return false;
                }
                return true;
            }

            function isBool(v) {
                return typeof v === 'boolean';
            }

            function isInt(v) {
                return typeof v === 'number' && ((v | 0) === v);
            }

            function isNum(v) {
                return typeof v === 'number';
            }

            function isString(v) {
                return typeof v === 'string';
            }

            function isArray(v) {
                return v instanceof Array;
            }

            function isArrayBuffer(v) {
                return typeof v === 'object' && v !== null && v.byteLength !== undefined;
            }

            function createPromiseCapability() {
                var capability = {};
                capability.promise = new Promise(function(resolve, reject) {
                    capability.resolve = resolve;
                    capability.reject = reject;
                });
                return capability;
            }
            PDFJS.createPromiseCapability = createPromiseCapability;
            (function PromiseClosure() {
                if (globalScope.Promise) {
                    if (typeof globalScope.Promise.all !== 'function') {
                        globalScope.Promise.all = function(iterable) {
                            var count = 0,
                                results = [],
                                resolve, reject;
                            var promise = new globalScope.Promise(function(resolve_, reject_) {
                                resolve = resolve_;
                                reject = reject_;
                            });
                            iterable.forEach(function(p, i) {
                                count++;
                                p.then(function(result) {
                                    results[i] = result;
                                    count--;
                                    if (count === 0) {
                                        resolve(results);
                                    }
                                }, reject);
                            });
                            if (count === 0) {
                                resolve(results);
                            }
                            return promise;
                        };
                    }
                    if (typeof globalScope.Promise.resolve !== 'function') {
                        globalScope.Promise.resolve = function(value) {
                            return new globalScope.Promise(function(resolve) {
                                resolve(value);
                            });
                        };
                    }
                    if (typeof globalScope.Promise.reject !== 'function') {
                        globalScope.Promise.reject = function(reason) {
                            return new globalScope.Promise(function(resolve, reject) {
                                reject(reason);
                            });
                        };
                    }
                    if (typeof globalScope.Promise.prototype.catch !== 'function') {
                        globalScope.Promise.prototype.catch = function(onReject) {
                            return globalScope.Promise.prototype.then(undefined, onReject);
                        };
                    }
                    return;
                }
                var STATUS_PENDING = 0;
                var STATUS_RESOLVED = 1;
                var STATUS_REJECTED = 2;
                var REJECTION_TIMEOUT = 500;
                var HandlerManager = {
                    handlers: [],
                    running: false,
                    unhandledRejections: [],
                    pendingRejectionCheck: false,
                    scheduleHandlers: function scheduleHandlers(promise) {
                        if (promise._status === STATUS_PENDING) {
                            return;
                        }
                        this.handlers = this.handlers.concat(promise._handlers);
                        promise._handlers = [];
                        if (this.running) {
                            return;
                        }
                        this.running = true;
                        setTimeout(this.runHandlers.bind(this), 0);
                    },
                    runHandlers: function runHandlers() {
                        var RUN_TIMEOUT = 1;
                        var timeoutAt = Date.now() + RUN_TIMEOUT;
                        while (this.handlers.length > 0) {
                            var handler = this.handlers.shift();
                            var nextStatus = handler.thisPromise._status;
                            var nextValue = handler.thisPromise._value;
                            try {
                                if (nextStatus === STATUS_RESOLVED) {
                                    if (typeof handler.onResolve === 'function') {
                                        nextValue = handler.onResolve(nextValue);
                                    }
                                } else if (typeof handler.onReject === 'function') {
                                    nextValue = handler.onReject(nextValue);
                                    nextStatus = STATUS_RESOLVED;
                                    if (handler.thisPromise._unhandledRejection) {
                                        this.removeUnhandeledRejection(handler.thisPromise);
                                    }
                                }
                            } catch (ex) {
                                nextStatus = STATUS_REJECTED;
                                nextValue = ex;
                            }
                            handler.nextPromise._updateStatus(nextStatus, nextValue);
                            if (Date.now() >= timeoutAt) {
                                break;
                            }
                        }
                        if (this.handlers.length > 0) {
                            setTimeout(this.runHandlers.bind(this), 0);
                            return;
                        }
                        this.running = false;
                    },
                    addUnhandledRejection: function addUnhandledRejection(promise) {
                        this.unhandledRejections.push({
                            promise: promise,
                            time: Date.now()
                        });
                        this.scheduleRejectionCheck();
                    },
                    removeUnhandeledRejection: function removeUnhandeledRejection(promise) {
                        promise._unhandledRejection = false;
                        for (var i = 0; i < this.unhandledRejections.length; i++) {
                            if (this.unhandledRejections[i].promise === promise) {
                                this.unhandledRejections.splice(i);
                                i--;
                            }
                        }
                    },
                    scheduleRejectionCheck: function scheduleRejectionCheck() {
                        if (this.pendingRejectionCheck) {
                            return;
                        }
                        this.pendingRejectionCheck = true;
                        setTimeout(function rejectionCheck() {
                            this.pendingRejectionCheck = false;
                            var now = Date.now();
                            for (var i = 0; i < this.unhandledRejections.length; i++) {
                                if (now - this.unhandledRejections[i].time > REJECTION_TIMEOUT) {
                                    var unhandled = this.unhandledRejections[i].promise._value;
                                    var msg = 'Unhandled rejection: ' + unhandled;
                                    if (unhandled.stack) {
                                        msg += '\n' + unhandled.stack;
                                    }
                                    warn(msg);
                                    this.unhandledRejections.splice(i);
                                    i--;
                                }
                            }
                            if (this.unhandledRejections.length) {
                                this.scheduleRejectionCheck();
                            }
                        }.bind(this), REJECTION_TIMEOUT);
                    }
                };

                function Promise(resolver) {
                    this._status = STATUS_PENDING;
                    this._handlers = [];
                    try {
                        resolver.call(this, this._resolve.bind(this), this._reject.bind(this));
                    } catch (e) {
                        this._reject(e);
                    }
                }
                Promise.all = function Promise_all(promises) {
                    var resolveAll, rejectAll;
                    var deferred = new Promise(function(resolve, reject) {
                        resolveAll = resolve;
                        rejectAll = reject;
                    });
                    var unresolved = promises.length;
                    var results = [];
                    if (unresolved === 0) {
                        resolveAll(results);
                        return deferred;
                    }

                    function reject(reason) {
                        if (deferred._status === STATUS_REJECTED) {
                            return;
                        }
                        results = [];
                        rejectAll(reason);
                    }
                    for (var i = 0, ii = promises.length; i < ii; ++i) {
                        var promise = promises[i];
                        var resolve = (function(i) {
                            return function(value) {
                                if (deferred._status === STATUS_REJECTED) {
                                    return;
                                }
                                results[i] = value;
                                unresolved--;
                                if (unresolved === 0) {
                                    resolveAll(results);
                                }
                            };
                        })(i);
                        if (Promise.isPromise(promise)) {
                            promise.then(resolve, reject);
                        } else {
                            resolve(promise);
                        }
                    }
                    return deferred;
                };
                Promise.isPromise = function Promise_isPromise(value) {
                    return value && typeof value.then === 'function';
                };
                Promise.resolve = function Promise_resolve(value) {
                    return new Promise(function(resolve) {
                        resolve(value);
                    });
                };
                Promise.reject = function Promise_reject(reason) {
                    return new Promise(function(resolve, reject) {
                        reject(reason);
                    });
                };
                Promise.prototype = {
                    _status: null,
                    _value: null,
                    _handlers: null,
                    _unhandledRejection: null,
                    _updateStatus: function Promise__updateStatus(status, value) {
                        if (this._status === STATUS_RESOLVED || this._status === STATUS_REJECTED) {
                            return;
                        }
                        if (status === STATUS_RESOLVED && Promise.isPromise(value)) {
                            value.then(this._updateStatus.bind(this, STATUS_RESOLVED), this._updateStatus.bind(this, STATUS_REJECTED));
                            return;
                        }
                        this._status = status;
                        this._value = value;
                        if (status === STATUS_REJECTED && this._handlers.length === 0) {
                            this._unhandledRejection = true;
                            HandlerManager.addUnhandledRejection(this);
                        }
                        HandlerManager.scheduleHandlers(this);
                    },
                    _resolve: function Promise_resolve(value) {
                        this._updateStatus(STATUS_RESOLVED, value);
                    },
                    _reject: function Promise_reject(reason) {
                        this._updateStatus(STATUS_REJECTED, reason);
                    },
                    then: function Promise_then(onResolve, onReject) {
                        var nextPromise = new Promise(function(resolve, reject) {
                            this.resolve = resolve;
                            this.reject = reject;
                        });
                        this._handlers.push({
                            thisPromise: this,
                            onResolve: onResolve,
                            onReject: onReject,
                            nextPromise: nextPromise
                        });
                        HandlerManager.scheduleHandlers(this);
                        return nextPromise;
                    },
                    catch: function Promise_catch(onReject) {
                        return this.then(undefined, onReject);
                    }
                };
                globalScope.Promise = Promise;
            })();
            var StatTimer = (function StatTimerClosure() {
                function rpad(str, pad, length) {
                    while (str.length < length) {
                        str += pad;
                    }
                    return str;
                }

                function StatTimer() {
                    this.started = {};
                    this.times = [];
                    this.enabled = true;
                }
                StatTimer.prototype = {
                    time: function StatTimer_time(name) {
                        if (!this.enabled) {
                            return;
                        }
                        if (name in this.started) {
                            warn('Timer is already running for ' + name);
                        }
                        this.started[name] = Date.now();
                    },
                    timeEnd: function StatTimer_timeEnd(name) {
                        if (!this.enabled) {
                            return;
                        }
                        if (!(name in this.started)) {
                            warn('Timer has not been started for ' + name);
                        }
                        this.times.push({
                            'name': name,
                            'start': this.started[name],
                            'end': Date.now()
                        });
                        delete this.started[name];
                    },
                    toString: function StatTimer_toString() {
                        var i, ii;
                        var times = this.times;
                        var out = '';
                        var longest = 0;
                        for (i = 0, ii = times.length; i < ii; ++i) {
                            var name = times[i]['name'];
                            if (name.length > longest) {
                                longest = name.length;
                            }
                        }
                        for (i = 0, ii = times.length; i < ii; ++i) {
                            var span = times[i];
                            var duration = span.end - span.start;
                            out += rpad(span['name'], ' ', longest) + ' ' + duration + 'ms\n';
                        }
                        return out;
                    }
                };
                return StatTimer;
            })();
            PDFJS.createBlob = function createBlob(data, contentType) {
                if (typeof Blob !== 'undefined') {
                    return new Blob([data], {
                        type: contentType
                    });
                }
                var bb = new MozBlobBuilder();
                bb.append(data);
                return bb.getBlob(contentType);
            };
            PDFJS.createObjectURL = (function createObjectURLClosure() {
                var digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
                return function createObjectURL(data, contentType) {
                    if (!PDFJS.disableCreateObjectURL && typeof URL !== 'undefined' && URL.createObjectURL) {
                        var blob = PDFJS.createBlob(data, contentType);
                        return URL.createObjectURL(blob);
                    }
                    var buffer = 'data:' + contentType + ';base64,';
                    for (var i = 0, ii = data.length; i < ii; i += 3) {
                        var b1 = data[i] & 0xFF;
                        var b2 = data[i + 1] & 0xFF;
                        var b3 = data[i + 2] & 0xFF;
                        var d1 = b1 >> 2,
                            d2 = ((b1 & 3) << 4) | (b2 >> 4);
                        var d3 = i + 1 < ii ? ((b2 & 0xF) << 2) | (b3 >> 6) : 64;
                        var d4 = i + 2 < ii ? (b3 & 0x3F) : 64;
                        buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
                    }
                    return buffer;
                };
            })();

            function MessageHandler(sourceName, targetName, comObj) {
                this.sourceName = sourceName;
                this.targetName = targetName;
                this.comObj = comObj;
                this.callbackIndex = 1;
                this.postMessageTransfers = true;
                var callbacksCapabilities = this.callbacksCapabilities = {};
                var ah = this.actionHandler = {};
                this._onComObjOnMessage = function messageHandlerComObjOnMessage(event) {
                    var data = event.data;
                    if (data.targetName !== this.sourceName) {
                        return;
                    }
                    if (data.isReply) {
                        var callbackId = data.callbackId;
                        if (data.callbackId in callbacksCapabilities) {
                            var callback = callbacksCapabilities[callbackId];
                            delete callbacksCapabilities[callbackId];
                            if ('error' in data) {
                                callback.reject(data.error);
                            } else {
                                callback.resolve(data.data);
                            }
                        } else {
                            error('Cannot resolve callback ' + callbackId);
                        }
                    } else if (data.action in ah) {
                        var action = ah[data.action];
                        if (data.callbackId) {
                            var sourceName = this.sourceName;
                            var targetName = data.sourceName;
                            Promise.resolve().then(function() {
                                return action[0].call(action[1], data.data);
                            }).then(function(result) {
                                comObj.postMessage({
                                    sourceName: sourceName,
                                    targetName: targetName,
                                    isReply: true,
                                    callbackId: data.callbackId,
                                    data: result
                                });
                            }, function(reason) {
                                if (reason instanceof Error) {
                                    reason = reason + '';
                                }
                                comObj.postMessage({
                                    sourceName: sourceName,
                                    targetName: targetName,
                                    isReply: true,
                                    callbackId: data.callbackId,
                                    error: reason
                                });
                            });
                        } else {
                            action[0].call(action[1], data.data);
                        }
                    } else {
                        error('Unknown action from worker: ' + data.action);
                    }
                }.bind(this);
                comObj.addEventListener('message', this._onComObjOnMessage);
            }
            MessageHandler.prototype = {
                on: function messageHandlerOn(actionName, handler, scope) {
                    var ah = this.actionHandler;
                    if (ah[actionName]) {
                        error('There is already an actionName called "' + actionName + '"');
                    }
                    ah[actionName] = [handler, scope];
                },
                send: function messageHandlerSend(actionName, data, transfers) {
                    var message = {
                        sourceName: this.sourceName,
                        targetName: this.targetName,
                        action: actionName,
                        data: data
                    };
                    this.postMessage(message, transfers);
                },
                sendWithPromise: function messageHandlerSendWithPromise(actionName, data, transfers) {
                    var callbackId = this.callbackIndex++;
                    var message = {
                        sourceName: this.sourceName,
                        targetName: this.targetName,
                        action: actionName,
                        data: data,
                        callbackId: callbackId
                    };
                    var capability = createPromiseCapability();
                    this.callbacksCapabilities[callbackId] = capability;
                    try {
                        this.postMessage(message, transfers);
                    } catch (e) {
                        capability.reject(e);
                    }
                    return capability.promise;
                },
                postMessage: function(message, transfers) {
                    if (transfers && this.postMessageTransfers) {
                        this.comObj.postMessage(message, transfers);
                    } else {
                        this.comObj.postMessage(message);
                    }
                },
                destroy: function() {
                    this.comObj.removeEventListener('message', this._onComObjOnMessage);
                }
            };

            function loadJpegStream(id, imageUrl, objs) {
                var img = new Image();
                img.onload = (function loadJpegStream_onloadClosure() {
                    objs.resolve(id, img);
                });
                img.onerror = (function loadJpegStream_onerrorClosure() {
                    objs.resolve(id, null);
                    warn('Error during JPEG image loading');
                });
                img.src = imageUrl;
            }
            (function checkURLConstructor(scope) {
                var hasWorkingUrl = false;
                try {
                    if (typeof URL === 'function' && typeof URL.prototype === 'object' && ('origin' in URL.prototype)) {
                        var u = new URL('b', 'http://a');
                        u.pathname = 'c%20d';
                        hasWorkingUrl = u.href === 'http://a/c%20d';
                    }
                } catch (e) {}
                if (hasWorkingUrl)
                    return;
                var relative = Object.create(null);
                relative['ftp'] = 21;
                relative['file'] = 0;
                relative['gopher'] = 70;
                relative['http'] = 80;
                relative['https'] = 443;
                relative['ws'] = 80;
                relative['wss'] = 443;
                var relativePathDotMapping = Object.create(null);
                relativePathDotMapping['%2e'] = '.';
                relativePathDotMapping['.%2e'] = '..';
                relativePathDotMapping['%2e.'] = '..';
                relativePathDotMapping['%2e%2e'] = '..';

                function isRelativeScheme(scheme) {
                    return relative[scheme] !== undefined;
                }

                function invalid() {
                    clear.call(this);
                    this._isInvalid = true;
                }

                function IDNAToASCII(h) {
                    if ('' == h) {
                        invalid.call(this)
                    }
                    return h.toLowerCase()
                }

                function percentEscape(c) {
                    var unicode = c.charCodeAt(0);
                    if (unicode > 0x20 && unicode < 0x7F && [0x22, 0x23, 0x3C, 0x3E, 0x3F, 0x60].indexOf(unicode) == -1) {
                        return c;
                    }
                    return encodeURIComponent(c);
                }

                function percentEscapeQuery(c) {
                    var unicode = c.charCodeAt(0);
                    if (unicode > 0x20 && unicode < 0x7F && [0x22, 0x23, 0x3C, 0x3E, 0x60].indexOf(unicode) == -1) {
                        return c;
                    }
                    return encodeURIComponent(c);
                }
                var EOF = undefined,
                    ALPHA = /[a-zA-Z]/,
                    ALPHANUMERIC = /[a-zA-Z0-9\+\-\.]/;

                function parse(input, stateOverride, base) {
                    function err(message) {
                        errors.push(message)
                    }
                    var state = stateOverride || 'scheme start',
                        cursor = 0,
                        buffer = '',
                        seenAt = false,
                        seenBracket = false,
                        errors = [];
                    loop: while ((input[cursor - 1] != EOF || cursor == 0) && !this._isInvalid) {
                        var c = input[cursor];
                        switch (state) {
                            case 'scheme start':
                                if (c && ALPHA.test(c)) {
                                    buffer += c.toLowerCase();
                                    state = 'scheme';
                                } else if (!stateOverride) {
                                    buffer = '';
                                    state = 'no scheme';
                                    continue;
                                } else {
                                    err('Invalid scheme.');
                                    break loop;
                                }
                                break;
                            case 'scheme':
                                if (c && ALPHANUMERIC.test(c)) {
                                    buffer += c.toLowerCase();
                                } else if (':' == c) {
                                    this._scheme = buffer;
                                    buffer = '';
                                    if (stateOverride) {
                                        break loop;
                                    }
                                    if (isRelativeScheme(this._scheme)) {
                                        this._isRelative = true;
                                    }
                                    if ('file' == this._scheme) {
                                        state = 'relative';
                                    } else if (this._isRelative && base && base._scheme == this._scheme) {
                                        state = 'relative or authority';
                                    } else if (this._isRelative) {
                                        state = 'authority first slash';
                                    } else {
                                        state = 'scheme data';
                                    }
                                } else if (!stateOverride) {
                                    buffer = '';
                                    cursor = 0;
                                    state = 'no scheme';
                                    continue;
                                } else if (EOF == c) {
                                    break loop;
                                } else {
                                    err('Code point not allowed in scheme: ' + c)
                                    break loop;
                                }
                                break;
                            case 'scheme data':
                                if ('?' == c) {
                                    this._query = '?';
                                    state = 'query';
                                } else if ('#' == c) {
                                    this._fragment = '#';
                                    state = 'fragment';
                                } else {
                                    if (EOF != c && '\t' != c && '\n' != c && '\r' != c) {
                                        this._schemeData += percentEscape(c);
                                    }
                                }
                                break;
                            case 'no scheme':
                                if (!base || !(isRelativeScheme(base._scheme))) {
                                    err('Missing scheme.');
                                    invalid.call(this);
                                } else {
                                    state = 'relative';
                                    continue;
                                }
                                break;
                            case 'relative or authority':
                                if ('/' == c && '/' == input[cursor + 1]) {
                                    state = 'authority ignore slashes';
                                } else {
                                    err('Expected /, got: ' + c);
                                    state = 'relative';
                                    continue
                                }
                                break;
                            case 'relative':
                                this._isRelative = true;
                                if ('file' != this._scheme)
                                    this._scheme = base._scheme;
                                if (EOF == c) {
                                    this._host = base._host;
                                    this._port = base._port;
                                    this._path = base._path.slice();
                                    this._query = base._query;
                                    this._username = base._username;
                                    this._password = base._password;
                                    break loop;
                                } else if ('/' == c || '\\' == c) {
                                    if ('\\' == c)
                                        err('\\ is an invalid code point.');
                                    state = 'relative slash';
                                } else if ('?' == c) {
                                    this._host = base._host;
                                    this._port = base._port;
                                    this._path = base._path.slice();
                                    this._query = '?';
                                    this._username = base._username;
                                    this._password = base._password;
                                    state = 'query';
                                } else if ('#' == c) {
                                    this._host = base._host;
                                    this._port = base._port;
                                    this._path = base._path.slice();
                                    this._query = base._query;
                                    this._fragment = '#';
                                    this._username = base._username;
                                    this._password = base._password;
                                    state = 'fragment';
                                } else {
                                    var nextC = input[cursor + 1]
                                    var nextNextC = input[cursor + 2]
                                    if ('file' != this._scheme || !ALPHA.test(c) || (nextC != ':' && nextC != '|') || (EOF != nextNextC && '/' != nextNextC && '\\' != nextNextC && '?' != nextNextC && '#' != nextNextC)) {
                                        this._host = base._host;
                                        this._port = base._port;
                                        this._username = base._username;
                                        this._password = base._password;
                                        this._path = base._path.slice();
                                        this._path.pop();
                                    }
                                    state = 'relative path';
                                    continue;
                                }
                                break;
                            case 'relative slash':
                                if ('/' == c || '\\' == c) {
                                    if ('\\' == c) {
                                        err('\\ is an invalid code point.');
                                    }
                                    if ('file' == this._scheme) {
                                        state = 'file host';
                                    } else {
                                        state = 'authority ignore slashes';
                                    }
                                } else {
                                    if ('file' != this._scheme) {
                                        this._host = base._host;
                                        this._port = base._port;
                                        this._username = base._username;
                                        this._password = base._password;
                                    }
                                    state = 'relative path';
                                    continue;
                                }
                                break;
                            case 'authority first slash':
                                if ('/' == c) {
                                    state = 'authority second slash';
                                } else {
                                    err("Expected '/', got: " + c);
                                    state = 'authority ignore slashes';
                                    continue;
                                }
                                break;
                            case 'authority second slash':
                                state = 'authority ignore slashes';
                                if ('/' != c) {
                                    err("Expected '/', got: " + c);
                                    continue;
                                }
                                break;
                            case 'authority ignore slashes':
                                if ('/' != c && '\\' != c) {
                                    state = 'authority';
                                    continue;
                                } else {
                                    err('Expected authority, got: ' + c);
                                }
                                break;
                            case 'authority':
                                if ('@' == c) {
                                    if (seenAt) {
                                        err('@ already seen.');
                                        buffer += '%40';
                                    }
                                    seenAt = true;
                                    for (var i = 0; i < buffer.length; i++) {
                                        var cp = buffer[i];
                                        if ('\t' == cp || '\n' == cp || '\r' == cp) {
                                            err('Invalid whitespace in authority.');
                                            continue;
                                        }
                                        if (':' == cp && null === this._password) {
                                            this._password = '';
                                            continue;
                                        }
                                        var tempC = percentEscape(cp);
                                        (null !== this._password) ? this._password += tempC: this._username += tempC;
                                    }
                                    buffer = '';
                                } else if (EOF == c || '/' == c || '\\' == c || '?' == c || '#' == c) {
                                    cursor -= buffer.length;
                                    buffer = '';
                                    state = 'host';
                                    continue;
                                } else {
                                    buffer += c;
                                }
                                break;
                            case 'file host':
                                if (EOF == c || '/' == c || '\\' == c || '?' == c || '#' == c) {
                                    if (buffer.length == 2 && ALPHA.test(buffer[0]) && (buffer[1] == ':' || buffer[1] == '|')) {
                                        state = 'relative path';
                                    } else if (buffer.length == 0) {
                                        state = 'relative path start';
                                    } else {
                                        this._host = IDNAToASCII.call(this, buffer);
                                        buffer = '';
                                        state = 'relative path start';
                                    }
                                    continue;
                                } else if ('\t' == c || '\n' == c || '\r' == c) {
                                    err('Invalid whitespace in file host.');
                                } else {
                                    buffer += c;
                                }
                                break;
                            case 'host':
                            case 'hostname':
                                if (':' == c && !seenBracket) {
                                    this._host = IDNAToASCII.call(this, buffer);
                                    buffer = '';
                                    state = 'port';
                                    if ('hostname' == stateOverride) {
                                        break loop;
                                    }
                                } else if (EOF == c || '/' == c || '\\' == c || '?' == c || '#' == c) {
                                    this._host = IDNAToASCII.call(this, buffer);
                                    buffer = '';
                                    state = 'relative path start';
                                    if (stateOverride) {
                                        break loop;
                                    }
                                    continue;
                                } else if ('\t' != c && '\n' != c && '\r' != c) {
                                    if ('[' == c) {
                                        seenBracket = true;
                                    } else if (']' == c) {
                                        seenBracket = false;
                                    }
                                    buffer += c;
                                } else {
                                    err('Invalid code point in host/hostname: ' + c);
                                }
                                break;
                            case 'port':
                                if (/[0-9]/.test(c)) {
                                    buffer += c;
                                } else if (EOF == c || '/' == c || '\\' == c || '?' == c || '#' == c || stateOverride) {
                                    if ('' != buffer) {
                                        var temp = parseInt(buffer, 10);
                                        if (temp != relative[this._scheme]) {
                                            this._port = temp + '';
                                        }
                                        buffer = '';
                                    }
                                    if (stateOverride) {
                                        break loop;
                                    }
                                    state = 'relative path start';
                                    continue;
                                } else if ('\t' == c || '\n' == c || '\r' == c) {
                                    err('Invalid code point in port: ' + c);
                                } else {
                                    invalid.call(this);
                                }
                                break;
                            case 'relative path start':
                                if ('\\' == c)
                                    err("'\\' not allowed in path.");
                                state = 'relative path';
                                if ('/' != c && '\\' != c) {
                                    continue;
                                }
                                break;
                            case 'relative path':
                                if (EOF == c || '/' == c || '\\' == c || (!stateOverride && ('?' == c || '#' == c))) {
                                    if ('\\' == c) {
                                        err('\\ not allowed in relative path.');
                                    }
                                    var tmp;
                                    if (tmp = relativePathDotMapping[buffer.toLowerCase()]) {
                                        buffer = tmp;
                                    }
                                    if ('..' == buffer) {
                                        this._path.pop();
                                        if ('/' != c && '\\' != c) {
                                            this._path.push('');
                                        }
                                    } else if ('.' == buffer && '/' != c && '\\' != c) {
                                        this._path.push('');
                                    } else if ('.' != buffer) {
                                        if ('file' == this._scheme && this._path.length == 0 && buffer.length == 2 && ALPHA.test(buffer[0]) && buffer[1] == '|') {
                                            buffer = buffer[0] + ':';
                                        }
                                        this._path.push(buffer);
                                    }
                                    buffer = '';
                                    if ('?' == c) {
                                        this._query = '?';
                                        state = 'query';
                                    } else if ('#' == c) {
                                        this._fragment = '#';
                                        state = 'fragment';
                                    }
                                } else if ('\t' != c && '\n' != c && '\r' != c) {
                                    buffer += percentEscape(c);
                                }
                                break;
                            case 'query':
                                if (!stateOverride && '#' == c) {
                                    this._fragment = '#';
                                    state = 'fragment';
                                } else if (EOF != c && '\t' != c && '\n' != c && '\r' != c) {
                                    this._query += percentEscapeQuery(c);
                                }
                                break;
                            case 'fragment':
                                if (EOF != c && '\t' != c && '\n' != c && '\r' != c) {
                                    this._fragment += c;
                                }
                                break;
                        }
                        cursor++;
                    }
                }

                function clear() {
                    this._scheme = '';
                    this._schemeData = '';
                    this._username = '';
                    this._password = null;
                    this._host = '';
                    this._port = '';
                    this._path = [];
                    this._query = '';
                    this._fragment = '';
                    this._isInvalid = false;
                    this._isRelative = false;
                }

                function jURL(url, base) {
                    if (base !== undefined && !(base instanceof jURL))
                        base = new jURL(String(base));
                    this._url = url;
                    clear.call(this);
                    var input = url.replace(/^[ \t\r\n\f]+|[ \t\r\n\f]+$/g, '');
                    parse.call(this, input, null, base);
                }
                jURL.prototype = {
                    toString: function() {
                        return this.href;
                    },
                    get href() {
                        if (this._isInvalid)
                            return this._url;
                        var authority = '';
                        if ('' != this._username || null != this._password) {
                            authority = this._username +
                                (null != this._password ? ':' + this._password : '') + '@';
                        }
                        return this.protocol +
                            (this._isRelative ? '//' + authority + this.host : '') +
                            this.pathname + this._query + this._fragment;
                    },
                    set href(href) {
                        clear.call(this);
                        parse.call(this, href);
                    },
                    get protocol() {
                        return this._scheme + ':';
                    },
                    set protocol(protocol) {
                        if (this._isInvalid)
                            return;
                        parse.call(this, protocol + ':', 'scheme start');
                    },
                    get host() {
                        return this._isInvalid ? '' : this._port ? this._host + ':' + this._port : this._host;
                    },
                    set host(host) {
                        if (this._isInvalid || !this._isRelative)
                            return;
                        parse.call(this, host, 'host');
                    },
                    get hostname() {
                        return this._host;
                    },
                    set hostname(hostname) {
                        if (this._isInvalid || !this._isRelative)
                            return;
                        parse.call(this, hostname, 'hostname');
                    },
                    get port() {
                        return this._port;
                    },
                    set port(port) {
                        if (this._isInvalid || !this._isRelative)
                            return;
                        parse.call(this, port, 'port');
                    },
                    get pathname() {
                        return this._isInvalid ? '' : this._isRelative ? '/' + this._path.join('/') : this._schemeData;
                    },
                    set pathname(pathname) {
                        if (this._isInvalid || !this._isRelative)
                            return;
                        this._path = [];
                        parse.call(this, pathname, 'relative path start');
                    },
                    get search() {
                        return this._isInvalid || !this._query || '?' == this._query ? '' : this._query;
                    },
                    set search(search) {
                        if (this._isInvalid || !this._isRelative)
                            return;
                        this._query = '?';
                        if ('?' == search[0])
                            search = search.slice(1);
                        parse.call(this, search, 'query');
                    },
                    get hash() {
                        return this._isInvalid || !this._fragment || '#' == this._fragment ? '' : this._fragment;
                    },
                    set hash(hash) {
                        if (this._isInvalid)
                            return;
                        this._fragment = '#';
                        if ('#' == hash[0])
                            hash = hash.slice(1);
                        parse.call(this, hash, 'fragment');
                    },
                    get origin() {
                        var host;
                        if (this._isInvalid || !this._scheme) {
                            return '';
                        }
                        switch (this._scheme) {
                            case 'data':
                            case 'file':
                            case 'javascript':
                            case 'mailto':
                                return 'null';
                        }
                        host = this.host;
                        if (!host) {
                            return '';
                        }
                        return this._scheme + '://' + host;
                    }
                };
                var OriginalURL = scope.URL;
                if (OriginalURL) {
                    jURL.createObjectURL = function(blob) {
                        return OriginalURL.createObjectURL.apply(OriginalURL, arguments);
                    };
                    jURL.revokeObjectURL = function(url) {
                        OriginalURL.revokeObjectURL(url);
                    };
                }
                scope.URL = jURL;
            })(globalScope);
            exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
            exports.IDENTITY_MATRIX = IDENTITY_MATRIX;
            exports.OPS = OPS;
            exports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
            exports.AnnotationBorderStyleType = AnnotationBorderStyleType;
            exports.AnnotationFlag = AnnotationFlag;
            exports.AnnotationType = AnnotationType;
            exports.FontType = FontType;
            exports.ImageKind = ImageKind;
            exports.InvalidPDFException = InvalidPDFException;
            exports.LinkTarget = LinkTarget;
            exports.LinkTargetStringMap = LinkTargetStringMap;
            exports.MessageHandler = MessageHandler;
            exports.MissingDataException = MissingDataException;
            exports.MissingPDFException = MissingPDFException;
            exports.NotImplementedException = NotImplementedException;
            exports.PasswordException = PasswordException;
            exports.PasswordResponses = PasswordResponses;
            exports.StatTimer = StatTimer;
            exports.StreamType = StreamType;
            exports.TextRenderingMode = TextRenderingMode;
            exports.UnexpectedResponseException = UnexpectedResponseException;
            exports.UnknownErrorException = UnknownErrorException;
            exports.Util = Util;
            exports.XRefParseException = XRefParseException;
            exports.assert = assert;
            exports.bytesToString = bytesToString;
            exports.combineUrl = combineUrl;
            exports.createPromiseCapability = createPromiseCapability;
            exports.deprecated = deprecated;
            exports.error = error;
            exports.info = info;
            exports.isArray = isArray;
            exports.isArrayBuffer = isArrayBuffer;
            exports.isBool = isBool;
            exports.isEmptyObj = isEmptyObj;
            exports.isExternalLinkTargetSet = isExternalLinkTargetSet;
            exports.isInt = isInt;
            exports.isNum = isNum;
            exports.isString = isString;
            exports.isValidUrl = isValidUrl;
            exports.addLinkAttributes = addLinkAttributes;
            exports.loadJpegStream = loadJpegStream;
            exports.log2 = log2;
            exports.readInt8 = readInt8;
            exports.readUint16 = readUint16;
            exports.readUint32 = readUint32;
            exports.removeNullCharacters = removeNullCharacters;
            exports.shadow = shadow;
            exports.string32 = string32;
            exports.stringToBytes = stringToBytes;
            exports.stringToPDFString = stringToPDFString;
            exports.stringToUTF8String = stringToUTF8String;
            exports.utf8StringToString = utf8StringToString;
            exports.warn = warn;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsDisplayAnnotationLayer = {}), root.pdfjsSharedUtil, root.pdfjsDisplayDOMUtils);
            }
        }(this, function(exports, sharedUtil, displayDOMUtils) {
            var AnnotationBorderStyleType = sharedUtil.AnnotationBorderStyleType;
            var AnnotationType = sharedUtil.AnnotationType;
            var Util = sharedUtil.Util;
            var addLinkAttributes = sharedUtil.addLinkAttributes;
            var warn = sharedUtil.warn;
            var CustomStyle = displayDOMUtils.CustomStyle;

            function AnnotationElementFactory() {}
            AnnotationElementFactory.prototype = {
                create: function AnnotationElementFactory_create(parameters) {
                    var subtype = parameters.data.annotationType;
                    switch (subtype) {
                        case AnnotationType.LINK:
                            return new LinkAnnotationElement(parameters);
                        case AnnotationType.TEXT:
                            return new TextAnnotationElement(parameters);
                        case AnnotationType.WIDGET:
                            return new WidgetAnnotationElement(parameters);
                        case AnnotationType.POPUP:
                            return new PopupAnnotationElement(parameters);
                        case AnnotationType.HIGHLIGHT:
                            return new HighlightAnnotationElement(parameters);
                        case AnnotationType.UNDERLINE:
                            return new UnderlineAnnotationElement(parameters);
                        case AnnotationType.SQUIGGLY:
                            return new SquigglyAnnotationElement(parameters);
                        case AnnotationType.STRIKEOUT:
                            return new StrikeOutAnnotationElement(parameters);
                        default:
                            throw new Error('Unimplemented annotation type "' + subtype + '"');
                    }
                }
            };
            var AnnotationElement = (function AnnotationElementClosure() {
                function AnnotationElement(parameters) {
                    this.data = parameters.data;
                    this.layer = parameters.layer;
                    this.page = parameters.page;
                    this.viewport = parameters.viewport;
                    this.linkService = parameters.linkService;
                    this.container = this._createContainer();
                }
                AnnotationElement.prototype = {
                    _createContainer: function AnnotationElement_createContainer() {
                        var data = this.data,
                            page = this.page,
                            viewport = this.viewport;
                        var container = document.createElement('section');
                        var width = data.rect[2] - data.rect[0];
                        var height = data.rect[3] - data.rect[1];
                        container.setAttribute('data-annotation-id', data.id);
                        var rect = Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);
                        CustomStyle.setProp('transform', container, 'matrix(' + viewport.transform.join(',') + ')');
                        CustomStyle.setProp('transformOrigin', container, -rect[0] + 'px ' + -rect[1] + 'px');
                        if (data.borderStyle.width > 0) {
                            container.style.borderWidth = data.borderStyle.width + 'px';
                            if (data.borderStyle.style !== AnnotationBorderStyleType.UNDERLINE) {
                                width = width - 2 * data.borderStyle.width;
                                height = height - 2 * data.borderStyle.width;
                            }
                            var horizontalRadius = data.borderStyle.horizontalCornerRadius;
                            var verticalRadius = data.borderStyle.verticalCornerRadius;
                            if (horizontalRadius > 0 || verticalRadius > 0) {
                                var radius = horizontalRadius + 'px / ' + verticalRadius + 'px';
                                CustomStyle.setProp('borderRadius', container, radius);
                            }
                            switch (data.borderStyle.style) {
                                case AnnotationBorderStyleType.SOLID:
                                    container.style.borderStyle = 'solid';
                                    break;
                                case AnnotationBorderStyleType.DASHED:
                                    container.style.borderStyle = 'dashed';
                                    break;
                                case AnnotationBorderStyleType.BEVELED:
                                    warn('Unimplemented border style: beveled');
                                    break;
                                case AnnotationBorderStyleType.INSET:
                                    warn('Unimplemented border style: inset');
                                    break;
                                case AnnotationBorderStyleType.UNDERLINE:
                                    container.style.borderBottomStyle = 'solid';
                                    break;
                                default:
                                    break;
                            }
                            if (data.color) {
                                container.style.borderColor = Util.makeCssRgb(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0);
                            } else {
                                container.style.borderWidth = 0;
                            }
                        }
                        container.style.left = rect[0] + 'px';
                        container.style.top = rect[1] + 'px';
                        container.style.width = width + 'px';
                        container.style.height = height + 'px';
                        return container;
                    },
                    render: function AnnotationElement_render() {
                        throw new Error('Abstract method AnnotationElement.render called');
                    }
                };
                return AnnotationElement;
            })();
            var LinkAnnotationElement = (function LinkAnnotationElementClosure() {
                function LinkAnnotationElement(parameters) {
                    AnnotationElement.call(this, parameters);
                }
                Util.inherit(LinkAnnotationElement, AnnotationElement, {
                    render: function LinkAnnotationElement_render() {
                        this.container.className = 'linkAnnotation';
                        var link = document.createElement('a');
                        addLinkAttributes(link, {
                            url: this.data.url
                        });
                        if (!this.data.url) {
                            if (this.data.action) {
                                this._bindNamedAction(link, this.data.action);
                            } else {
                                this._bindLink(link, ('dest' in this.data) ? this.data.dest : null);
                            }
                        }
                        this.container.appendChild(link);
                        return this.container;
                    },
                    _bindLink: function LinkAnnotationElement_bindLink(link, destination) {
                        var self = this;
                        link.href = this.linkService.getDestinationHash(destination);
                        link.onclick = function() {
                            if (destination) {
                                self.linkService.navigateTo(destination);
                            }
                            return false;
                        };
                        if (destination) {
                            link.className = 'internalLink';
                        }
                    },
                    _bindNamedAction: function LinkAnnotationElement_bindNamedAction(link, action) {
                        var self = this;
                        link.href = this.linkService.getAnchorUrl('');
                        link.onclick = function() {
                            self.linkService.executeNamedAction(action);
                            return false;
                        };
                        link.className = 'internalLink';
                    }
                });
                return LinkAnnotationElement;
            })();
            var TextAnnotationElement = (function TextAnnotationElementClosure() {
                function TextAnnotationElement(parameters) {
                    AnnotationElement.call(this, parameters);
                }
                Util.inherit(TextAnnotationElement, AnnotationElement, {
                    render: function TextAnnotationElement_render() {
                        this.container.className = 'textAnnotation';
                        var image = document.createElement('img');
                        image.style.height = this.container.style.height;
                        image.style.width = this.container.style.width;
                        image.src = PDFJS.imageResourcesPath + 'annotation-' +
                            this.data.name.toLowerCase() + '.svg';
                        image.alt = '[{{type}} Annotation]';
                        image.dataset.l10nId = 'text_annotation_type';
                        image.dataset.l10nArgs = JSON.stringify({
                            type: this.data.name
                        });
                        if (!this.data.hasPopup) {
                            var popupElement = new PopupElement({
                                container: this.container,
                                trigger: image,
                                color: this.data.color,
                                title: this.data.title,
                                contents: this.data.contents,
                                hideWrapper: true
                            });
                            var popup = popupElement.render();
                            popup.style.left = image.style.width;
                            this.container.appendChild(popup);
                        }
                        this.container.appendChild(image);
                        return this.container;
                    }
                });
                return TextAnnotationElement;
            })();
            var WidgetAnnotationElement = (function WidgetAnnotationElementClosure() {
                function WidgetAnnotationElement(parameters) {
                    AnnotationElement.call(this, parameters);
                }
                Util.inherit(WidgetAnnotationElement, AnnotationElement, {
                    render: function WidgetAnnotationElement_render() {
                        var content = document.createElement('div');
                        content.textContent = this.data.fieldValue;
                        var textAlignment = this.data.textAlignment;
                        content.style.textAlign = ['left', 'center', 'right'][textAlignment];
                        content.style.verticalAlign = 'middle';
                        content.style.display = 'table-cell';
                        var font = (this.data.fontRefName ? this.page.commonObjs.getData(this.data.fontRefName) : null);
                        this._setTextStyle(content, font);
                        this.container.appendChild(content);
                        return this.container;
                    },
                    _setTextStyle: function WidgetAnnotationElement_setTextStyle(element, font) {
                        var style = element.style;
                        style.fontSize = this.data.fontSize + 'px';
                        style.direction = (this.data.fontDirection < 0 ? 'rtl' : 'ltr');
                        if (!font) {
                            return;
                        }
                        style.fontWeight = (font.black ? (font.bold ? '900' : 'bold') : (font.bold ? 'bold' : 'normal'));
                        style.fontStyle = (font.italic ? 'italic' : 'normal');
                        var fontFamily = font.loadedName ? '"' + font.loadedName + '", ' : '';
                        var fallbackName = font.fallbackName || 'Helvetica, sans-serif';
                        style.fontFamily = fontFamily + fallbackName;
                    }
                });
                return WidgetAnnotationElement;
            })();
            var PopupAnnotationElement = (function PopupAnnotationElementClosure() {
                function PopupAnnotationElement(parameters) {
                    AnnotationElement.call(this, parameters);
                }
                Util.inherit(PopupAnnotationElement, AnnotationElement, {
                    render: function PopupAnnotationElement_render() {
                        this.container.className = 'popupAnnotation';
                        var selector = '[data-annotation-id="' + this.data.parentId + '"]';
                        var parentElement = this.layer.querySelector(selector);
                        if (!parentElement) {
                            return this.container;
                        }
                        var popup = new PopupElement({
                            container: this.container,
                            trigger: parentElement,
                            color: this.data.color,
                            title: this.data.title,
                            contents: this.data.contents
                        });
                        var parentLeft = parseFloat(parentElement.style.left);
                        var parentWidth = parseFloat(parentElement.style.width);
                        CustomStyle.setProp('transformOrigin', this.container, -(parentLeft + parentWidth) + 'px -' +
                            parentElement.style.top);
                        this.container.style.left = (parentLeft + parentWidth) + 'px';
                        this.container.appendChild(popup.render());
                        return this.container;
                    }
                });
                return PopupAnnotationElement;
            })();
            var PopupElement = (function PopupElementClosure() {
                var BACKGROUND_ENLIGHT = 0.7;

                function PopupElement(parameters) {
                    this.container = parameters.container;
                    this.trigger = parameters.trigger;
                    this.color = parameters.color;
                    this.title = parameters.title;
                    this.contents = parameters.contents;
                    this.hideWrapper = parameters.hideWrapper || false;
                    this.pinned = false;
                }
                PopupElement.prototype = {
                    render: function PopupElement_render() {
                        var wrapper = document.createElement('div');
                        wrapper.className = 'popupWrapper';
                        this.hideElement = (this.hideWrapper ? wrapper : this.container);
                        this.hideElement.setAttribute('hidden', true);
                        var popup = document.createElement('div');
                        popup.className = 'popup';
                        var color = this.color;
                        if (color) {
                            var r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];
                            var g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];
                            var b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];
                            popup.style.backgroundColor = Util.makeCssRgb(r | 0, g | 0, b | 0);
                        }
                        var contents = this._formatContents(this.contents);
                        var title = document.createElement('h1');
                        title.textContent = this.title;
                        this.trigger.addEventListener('click', this._toggle.bind(this));
                        this.trigger.addEventListener('mouseover', this._show.bind(this, false));
                        this.trigger.addEventListener('mouseout', this._hide.bind(this, false));
                        popup.addEventListener('click', this._hide.bind(this, true));
                        popup.appendChild(title);
                        popup.appendChild(contents);
                        wrapper.appendChild(popup);
                        return wrapper;
                    },
                    _formatContents: function PopupElement_formatContents(contents) {
                        var p = document.createElement('p');
                        var lines = contents.split(/(?:\r\n?|\n)/);
                        for (var i = 0, ii = lines.length; i < ii; ++i) {
                            var line = lines[i];
                            p.appendChild(document.createTextNode(line));
                            if (i < (ii - 1)) {
                                p.appendChild(document.createElement('br'));
                            }
                        }
                        return p;
                    },
                    _toggle: function PopupElement_toggle() {
                        if (this.pinned) {
                            this._hide(true);
                        } else {
                            this._show(true);
                        }
                    },
                    _show: function PopupElement_show(pin) {
                        if (pin) {
                            this.pinned = true;
                        }
                        if (this.hideElement.hasAttribute('hidden')) {
                            this.hideElement.removeAttribute('hidden');
                            this.container.style.zIndex += 1;
                        }
                    },
                    _hide: function PopupElement_hide(unpin) {
                        if (unpin) {
                            this.pinned = false;
                        }
                        if (!this.hideElement.hasAttribute('hidden') && !this.pinned) {
                            this.hideElement.setAttribute('hidden', true);
                            this.container.style.zIndex -= 1;
                        }
                    }
                };
                return PopupElement;
            })();
            var HighlightAnnotationElement = (function HighlightAnnotationElementClosure() {
                function HighlightAnnotationElement(parameters) {
                    AnnotationElement.call(this, parameters);
                }
                Util.inherit(HighlightAnnotationElement, AnnotationElement, {
                    render: function HighlightAnnotationElement_render() {
                        this.container.className = 'highlightAnnotation';
                        return this.container;
                    }
                });
                return HighlightAnnotationElement;
            })();
            var UnderlineAnnotationElement = (function UnderlineAnnotationElementClosure() {
                function UnderlineAnnotationElement(parameters) {
                    AnnotationElement.call(this, parameters);
                }
                Util.inherit(UnderlineAnnotationElement, AnnotationElement, {
                    render: function UnderlineAnnotationElement_render() {
                        this.container.className = 'underlineAnnotation';
                        return this.container;
                    }
                });
                return UnderlineAnnotationElement;
            })();
            var SquigglyAnnotationElement = (function SquigglyAnnotationElementClosure() {
                function SquigglyAnnotationElement(parameters) {
                    AnnotationElement.call(this, parameters);
                }
                Util.inherit(SquigglyAnnotationElement, AnnotationElement, {
                    render: function SquigglyAnnotationElement_render() {
                        this.container.className = 'squigglyAnnotation';
                        return this.container;
                    }
                });
                return SquigglyAnnotationElement;
            })();
            var StrikeOutAnnotationElement = (function StrikeOutAnnotationElementClosure() {
                function StrikeOutAnnotationElement(parameters) {
                    AnnotationElement.call(this, parameters);
                }
                Util.inherit(StrikeOutAnnotationElement, AnnotationElement, {
                    render: function StrikeOutAnnotationElement_render() {
                        this.container.className = 'strikeoutAnnotation';
                        return this.container;
                    }
                });
                return StrikeOutAnnotationElement;
            })();
            var AnnotationLayer = (function AnnotationLayerClosure() {
                return {
                    render: function AnnotationLayer_render(parameters) {
                        var annotationElementFactory = new AnnotationElementFactory();
                        for (var i = 0, ii = parameters.annotations.length; i < ii; i++) {
                            var data = parameters.annotations[i];
                            if (!data || !data.hasHtml) {
                                continue;
                            }
                            var properties = {
                                data: data,
                                layer: parameters.div,
                                page: parameters.page,
                                viewport: parameters.viewport,
                                linkService: parameters.linkService
                            };
                            var element = annotationElementFactory.create(properties);
                            parameters.div.appendChild(element.render());
                        }
                    },
                    update: function AnnotationLayer_update(parameters) {
                        for (var i = 0, ii = parameters.annotations.length; i < ii; i++) {
                            var data = parameters.annotations[i];
                            var element = parameters.div.querySelector('[data-annotation-id="' + data.id + '"]');
                            if (element) {
                                CustomStyle.setProp('transform', element, 'matrix(' + parameters.viewport.transform.join(',') + ')');
                            }
                        }
                        parameters.div.removeAttribute('hidden');
                    }
                };
            })();
            PDFJS.AnnotationLayer = AnnotationLayer;
            exports.AnnotationLayer = AnnotationLayer;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsDisplayFontLoader = {}), root.pdfjsSharedUtil, root.pdfjsSharedGlobal);
            }
        }(this, function(exports, sharedUtil, sharedGlobal) {
            var assert = sharedUtil.assert;
            var bytesToString = sharedUtil.bytesToString;
            var string32 = sharedUtil.string32;
            var shadow = sharedUtil.shadow;
            var warn = sharedUtil.warn;
            var PDFJS = sharedGlobal.PDFJS;
            var globalScope = sharedGlobal.globalScope;
            var isWorker = sharedGlobal.isWorker;

            function FontLoader(docId) {
                this.docId = docId;
                this.styleElement = null;
                this.nativeFontFaces = [];
                this.loadTestFontId = 0;
                this.loadingContext = {
                    requests: [],
                    nextRequestId: 0
                };
            }
            FontLoader.prototype = {
                insertRule: function fontLoaderInsertRule(rule) {
                    var styleElement = this.styleElement;
                    if (!styleElement) {
                        styleElement = this.styleElement = document.createElement('style');
                        styleElement.id = 'PDFJS_FONT_STYLE_TAG_' + this.docId;
                        document.documentElement.getElementsByTagName('head')[0].appendChild(styleElement);
                    }
                    var styleSheet = styleElement.sheet;
                    styleSheet.insertRule(rule, styleSheet.cssRules.length);
                },
                clear: function fontLoaderClear() {
                    var styleElement = this.styleElement;
                    if (styleElement) {
                        styleElement.parentNode.removeChild(styleElement);
                        styleElement = this.styleElement = null;
                    }
                    this.nativeFontFaces.forEach(function(nativeFontFace) {
                        document.fonts.delete(nativeFontFace);
                    });
                    this.nativeFontFaces.length = 0;
                },
                get loadTestFont() {
                    return shadow(this, 'loadTestFont', atob('T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQ' + 'AABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwA' + 'AAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbm' + 'FtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAA' + 'AADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6A' + 'ABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAA' + 'MQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAA' + 'AAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAA' + 'AAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQ' + 'AAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMA' + 'AQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAA' + 'EAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAA' + 'AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAA' + 'AAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgc' + 'A/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWF' + 'hYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQA' + 'AAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAg' + 'ABAAAAAAAAAAAD6AAAAAAAAA=='));
                },
                addNativeFontFace: function fontLoader_addNativeFontFace(nativeFontFace) {
                    this.nativeFontFaces.push(nativeFontFace);
                    document.fonts.add(nativeFontFace);
                },
                bind: function fontLoaderBind(fonts, callback) {
                    assert(!isWorker, 'bind() shall be called from main thread');
                    var rules = [];
                    var fontsToLoad = [];
                    var fontLoadPromises = [];
                    var getNativeFontPromise = function(nativeFontFace) {
                        return nativeFontFace.loaded.catch(function(e) {
                            warn('Failed to load font "' + nativeFontFace.family + '": ' + e);
                        });
                    };
                    for (var i = 0, ii = fonts.length; i < ii; i++) {
                        var font = fonts[i];
                        if (font.attached || font.loading === false) {
                            continue;
                        }
                        font.attached = true;
                        if (FontLoader.isFontLoadingAPISupported) {
                            var nativeFontFace = font.createNativeFontFace();
                            if (nativeFontFace) {
                                this.addNativeFontFace(nativeFontFace);
                                fontLoadPromises.push(getNativeFontPromise(nativeFontFace));
                            }
                        } else {
                            var rule = font.createFontFaceRule();
                            if (rule) {
                                this.insertRule(rule);
                                rules.push(rule);
                                fontsToLoad.push(font);
                            }
                        }
                    }
                    var request = this.queueLoadingCallback(callback);
                    if (FontLoader.isFontLoadingAPISupported) {
                        Promise.all(fontLoadPromises).then(function() {
                            request.complete();
                        });
                    } else if (rules.length > 0 && !FontLoader.isSyncFontLoadingSupported) {
                        this.prepareFontLoadEvent(rules, fontsToLoad, request);
                    } else {
                        request.complete();
                    }
                },
                queueLoadingCallback: function FontLoader_queueLoadingCallback(callback) {
                    function LoadLoader_completeRequest() {
                        assert(!request.end, 'completeRequest() cannot be called twice');
                        request.end = Date.now();
                        while (context.requests.length > 0 && context.requests[0].end) {
                            var otherRequest = context.requests.shift();
                            setTimeout(otherRequest.callback, 0);
                        }
                    }
                    var context = this.loadingContext;
                    var requestId = 'pdfjs-font-loading-' + (context.nextRequestId++);
                    var request = {
                        id: requestId,
                        complete: LoadLoader_completeRequest,
                        callback: callback,
                        started: Date.now()
                    };
                    context.requests.push(request);
                    return request;
                },
                prepareFontLoadEvent: function fontLoaderPrepareFontLoadEvent(rules, fonts, request) {
                    function int32(data, offset) {
                        return (data.charCodeAt(offset) << 24) | (data.charCodeAt(offset + 1) << 16) | (data.charCodeAt(offset + 2) << 8) | (data.charCodeAt(offset + 3) & 0xff);
                    }

                    function spliceString(s, offset, remove, insert) {
                        var chunk1 = s.substr(0, offset);
                        var chunk2 = s.substr(offset + remove);
                        return chunk1 + insert + chunk2;
                    }
                    var i, ii;
                    var canvas = document.createElement('canvas');
                    canvas.width = 1;
                    canvas.height = 1;
                    var ctx = canvas.getContext('2d');
                    var called = 0;

                    function isFontReady(name, callback) {
                        called++;
                        if (called > 30) {
                            warn('Load test font never loaded.');
                            callback();
                            return;
                        }
                        ctx.font = '30px ' + name;
                        ctx.fillText('.', 0, 20);
                        var imageData = ctx.getImageData(0, 0, 1, 1);
                        if (imageData.data[3] > 0) {
                            callback();
                            return;
                        }
                        setTimeout(isFontReady.bind(null, name, callback));
                    }
                    var loadTestFontId = 'lt' + Date.now() + this.loadTestFontId++;
                    var data = this.loadTestFont;
                    var COMMENT_OFFSET = 976;
                    data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
                    var CFF_CHECKSUM_OFFSET = 16;
                    var XXXX_VALUE = 0x58585858;
                    var checksum = int32(data, CFF_CHECKSUM_OFFSET);
                    for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
                        checksum = (checksum - XXXX_VALUE + int32(loadTestFontId, i)) | 0;
                    }
                    if (i < loadTestFontId.length) {
                        checksum = (checksum - XXXX_VALUE +
                            int32(loadTestFontId + 'XXX', i)) | 0;
                    }
                    data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, string32(checksum));
                    var url = 'url(data:font/opentype;base64,' + btoa(data) + ');';
                    var rule = '@font-face { font-family:"' + loadTestFontId + '";src:' +
                        url + '}';
                    this.insertRule(rule);
                    var names = [];
                    for (i = 0, ii = fonts.length; i < ii; i++) {
                        names.push(fonts[i].loadedName);
                    }
                    names.push(loadTestFontId);
                    var div = document.createElement('div');
                    div.setAttribute('style', 'visibility: hidden;' + 'width: 10px; height: 10px;' + 'position: absolute; top: 0px; left: 0px;');
                    for (i = 0, ii = names.length; i < ii; ++i) {
                        var span = document.createElement('span');
                        span.textContent = 'Hi';
                        span.style.fontFamily = names[i];
                        div.appendChild(span);
                    }
                    document.body.appendChild(div);
                    isFontReady(loadTestFontId, function() {
                        document.body.removeChild(div);
                        request.complete();
                    });
                }
            };
            FontLoader.isFontLoadingAPISupported = (!isWorker && typeof document !== 'undefined' && !!document.fonts);
            Object.defineProperty(FontLoader, 'isSyncFontLoadingSupported', {
                get: function() {
                    var supported = false;
                    var userAgent = window.navigator.userAgent;
                    var m = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(userAgent);
                    if (m && m[1] >= 14) {
                        supported = true;
                    }
                    if (userAgent === 'node') {
                        supported = true;
                    }
                    return shadow(FontLoader, 'isSyncFontLoadingSupported', supported);
                },
                enumerable: true,
                configurable: true
            });
            var FontFaceObject = (function FontFaceObjectClosure() {
                function FontFaceObject(translatedData) {
                    this.compiledGlyphs = {};
                    for (var i in translatedData) {
                        this[i] = translatedData[i];
                    }
                }
                Object.defineProperty(FontFaceObject, 'isEvalSupported', {
                    get: function() {
                        var evalSupport = false;
                        if (PDFJS.isEvalSupported) {
                            try {
                                new Function('');
                                evalSupport = true;
                            } catch (e) {}
                        }
                        return shadow(this, 'isEvalSupported', evalSupport);
                    },
                    enumerable: true,
                    configurable: true
                });
                FontFaceObject.prototype = {
                    createNativeFontFace: function FontFaceObject_createNativeFontFace() {
                        if (!this.data) {
                            return null;
                        }
                        if (PDFJS.disableFontFace) {
                            this.disableFontFace = true;
                            return null;
                        }
                        var nativeFontFace = new FontFace(this.loadedName, this.data, {});
                        if (PDFJS.pdfBug && 'FontInspector' in globalScope && globalScope['FontInspector'].enabled) {
                            globalScope['FontInspector'].fontAdded(this);
                        }
                        return nativeFontFace;
                    },
                    createFontFaceRule: function FontFaceObject_createFontFaceRule() {
                        if (!this.data) {
                            return null;
                        }
                        if (PDFJS.disableFontFace) {
                            this.disableFontFace = true;
                            return null;
                        }
                        var data = bytesToString(new Uint8Array(this.data));
                        var fontName = this.loadedName;
                        var url = ('url(data:' + this.mimetype + ';base64,' +
                            window.btoa(data) + ');');
                        var rule = '@font-face { font-family:"' + fontName + '";src:' + url + '}';
                        if (PDFJS.pdfBug && 'FontInspector' in globalScope && globalScope['FontInspector'].enabled) {
                            globalScope['FontInspector'].fontAdded(this, url);
                        }
                        return rule;
                    },
                    getPathGenerator: function FontFaceObject_getPathGenerator(objs, character) {
                        if (!(character in this.compiledGlyphs)) {
                            var cmds = objs.get(this.loadedName + '_path_' + character);
                            var current, i, len;
                            if (FontFaceObject.isEvalSupported) {
                                var args, js = '';
                                for (i = 0, len = cmds.length; i < len; i++) {
                                    current = cmds[i];
                                    if (current.args !== undefined) {
                                        args = current.args.join(',');
                                    } else {
                                        args = '';
                                    }
                                    js += 'c.' + current.cmd + '(' + args + ');\n';
                                }
                                this.compiledGlyphs[character] = new Function('c', 'size', js);
                            } else {
                                this.compiledGlyphs[character] = function(c, size) {
                                    for (i = 0, len = cmds.length; i < len; i++) {
                                        current = cmds[i];
                                        if (current.cmd === 'scale') {
                                            current.args = [size, -size];
                                        }
                                        c[current.cmd].apply(c, current.args);
                                    }
                                };
                            }
                        }
                        return this.compiledGlyphs[character];
                    }
                };
                return FontFaceObject;
            })();
            exports.FontFaceObject = FontFaceObject;
            exports.FontLoader = FontLoader;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsDisplayMetadata = {}), root.pdfjsSharedUtil);
            }
        }(this, function(exports, sharedUtil) {
            var error = sharedUtil.error;
            var Metadata = PDFJS.Metadata = (function MetadataClosure() {
                function fixMetadata(meta) {
                    return meta.replace(/>\\376\\377([^<]+)/g, function(all, codes) {
                        var bytes = codes.replace(/\\([0-3])([0-7])([0-7])/g, function(code, d1, d2, d3) {
                            return String.fromCharCode(d1 * 64 + d2 * 8 + d3 * 1);
                        });
                        var chars = '';
                        for (var i = 0; i < bytes.length; i += 2) {
                            var code = bytes.charCodeAt(i) * 256 + bytes.charCodeAt(i + 1);
                            chars += code >= 32 && code < 127 && code !== 60 && code !== 62 && code !== 38 && false ? String.fromCharCode(code) : '&#x' + (0x10000 + code).toString(16).substring(1) + ';';
                        }
                        return '>' + chars;
                    });
                }

                function Metadata(meta) {
                    if (typeof meta === 'string') {
                        meta = fixMetadata(meta);
                        var parser = new DOMParser();
                        meta = parser.parseFromString(meta, 'application/xml');
                    } else if (!(meta instanceof Document)) {
                        error('Metadata: Invalid metadata object');
                    }
                    this.metaDocument = meta;
                    this.metadata = {};
                    this.parse();
                }
                Metadata.prototype = {
                    parse: function Metadata_parse() {
                        var doc = this.metaDocument;
                        var rdf = doc.documentElement;
                        if (rdf.nodeName.toLowerCase() !== 'rdf:rdf') {
                            rdf = rdf.firstChild;
                            while (rdf && rdf.nodeName.toLowerCase() !== 'rdf:rdf') {
                                rdf = rdf.nextSibling;
                            }
                        }
                        var nodeName = (rdf) ? rdf.nodeName.toLowerCase() : null;
                        if (!rdf || nodeName !== 'rdf:rdf' || !rdf.hasChildNodes()) {
                            return;
                        }
                        var children = rdf.childNodes,
                            desc, entry, name, i, ii, length, iLength;
                        for (i = 0, length = children.length; i < length; i++) {
                            desc = children[i];
                            if (desc.nodeName.toLowerCase() !== 'rdf:description') {
                                continue;
                            }
                            for (ii = 0, iLength = desc.childNodes.length; ii < iLength; ii++) {
                                if (desc.childNodes[ii].nodeName.toLowerCase() !== '#text') {
                                    entry = desc.childNodes[ii];
                                    name = entry.nodeName.toLowerCase();
                                    this.metadata[name] = entry.textContent.trim();
                                }
                            }
                        }
                    },
                    get: function Metadata_get(name) {
                        return this.metadata[name] || null;
                    },
                    has: function Metadata_has(name) {
                        return typeof this.metadata[name] !== 'undefined';
                    }
                };
                return Metadata;
            })();
            exports.Metadata = Metadata;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsDisplaySVG = {}), root.pdfjsSharedUtil);
            }
        }(this, function(exports, sharedUtil) {
            var FONT_IDENTITY_MATRIX = sharedUtil.FONT_IDENTITY_MATRIX;
            var IDENTITY_MATRIX = sharedUtil.IDENTITY_MATRIX;
            var ImageKind = sharedUtil.ImageKind;
            var OPS = sharedUtil.OPS;
            var Util = sharedUtil.Util;
            var isNum = sharedUtil.isNum;
            var isArray = sharedUtil.isArray;
            var warn = sharedUtil.warn;
            var SVG_DEFAULTS = {
                fontStyle: 'normal',
                fontWeight: 'normal',
                fillColor: '#000000'
            };
            var convertImgDataToPng = (function convertImgDataToPngClosure() {
                var PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);
                var CHUNK_WRAPPER_SIZE = 12;
                var crcTable = new Int32Array(256);
                for (var i = 0; i < 256; i++) {
                    var c = i;
                    for (var h = 0; h < 8; h++) {
                        if (c & 1) {
                            c = 0xedB88320 ^ ((c >> 1) & 0x7fffffff);
                        } else {
                            c = (c >> 1) & 0x7fffffff;
                        }
                    }
                    crcTable[i] = c;
                }

                function crc32(data, start, end) {
                    var crc = -1;
                    for (var i = start; i < end; i++) {
                        var a = (crc ^ data[i]) & 0xff;
                        var b = crcTable[a];
                        crc = (crc >>> 8) ^ b;
                    }
                    return crc ^ -1;
                }

                function writePngChunk(type, body, data, offset) {
                    var p = offset;
                    var len = body.length;
                    data[p] = len >> 24 & 0xff;
                    data[p + 1] = len >> 16 & 0xff;
                    data[p + 2] = len >> 8 & 0xff;
                    data[p + 3] = len & 0xff;
                    p += 4;
                    data[p] = type.charCodeAt(0) & 0xff;
                    data[p + 1] = type.charCodeAt(1) & 0xff;
                    data[p + 2] = type.charCodeAt(2) & 0xff;
                    data[p + 3] = type.charCodeAt(3) & 0xff;
                    p += 4;
                    data.set(body, p);
                    p += body.length;
                    var crc = crc32(data, offset + 4, p);
                    data[p] = crc >> 24 & 0xff;
                    data[p + 1] = crc >> 16 & 0xff;
                    data[p + 2] = crc >> 8 & 0xff;
                    data[p + 3] = crc & 0xff;
                }

                function adler32(data, start, end) {
                    var a = 1;
                    var b = 0;
                    for (var i = start; i < end; ++i) {
                        a = (a + (data[i] & 0xff)) % 65521;
                        b = (b + a) % 65521;
                    }
                    return (b << 16) | a;
                }

                function encode(imgData, kind) {
                    var width = imgData.width;
                    var height = imgData.height;
                    var bitDepth, colorType, lineSize;
                    var bytes = imgData.data;
                    switch (kind) {
                        case ImageKind.GRAYSCALE_1BPP:
                            colorType = 0;
                            bitDepth = 1;
                            lineSize = (width + 7) >> 3;
                            break;
                        case ImageKind.RGB_24BPP:
                            colorType = 2;
                            bitDepth = 8;
                            lineSize = width * 3;
                            break;
                        case ImageKind.RGBA_32BPP:
                            colorType = 6;
                            bitDepth = 8;
                            lineSize = width * 4;
                            break;
                        default:
                            throw new Error('invalid format');
                    }
                    var literals = new Uint8Array((1 + lineSize) * height);
                    var offsetLiterals = 0,
                        offsetBytes = 0;
                    var y, i;
                    for (y = 0; y < height; ++y) {
                        literals[offsetLiterals++] = 0;
                        literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
                        offsetBytes += lineSize;
                        offsetLiterals += lineSize;
                    }
                    if (kind === ImageKind.GRAYSCALE_1BPP) {
                        offsetLiterals = 0;
                        for (y = 0; y < height; y++) {
                            offsetLiterals++;
                            for (i = 0; i < lineSize; i++) {
                                literals[offsetLiterals++] ^= 0xFF;
                            }
                        }
                    }
                    var ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);
                    var len = literals.length;
                    var maxBlockLength = 0xFFFF;
                    var deflateBlocks = Math.ceil(len / maxBlockLength);
                    var idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);
                    var pi = 0;
                    idat[pi++] = 0x78;
                    idat[pi++] = 0x9c;
                    var pos = 0;
                    while (len > maxBlockLength) {
                        idat[pi++] = 0x00;
                        idat[pi++] = 0xff;
                        idat[pi++] = 0xff;
                        idat[pi++] = 0x00;
                        idat[pi++] = 0x00;
                        idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
                        pi += maxBlockLength;
                        pos += maxBlockLength;
                        len -= maxBlockLength;
                    }
                    idat[pi++] = 0x01;
                    idat[pi++] = len & 0xff;
                    idat[pi++] = len >> 8 & 0xff;
                    idat[pi++] = (~len & 0xffff) & 0xff;
                    idat[pi++] = (~len & 0xffff) >> 8 & 0xff;
                    idat.set(literals.subarray(pos), pi);
                    pi += literals.length - pos;
                    var adler = adler32(literals, 0, literals.length);
                    idat[pi++] = adler >> 24 & 0xff;
                    idat[pi++] = adler >> 16 & 0xff;
                    idat[pi++] = adler >> 8 & 0xff;
                    idat[pi++] = adler & 0xff;
                    var pngLength = PNG_HEADER.length + (CHUNK_WRAPPER_SIZE * 3) +
                        ihdr.length + idat.length;
                    var data = new Uint8Array(pngLength);
                    var offset = 0;
                    data.set(PNG_HEADER, offset);
                    offset += PNG_HEADER.length;
                    writePngChunk('IHDR', ihdr, data, offset);
                    offset += CHUNK_WRAPPER_SIZE + ihdr.length;
                    writePngChunk('IDATA', idat, data, offset);
                    offset += CHUNK_WRAPPER_SIZE + idat.length;
                    writePngChunk('IEND', new Uint8Array(0), data, offset);
                    return PDFJS.createObjectURL(data, 'image/png');
                }
                return function convertImgDataToPng(imgData) {
                    var kind = (imgData.kind === undefined ? ImageKind.GRAYSCALE_1BPP : imgData.kind);
                    return encode(imgData, kind);
                };
            })();
            var SVGExtraState = (function SVGExtraStateClosure() {
                function SVGExtraState() {
                    this.fontSizeScale = 1;
                    this.fontWeight = SVG_DEFAULTS.fontWeight;
                    this.fontSize = 0;
                    this.textMatrix = IDENTITY_MATRIX;
                    this.fontMatrix = FONT_IDENTITY_MATRIX;
                    this.leading = 0;
                    this.x = 0;
                    this.y = 0;
                    this.lineX = 0;
                    this.lineY = 0;
                    this.charSpacing = 0;
                    this.wordSpacing = 0;
                    this.textHScale = 1;
                    this.textRise = 0;
                    this.fillColor = SVG_DEFAULTS.fillColor;
                    this.strokeColor = '#000000';
                    this.fillAlpha = 1;
                    this.strokeAlpha = 1;
                    this.lineWidth = 1;
                    this.lineJoin = '';
                    this.lineCap = '';
                    this.miterLimit = 0;
                    this.dashArray = [];
                    this.dashPhase = 0;
                    this.dependencies = [];
                    this.clipId = '';
                    this.pendingClip = false;
                    this.maskId = '';
                }
                SVGExtraState.prototype = {
                    clone: function SVGExtraState_clone() {
                        return Object.create(this);
                    },
                    setCurrentPoint: function SVGExtraState_setCurrentPoint(x, y) {
                        this.x = x;
                        this.y = y;
                    }
                };
                return SVGExtraState;
            })();
            var SVGGraphics = (function SVGGraphicsClosure() {
                function createScratchSVG(width, height) {
                    var NS = 'http://www.w3.org/2000/svg';
                    var svg = document.createElementNS(NS, 'svg:svg');
                    svg.setAttributeNS(null, 'version', '1.1');
                    svg.setAttributeNS(null, 'width', width + 'px');
                    svg.setAttributeNS(null, 'height', height + 'px');
                    svg.setAttributeNS(null, 'viewBox', '0 0 ' + width + ' ' + height);
                    return svg;
                }

                function opListToTree(opList) {
                    var opTree = [];
                    var tmp = [];
                    var opListLen = opList.length;
                    for (var x = 0; x < opListLen; x++) {
                        if (opList[x].fn === 'save') {
                            opTree.push({
                                'fnId': 92,
                                'fn': 'group',
                                'items': []
                            });
                            tmp.push(opTree);
                            opTree = opTree[opTree.length - 1].items;
                            continue;
                        }
                        if (opList[x].fn === 'restore') {
                            opTree = tmp.pop();
                        } else {
                            opTree.push(opList[x]);
                        }
                    }
                    return opTree;
                }

                function pf(value) {
                    if (value === (value | 0)) {
                        return value.toString();
                    }
                    var s = value.toFixed(10);
                    var i = s.length - 1;
                    if (s[i] !== '0') {
                        return s;
                    }
                    do {
                        i--;
                    } while (s[i] === '0');
                    return s.substr(0, s[i] === '.' ? i : i + 1);
                }

                function pm(m) {
                    if (m[4] === 0 && m[5] === 0) {
                        if (m[1] === 0 && m[2] === 0) {
                            if (m[0] === 1 && m[3] === 1) {
                                return '';
                            }
                            return 'scale(' + pf(m[0]) + ' ' + pf(m[3]) + ')';
                        }
                        if (m[0] === m[3] && m[1] === -m[2]) {
                            var a = Math.acos(m[0]) * 180 / Math.PI;
                            return 'rotate(' + pf(a) + ')';
                        }
                    } else {
                        if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {
                            return 'translate(' + pf(m[4]) + ' ' + pf(m[5]) + ')';
                        }
                    }
                    return 'matrix(' + pf(m[0]) + ' ' + pf(m[1]) + ' ' + pf(m[2]) + ' ' +
                        pf(m[3]) + ' ' + pf(m[4]) + ' ' + pf(m[5]) + ')';
                }

                function SVGGraphics(commonObjs, objs) {
                    this.current = new SVGExtraState();
                    this.transformMatrix = IDENTITY_MATRIX;
                    this.transformStack = [];
                    this.extraStack = [];
                    this.commonObjs = commonObjs;
                    this.objs = objs;
                    this.pendingEOFill = false;
                    this.embedFonts = false;
                    this.embeddedFonts = {};
                    this.cssStyle = null;
                }
                var NS = 'http://www.w3.org/2000/svg';
                var XML_NS = 'http://www.w3.org/XML/1998/namespace';
                var XLINK_NS = 'http://www.w3.org/1999/xlink';
                var LINE_CAP_STYLES = ['butt', 'round', 'square'];
                var LINE_JOIN_STYLES = ['miter', 'round', 'bevel'];
                var clipCount = 0;
                var maskCount = 0;
                SVGGraphics.prototype = {
                    save: function SVGGraphics_save() {
                        this.transformStack.push(this.transformMatrix);
                        var old = this.current;
                        this.extraStack.push(old);
                        this.current = old.clone();
                    },
                    restore: function SVGGraphics_restore() {
                        this.transformMatrix = this.transformStack.pop();
                        this.current = this.extraStack.pop();
                        this.tgrp = document.createElementNS(NS, 'svg:g');
                        this.tgrp.setAttributeNS(null, 'transform', pm(this.transformMatrix));
                        this.pgrp.appendChild(this.tgrp);
                    },
                    group: function SVGGraphics_group(items) {
                        this.save();
                        this.executeOpTree(items);
                        this.restore();
                    },
                    loadDependencies: function SVGGraphics_loadDependencies(operatorList) {
                        var fnArray = operatorList.fnArray;
                        var fnArrayLen = fnArray.length;
                        var argsArray = operatorList.argsArray;
                        var self = this;
                        for (var i = 0; i < fnArrayLen; i++) {
                            if (OPS.dependency === fnArray[i]) {
                                var deps = argsArray[i];
                                for (var n = 0, nn = deps.length; n < nn; n++) {
                                    var obj = deps[n];
                                    var common = obj.substring(0, 2) === 'g_';
                                    var promise;
                                    if (common) {
                                        promise = new Promise(function(resolve) {
                                            self.commonObjs.get(obj, resolve);
                                        });
                                    } else {
                                        promise = new Promise(function(resolve) {
                                            self.objs.get(obj, resolve);
                                        });
                                    }
                                    this.current.dependencies.push(promise);
                                }
                            }
                        }
                        return Promise.all(this.current.dependencies);
                    },
                    transform: function SVGGraphics_transform(a, b, c, d, e, f) {
                        var transformMatrix = [a, b, c, d, e, f];
                        this.transformMatrix = PDFJS.Util.transform(this.transformMatrix, transformMatrix);
                        this.tgrp = document.createElementNS(NS, 'svg:g');
                        this.tgrp.setAttributeNS(null, 'transform', pm(this.transformMatrix));
                    },
                    getSVG: function SVGGraphics_getSVG(operatorList, viewport) {
                        this.svg = createScratchSVG(viewport.width, viewport.height);
                        this.viewport = viewport;
                        return this.loadDependencies(operatorList).then(function() {
                            this.transformMatrix = IDENTITY_MATRIX;
                            this.pgrp = document.createElementNS(NS, 'svg:g');
                            this.pgrp.setAttributeNS(null, 'transform', pm(viewport.transform));
                            this.tgrp = document.createElementNS(NS, 'svg:g');
                            this.tgrp.setAttributeNS(null, 'transform', pm(this.transformMatrix));
                            this.defs = document.createElementNS(NS, 'svg:defs');
                            this.pgrp.appendChild(this.defs);
                            this.pgrp.appendChild(this.tgrp);
                            this.svg.appendChild(this.pgrp);
                            var opTree = this.convertOpList(operatorList);
                            this.executeOpTree(opTree);
                            return this.svg;
                        }.bind(this));
                    },
                    convertOpList: function SVGGraphics_convertOpList(operatorList) {
                        var argsArray = operatorList.argsArray;
                        var fnArray = operatorList.fnArray;
                        var fnArrayLen = fnArray.length;
                        var REVOPS = [];
                        var opList = [];
                        for (var op in OPS) {
                            REVOPS[OPS[op]] = op;
                        }
                        for (var x = 0; x < fnArrayLen; x++) {
                            var fnId = fnArray[x];
                            opList.push({
                                'fnId': fnId,
                                'fn': REVOPS[fnId],
                                'args': argsArray[x]
                            });
                        }
                        return opListToTree(opList);
                    },
                    executeOpTree: function SVGGraphics_executeOpTree(opTree) {
                        var opTreeLen = opTree.length;
                        for (var x = 0; x < opTreeLen; x++) {
                            var fn = opTree[x].fn;
                            var fnId = opTree[x].fnId;
                            var args = opTree[x].args;
                            switch (fnId | 0) {
                                case OPS.beginText:
                                    this.beginText();
                                    break;
                                case OPS.setLeading:
                                    this.setLeading(args);
                                    break;
                                case OPS.setLeadingMoveText:
                                    this.setLeadingMoveText(args[0], args[1]);
                                    break;
                                case OPS.setFont:
                                    this.setFont(args);
                                    break;
                                case OPS.showText:
                                    this.showText(args[0]);
                                    break;
                                case OPS.showSpacedText:
                                    this.showText(args[0]);
                                    break;
                                case OPS.endText:
                                    this.endText();
                                    break;
                                case OPS.moveText:
                                    this.moveText(args[0], args[1]);
                                    break;
                                case OPS.setCharSpacing:
                                    this.setCharSpacing(args[0]);
                                    break;
                                case OPS.setWordSpacing:
                                    this.setWordSpacing(args[0]);
                                    break;
                                case OPS.setHScale:
                                    this.setHScale(args[0]);
                                    break;
                                case OPS.setTextMatrix:
                                    this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                                    break;
                                case OPS.setLineWidth:
                                    this.setLineWidth(args[0]);
                                    break;
                                case OPS.setLineJoin:
                                    this.setLineJoin(args[0]);
                                    break;
                                case OPS.setLineCap:
                                    this.setLineCap(args[0]);
                                    break;
                                case OPS.setMiterLimit:
                                    this.setMiterLimit(args[0]);
                                    break;
                                case OPS.setFillRGBColor:
                                    this.setFillRGBColor(args[0], args[1], args[2]);
                                    break;
                                case OPS.setStrokeRGBColor:
                                    this.setStrokeRGBColor(args[0], args[1], args[2]);
                                    break;
                                case OPS.setDash:
                                    this.setDash(args[0], args[1]);
                                    break;
                                case OPS.setGState:
                                    this.setGState(args[0]);
                                    break;
                                case OPS.fill:
                                    this.fill();
                                    break;
                                case OPS.eoFill:
                                    this.eoFill();
                                    break;
                                case OPS.stroke:
                                    this.stroke();
                                    break;
                                case OPS.fillStroke:
                                    this.fillStroke();
                                    break;
                                case OPS.eoFillStroke:
                                    this.eoFillStroke();
                                    break;
                                case OPS.clip:
                                    this.clip('nonzero');
                                    break;
                                case OPS.eoClip:
                                    this.clip('evenodd');
                                    break;
                                case OPS.paintSolidColorImageMask:
                                    this.paintSolidColorImageMask();
                                    break;
                                case OPS.paintJpegXObject:
                                    this.paintJpegXObject(args[0], args[1], args[2]);
                                    break;
                                case OPS.paintImageXObject:
                                    this.paintImageXObject(args[0]);
                                    break;
                                case OPS.paintInlineImageXObject:
                                    this.paintInlineImageXObject(args[0]);
                                    break;
                                case OPS.paintImageMaskXObject:
                                    this.paintImageMaskXObject(args[0]);
                                    break;
                                case OPS.paintFormXObjectBegin:
                                    this.paintFormXObjectBegin(args[0], args[1]);
                                    break;
                                case OPS.paintFormXObjectEnd:
                                    this.paintFormXObjectEnd();
                                    break;
                                case OPS.closePath:
                                    this.closePath();
                                    break;
                                case OPS.closeStroke:
                                    this.closeStroke();
                                    break;
                                case OPS.closeFillStroke:
                                    this.closeFillStroke();
                                    break;
                                case OPS.nextLine:
                                    this.nextLine();
                                    break;
                                case OPS.transform:
                                    this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
                                    break;
                                case OPS.constructPath:
                                    this.constructPath(args[0], args[1]);
                                    break;
                                case OPS.endPath:
                                    this.endPath();
                                    break;
                                case 92:
                                    this.group(opTree[x].items);
                                    break;
                                default:
                                    warn('Unimplemented method ' + fn);
                                    break;
                            }
                        }
                    },
                    setWordSpacing: function SVGGraphics_setWordSpacing(wordSpacing) {
                        this.current.wordSpacing = wordSpacing;
                    },
                    setCharSpacing: function SVGGraphics_setCharSpacing(charSpacing) {
                        this.current.charSpacing = charSpacing;
                    },
                    nextLine: function SVGGraphics_nextLine() {
                        this.moveText(0, this.current.leading);
                    },
                    setTextMatrix: function SVGGraphics_setTextMatrix(a, b, c, d, e, f) {
                        var current = this.current;
                        this.current.textMatrix = this.current.lineMatrix = [a, b, c, d, e, f];
                        this.current.x = this.current.lineX = 0;
                        this.current.y = this.current.lineY = 0;
                        current.xcoords = [];
                        current.tspan = document.createElementNS(NS, 'svg:tspan');
                        current.tspan.setAttributeNS(null, 'font-family', current.fontFamily);
                        current.tspan.setAttributeNS(null, 'font-size', pf(current.fontSize) + 'px');
                        current.tspan.setAttributeNS(null, 'y', pf(-current.y));
                        current.txtElement = document.createElementNS(NS, 'svg:text');
                        current.txtElement.appendChild(current.tspan);
                    },
                    beginText: function SVGGraphics_beginText() {
                        this.current.x = this.current.lineX = 0;
                        this.current.y = this.current.lineY = 0;
                        this.current.textMatrix = IDENTITY_MATRIX;
                        this.current.lineMatrix = IDENTITY_MATRIX;
                        this.current.tspan = document.createElementNS(NS, 'svg:tspan');
                        this.current.txtElement = document.createElementNS(NS, 'svg:text');
                        this.current.txtgrp = document.createElementNS(NS, 'svg:g');
                        this.current.xcoords = [];
                    },
                    moveText: function SVGGraphics_moveText(x, y) {
                        var current = this.current;
                        this.current.x = this.current.lineX += x;
                        this.current.y = this.current.lineY += y;
                        current.xcoords = [];
                        current.tspan = document.createElementNS(NS, 'svg:tspan');
                        current.tspan.setAttributeNS(null, 'font-family', current.fontFamily);
                        current.tspan.setAttributeNS(null, 'font-size', pf(current.fontSize) + 'px');
                        current.tspan.setAttributeNS(null, 'y', pf(-current.y));
                    },
                    showText: function SVGGraphics_showText(glyphs) {
                        var current = this.current;
                        var font = current.font;
                        var fontSize = current.fontSize;
                        if (fontSize === 0) {
                            return;
                        }
                        var charSpacing = current.charSpacing;
                        var wordSpacing = current.wordSpacing;
                        var fontDirection = current.fontDirection;
                        var textHScale = current.textHScale * fontDirection;
                        var glyphsLength = glyphs.length;
                        var vertical = font.vertical;
                        var widthAdvanceScale = fontSize * current.fontMatrix[0];
                        var x = 0,
                            i;
                        for (i = 0; i < glyphsLength; ++i) {
                            var glyph = glyphs[i];
                            if (glyph === null) {
                                x += fontDirection * wordSpacing;
                                continue;
                            } else if (isNum(glyph)) {
                                x += -glyph * fontSize * 0.001;
                                continue;
                            }
                            current.xcoords.push(current.x + x * textHScale);
                            var width = glyph.width;
                            var character = glyph.fontChar;
                            var charWidth = width * widthAdvanceScale + charSpacing * fontDirection;
                            x += charWidth;
                            current.tspan.textContent += character;
                        }
                        if (vertical) {
                            current.y -= x * textHScale;
                        } else {
                            current.x += x * textHScale;
                        }
                        current.tspan.setAttributeNS(null, 'x', current.xcoords.map(pf).join(' '));
                        current.tspan.setAttributeNS(null, 'y', pf(-current.y));
                        current.tspan.setAttributeNS(null, 'font-family', current.fontFamily);
                        current.tspan.setAttributeNS(null, 'font-size', pf(current.fontSize) + 'px');
                        if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
                            current.tspan.setAttributeNS(null, 'font-style', current.fontStyle);
                        }
                        if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
                            current.tspan.setAttributeNS(null, 'font-weight', current.fontWeight);
                        }
                        if (current.fillColor !== SVG_DEFAULTS.fillColor) {
                            current.tspan.setAttributeNS(null, 'fill', current.fillColor);
                        }
                        current.txtElement.setAttributeNS(null, 'transform', pm(current.textMatrix) + ' scale(1, -1)');
                        current.txtElement.setAttributeNS(XML_NS, 'xml:space', 'preserve');
                        current.txtElement.appendChild(current.tspan);
                        current.txtgrp.appendChild(current.txtElement);
                        this.tgrp.appendChild(current.txtElement);
                    },
                    setLeadingMoveText: function SVGGraphics_setLeadingMoveText(x, y) {
                        this.setLeading(-y);
                        this.moveText(x, y);
                    },
                    addFontStyle: function SVGGraphics_addFontStyle(fontObj) {
                        if (!this.cssStyle) {
                            this.cssStyle = document.createElementNS(NS, 'svg:style');
                            this.cssStyle.setAttributeNS(null, 'type', 'text/css');
                            this.defs.appendChild(this.cssStyle);
                        }
                        var url = PDFJS.createObjectURL(fontObj.data, fontObj.mimetype);
                        this.cssStyle.textContent += '@font-face { font-family: "' + fontObj.loadedName + '";' + ' src: url(' + url + '); }\n';
                    },
                    setFont: function SVGGraphics_setFont(details) {
                        var current = this.current;
                        var fontObj = this.commonObjs.get(details[0]);
                        var size = details[1];
                        this.current.font = fontObj;
                        if (this.embedFonts && fontObj.data && !this.embeddedFonts[fontObj.loadedName]) {
                            this.addFontStyle(fontObj);
                            this.embeddedFonts[fontObj.loadedName] = fontObj;
                        }
                        current.fontMatrix = (fontObj.fontMatrix ? fontObj.fontMatrix : FONT_IDENTITY_MATRIX);
                        var bold = fontObj.black ? (fontObj.bold ? 'bolder' : 'bold') : (fontObj.bold ? 'bold' : 'normal');
                        var italic = fontObj.italic ? 'italic' : 'normal';
                        if (size < 0) {
                            size = -size;
                            current.fontDirection = -1;
                        } else {
                            current.fontDirection = 1;
                        }
                        current.fontSize = size;
                        current.fontFamily = fontObj.loadedName;
                        current.fontWeight = bold;
                        current.fontStyle = italic;
                        current.tspan = document.createElementNS(NS, 'svg:tspan');
                        current.tspan.setAttributeNS(null, 'y', pf(-current.y));
                        current.xcoords = [];
                    },
                    endText: function SVGGraphics_endText() {
                        if (this.current.pendingClip) {
                            this.cgrp.appendChild(this.tgrp);
                            this.pgrp.appendChild(this.cgrp);
                        } else {
                            this.pgrp.appendChild(this.tgrp);
                        }
                        this.tgrp = document.createElementNS(NS, 'svg:g');
                        this.tgrp.setAttributeNS(null, 'transform', pm(this.transformMatrix));
                    },
                    setLineWidth: function SVGGraphics_setLineWidth(width) {
                        this.current.lineWidth = width;
                    },
                    setLineCap: function SVGGraphics_setLineCap(style) {
                        this.current.lineCap = LINE_CAP_STYLES[style];
                    },
                    setLineJoin: function SVGGraphics_setLineJoin(style) {
                        this.current.lineJoin = LINE_JOIN_STYLES[style];
                    },
                    setMiterLimit: function SVGGraphics_setMiterLimit(limit) {
                        this.current.miterLimit = limit;
                    },
                    setStrokeRGBColor: function SVGGraphics_setStrokeRGBColor(r, g, b) {
                        var color = Util.makeCssRgb(r, g, b);
                        this.current.strokeColor = color;
                    },
                    setFillRGBColor: function SVGGraphics_setFillRGBColor(r, g, b) {
                        var color = Util.makeCssRgb(r, g, b);
                        this.current.fillColor = color;
                        this.current.tspan = document.createElementNS(NS, 'svg:tspan');
                        this.current.xcoords = [];
                    },
                    setDash: function SVGGraphics_setDash(dashArray, dashPhase) {
                        this.current.dashArray = dashArray;
                        this.current.dashPhase = dashPhase;
                    },
                    constructPath: function SVGGraphics_constructPath(ops, args) {
                        var current = this.current;
                        var x = current.x,
                            y = current.y;
                        current.path = document.createElementNS(NS, 'svg:path');
                        var d = [];
                        var opLength = ops.length;
                        for (var i = 0, j = 0; i < opLength; i++) {
                            switch (ops[i] | 0) {
                                case OPS.rectangle:
                                    x = args[j++];
                                    y = args[j++];
                                    var width = args[j++];
                                    var height = args[j++];
                                    var xw = x + width;
                                    var yh = y + height;
                                    d.push('M', pf(x), pf(y), 'L', pf(xw), pf(y), 'L', pf(xw), pf(yh), 'L', pf(x), pf(yh), 'Z');
                                    break;
                                case OPS.moveTo:
                                    x = args[j++];
                                    y = args[j++];
                                    d.push('M', pf(x), pf(y));
                                    break;
                                case OPS.lineTo:
                                    x = args[j++];
                                    y = args[j++];
                                    d.push('L', pf(x), pf(y));
                                    break;
                                case OPS.curveTo:
                                    x = args[j + 4];
                                    y = args[j + 5];
                                    d.push('C', pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));
                                    j += 6;
                                    break;
                                case OPS.curveTo2:
                                    x = args[j + 2];
                                    y = args[j + 3];
                                    d.push('C', pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));
                                    j += 4;
                                    break;
                                case OPS.curveTo3:
                                    x = args[j + 2];
                                    y = args[j + 3];
                                    d.push('C', pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));
                                    j += 4;
                                    break;
                                case OPS.closePath:
                                    d.push('Z');
                                    break;
                            }
                        }
                        current.path.setAttributeNS(null, 'd', d.join(' '));
                        current.path.setAttributeNS(null, 'stroke-miterlimit', pf(current.miterLimit));
                        current.path.setAttributeNS(null, 'stroke-linecap', current.lineCap);
                        current.path.setAttributeNS(null, 'stroke-linejoin', current.lineJoin);
                        current.path.setAttributeNS(null, 'stroke-width', pf(current.lineWidth) + 'px');
                        current.path.setAttributeNS(null, 'stroke-dasharray', current.dashArray.map(pf).join(' '));
                        current.path.setAttributeNS(null, 'stroke-dashoffset', pf(current.dashPhase) + 'px');
                        current.path.setAttributeNS(null, 'fill', 'none');
                        this.tgrp.appendChild(current.path);
                        if (current.pendingClip) {
                            this.cgrp.appendChild(this.tgrp);
                            this.pgrp.appendChild(this.cgrp);
                        } else {
                            this.pgrp.appendChild(this.tgrp);
                        }
                        current.element = current.path;
                        current.setCurrentPoint(x, y);
                    },
                    endPath: function SVGGraphics_endPath() {
                        var current = this.current;
                        if (current.pendingClip) {
                            this.cgrp.appendChild(this.tgrp);
                            this.pgrp.appendChild(this.cgrp);
                        } else {
                            this.pgrp.appendChild(this.tgrp);
                        }
                        this.tgrp = document.createElementNS(NS, 'svg:g');
                        this.tgrp.setAttributeNS(null, 'transform', pm(this.transformMatrix));
                    },
                    clip: function SVGGraphics_clip(type) {
                        var current = this.current;
                        current.clipId = 'clippath' + clipCount;
                        clipCount++;
                        this.clippath = document.createElementNS(NS, 'svg:clipPath');
                        this.clippath.setAttributeNS(null, 'id', current.clipId);
                        var clipElement = current.element.cloneNode();
                        if (type === 'evenodd') {
                            clipElement.setAttributeNS(null, 'clip-rule', 'evenodd');
                        } else {
                            clipElement.setAttributeNS(null, 'clip-rule', 'nonzero');
                        }
                        this.clippath.setAttributeNS(null, 'transform', pm(this.transformMatrix));
                        this.clippath.appendChild(clipElement);
                        this.defs.appendChild(this.clippath);
                        current.pendingClip = true;
                        this.cgrp = document.createElementNS(NS, 'svg:g');
                        this.cgrp.setAttributeNS(null, 'clip-path', 'url(#' + current.clipId + ')');
                        this.pgrp.appendChild(this.cgrp);
                    },
                    closePath: function SVGGraphics_closePath() {
                        var current = this.current;
                        var d = current.path.getAttributeNS(null, 'd');
                        d += 'Z';
                        current.path.setAttributeNS(null, 'd', d);
                    },
                    setLeading: function SVGGraphics_setLeading(leading) {
                        this.current.leading = -leading;
                    },
                    setTextRise: function SVGGraphics_setTextRise(textRise) {
                        this.current.textRise = textRise;
                    },
                    setHScale: function SVGGraphics_setHScale(scale) {
                        this.current.textHScale = scale / 100;
                    },
                    setGState: function SVGGraphics_setGState(states) {
                        for (var i = 0, ii = states.length; i < ii; i++) {
                            var state = states[i];
                            var key = state[0];
                            var value = state[1];
                            switch (key) {
                                case 'LW':
                                    this.setLineWidth(value);
                                    break;
                                case 'LC':
                                    this.setLineCap(value);
                                    break;
                                case 'LJ':
                                    this.setLineJoin(value);
                                    break;
                                case 'ML':
                                    this.setMiterLimit(value);
                                    break;
                                case 'D':
                                    this.setDash(value[0], value[1]);
                                    break;
                                case 'RI':
                                    break;
                                case 'FL':
                                    break;
                                case 'Font':
                                    this.setFont(value);
                                    break;
                                case 'CA':
                                    break;
                                case 'ca':
                                    break;
                                case 'BM':
                                    break;
                                case 'SMask':
                                    break;
                            }
                        }
                    },
                    fill: function SVGGraphics_fill() {
                        var current = this.current;
                        current.element.setAttributeNS(null, 'fill', current.fillColor);
                    },
                    stroke: function SVGGraphics_stroke() {
                        var current = this.current;
                        current.element.setAttributeNS(null, 'stroke', current.strokeColor);
                        current.element.setAttributeNS(null, 'fill', 'none');
                    },
                    eoFill: function SVGGraphics_eoFill() {
                        var current = this.current;
                        current.element.setAttributeNS(null, 'fill', current.fillColor);
                        current.element.setAttributeNS(null, 'fill-rule', 'evenodd');
                    },
                    fillStroke: function SVGGraphics_fillStroke() {
                        this.stroke();
                        this.fill();
                    },
                    eoFillStroke: function SVGGraphics_eoFillStroke() {
                        this.current.element.setAttributeNS(null, 'fill-rule', 'evenodd');
                        this.fillStroke();
                    },
                    closeStroke: function SVGGraphics_closeStroke() {
                        this.closePath();
                        this.stroke();
                    },
                    closeFillStroke: function SVGGraphics_closeFillStroke() {
                        this.closePath();
                        this.fillStroke();
                    },
                    paintSolidColorImageMask: function SVGGraphics_paintSolidColorImageMask() {
                        var current = this.current;
                        var rect = document.createElementNS(NS, 'svg:rect');
                        rect.setAttributeNS(null, 'x', '0');
                        rect.setAttributeNS(null, 'y', '0');
                        rect.setAttributeNS(null, 'width', '1px');
                        rect.setAttributeNS(null, 'height', '1px');
                        rect.setAttributeNS(null, 'fill', current.fillColor);
                        this.tgrp.appendChild(rect);
                    },
                    paintJpegXObject: function SVGGraphics_paintJpegXObject(objId, w, h) {
                        var current = this.current;
                        var imgObj = this.objs.get(objId);
                        var imgEl = document.createElementNS(NS, 'svg:image');
                        imgEl.setAttributeNS(XLINK_NS, 'xlink:href', imgObj.src);
                        imgEl.setAttributeNS(null, 'width', imgObj.width + 'px');
                        imgEl.setAttributeNS(null, 'height', imgObj.height + 'px');
                        imgEl.setAttributeNS(null, 'x', '0');
                        imgEl.setAttributeNS(null, 'y', pf(-h));
                        imgEl.setAttributeNS(null, 'transform', 'scale(' + pf(1 / w) + ' ' + pf(-1 / h) + ')');
                        this.tgrp.appendChild(imgEl);
                        if (current.pendingClip) {
                            this.cgrp.appendChild(this.tgrp);
                            this.pgrp.appendChild(this.cgrp);
                        } else {
                            this.pgrp.appendChild(this.tgrp);
                        }
                    },
                    paintImageXObject: function SVGGraphics_paintImageXObject(objId) {
                        var imgData = this.objs.get(objId);
                        if (!imgData) {
                            warn('Dependent image isn\'t ready yet');
                            return;
                        }
                        this.paintInlineImageXObject(imgData);
                    },
                    paintInlineImageXObject: function SVGGraphics_paintInlineImageXObject(imgData, mask) {
                        var current = this.current;
                        var width = imgData.width;
                        var height = imgData.height;
                        var imgSrc = convertImgDataToPng(imgData);
                        var cliprect = document.createElementNS(NS, 'svg:rect');
                        cliprect.setAttributeNS(null, 'x', '0');
                        cliprect.setAttributeNS(null, 'y', '0');
                        cliprect.setAttributeNS(null, 'width', pf(width));
                        cliprect.setAttributeNS(null, 'height', pf(height));
                        current.element = cliprect;
                        this.clip('nonzero');
                        var imgEl = document.createElementNS(NS, 'svg:image');
                        imgEl.setAttributeNS(XLINK_NS, 'xlink:href', imgSrc);
                        imgEl.setAttributeNS(null, 'x', '0');
                        imgEl.setAttributeNS(null, 'y', pf(-height));
                        imgEl.setAttributeNS(null, 'width', pf(width) + 'px');
                        imgEl.setAttributeNS(null, 'height', pf(height) + 'px');
                        imgEl.setAttributeNS(null, 'transform', 'scale(' + pf(1 / width) + ' ' +
                            pf(-1 / height) + ')');
                        if (mask) {
                            mask.appendChild(imgEl);
                        } else {
                            this.tgrp.appendChild(imgEl);
                        }
                        if (current.pendingClip) {
                            this.cgrp.appendChild(this.tgrp);
                            this.pgrp.appendChild(this.cgrp);
                        } else {
                            this.pgrp.appendChild(this.tgrp);
                        }
                    },
                    paintImageMaskXObject: function SVGGraphics_paintImageMaskXObject(imgData) {
                        var current = this.current;
                        var width = imgData.width;
                        var height = imgData.height;
                        var fillColor = current.fillColor;
                        current.maskId = 'mask' + maskCount++;
                        var mask = document.createElementNS(NS, 'svg:mask');
                        mask.setAttributeNS(null, 'id', current.maskId);
                        var rect = document.createElementNS(NS, 'svg:rect');
                        rect.setAttributeNS(null, 'x', '0');
                        rect.setAttributeNS(null, 'y', '0');
                        rect.setAttributeNS(null, 'width', pf(width));
                        rect.setAttributeNS(null, 'height', pf(height));
                        rect.setAttributeNS(null, 'fill', fillColor);
                        rect.setAttributeNS(null, 'mask', 'url(#' + current.maskId + ')');
                        this.defs.appendChild(mask);
                        this.tgrp.appendChild(rect);
                        this.paintInlineImageXObject(imgData, mask);
                    },
                    paintFormXObjectBegin: function SVGGraphics_paintFormXObjectBegin(matrix, bbox) {
                        this.save();
                        if (isArray(matrix) && matrix.length === 6) {
                            this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
                        }
                        if (isArray(bbox) && bbox.length === 4) {
                            var width = bbox[2] - bbox[0];
                            var height = bbox[3] - bbox[1];
                            var cliprect = document.createElementNS(NS, 'svg:rect');
                            cliprect.setAttributeNS(null, 'x', bbox[0]);
                            cliprect.setAttributeNS(null, 'y', bbox[1]);
                            cliprect.setAttributeNS(null, 'width', pf(width));
                            cliprect.setAttributeNS(null, 'height', pf(height));
                            this.current.element = cliprect;
                            this.clip('nonzero');
                            this.endPath();
                        }
                    },
                    paintFormXObjectEnd: function SVGGraphics_paintFormXObjectEnd() {
                        this.restore();
                    }
                };
                return SVGGraphics;
            })();
            PDFJS.SVGGraphics = SVGGraphics;
            exports.SVGGraphics = SVGGraphics;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsDisplayTextLayer = {}), root.pdfjsSharedUtil, root.pdfjsDisplayDOMUtils, root.pdfjsSharedGlobal);
            }
        }(this, function(exports, sharedUtil, displayDOMUtils, sharedGlobal) {
            var Util = sharedUtil.Util;
            var createPromiseCapability = sharedUtil.createPromiseCapability;
            var CustomStyle = displayDOMUtils.CustomStyle;
            var PDFJS = sharedGlobal.PDFJS;
            var renderTextLayer = (function renderTextLayerClosure() {
                var MAX_TEXT_DIVS_TO_RENDER = 100000;
                var NonWhitespaceRegexp = /\S/;

                function isAllWhitespace(str) {
                    return !NonWhitespaceRegexp.test(str);
                }

                function appendText(textDivs, viewport, geom, styles) {
                    var style = styles[geom.fontName];
                    var textDiv = document.createElement('div');
                    textDivs.push(textDiv);
                    if (isAllWhitespace(geom.str)) {
                        textDiv.dataset.isWhitespace = true;
                        return;
                    }
                    var tx = Util.transform(viewport.transform, geom.transform);
                    var angle = Math.atan2(tx[1], tx[0]);
                    if (style.vertical) {
                        angle += Math.PI / 2;
                    }
                    var fontHeight = Math.sqrt((tx[2] * tx[2]) + (tx[3] * tx[3]));
                    var fontAscent = fontHeight;
                    if (style.ascent) {
                        fontAscent = style.ascent * fontAscent;
                    } else if (style.descent) {
                        fontAscent = (1 + style.descent) * fontAscent;
                    }
                    var left;
                    var top;
                    if (angle === 0) {
                        left = tx[4];
                        top = tx[5] - fontAscent;
                    } else {
                        left = tx[4] + (fontAscent * Math.sin(angle));
                        top = tx[5] - (fontAscent * Math.cos(angle));
                    }
                    textDiv.style.left = left + 'px';
                    textDiv.style.top = top + 'px';
                    textDiv.style.fontSize = fontHeight + 'px';
                    textDiv.style.fontFamily = style.fontFamily;
                    textDiv.textContent = geom.str;
                    if (PDFJS.pdfBug) {
                        textDiv.dataset.fontName = geom.fontName;
                    }
                    if (angle !== 0) {
                        textDiv.dataset.angle = angle * (180 / Math.PI);
                    }
                    if (geom.str.length > 1) {
                        if (style.vertical) {
                            textDiv.dataset.canvasWidth = geom.height * viewport.scale;
                        } else {
                            textDiv.dataset.canvasWidth = geom.width * viewport.scale;
                        }
                    }
                }

                function render(task) {
                    if (task._canceled) {
                        return;
                    }
                    var textLayerFrag = task._container;
                    var textDivs = task._textDivs;
                    var capability = task._capability;
                    var textDivsLength = textDivs.length;
                    if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
                        capability.resolve();
                        return;
                    }
                    var canvas = document.createElement('canvas');
                    canvas.mozOpaque = true;
                    var ctx = canvas.getContext('2d', {
                        alpha: false
                    });
                    var lastFontSize;
                    var lastFontFamily;
                    for (var i = 0; i < textDivsLength; i++) {
                        var textDiv = textDivs[i];
                        if (textDiv.dataset.isWhitespace !== undefined) {
                            continue;
                        }
                        var fontSize = textDiv.style.fontSize;
                        var fontFamily = textDiv.style.fontFamily;
                        if (fontSize !== lastFontSize || fontFamily !== lastFontFamily) {
                            ctx.font = fontSize + ' ' + fontFamily;
                            lastFontSize = fontSize;
                            lastFontFamily = fontFamily;
                        }
                        var width = ctx.measureText(textDiv.textContent).width;
                        if (width > 0) {
                            textLayerFrag.appendChild(textDiv);
                            var transform;
                            if (textDiv.dataset.canvasWidth !== undefined) {
                                var textScale = textDiv.dataset.canvasWidth / width;
                                transform = 'scaleX(' + textScale + ')';
                            } else {
                                transform = '';
                            }
                            var rotation = textDiv.dataset.angle;
                            if (rotation) {
                                transform = 'rotate(' + rotation + 'deg) ' + transform;
                            }
                            if (transform) {
                                CustomStyle.setProp('transform', textDiv, transform);
                            }
                        }
                    }
                    capability.resolve();
                }

                function TextLayerRenderTask(textContent, container, viewport, textDivs) {
                    this._textContent = textContent;
                    this._container = container;
                    this._viewport = viewport;
                    textDivs = textDivs || [];
                    this._textDivs = textDivs;
                    this._canceled = false;
                    this._capability = createPromiseCapability();
                    this._renderTimer = null;
                }
                TextLayerRenderTask.prototype = {
                    get promise() {
                        return this._capability.promise;
                    },
                    cancel: function TextLayer_cancel() {
                        this._canceled = true;
                        if (this._renderTimer !== null) {
                            clearTimeout(this._renderTimer);
                            this._renderTimer = null;
                        }
                        this._capability.reject('canceled');
                    },
                    _render: function TextLayer_render(timeout) {
                        var textItems = this._textContent.items;
                        var styles = this._textContent.styles;
                        var textDivs = this._textDivs;
                        var viewport = this._viewport;
                        for (var i = 0, len = textItems.length; i < len; i++) {
                            appendText(textDivs, viewport, textItems[i], styles);
                        }
                        if (!timeout) {
                            render(this);
                        } else {
                            var self = this;
                            this._renderTimer = setTimeout(function() {
                                render(self);
                                self._renderTimer = null;
                            }, timeout);
                        }
                    }
                };

                function renderTextLayer(renderParameters) {
                    var task = new TextLayerRenderTask(renderParameters.textContent, renderParameters.container, renderParameters.viewport, renderParameters.textDivs);
                    task._render(renderParameters.timeout);
                    return task;
                }
                return renderTextLayer;
            })();
            PDFJS.renderTextLayer = renderTextLayer;
            exports.renderTextLayer = renderTextLayer;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsDisplayWebGL = {}), root.pdfjsSharedUtil);
            }
        }(this, function(exports, sharedUtil) {
            var shadow = sharedUtil.shadow;
            var WebGLUtils = (function WebGLUtilsClosure() {
                function loadShader(gl, code, shaderType) {
                    var shader = gl.createShader(shaderType);
                    gl.shaderSource(shader, code);
                    gl.compileShader(shader);
                    var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
                    if (!compiled) {
                        var errorMsg = gl.getShaderInfoLog(shader);
                        throw new Error('Error during shader compilation: ' + errorMsg);
                    }
                    return shader;
                }

                function createVertexShader(gl, code) {
                    return loadShader(gl, code, gl.VERTEX_SHADER);
                }

                function createFragmentShader(gl, code) {
                    return loadShader(gl, code, gl.FRAGMENT_SHADER);
                }

                function createProgram(gl, shaders) {
                    var program = gl.createProgram();
                    for (var i = 0, ii = shaders.length; i < ii; ++i) {
                        gl.attachShader(program, shaders[i]);
                    }
                    gl.linkProgram(program);
                    var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
                    if (!linked) {
                        var errorMsg = gl.getProgramInfoLog(program);
                        throw new Error('Error during program linking: ' + errorMsg);
                    }
                    return program;
                }

                function createTexture(gl, image, textureId) {
                    gl.activeTexture(textureId);
                    var texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                    return texture;
                }
                var currentGL, currentCanvas;

                function generateGL() {
                    if (currentGL) {
                        return;
                    }
                    currentCanvas = document.createElement('canvas');
                    currentGL = currentCanvas.getContext('webgl', {
                        premultipliedalpha: false
                    });
                }
                var smaskVertexShaderCode = '\
  attribute vec2 a_position;                                    \
  attribute vec2 a_texCoord;                                    \
                                                                \
  uniform vec2 u_resolution;                                    \
                                                                \
  varying vec2 v_texCoord;                                      \
                                                                \
  void main() {                                                 \
    vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;   \
    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \
                                                                \
    v_texCoord = a_texCoord;                                    \
  }                                                             ';
                var smaskFragmentShaderCode = '\
  precision mediump float;                                      \
                                                                \
  uniform vec4 u_backdrop;                                      \
  uniform int u_subtype;                                        \
  uniform sampler2D u_image;                                    \
  uniform sampler2D u_mask;                                     \
                                                                \
  varying vec2 v_texCoord;                                      \
                                                                \
  void main() {                                                 \
    vec4 imageColor = texture2D(u_image, v_texCoord);           \
    vec4 maskColor = texture2D(u_mask, v_texCoord);             \
    if (u_backdrop.a > 0.0) {                                   \
      maskColor.rgb = maskColor.rgb * maskColor.a +             \
                      u_backdrop.rgb * (1.0 - maskColor.a);     \
    }                                                           \
    float lum;                                                  \
    if (u_subtype == 0) {                                       \
      lum = maskColor.a;                                        \
    } else {                                                    \
      lum = maskColor.r * 0.3 + maskColor.g * 0.59 +            \
            maskColor.b * 0.11;                                 \
    }                                                           \
    imageColor.a *= lum;                                        \
    imageColor.rgb *= imageColor.a;                             \
    gl_FragColor = imageColor;                                  \
  }                                                             ';
                var smaskCache = null;

                function initSmaskGL() {
                    var canvas, gl;
                    generateGL();
                    canvas = currentCanvas;
                    currentCanvas = null;
                    gl = currentGL;
                    currentGL = null;
                    var vertexShader = createVertexShader(gl, smaskVertexShaderCode);
                    var fragmentShader = createFragmentShader(gl, smaskFragmentShaderCode);
                    var program = createProgram(gl, [vertexShader, fragmentShader]);
                    gl.useProgram(program);
                    var cache = {};
                    cache.gl = gl;
                    cache.canvas = canvas;
                    cache.resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
                    cache.positionLocation = gl.getAttribLocation(program, 'a_position');
                    cache.backdropLocation = gl.getUniformLocation(program, 'u_backdrop');
                    cache.subtypeLocation = gl.getUniformLocation(program, 'u_subtype');
                    var texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');
                    var texLayerLocation = gl.getUniformLocation(program, 'u_image');
                    var texMaskLocation = gl.getUniformLocation(program, 'u_mask');
                    var texCoordBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), gl.STATIC_DRAW);
                    gl.enableVertexAttribArray(texCoordLocation);
                    gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
                    gl.uniform1i(texLayerLocation, 0);
                    gl.uniform1i(texMaskLocation, 1);
                    smaskCache = cache;
                }

                function composeSMask(layer, mask, properties) {
                    var width = layer.width,
                        height = layer.height;
                    if (!smaskCache) {
                        initSmaskGL();
                    }
                    var cache = smaskCache,
                        canvas = cache.canvas,
                        gl = cache.gl;
                    canvas.width = width;
                    canvas.height = height;
                    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                    gl.uniform2f(cache.resolutionLocation, width, height);
                    if (properties.backdrop) {
                        gl.uniform4f(cache.resolutionLocation, properties.backdrop[0], properties.backdrop[1], properties.backdrop[2], 1);
                    } else {
                        gl.uniform4f(cache.resolutionLocation, 0, 0, 0, 0);
                    }
                    gl.uniform1i(cache.subtypeLocation, properties.subtype === 'Luminosity' ? 1 : 0);
                    var texture = createTexture(gl, layer, gl.TEXTURE0);
                    var maskTexture = createTexture(gl, mask, gl.TEXTURE1);
                    var buffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, width, 0, 0, height, 0, height, width, 0, width, height]), gl.STATIC_DRAW);
                    gl.enableVertexAttribArray(cache.positionLocation);
                    gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);
                    gl.clearColor(0, 0, 0, 0);
                    gl.enable(gl.BLEND);
                    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    gl.flush();
                    gl.deleteTexture(texture);
                    gl.deleteTexture(maskTexture);
                    gl.deleteBuffer(buffer);
                    return canvas;
                }
                var figuresVertexShaderCode = '\
  attribute vec2 a_position;                                    \
  attribute vec3 a_color;                                       \
                                                                \
  uniform vec2 u_resolution;                                    \
  uniform vec2 u_scale;                                         \
  uniform vec2 u_offset;                                        \
                                                                \
  varying vec4 v_color;                                         \
                                                                \
  void main() {                                                 \
    vec2 position = (a_position + u_offset) * u_scale;          \
    vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0;     \
    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \
                                                                \
    v_color = vec4(a_color / 255.0, 1.0);                       \
  }                                                             ';
                var figuresFragmentShaderCode = '\
  precision mediump float;                                      \
                                                                \
  varying vec4 v_color;                                         \
                                                                \
  void main() {                                                 \
    gl_FragColor = v_color;                                     \
  }                                                             ';
                var figuresCache = null;

                function initFiguresGL() {
                    var canvas, gl;
                    generateGL();
                    canvas = currentCanvas;
                    currentCanvas = null;
                    gl = currentGL;
                    currentGL = null;
                    var vertexShader = createVertexShader(gl, figuresVertexShaderCode);
                    var fragmentShader = createFragmentShader(gl, figuresFragmentShaderCode);
                    var program = createProgram(gl, [vertexShader, fragmentShader]);
                    gl.useProgram(program);
                    var cache = {};
                    cache.gl = gl;
                    cache.canvas = canvas;
                    cache.resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
                    cache.scaleLocation = gl.getUniformLocation(program, 'u_scale');
                    cache.offsetLocation = gl.getUniformLocation(program, 'u_offset');
                    cache.positionLocation = gl.getAttribLocation(program, 'a_position');
                    cache.colorLocation = gl.getAttribLocation(program, 'a_color');
                    figuresCache = cache;
                }

                function drawFigures(width, height, backgroundColor, figures, context) {
                    if (!figuresCache) {
                        initFiguresGL();
                    }
                    var cache = figuresCache,
                        canvas = cache.canvas,
                        gl = cache.gl;
                    canvas.width = width;
                    canvas.height = height;
                    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                    gl.uniform2f(cache.resolutionLocation, width, height);
                    var count = 0;
                    var i, ii, rows;
                    for (i = 0, ii = figures.length; i < ii; i++) {
                        switch (figures[i].type) {
                            case 'lattice':
                                rows = (figures[i].coords.length / figures[i].verticesPerRow) | 0;
                                count += (rows - 1) * (figures[i].verticesPerRow - 1) * 6;
                                break;
                            case 'triangles':
                                count += figures[i].coords.length;
                                break;
                        }
                    }
                    var coords = new Float32Array(count * 2);
                    var colors = new Uint8Array(count * 3);
                    var coordsMap = context.coords,
                        colorsMap = context.colors;
                    var pIndex = 0,
                        cIndex = 0;
                    for (i = 0, ii = figures.length; i < ii; i++) {
                        var figure = figures[i],
                            ps = figure.coords,
                            cs = figure.colors;
                        switch (figure.type) {
                            case 'lattice':
                                var cols = figure.verticesPerRow;
                                rows = (ps.length / cols) | 0;
                                for (var row = 1; row < rows; row++) {
                                    var offset = row * cols + 1;
                                    for (var col = 1; col < cols; col++, offset++) {
                                        coords[pIndex] = coordsMap[ps[offset - cols - 1]];
                                        coords[pIndex + 1] = coordsMap[ps[offset - cols - 1] + 1];
                                        coords[pIndex + 2] = coordsMap[ps[offset - cols]];
                                        coords[pIndex + 3] = coordsMap[ps[offset - cols] + 1];
                                        coords[pIndex + 4] = coordsMap[ps[offset - 1]];
                                        coords[pIndex + 5] = coordsMap[ps[offset - 1] + 1];
                                        colors[cIndex] = colorsMap[cs[offset - cols - 1]];
                                        colors[cIndex + 1] = colorsMap[cs[offset - cols - 1] + 1];
                                        colors[cIndex + 2] = colorsMap[cs[offset - cols - 1] + 2];
                                        colors[cIndex + 3] = colorsMap[cs[offset - cols]];
                                        colors[cIndex + 4] = colorsMap[cs[offset - cols] + 1];
                                        colors[cIndex + 5] = colorsMap[cs[offset - cols] + 2];
                                        colors[cIndex + 6] = colorsMap[cs[offset - 1]];
                                        colors[cIndex + 7] = colorsMap[cs[offset - 1] + 1];
                                        colors[cIndex + 8] = colorsMap[cs[offset - 1] + 2];
                                        coords[pIndex + 6] = coords[pIndex + 2];
                                        coords[pIndex + 7] = coords[pIndex + 3];
                                        coords[pIndex + 8] = coords[pIndex + 4];
                                        coords[pIndex + 9] = coords[pIndex + 5];
                                        coords[pIndex + 10] = coordsMap[ps[offset]];
                                        coords[pIndex + 11] = coordsMap[ps[offset] + 1];
                                        colors[cIndex + 9] = colors[cIndex + 3];
                                        colors[cIndex + 10] = colors[cIndex + 4];
                                        colors[cIndex + 11] = colors[cIndex + 5];
                                        colors[cIndex + 12] = colors[cIndex + 6];
                                        colors[cIndex + 13] = colors[cIndex + 7];
                                        colors[cIndex + 14] = colors[cIndex + 8];
                                        colors[cIndex + 15] = colorsMap[cs[offset]];
                                        colors[cIndex + 16] = colorsMap[cs[offset] + 1];
                                        colors[cIndex + 17] = colorsMap[cs[offset] + 2];
                                        pIndex += 12;
                                        cIndex += 18;
                                    }
                                }
                                break;
                            case 'triangles':
                                for (var j = 0, jj = ps.length; j < jj; j++) {
                                    coords[pIndex] = coordsMap[ps[j]];
                                    coords[pIndex + 1] = coordsMap[ps[j] + 1];
                                    colors[cIndex] = colorsMap[cs[j]];
                                    colors[cIndex + 1] = colorsMap[cs[j] + 1];
                                    colors[cIndex + 2] = colorsMap[cs[j] + 2];
                                    pIndex += 2;
                                    cIndex += 3;
                                }
                                break;
                        }
                    }
                    if (backgroundColor) {
                        gl.clearColor(backgroundColor[0] / 255, backgroundColor[1] / 255, backgroundColor[2] / 255, 1.0);
                    } else {
                        gl.clearColor(0, 0, 0, 0);
                    }
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    var coordsBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, coordsBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STATIC_DRAW);
                    gl.enableVertexAttribArray(cache.positionLocation);
                    gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);
                    var colorsBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
                    gl.enableVertexAttribArray(cache.colorLocation);
                    gl.vertexAttribPointer(cache.colorLocation, 3, gl.UNSIGNED_BYTE, false, 0, 0);
                    gl.uniform2f(cache.scaleLocation, context.scaleX, context.scaleY);
                    gl.uniform2f(cache.offsetLocation, context.offsetX, context.offsetY);
                    gl.drawArrays(gl.TRIANGLES, 0, count);
                    gl.flush();
                    gl.deleteBuffer(coordsBuffer);
                    gl.deleteBuffer(colorsBuffer);
                    return canvas;
                }

                function cleanup() {
                    if (smaskCache && smaskCache.canvas) {
                        smaskCache.canvas.width = 0;
                        smaskCache.canvas.height = 0;
                    }
                    if (figuresCache && figuresCache.canvas) {
                        figuresCache.canvas.width = 0;
                        figuresCache.canvas.height = 0;
                    }
                    smaskCache = null;
                    figuresCache = null;
                }
                return {
                    get isEnabled() {
                        if (PDFJS.disableWebGL) {
                            return false;
                        }
                        var enabled = false;
                        try {
                            generateGL();
                            enabled = !!currentGL;
                        } catch (e) {}
                        return shadow(this, 'isEnabled', enabled);
                    },
                    composeSMask: composeSMask,
                    drawFigures: drawFigures,
                    clear: cleanup
                };
            })();
            exports.WebGLUtils = WebGLUtils;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsDisplayPatternHelper = {}), root.pdfjsSharedUtil, root.pdfjsDisplayWebGL);
            }
        }(this, function(exports, sharedUtil, displayWebGL) {
            var Util = sharedUtil.Util;
            var info = sharedUtil.info;
            var isArray = sharedUtil.isArray;
            var error = sharedUtil.error;
            var WebGLUtils = displayWebGL.WebGLUtils;
            var ShadingIRs = {};
            ShadingIRs.RadialAxial = {
                fromIR: function RadialAxial_fromIR(raw) {
                    var type = raw[1];
                    var colorStops = raw[2];
                    var p0 = raw[3];
                    var p1 = raw[4];
                    var r0 = raw[5];
                    var r1 = raw[6];
                    return {
                        type: 'Pattern',
                        getPattern: function RadialAxial_getPattern(ctx) {
                            var grad;
                            if (type === 'axial') {
                                grad = ctx.createLinearGradient(p0[0], p0[1], p1[0], p1[1]);
                            } else if (type === 'radial') {
                                grad = ctx.createRadialGradient(p0[0], p0[1], r0, p1[0], p1[1], r1);
                            }
                            for (var i = 0, ii = colorStops.length; i < ii; ++i) {
                                var c = colorStops[i];
                                grad.addColorStop(c[0], c[1]);
                            }
                            return grad;
                        }
                    };
                }
            };
            var createMeshCanvas = (function createMeshCanvasClosure() {
                function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
                    var coords = context.coords,
                        colors = context.colors;
                    var bytes = data.data,
                        rowSize = data.width * 4;
                    var tmp;
                    if (coords[p1 + 1] > coords[p2 + 1]) {
                        tmp = p1;
                        p1 = p2;
                        p2 = tmp;
                        tmp = c1;
                        c1 = c2;
                        c2 = tmp;
                    }
                    if (coords[p2 + 1] > coords[p3 + 1]) {
                        tmp = p2;
                        p2 = p3;
                        p3 = tmp;
                        tmp = c2;
                        c2 = c3;
                        c3 = tmp;
                    }
                    if (coords[p1 + 1] > coords[p2 + 1]) {
                        tmp = p1;
                        p1 = p2;
                        p2 = tmp;
                        tmp = c1;
                        c1 = c2;
                        c2 = tmp;
                    }
                    var x1 = (coords[p1] + context.offsetX) * context.scaleX;
                    var y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
                    var x2 = (coords[p2] + context.offsetX) * context.scaleX;
                    var y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
                    var x3 = (coords[p3] + context.offsetX) * context.scaleX;
                    var y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;
                    if (y1 >= y3) {
                        return;
                    }
                    var c1r = colors[c1],
                        c1g = colors[c1 + 1],
                        c1b = colors[c1 + 2];
                    var c2r = colors[c2],
                        c2g = colors[c2 + 1],
                        c2b = colors[c2 + 2];
                    var c3r = colors[c3],
                        c3g = colors[c3 + 1],
                        c3b = colors[c3 + 2];
                    var minY = Math.round(y1),
                        maxY = Math.round(y3);
                    var xa, car, cag, cab;
                    var xb, cbr, cbg, cbb;
                    var k;
                    for (var y = minY; y <= maxY; y++) {
                        if (y < y2) {
                            k = y < y1 ? 0 : y1 === y2 ? 1 : (y1 - y) / (y1 - y2);
                            xa = x1 - (x1 - x2) * k;
                            car = c1r - (c1r - c2r) * k;
                            cag = c1g - (c1g - c2g) * k;
                            cab = c1b - (c1b - c2b) * k;
                        } else {
                            k = y > y3 ? 1 : y2 === y3 ? 0 : (y2 - y) / (y2 - y3);
                            xa = x2 - (x2 - x3) * k;
                            car = c2r - (c2r - c3r) * k;
                            cag = c2g - (c2g - c3g) * k;
                            cab = c2b - (c2b - c3b) * k;
                        }
                        k = y < y1 ? 0 : y > y3 ? 1 : (y1 - y) / (y1 - y3);
                        xb = x1 - (x1 - x3) * k;
                        cbr = c1r - (c1r - c3r) * k;
                        cbg = c1g - (c1g - c3g) * k;
                        cbb = c1b - (c1b - c3b) * k;
                        var x1_ = Math.round(Math.min(xa, xb));
                        var x2_ = Math.round(Math.max(xa, xb));
                        var j = rowSize * y + x1_ * 4;
                        for (var x = x1_; x <= x2_; x++) {
                            k = (xa - x) / (xa - xb);
                            k = k < 0 ? 0 : k > 1 ? 1 : k;
                            bytes[j++] = (car - (car - cbr) * k) | 0;
                            bytes[j++] = (cag - (cag - cbg) * k) | 0;
                            bytes[j++] = (cab - (cab - cbb) * k) | 0;
                            bytes[j++] = 255;
                        }
                    }
                }

                function drawFigure(data, figure, context) {
                    var ps = figure.coords;
                    var cs = figure.colors;
                    var i, ii;
                    switch (figure.type) {
                        case 'lattice':
                            var verticesPerRow = figure.verticesPerRow;
                            var rows = Math.floor(ps.length / verticesPerRow) - 1;
                            var cols = verticesPerRow - 1;
                            for (i = 0; i < rows; i++) {
                                var q = i * verticesPerRow;
                                for (var j = 0; j < cols; j++, q++) {
                                    drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
                                    drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
                                }
                            }
                            break;
                        case 'triangles':
                            for (i = 0, ii = ps.length; i < ii; i += 3) {
                                drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
                            }
                            break;
                        default:
                            error('illigal figure');
                            break;
                    }
                }

                function createMeshCanvas(bounds, combinesScale, coords, colors, figures, backgroundColor, cachedCanvases) {
                    var EXPECTED_SCALE = 1.1;
                    var MAX_PATTERN_SIZE = 3000;
                    var offsetX = Math.floor(bounds[0]);
                    var offsetY = Math.floor(bounds[1]);
                    var boundsWidth = Math.ceil(bounds[2]) - offsetX;
                    var boundsHeight = Math.ceil(bounds[3]) - offsetY;
                    var width = Math.min(Math.ceil(Math.abs(boundsWidth * combinesScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                    var height = Math.min(Math.ceil(Math.abs(boundsHeight * combinesScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                    var scaleX = boundsWidth / width;
                    var scaleY = boundsHeight / height;
                    var context = {
                        coords: coords,
                        colors: colors,
                        offsetX: -offsetX,
                        offsetY: -offsetY,
                        scaleX: 1 / scaleX,
                        scaleY: 1 / scaleY
                    };
                    var canvas, tmpCanvas, i, ii;
                    if (WebGLUtils.isEnabled) {
                        canvas = WebGLUtils.drawFigures(width, height, backgroundColor, figures, context);
                        tmpCanvas = cachedCanvases.getCanvas('mesh', width, height, false);
                        tmpCanvas.context.drawImage(canvas, 0, 0);
                        canvas = tmpCanvas.canvas;
                    } else {
                        tmpCanvas = cachedCanvases.getCanvas('mesh', width, height, false);
                        var tmpCtx = tmpCanvas.context;
                        var data = tmpCtx.createImageData(width, height);
                        if (backgroundColor) {
                            var bytes = data.data;
                            for (i = 0, ii = bytes.length; i < ii; i += 4) {
                                bytes[i] = backgroundColor[0];
                                bytes[i + 1] = backgroundColor[1];
                                bytes[i + 2] = backgroundColor[2];
                                bytes[i + 3] = 255;
                            }
                        }
                        for (i = 0; i < figures.length; i++) {
                            drawFigure(data, figures[i], context);
                        }
                        tmpCtx.putImageData(data, 0, 0);
                        canvas = tmpCanvas.canvas;
                    }
                    return {
                        canvas: canvas,
                        offsetX: offsetX,
                        offsetY: offsetY,
                        scaleX: scaleX,
                        scaleY: scaleY
                    };
                }
                return createMeshCanvas;
            })();
            ShadingIRs.Mesh = {
                fromIR: function Mesh_fromIR(raw) {
                    var coords = raw[2];
                    var colors = raw[3];
                    var figures = raw[4];
                    var bounds = raw[5];
                    var matrix = raw[6];
                    var background = raw[8];
                    return {
                        type: 'Pattern',
                        getPattern: function Mesh_getPattern(ctx, owner, shadingFill) {
                            var scale;
                            if (shadingFill) {
                                scale = Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);
                            } else {
                                scale = Util.singularValueDecompose2dScale(owner.baseTransform);
                                if (matrix) {
                                    var matrixScale = Util.singularValueDecompose2dScale(matrix);
                                    scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
                                }
                            }
                            var temporaryPatternCanvas = createMeshCanvas(bounds, scale, coords, colors, figures, shadingFill ? null : background, owner.cachedCanvases);
                            if (!shadingFill) {
                                ctx.setTransform.apply(ctx, owner.baseTransform);
                                if (matrix) {
                                    ctx.transform.apply(ctx, matrix);
                                }
                            }
                            ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
                            ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
                            return ctx.createPattern(temporaryPatternCanvas.canvas, 'no-repeat');
                        }
                    };
                }
            };
            ShadingIRs.Dummy = {
                fromIR: function Dummy_fromIR() {
                    return {
                        type: 'Pattern',
                        getPattern: function Dummy_fromIR_getPattern() {
                            return 'hotpink';
                        }
                    };
                }
            };

            function getShadingPatternFromIR(raw) {
                var shadingIR = ShadingIRs[raw[0]];
                if (!shadingIR) {
                    error('Unknown IR type: ' + raw[0]);
                }
                return shadingIR.fromIR(raw);
            }
            var TilingPattern = (function TilingPatternClosure() {
                var PaintType = {
                    COLORED: 1,
                    UNCOLORED: 2
                };
                var MAX_PATTERN_SIZE = 3000;

                function TilingPattern(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
                    this.operatorList = IR[2];
                    this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
                    this.bbox = IR[4];
                    this.xstep = IR[5];
                    this.ystep = IR[6];
                    this.paintType = IR[7];
                    this.tilingType = IR[8];
                    this.color = color;
                    this.canvasGraphicsFactory = canvasGraphicsFactory;
                    this.baseTransform = baseTransform;
                    this.type = 'Pattern';
                    this.ctx = ctx;
                }
                TilingPattern.prototype = {
                    createPatternCanvas: function TilinPattern_createPatternCanvas(owner) {
                        var operatorList = this.operatorList;
                        var bbox = this.bbox;
                        var xstep = this.xstep;
                        var ystep = this.ystep;
                        var paintType = this.paintType;
                        var tilingType = this.tilingType;
                        var color = this.color;
                        var canvasGraphicsFactory = this.canvasGraphicsFactory;
                        info('TilingType: ' + tilingType);
                        var x0 = bbox[0],
                            y0 = bbox[1],
                            x1 = bbox[2],
                            y1 = bbox[3];
                        var topLeft = [x0, y0];
                        var botRight = [x0 + xstep, y0 + ystep];
                        var width = botRight[0] - topLeft[0];
                        var height = botRight[1] - topLeft[1];
                        var matrixScale = Util.singularValueDecompose2dScale(this.matrix);
                        var curMatrixScale = Util.singularValueDecompose2dScale(this.baseTransform);
                        var combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
                        width = Math.min(Math.ceil(Math.abs(width * combinedScale[0])), MAX_PATTERN_SIZE);
                        height = Math.min(Math.ceil(Math.abs(height * combinedScale[1])), MAX_PATTERN_SIZE);
                        var tmpCanvas = owner.cachedCanvases.getCanvas('pattern', width, height, true);
                        var tmpCtx = tmpCanvas.context;
                        var graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
                        graphics.groupLevel = owner.groupLevel;
                        this.setFillAndStrokeStyleToContext(tmpCtx, paintType, color);
                        this.setScale(width, height, xstep, ystep);
                        this.transformToScale(graphics);
                        var tmpTranslate = [1, 0, 0, 1, -topLeft[0], -topLeft[1]];
                        graphics.transform.apply(graphics, tmpTranslate);
                        this.clipBbox(graphics, bbox, x0, y0, x1, y1);
                        graphics.executeOperatorList(operatorList);
                        return tmpCanvas.canvas;
                    },
                    setScale: function TilingPattern_setScale(width, height, xstep, ystep) {
                        this.scale = [width / xstep, height / ystep];
                    },
                    transformToScale: function TilingPattern_transformToScale(graphics) {
                        var scale = this.scale;
                        var tmpScale = [scale[0], 0, 0, scale[1], 0, 0];
                        graphics.transform.apply(graphics, tmpScale);
                    },
                    scaleToContext: function TilingPattern_scaleToContext() {
                        var scale = this.scale;
                        this.ctx.scale(1 / scale[0], 1 / scale[1]);
                    },
                    clipBbox: function clipBbox(graphics, bbox, x0, y0, x1, y1) {
                        if (bbox && isArray(bbox) && bbox.length === 4) {
                            var bboxWidth = x1 - x0;
                            var bboxHeight = y1 - y0;
                            graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
                            graphics.clip();
                            graphics.endPath();
                        }
                    },
                    setFillAndStrokeStyleToContext: function setFillAndStrokeStyleToContext(context, paintType, color) {
                        switch (paintType) {
                            case PaintType.COLORED:
                                var ctx = this.ctx;
                                context.fillStyle = ctx.fillStyle;
                                context.strokeStyle = ctx.strokeStyle;
                                break;
                            case PaintType.UNCOLORED:
                                var cssColor = Util.makeCssRgb(color[0], color[1], color[2]);
                                context.fillStyle = cssColor;
                                context.strokeStyle = cssColor;
                                break;
                            default:
                                error('Unsupported paint type: ' + paintType);
                        }
                    },
                    getPattern: function TilingPattern_getPattern(ctx, owner) {
                        var temporaryPatternCanvas = this.createPatternCanvas(owner);
                        ctx = this.ctx;
                        ctx.setTransform.apply(ctx, this.baseTransform);
                        ctx.transform.apply(ctx, this.matrix);
                        this.scaleToContext();
                        return ctx.createPattern(temporaryPatternCanvas, 'repeat');
                    }
                };
                return TilingPattern;
            })();
            exports.getShadingPatternFromIR = getShadingPatternFromIR;
            exports.TilingPattern = TilingPattern;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsDisplayCanvas = {}), root.pdfjsSharedUtil, root.pdfjsDisplayPatternHelper, root.pdfjsDisplayWebGL);
            }
        }(this, function(exports, sharedUtil, displayPatternHelper, displayWebGL) {
            var FONT_IDENTITY_MATRIX = sharedUtil.FONT_IDENTITY_MATRIX;
            var IDENTITY_MATRIX = sharedUtil.IDENTITY_MATRIX;
            var ImageKind = sharedUtil.ImageKind;
            var OPS = sharedUtil.OPS;
            var TextRenderingMode = sharedUtil.TextRenderingMode;
            var Uint32ArrayView = sharedUtil.Uint32ArrayView;
            var Util = sharedUtil.Util;
            var assert = sharedUtil.assert;
            var info = sharedUtil.info;
            var isNum = sharedUtil.isNum;
            var isArray = sharedUtil.isArray;
            var error = sharedUtil.error;
            var shadow = sharedUtil.shadow;
            var warn = sharedUtil.warn;
            var TilingPattern = displayPatternHelper.TilingPattern;
            var getShadingPatternFromIR = displayPatternHelper.getShadingPatternFromIR;
            var WebGLUtils = displayWebGL.WebGLUtils;
            var MIN_FONT_SIZE = 16;
            var MAX_FONT_SIZE = 100;
            var MAX_GROUP_SIZE = 4096;
            var MIN_WIDTH_FACTOR = 0.65;
            var COMPILE_TYPE3_GLYPHS = true;
            var MAX_SIZE_TO_COMPILE = 1000;
            var FULL_CHUNK_HEIGHT = 16;

            function createScratchCanvas(width, height) {
                var canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                return canvas;
            }

            function addContextCurrentTransform(ctx) {
                if (!ctx.mozCurrentTransform) {
                    ctx._originalSave = ctx.save;
                    ctx._originalRestore = ctx.restore;
                    ctx._originalRotate = ctx.rotate;
                    ctx._originalScale = ctx.scale;
                    ctx._originalTranslate = ctx.translate;
                    ctx._originalTransform = ctx.transform;
                    ctx._originalSetTransform = ctx.setTransform;
                    ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];
                    ctx._transformStack = [];
                    Object.defineProperty(ctx, 'mozCurrentTransform', {
                        get: function getCurrentTransform() {
                            return this._transformMatrix;
                        }
                    });
                    Object.defineProperty(ctx, 'mozCurrentTransformInverse', {
                        get: function getCurrentTransformInverse() {
                            var m = this._transformMatrix;
                            var a = m[0],
                                b = m[1],
                                c = m[2],
                                d = m[3],
                                e = m[4],
                                f = m[5];
                            var ad_bc = a * d - b * c;
                            var bc_ad = b * c - a * d;
                            return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];
                        }
                    });
                    ctx.save = function ctxSave() {
                        var old = this._transformMatrix;
                        this._transformStack.push(old);
                        this._transformMatrix = old.slice(0, 6);
                        this._originalSave();
                    };
                    ctx.restore = function ctxRestore() {
                        var prev = this._transformStack.pop();
                        if (prev) {
                            this._transformMatrix = prev;
                            this._originalRestore();
                        }
                    };
                    ctx.translate = function ctxTranslate(x, y) {
                        var m = this._transformMatrix;
                        m[4] = m[0] * x + m[2] * y + m[4];
                        m[5] = m[1] * x + m[3] * y + m[5];
                        this._originalTranslate(x, y);
                    };
                    ctx.scale = function ctxScale(x, y) {
                        var m = this._transformMatrix;
                        m[0] = m[0] * x;
                        m[1] = m[1] * x;
                        m[2] = m[2] * y;
                        m[3] = m[3] * y;
                        this._originalScale(x, y);
                    };
                    ctx.transform = function ctxTransform(a, b, c, d, e, f) {
                        var m = this._transformMatrix;
                        this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];
                        ctx._originalTransform(a, b, c, d, e, f);
                    };
                    ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
                        this._transformMatrix = [a, b, c, d, e, f];
                        ctx._originalSetTransform(a, b, c, d, e, f);
                    };
                    ctx.rotate = function ctxRotate(angle) {
                        var cosValue = Math.cos(angle);
                        var sinValue = Math.sin(angle);
                        var m = this._transformMatrix;
                        this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * (-sinValue) + m[2] * cosValue, m[1] * (-sinValue) + m[3] * cosValue, m[4], m[5]];
                        this._originalRotate(angle);
                    };
                }
            }
            var CachedCanvases = (function CachedCanvasesClosure() {
                function CachedCanvases() {
                    this.cache = Object.create(null);
                }
                CachedCanvases.prototype = {
                    getCanvas: function CachedCanvases_getCanvas(id, width, height, trackTransform) {
                        var canvasEntry;
                        if (this.cache[id] !== undefined) {
                            canvasEntry = this.cache[id];
                            canvasEntry.canvas.width = width;
                            canvasEntry.canvas.height = height;
                            canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);
                        } else {
                            var canvas = createScratchCanvas(width, height);
                            var ctx = canvas.getContext('2d');
                            if (trackTransform) {
                                addContextCurrentTransform(ctx);
                            }
                            this.cache[id] = canvasEntry = {
                                canvas: canvas,
                                context: ctx
                            };
                        }
                        return canvasEntry;
                    },
                    clear: function() {
                        for (var id in this.cache) {
                            var canvasEntry = this.cache[id];
                            canvasEntry.canvas.width = 0;
                            canvasEntry.canvas.height = 0;
                            delete this.cache[id];
                        }
                    }
                };
                return CachedCanvases;
            })();

            function compileType3Glyph(imgData) {
                var POINT_TO_PROCESS_LIMIT = 1000;
                var width = imgData.width,
                    height = imgData.height;
                var i, j, j0, width1 = width + 1;
                var points = new Uint8Array(width1 * (height + 1));
                var POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
                var lineSize = (width + 7) & ~7,
                    data0 = imgData.data;
                var data = new Uint8Array(lineSize * height),
                    pos = 0,
                    ii;
                for (i = 0, ii = data0.length; i < ii; i++) {
                    var mask = 128,
                        elem = data0[i];
                    while (mask > 0) {
                        data[pos++] = (elem & mask) ? 0 : 255;
                        mask >>= 1;
                    }
                }
                var count = 0;
                pos = 0;
                if (data[pos] !== 0) {
                    points[0] = 1;
                    ++count;
                }
                for (j = 1; j < width; j++) {
                    if (data[pos] !== data[pos + 1]) {
                        points[j] = data[pos] ? 2 : 1;
                        ++count;
                    }
                    pos++;
                }
                if (data[pos] !== 0) {
                    points[j] = 2;
                    ++count;
                }
                for (i = 1; i < height; i++) {
                    pos = i * lineSize;
                    j0 = i * width1;
                    if (data[pos - lineSize] !== data[pos]) {
                        points[j0] = data[pos] ? 1 : 8;
                        ++count;
                    }
                    var sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);
                    for (j = 1; j < width; j++) {
                        sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) +
                            (data[pos - lineSize + 1] ? 8 : 0);
                        if (POINT_TYPES[sum]) {
                            points[j0 + j] = POINT_TYPES[sum];
                            ++count;
                        }
                        pos++;
                    }
                    if (data[pos - lineSize] !== data[pos]) {
                        points[j0 + j] = data[pos] ? 2 : 4;
                        ++count;
                    }
                    if (count > POINT_TO_PROCESS_LIMIT) {
                        return null;
                    }
                }
                pos = lineSize * (height - 1);
                j0 = i * width1;
                if (data[pos] !== 0) {
                    points[j0] = 8;
                    ++count;
                }
                for (j = 1; j < width; j++) {
                    if (data[pos] !== data[pos + 1]) {
                        points[j0 + j] = data[pos] ? 4 : 8;
                        ++count;
                    }
                    pos++;
                }
                if (data[pos] !== 0) {
                    points[j0 + j] = 4;
                    ++count;
                }
                if (count > POINT_TO_PROCESS_LIMIT) {
                    return null;
                }
                var steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
                var outlines = [];
                for (i = 0; count && i <= height; i++) {
                    var p = i * width1;
                    var end = p + width;
                    while (p < end && !points[p]) {
                        p++;
                    }
                    if (p === end) {
                        continue;
                    }
                    var coords = [p % width1, i];
                    var type = points[p],
                        p0 = p,
                        pp;
                    do {
                        var step = steps[type];
                        do {
                            p += step;
                        } while (!points[p]);
                        pp = points[p];
                        if (pp !== 5 && pp !== 10) {
                            type = pp;
                            points[p] = 0;
                        } else {
                            type = pp & ((0x33 * type) >> 4);
                            points[p] &= (type >> 2 | type << 2);
                        }
                        coords.push(p % width1);
                        coords.push((p / width1) | 0);
                        --count;
                    } while (p0 !== p);
                    outlines.push(coords);
                    --i;
                }
                var drawOutline = function(c) {
                    c.save();
                    c.scale(1 / width, -1 / height);
                    c.translate(0, -height);
                    c.beginPath();
                    for (var i = 0, ii = outlines.length; i < ii; i++) {
                        var o = outlines[i];
                        c.moveTo(o[0], o[1]);
                        for (var j = 2, jj = o.length; j < jj; j += 2) {
                            c.lineTo(o[j], o[j + 1]);
                        }
                    }
                    c.fill();
                    c.beginPath();
                    c.restore();
                };
                return drawOutline;
            }
            var CanvasExtraState = (function CanvasExtraStateClosure() {
                function CanvasExtraState(old) {
                    this.alphaIsShape = false;
                    this.fontSize = 0;
                    this.fontSizeScale = 1;
                    this.textMatrix = IDENTITY_MATRIX;
                    this.textMatrixScale = 1;
                    this.fontMatrix = FONT_IDENTITY_MATRIX;
                    this.leading = 0;
                    this.x = 0;
                    this.y = 0;
                    this.lineX = 0;
                    this.lineY = 0;
                    this.charSpacing = 0;
                    this.wordSpacing = 0;
                    this.textHScale = 1;
                    this.textRenderingMode = TextRenderingMode.FILL;
                    this.textRise = 0;
                    this.fillColor = '#000000';
                    this.strokeColor = '#000000';
                    this.patternFill = false;
                    this.fillAlpha = 1;
                    this.strokeAlpha = 1;
                    this.lineWidth = 1;
                    this.activeSMask = null;
                    this.old = old;
                }
                CanvasExtraState.prototype = {
                    clone: function CanvasExtraState_clone() {
                        return Object.create(this);
                    },
                    setCurrentPoint: function CanvasExtraState_setCurrentPoint(x, y) {
                        this.x = x;
                        this.y = y;
                    }
                };
                return CanvasExtraState;
            })();
            var CanvasGraphics = (function CanvasGraphicsClosure() {
                var EXECUTION_TIME = 15;
                var EXECUTION_STEPS = 10;

                function CanvasGraphics(canvasCtx, commonObjs, objs, imageLayer) {
                    this.ctx = canvasCtx;
                    this.current = new CanvasExtraState();
                    this.stateStack = [];
                    this.pendingClip = null;
                    this.pendingEOFill = false;
                    this.res = null;
                    this.xobjs = null;
                    this.commonObjs = commonObjs;
                    this.objs = objs;
                    this.imageLayer = imageLayer;
                    this.groupStack = [];
                    this.processingType3 = null;
                    this.baseTransform = null;
                    this.baseTransformStack = [];
                    this.groupLevel = 0;
                    this.smaskStack = [];
                    this.smaskCounter = 0;
                    this.tempSMask = null;
                    this.cachedCanvases = new CachedCanvases();
                    if (canvasCtx) {
                        addContextCurrentTransform(canvasCtx);
                    }
                    this.cachedGetSinglePixelWidth = null;
                }

                function putBinaryImageData(ctx, imgData) {
                    if (typeof ImageData !== 'undefined' && imgData instanceof ImageData) {
                        ctx.putImageData(imgData, 0, 0);
                        return;
                    }
                    var height = imgData.height,
                        width = imgData.width;
                    var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
                    var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
                    var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
                    var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
                    var srcPos = 0,
                        destPos;
                    var src = imgData.data;
                    var dest = chunkImgData.data;
                    var i, j, thisChunkHeight, elemsInThisChunk;
                    if (imgData.kind === ImageKind.GRAYSCALE_1BPP) {
                        var srcLength = src.byteLength;
                        var dest32 = PDFJS.hasCanvasTypedArrays ? new Uint32Array(dest.buffer) : new Uint32ArrayView(dest);
                        var dest32DataLength = dest32.length;
                        var fullSrcDiff = (width + 7) >> 3;
                        var white = 0xFFFFFFFF;
                        var black = (PDFJS.isLittleEndian || !PDFJS.hasCanvasTypedArrays) ? 0xFF000000 : 0x000000FF;
                        for (i = 0; i < totalChunks; i++) {
                            thisChunkHeight = (i < fullChunks) ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                            destPos = 0;
                            for (j = 0; j < thisChunkHeight; j++) {
                                var srcDiff = srcLength - srcPos;
                                var k = 0;
                                var kEnd = (srcDiff > fullSrcDiff) ? width : srcDiff * 8 - 7;
                                var kEndUnrolled = kEnd & ~7;
                                var mask = 0;
                                var srcByte = 0;
                                for (; k < kEndUnrolled; k += 8) {
                                    srcByte = src[srcPos++];
                                    dest32[destPos++] = (srcByte & 128) ? white : black;
                                    dest32[destPos++] = (srcByte & 64) ? white : black;
                                    dest32[destPos++] = (srcByte & 32) ? white : black;
                                    dest32[destPos++] = (srcByte & 16) ? white : black;
                                    dest32[destPos++] = (srcByte & 8) ? white : black;
                                    dest32[destPos++] = (srcByte & 4) ? white : black;
                                    dest32[destPos++] = (srcByte & 2) ? white : black;
                                    dest32[destPos++] = (srcByte & 1) ? white : black;
                                }
                                for (; k < kEnd; k++) {
                                    if (mask === 0) {
                                        srcByte = src[srcPos++];
                                        mask = 128;
                                    }
                                    dest32[destPos++] = (srcByte & mask) ? white : black;
                                    mask >>= 1;
                                }
                            }
                            while (destPos < dest32DataLength) {
                                dest32[destPos++] = 0;
                            }
                            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                        }
                    } else if (imgData.kind === ImageKind.RGBA_32BPP) {
                        j = 0;
                        elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
                        for (i = 0; i < fullChunks; i++) {
                            dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
                            srcPos += elemsInThisChunk;
                            ctx.putImageData(chunkImgData, 0, j);
                            j += FULL_CHUNK_HEIGHT;
                        }
                        if (i < totalChunks) {
                            elemsInThisChunk = width * partialChunkHeight * 4;
                            dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
                            ctx.putImageData(chunkImgData, 0, j);
                        }
                    } else if (imgData.kind === ImageKind.RGB_24BPP) {
                        thisChunkHeight = FULL_CHUNK_HEIGHT;
                        elemsInThisChunk = width * thisChunkHeight;
                        for (i = 0; i < totalChunks; i++) {
                            if (i >= fullChunks) {
                                thisChunkHeight = partialChunkHeight;
                                elemsInThisChunk = width * thisChunkHeight;
                            }
                            destPos = 0;
                            for (j = elemsInThisChunk; j--;) {
                                dest[destPos++] = src[srcPos++];
                                dest[destPos++] = src[srcPos++];
                                dest[destPos++] = src[srcPos++];
                                dest[destPos++] = 255;
                            }
                            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                        }
                    } else {
                        error('bad image kind: ' + imgData.kind);
                    }
                }

                function putBinaryImageMask(ctx, imgData) {
                    var height = imgData.height,
                        width = imgData.width;
                    var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
                    var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
                    var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
                    var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
                    var srcPos = 0;
                    var src = imgData.data;
                    var dest = chunkImgData.data;
                    for (var i = 0; i < totalChunks; i++) {
                        var thisChunkHeight = (i < fullChunks) ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                        var destPos = 3;
                        for (var j = 0; j < thisChunkHeight; j++) {
                            var mask = 0;
                            for (var k = 0; k < width; k++) {
                                if (!mask) {
                                    var elem = src[srcPos++];
                                    mask = 128;
                                }
                                dest[destPos] = (elem & mask) ? 0 : 255;
                                destPos += 4;
                                mask >>= 1;
                            }
                        }
                        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                    }
                }

                function copyCtxState(sourceCtx, destCtx) {
                    var properties = ['strokeStyle', 'fillStyle', 'fillRule', 'globalAlpha', 'lineWidth', 'lineCap', 'lineJoin', 'miterLimit', 'globalCompositeOperation', 'font'];
                    for (var i = 0, ii = properties.length; i < ii; i++) {
                        var property = properties[i];
                        if (sourceCtx[property] !== undefined) {
                            destCtx[property] = sourceCtx[property];
                        }
                    }
                    if (sourceCtx.setLineDash !== undefined) {
                        destCtx.setLineDash(sourceCtx.getLineDash());
                        destCtx.lineDashOffset = sourceCtx.lineDashOffset;
                    } else if (sourceCtx.mozDashOffset !== undefined) {
                        destCtx.mozDash = sourceCtx.mozDash;
                        destCtx.mozDashOffset = sourceCtx.mozDashOffset;
                    }
                }

                function composeSMaskBackdrop(bytes, r0, g0, b0) {
                    var length = bytes.length;
                    for (var i = 3; i < length; i += 4) {
                        var alpha = bytes[i];
                        if (alpha === 0) {
                            bytes[i - 3] = r0;
                            bytes[i - 2] = g0;
                            bytes[i - 1] = b0;
                        } else if (alpha < 255) {
                            var alpha_ = 255 - alpha;
                            bytes[i - 3] = (bytes[i - 3] * alpha + r0 * alpha_) >> 8;
                            bytes[i - 2] = (bytes[i - 2] * alpha + g0 * alpha_) >> 8;
                            bytes[i - 1] = (bytes[i - 1] * alpha + b0 * alpha_) >> 8;
                        }
                    }
                }

                function composeSMaskAlpha(maskData, layerData, transferMap) {
                    var length = maskData.length;
                    var scale = 1 / 255;
                    for (var i = 3; i < length; i += 4) {
                        var alpha = transferMap ? transferMap[maskData[i]] : maskData[i];
                        layerData[i] = (layerData[i] * alpha * scale) | 0;
                    }
                }

                function composeSMaskLuminosity(maskData, layerData, transferMap) {
                    var length = maskData.length;
                    for (var i = 3; i < length; i += 4) {
                        var y = (maskData[i - 3] * 77) +
                            (maskData[i - 2] * 152) +
                            (maskData[i - 1] * 28);
                        layerData[i] = transferMap ? (layerData[i] * transferMap[y >> 8]) >> 8 : (layerData[i] * y) >> 16;
                    }
                }

                function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap) {
                    var hasBackdrop = !!backdrop;
                    var r0 = hasBackdrop ? backdrop[0] : 0;
                    var g0 = hasBackdrop ? backdrop[1] : 0;
                    var b0 = hasBackdrop ? backdrop[2] : 0;
                    var composeFn;
                    if (subtype === 'Luminosity') {
                        composeFn = composeSMaskLuminosity;
                    } else {
                        composeFn = composeSMaskAlpha;
                    }
                    var PIXELS_TO_PROCESS = 1048576;
                    var chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));
                    for (var row = 0; row < height; row += chunkSize) {
                        var chunkHeight = Math.min(chunkSize, height - row);
                        var maskData = maskCtx.getImageData(0, row, width, chunkHeight);
                        var layerData = layerCtx.getImageData(0, row, width, chunkHeight);
                        if (hasBackdrop) {
                            composeSMaskBackdrop(maskData.data, r0, g0, b0);
                        }
                        composeFn(maskData.data, layerData.data, transferMap);
                        maskCtx.putImageData(layerData, 0, row);
                    }
                }

                function composeSMask(ctx, smask, layerCtx) {
                    var mask = smask.canvas;
                    var maskCtx = smask.context;
                    ctx.setTransform(smask.scaleX, 0, 0, smask.scaleY, smask.offsetX, smask.offsetY);
                    var backdrop = smask.backdrop || null;
                    if (!smask.transferMap && WebGLUtils.isEnabled) {
                        var composed = WebGLUtils.composeSMask(layerCtx.canvas, mask, {
                            subtype: smask.subtype,
                            backdrop: backdrop
                        });
                        ctx.setTransform(1, 0, 0, 1, 0, 0);
                        ctx.drawImage(composed, smask.offsetX, smask.offsetY);
                        return;
                    }
                    genericComposeSMask(maskCtx, layerCtx, mask.width, mask.height, smask.subtype, backdrop, smask.transferMap);
                    ctx.drawImage(mask, 0, 0);
                }
                var LINE_CAP_STYLES = ['butt', 'round', 'square'];
                var LINE_JOIN_STYLES = ['miter', 'round', 'bevel'];
                var NORMAL_CLIP = {};
                var EO_CLIP = {};
                CanvasGraphics.prototype = {
                    beginDrawing: function CanvasGraphics_beginDrawing(transform, viewport, transparency) {
                        var width = this.ctx.canvas.width;
                        var height = this.ctx.canvas.height;
                        this.ctx.save();
                        this.ctx.fillStyle = 'rgb(255, 255, 255)';
                        this.ctx.fillRect(0, 0, width, height);
                        this.ctx.restore();
                        if (transparency) {
                            var transparentCanvas = this.cachedCanvases.getCanvas('transparent', width, height, true);
                            this.compositeCtx = this.ctx;
                            this.transparentCanvas = transparentCanvas.canvas;
                            this.ctx = transparentCanvas.context;
                            this.ctx.save();
                            this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);
                        }
                        this.ctx.save();
                        if (transform) {
                            this.ctx.transform.apply(this.ctx, transform);
                        }
                        this.ctx.transform.apply(this.ctx, viewport.transform);
                        this.baseTransform = this.ctx.mozCurrentTransform.slice();
                        if (this.imageLayer) {
                            this.imageLayer.beginLayout();
                        }
                    },
                    executeOperatorList: function CanvasGraphics_executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
                        var argsArray = operatorList.argsArray;
                        var fnArray = operatorList.fnArray;
                        var i = executionStartIdx || 0;
                        var argsArrayLen = argsArray.length;
                        if (argsArrayLen === i) {
                            return i;
                        }
                        var chunkOperations = (argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === 'function');
                        var endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
                        var steps = 0;
                        var commonObjs = this.commonObjs;
                        var objs = this.objs;
                        var fnId;
                        while (true) {
                            if (stepper !== undefined && i === stepper.nextBreakPoint) {
                                stepper.breakIt(i, continueCallback);
                                return i;
                            }
                            fnId = fnArray[i];
                            if (fnId !== OPS.dependency) {
                                this[fnId].apply(this, argsArray[i]);
                            } else {
                                var deps = argsArray[i];
                                for (var n = 0, nn = deps.length; n < nn; n++) {
                                    var depObjId = deps[n];
                                    var common = depObjId[0] === 'g' && depObjId[1] === '_';
                                    var objsPool = common ? commonObjs : objs;
                                    if (!objsPool.isResolved(depObjId)) {
                                        objsPool.get(depObjId, continueCallback);
                                        return i;
                                    }
                                }
                            }
                            i++;
                            if (i === argsArrayLen) {
                                return i;
                            }
                            if (chunkOperations && ++steps > EXECUTION_STEPS) {
                                if (Date.now() > endTime) {
                                    continueCallback();
                                    return i;
                                }
                                steps = 0;
                            }
                        }
                    },
                    endDrawing: function CanvasGraphics_endDrawing() {
                        this.ctx.restore();
                        if (this.transparentCanvas) {
                            this.ctx = this.compositeCtx;
                            this.ctx.drawImage(this.transparentCanvas, 0, 0);
                            this.transparentCanvas = null;
                        }
                        this.cachedCanvases.clear();
                        WebGLUtils.clear();
                        if (this.imageLayer) {
                            this.imageLayer.endLayout();
                        }
                    },
                    setLineWidth: function CanvasGraphics_setLineWidth(width) {
                        this.current.lineWidth = width;
                        this.ctx.lineWidth = width;
                    },
                    setLineCap: function CanvasGraphics_setLineCap(style) {
                        this.ctx.lineCap = LINE_CAP_STYLES[style];
                    },
                    setLineJoin: function CanvasGraphics_setLineJoin(style) {
                        this.ctx.lineJoin = LINE_JOIN_STYLES[style];
                    },
                    setMiterLimit: function CanvasGraphics_setMiterLimit(limit) {
                        this.ctx.miterLimit = limit;
                    },
                    setDash: function CanvasGraphics_setDash(dashArray, dashPhase) {
                        var ctx = this.ctx;
                        if (ctx.setLineDash !== undefined) {
                            ctx.setLineDash(dashArray);
                            ctx.lineDashOffset = dashPhase;
                        } else {
                            ctx.mozDash = dashArray;
                            ctx.mozDashOffset = dashPhase;
                        }
                    },
                    setRenderingIntent: function CanvasGraphics_setRenderingIntent(intent) {},
                    setFlatness: function CanvasGraphics_setFlatness(flatness) {},
                    setGState: function CanvasGraphics_setGState(states) {
                        for (var i = 0, ii = states.length; i < ii; i++) {
                            var state = states[i];
                            var key = state[0];
                            var value = state[1];
                            switch (key) {
                                case 'LW':
                                    this.setLineWidth(value);
                                    break;
                                case 'LC':
                                    this.setLineCap(value);
                                    break;
                                case 'LJ':
                                    this.setLineJoin(value);
                                    break;
                                case 'ML':
                                    this.setMiterLimit(value);
                                    break;
                                case 'D':
                                    this.setDash(value[0], value[1]);
                                    break;
                                case 'RI':
                                    this.setRenderingIntent(value);
                                    break;
                                case 'FL':
                                    this.setFlatness(value);
                                    break;
                                case 'Font':
                                    this.setFont(value[0], value[1]);
                                    break;
                                case 'CA':
                                    this.current.strokeAlpha = state[1];
                                    break;
                                case 'ca':
                                    this.current.fillAlpha = state[1];
                                    this.ctx.globalAlpha = state[1];
                                    break;
                                case 'BM':
                                    if (value && value.name && (value.name !== 'Normal')) {
                                        var mode = value.name.replace(/([A-Z])/g, function(c) {
                                            return '-' + c.toLowerCase();
                                        }).substring(1);
                                        this.ctx.globalCompositeOperation = mode;
                                        if (this.ctx.globalCompositeOperation !== mode) {
                                            warn('globalCompositeOperation "' + mode + '" is not supported');
                                        }
                                    } else {
                                        this.ctx.globalCompositeOperation = 'source-over';
                                    }
                                    break;
                                case 'SMask':
                                    if (this.current.activeSMask) {
                                        this.endSMaskGroup();
                                    }
                                    this.current.activeSMask = value ? this.tempSMask : null;
                                    if (this.current.activeSMask) {
                                        this.beginSMaskGroup();
                                    }
                                    this.tempSMask = null;
                                    break;
                            }
                        }
                    },
                    beginSMaskGroup: function CanvasGraphics_beginSMaskGroup() {
                        var activeSMask = this.current.activeSMask;
                        var drawnWidth = activeSMask.canvas.width;
                        var drawnHeight = activeSMask.canvas.height;
                        var cacheId = 'smaskGroupAt' + this.groupLevel;
                        var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
                        var currentCtx = this.ctx;
                        var currentTransform = currentCtx.mozCurrentTransform;
                        this.ctx.save();
                        var groupCtx = scratchCanvas.context;
                        groupCtx.scale(1 / activeSMask.scaleX, 1 / activeSMask.scaleY);
                        groupCtx.translate(-activeSMask.offsetX, -activeSMask.offsetY);
                        groupCtx.transform.apply(groupCtx, currentTransform);
                        copyCtxState(currentCtx, groupCtx);
                        this.ctx = groupCtx;
                        this.setGState([
                            ['BM', 'Normal'],
                            ['ca', 1],
                            ['CA', 1]
                        ]);
                        this.groupStack.push(currentCtx);
                        this.groupLevel++;
                    },
                    endSMaskGroup: function CanvasGraphics_endSMaskGroup() {
                        var groupCtx = this.ctx;
                        this.groupLevel--;
                        this.ctx = this.groupStack.pop();
                        composeSMask(this.ctx, this.current.activeSMask, groupCtx);
                        this.ctx.restore();
                        copyCtxState(groupCtx, this.ctx);
                    },
                    save: function CanvasGraphics_save() {
                        this.ctx.save();
                        var old = this.current;
                        this.stateStack.push(old);
                        this.current = old.clone();
                        this.current.activeSMask = null;
                    },
                    restore: function CanvasGraphics_restore() {
                        if (this.stateStack.length !== 0) {
                            if (this.current.activeSMask !== null) {
                                this.endSMaskGroup();
                            }
                            this.current = this.stateStack.pop();
                            this.ctx.restore();
                            this.pendingClip = null;
                            this.cachedGetSinglePixelWidth = null;
                        }
                    },
                    transform: function CanvasGraphics_transform(a, b, c, d, e, f) {
                        this.ctx.transform(a, b, c, d, e, f);
                        this.cachedGetSinglePixelWidth = null;
                    },
                    constructPath: function CanvasGraphics_constructPath(ops, args) {
                        var ctx = this.ctx;
                        var current = this.current;
                        var x = current.x,
                            y = current.y;
                        for (var i = 0, j = 0, ii = ops.length; i < ii; i++) {
                            switch (ops[i] | 0) {
                                case OPS.rectangle:
                                    x = args[j++];
                                    y = args[j++];
                                    var width = args[j++];
                                    var height = args[j++];
                                    if (width === 0) {
                                        width = this.getSinglePixelWidth();
                                    }
                                    if (height === 0) {
                                        height = this.getSinglePixelWidth();
                                    }
                                    var xw = x + width;
                                    var yh = y + height;
                                    this.ctx.moveTo(x, y);
                                    this.ctx.lineTo(xw, y);
                                    this.ctx.lineTo(xw, yh);
                                    this.ctx.lineTo(x, yh);
                                    this.ctx.lineTo(x, y);
                                    this.ctx.closePath();
                                    break;
                                case OPS.moveTo:
                                    x = args[j++];
                                    y = args[j++];
                                    ctx.moveTo(x, y);
                                    break;
                                case OPS.lineTo:
                                    x = args[j++];
                                    y = args[j++];
                                    ctx.lineTo(x, y);
                                    break;
                                case OPS.curveTo:
                                    x = args[j + 4];
                                    y = args[j + 5];
                                    ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
                                    j += 6;
                                    break;
                                case OPS.curveTo2:
                                    ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
                                    x = args[j + 2];
                                    y = args[j + 3];
                                    j += 4;
                                    break;
                                case OPS.curveTo3:
                                    x = args[j + 2];
                                    y = args[j + 3];
                                    ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
                                    j += 4;
                                    break;
                                case OPS.closePath:
                                    ctx.closePath();
                                    break;
                            }
                        }
                        current.setCurrentPoint(x, y);
                    },
                    closePath: function CanvasGraphics_closePath() {
                        this.ctx.closePath();
                    },
                    stroke: function CanvasGraphics_stroke(consumePath) {
                        consumePath = typeof consumePath !== 'undefined' ? consumePath : true;
                        var ctx = this.ctx;
                        var strokeColor = this.current.strokeColor;
                        ctx.lineWidth = Math.max(this.getSinglePixelWidth() * MIN_WIDTH_FACTOR, this.current.lineWidth);
                        ctx.globalAlpha = this.current.strokeAlpha;
                        if (strokeColor && strokeColor.hasOwnProperty('type') && strokeColor.type === 'Pattern') {
                            ctx.save();
                            ctx.strokeStyle = strokeColor.getPattern(ctx, this);
                            ctx.stroke();
                            ctx.restore();
                        } else {
                            ctx.stroke();
                        }
                        if (consumePath) {
                            this.consumePath();
                        }
                        ctx.globalAlpha = this.current.fillAlpha;
                    },
                    closeStroke: function CanvasGraphics_closeStroke() {
                        this.closePath();
                        this.stroke();
                    },
                    fill: function CanvasGraphics_fill(consumePath) {
                        consumePath = typeof consumePath !== 'undefined' ? consumePath : true;
                        var ctx = this.ctx;
                        var fillColor = this.current.fillColor;
                        var isPatternFill = this.current.patternFill;
                        var needRestore = false;
                        if (isPatternFill) {
                            ctx.save();
                            if (this.baseTransform) {
                                ctx.setTransform.apply(ctx, this.baseTransform);
                            }
                            ctx.fillStyle = fillColor.getPattern(ctx, this);
                            needRestore = true;
                        }
                        if (this.pendingEOFill) {
                            if (ctx.mozFillRule !== undefined) {
                                ctx.mozFillRule = 'evenodd';
                                ctx.fill();
                                ctx.mozFillRule = 'nonzero';
                            } else {
                                ctx.fill('evenodd');
                            }
                            this.pendingEOFill = false;
                        } else {
                            ctx.fill();
                        }
                        if (needRestore) {
                            ctx.restore();
                        }
                        if (consumePath) {
                            this.consumePath();
                        }
                    },
                    eoFill: function CanvasGraphics_eoFill() {
                        this.pendingEOFill = true;
                        this.fill();
                    },
                    fillStroke: function CanvasGraphics_fillStroke() {
                        this.fill(false);
                        this.stroke(false);
                        this.consumePath();
                    },
                    eoFillStroke: function CanvasGraphics_eoFillStroke() {
                        this.pendingEOFill = true;
                        this.fillStroke();
                    },
                    closeFillStroke: function CanvasGraphics_closeFillStroke() {
                        this.closePath();
                        this.fillStroke();
                    },
                    closeEOFillStroke: function CanvasGraphics_closeEOFillStroke() {
                        this.pendingEOFill = true;
                        this.closePath();
                        this.fillStroke();
                    },
                    endPath: function CanvasGraphics_endPath() {
                        this.consumePath();
                    },
                    clip: function CanvasGraphics_clip() {
                        this.pendingClip = NORMAL_CLIP;
                    },
                    eoClip: function CanvasGraphics_eoClip() {
                        this.pendingClip = EO_CLIP;
                    },
                    beginText: function CanvasGraphics_beginText() {
                        this.current.textMatrix = IDENTITY_MATRIX;
                        this.current.textMatrixScale = 1;
                        this.current.x = this.current.lineX = 0;
                        this.current.y = this.current.lineY = 0;
                    },
                    endText: function CanvasGraphics_endText() {
                        var paths = this.pendingTextPaths;
                        var ctx = this.ctx;
                        if (paths === undefined) {
                            ctx.beginPath();
                            return;
                        }
                        ctx.save();
                        ctx.beginPath();
                        for (var i = 0; i < paths.length; i++) {
                            var path = paths[i];
                            ctx.setTransform.apply(ctx, path.transform);
                            ctx.translate(path.x, path.y);
                            path.addToPath(ctx, path.fontSize);
                        }
                        ctx.restore();
                        ctx.clip();
                        ctx.beginPath();
                        delete this.pendingTextPaths;
                    },
                    setCharSpacing: function CanvasGraphics_setCharSpacing(spacing) {
                        this.current.charSpacing = spacing;
                    },
                    setWordSpacing: function CanvasGraphics_setWordSpacing(spacing) {
                        this.current.wordSpacing = spacing;
                    },
                    setHScale: function CanvasGraphics_setHScale(scale) {
                        this.current.textHScale = scale / 100;
                    },
                    setLeading: function CanvasGraphics_setLeading(leading) {
                        this.current.leading = -leading;
                    },
                    setFont: function CanvasGraphics_setFont(fontRefName, size) {
                        var fontObj = this.commonObjs.get(fontRefName);
                        var current = this.current;
                        if (!fontObj) {
                            error('Can\'t find font for ' + fontRefName);
                        }
                        current.fontMatrix = (fontObj.fontMatrix ? fontObj.fontMatrix : FONT_IDENTITY_MATRIX);
                        if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
                            warn('Invalid font matrix for font ' + fontRefName);
                        }
                        if (size < 0) {
                            size = -size;
                            current.fontDirection = -1;
                        } else {
                            current.fontDirection = 1;
                        }
                        this.current.font = fontObj;
                        this.current.fontSize = size;
                        if (fontObj.isType3Font) {
                            return;
                        }
                        var name = fontObj.loadedName || 'sans-serif';
                        var bold = fontObj.black ? (fontObj.bold ? '900' : 'bold') : (fontObj.bold ? 'bold' : 'normal');
                        var italic = fontObj.italic ? 'italic' : 'normal';
                        var typeface = '"' + name + '", ' + fontObj.fallbackName;
                        var browserFontSize = size < MIN_FONT_SIZE ? MIN_FONT_SIZE : size > MAX_FONT_SIZE ? MAX_FONT_SIZE : size;
                        this.current.fontSizeScale = size / browserFontSize;
                        var rule = italic + ' ' + bold + ' ' + browserFontSize + 'px ' + typeface;
                        this.ctx.font = rule;
                    },
                    setTextRenderingMode: function CanvasGraphics_setTextRenderingMode(mode) {
                        this.current.textRenderingMode = mode;
                    },
                    setTextRise: function CanvasGraphics_setTextRise(rise) {
                        this.current.textRise = rise;
                    },
                    moveText: function CanvasGraphics_moveText(x, y) {
                        this.current.x = this.current.lineX += x;
                        this.current.y = this.current.lineY += y;
                    },
                    setLeadingMoveText: function CanvasGraphics_setLeadingMoveText(x, y) {
                        this.setLeading(-y);
                        this.moveText(x, y);
                    },
                    setTextMatrix: function CanvasGraphics_setTextMatrix(a, b, c, d, e, f) {
                        this.current.textMatrix = [a, b, c, d, e, f];
                        this.current.textMatrixScale = Math.sqrt(a * a + b * b);
                        this.current.x = this.current.lineX = 0;
                        this.current.y = this.current.lineY = 0;
                    },
                    nextLine: function CanvasGraphics_nextLine() {
                        this.moveText(0, this.current.leading);
                    },
                    paintChar: function CanvasGraphics_paintChar(character, x, y) {
                        var ctx = this.ctx;
                        var current = this.current;
                        var font = current.font;
                        var textRenderingMode = current.textRenderingMode;
                        var fontSize = current.fontSize / current.fontSizeScale;
                        var fillStrokeMode = textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
                        var isAddToPathSet = !!(textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG);
                        var addToPath;
                        if (font.disableFontFace || isAddToPathSet) {
                            addToPath = font.getPathGenerator(this.commonObjs, character);
                        }
                        if (font.disableFontFace) {
                            ctx.save();
                            ctx.translate(x, y);
                            ctx.beginPath();
                            addToPath(ctx, fontSize);
                            if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
                                ctx.fill();
                            }
                            if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
                                ctx.stroke();
                            }
                            ctx.restore();
                        } else {
                            if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
                                ctx.fillText(character, x, y);
                            }
                            if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
                                ctx.strokeText(character, x, y);
                            }
                        }
                        if (isAddToPathSet) {
                            var paths = this.pendingTextPaths || (this.pendingTextPaths = []);
                            paths.push({
                                transform: ctx.mozCurrentTransform,
                                x: x,
                                y: y,
                                fontSize: fontSize,
                                addToPath: addToPath
                            });
                        }
                    },
                    get isFontSubpixelAAEnabled() {
                        var ctx = document.createElement('canvas').getContext('2d');
                        ctx.scale(1.5, 1);
                        ctx.fillText('I', 0, 10);
                        var data = ctx.getImageData(0, 0, 10, 10).data;
                        var enabled = false;
                        for (var i = 3; i < data.length; i += 4) {
                            if (data[i] > 0 && data[i] < 255) {
                                enabled = true;
                                break;
                            }
                        }
                        return shadow(this, 'isFontSubpixelAAEnabled', enabled);
                    },
                    showText: function CanvasGraphics_showText(glyphs) {
                        var current = this.current;
                        var font = current.font;
                        if (font.isType3Font) {
                            return this.showType3Text(glyphs);
                        }
                        var fontSize = current.fontSize;
                        if (fontSize === 0) {
                            return;
                        }
                        var ctx = this.ctx;
                        var fontSizeScale = current.fontSizeScale;
                        var charSpacing = current.charSpacing;
                        var wordSpacing = current.wordSpacing;
                        var fontDirection = current.fontDirection;
                        var textHScale = current.textHScale * fontDirection;
                        var glyphsLength = glyphs.length;
                        var vertical = font.vertical;
                        var spacingDir = vertical ? 1 : -1;
                        var defaultVMetrics = font.defaultVMetrics;
                        var widthAdvanceScale = fontSize * current.fontMatrix[0];
                        var simpleFillText = current.textRenderingMode === TextRenderingMode.FILL && !font.disableFontFace;
                        ctx.save();
                        ctx.transform.apply(ctx, current.textMatrix);
                        ctx.translate(current.x, current.y + current.textRise);
                        if (current.patternFill) {
                            ctx.fillStyle = current.fillColor.getPattern(ctx, this);
                        }
                        if (fontDirection > 0) {
                            ctx.scale(textHScale, -1);
                        } else {
                            ctx.scale(textHScale, 1);
                        }
                        var lineWidth = current.lineWidth;
                        var scale = current.textMatrixScale;
                        if (scale === 0 || lineWidth === 0) {
                            var fillStrokeMode = current.textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
                            if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
                                this.cachedGetSinglePixelWidth = null;
                                lineWidth = this.getSinglePixelWidth() * MIN_WIDTH_FACTOR;
                            }
                        } else {
                            lineWidth /= scale;
                        }
                        if (fontSizeScale !== 1.0) {
                            ctx.scale(fontSizeScale, fontSizeScale);
                            lineWidth /= fontSizeScale;
                        }
                        ctx.lineWidth = lineWidth;
                        var x = 0,
                            i;
                        for (i = 0; i < glyphsLength; ++i) {
                            var glyph = glyphs[i];
                            if (isNum(glyph)) {
                                x += spacingDir * glyph * fontSize / 1000;
                                continue;
                            }
                            var restoreNeeded = false;
                            var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                            var character = glyph.fontChar;
                            var accent = glyph.accent;
                            var scaledX, scaledY, scaledAccentX, scaledAccentY;
                            var width = glyph.width;
                            if (vertical) {
                                var vmetric, vx, vy;
                                vmetric = glyph.vmetric || defaultVMetrics;
                                vx = glyph.vmetric ? vmetric[1] : width * 0.5;
                                vx = -vx * widthAdvanceScale;
                                vy = vmetric[2] * widthAdvanceScale;
                                width = vmetric ? -vmetric[0] : width;
                                scaledX = vx / fontSizeScale;
                                scaledY = (x + vy) / fontSizeScale;
                            } else {
                                scaledX = x / fontSizeScale;
                                scaledY = 0;
                            }
                            if (font.remeasure && width > 0) {
                                var measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;
                                if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
                                    var characterScaleX = width / measuredWidth;
                                    restoreNeeded = true;
                                    ctx.save();
                                    ctx.scale(characterScaleX, 1);
                                    scaledX /= characterScaleX;
                                } else if (width !== measuredWidth) {
                                    scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;
                                }
                            }
                            if (simpleFillText && !accent) {
                                ctx.fillText(character, scaledX, scaledY);
                            } else {
                                this.paintChar(character, scaledX, scaledY);
                                if (accent) {
                                    scaledAccentX = scaledX + accent.offset.x / fontSizeScale;
                                    scaledAccentY = scaledY - accent.offset.y / fontSizeScale;
                                    this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY);
                                }
                            }
                            var charWidth = width * widthAdvanceScale + spacing * fontDirection;
                            x += charWidth;
                            if (restoreNeeded) {
                                ctx.restore();
                            }
                        }
                        if (vertical) {
                            current.y -= x * textHScale;
                        } else {
                            current.x += x * textHScale;
                        }
                        ctx.restore();
                    },
                    showType3Text: function CanvasGraphics_showType3Text(glyphs) {
                        var ctx = this.ctx;
                        var current = this.current;
                        var font = current.font;
                        var fontSize = current.fontSize;
                        var fontDirection = current.fontDirection;
                        var spacingDir = font.vertical ? 1 : -1;
                        var charSpacing = current.charSpacing;
                        var wordSpacing = current.wordSpacing;
                        var textHScale = current.textHScale * fontDirection;
                        var fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;
                        var glyphsLength = glyphs.length;
                        var isTextInvisible = current.textRenderingMode === TextRenderingMode.INVISIBLE;
                        var i, glyph, width, spacingLength;
                        if (isTextInvisible || fontSize === 0) {
                            return;
                        }
                        this.cachedGetSinglePixelWidth = null;
                        ctx.save();
                        ctx.transform.apply(ctx, current.textMatrix);
                        ctx.translate(current.x, current.y);
                        ctx.scale(textHScale, fontDirection);
                        for (i = 0; i < glyphsLength; ++i) {
                            glyph = glyphs[i];
                            if (isNum(glyph)) {
                                spacingLength = spacingDir * glyph * fontSize / 1000;
                                this.ctx.translate(spacingLength, 0);
                                current.x += spacingLength * textHScale;
                                continue;
                            }
                            var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                            var operatorList = font.charProcOperatorList[glyph.operatorListId];
                            if (!operatorList) {
                                warn('Type3 character \"' + glyph.operatorListId + '\" is not available');
                                continue;
                            }
                            this.processingType3 = glyph;
                            this.save();
                            ctx.scale(fontSize, fontSize);
                            ctx.transform.apply(ctx, fontMatrix);
                            this.executeOperatorList(operatorList);
                            this.restore();
                            var transformed = Util.applyTransform([glyph.width, 0], fontMatrix);
                            width = transformed[0] * fontSize + spacing;
                            ctx.translate(width, 0);
                            current.x += width * textHScale;
                        }
                        ctx.restore();
                        this.processingType3 = null;
                    },
                    setCharWidth: function CanvasGraphics_setCharWidth(xWidth, yWidth) {},
                    setCharWidthAndBounds: function CanvasGraphics_setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
                        this.ctx.rect(llx, lly, urx - llx, ury - lly);
                        this.clip();
                        this.endPath();
                    },
                    getColorN_Pattern: function CanvasGraphics_getColorN_Pattern(IR) {
                        var pattern;
                        if (IR[0] === 'TilingPattern') {
                            var color = IR[1];
                            var baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice();
                            var self = this;
                            var canvasGraphicsFactory = {
                                createCanvasGraphics: function(ctx) {
                                    return new CanvasGraphics(ctx, self.commonObjs, self.objs);
                                }
                            };
                            pattern = new TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
                        } else {
                            pattern = getShadingPatternFromIR(IR);
                        }
                        return pattern;
                    },
                    setStrokeColorN: function CanvasGraphics_setStrokeColorN() {
                        this.current.strokeColor = this.getColorN_Pattern(arguments);
                    },
                    setFillColorN: function CanvasGraphics_setFillColorN() {
                        this.current.fillColor = this.getColorN_Pattern(arguments);
                        this.current.patternFill = true;
                    },
                    setStrokeRGBColor: function CanvasGraphics_setStrokeRGBColor(r, g, b) {
                        var color = Util.makeCssRgb(r, g, b);
                        this.ctx.strokeStyle = color;
                        this.current.strokeColor = color;
                    },
                    setFillRGBColor: function CanvasGraphics_setFillRGBColor(r, g, b) {
                        var color = Util.makeCssRgb(r, g, b);
                        this.ctx.fillStyle = color;
                        this.current.fillColor = color;
                        this.current.patternFill = false;
                    },
                    shadingFill: function CanvasGraphics_shadingFill(patternIR) {
                        var ctx = this.ctx;
                        this.save();
                        var pattern = getShadingPatternFromIR(patternIR);
                        ctx.fillStyle = pattern.getPattern(ctx, this, true);
                        var inv = ctx.mozCurrentTransformInverse;
                        if (inv) {
                            var canvas = ctx.canvas;
                            var width = canvas.width;
                            var height = canvas.height;
                            var bl = Util.applyTransform([0, 0], inv);
                            var br = Util.applyTransform([0, height], inv);
                            var ul = Util.applyTransform([width, 0], inv);
                            var ur = Util.applyTransform([width, height], inv);
                            var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
                            var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
                            var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
                            var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
                            this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
                        } else {
                            this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
                        }
                        this.restore();
                    },
                    beginInlineImage: function CanvasGraphics_beginInlineImage() {
                        error('Should not call beginInlineImage');
                    },
                    beginImageData: function CanvasGraphics_beginImageData() {
                        error('Should not call beginImageData');
                    },
                    paintFormXObjectBegin: function CanvasGraphics_paintFormXObjectBegin(matrix, bbox) {
                        this.save();
                        this.baseTransformStack.push(this.baseTransform);
                        if (isArray(matrix) && 6 === matrix.length) {
                            this.transform.apply(this, matrix);
                        }
                        this.baseTransform = this.ctx.mozCurrentTransform;
                        if (isArray(bbox) && 4 === bbox.length) {
                            var width = bbox[2] - bbox[0];
                            var height = bbox[3] - bbox[1];
                            this.ctx.rect(bbox[0], bbox[1], width, height);
                            this.clip();
                            this.endPath();
                        }
                    },
                    paintFormXObjectEnd: function CanvasGraphics_paintFormXObjectEnd() {
                        this.restore();
                        this.baseTransform = this.baseTransformStack.pop();
                    },
                    beginGroup: function CanvasGraphics_beginGroup(group) {
                        this.save();
                        var currentCtx = this.ctx;
                        if (!group.isolated) {
                            info('TODO: Support non-isolated groups.');
                        }
                        if (group.knockout) {
                            warn('Knockout groups not supported.');
                        }
                        var currentTransform = currentCtx.mozCurrentTransform;
                        if (group.matrix) {
                            currentCtx.transform.apply(currentCtx, group.matrix);
                        }
                        assert(group.bbox, 'Bounding box is required.');
                        var bounds = Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform);
                        var canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
                        bounds = Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
                        var offsetX = Math.floor(bounds[0]);
                        var offsetY = Math.floor(bounds[1]);
                        var drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
                        var drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
                        var scaleX = 1,
                            scaleY = 1;
                        if (drawnWidth > MAX_GROUP_SIZE) {
                            scaleX = drawnWidth / MAX_GROUP_SIZE;
                            drawnWidth = MAX_GROUP_SIZE;
                        }
                        if (drawnHeight > MAX_GROUP_SIZE) {
                            scaleY = drawnHeight / MAX_GROUP_SIZE;
                            drawnHeight = MAX_GROUP_SIZE;
                        }
                        var cacheId = 'groupAt' + this.groupLevel;
                        if (group.smask) {
                            cacheId += '_smask_' + ((this.smaskCounter++) % 2);
                        }
                        var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
                        var groupCtx = scratchCanvas.context;
                        groupCtx.scale(1 / scaleX, 1 / scaleY);
                        groupCtx.translate(-offsetX, -offsetY);
                        groupCtx.transform.apply(groupCtx, currentTransform);
                        if (group.smask) {
                            this.smaskStack.push({
                                canvas: scratchCanvas.canvas,
                                context: groupCtx,
                                offsetX: offsetX,
                                offsetY: offsetY,
                                scaleX: scaleX,
                                scaleY: scaleY,
                                subtype: group.smask.subtype,
                                backdrop: group.smask.backdrop,
                                transferMap: group.smask.transferMap || null
                            });
                        } else {
                            currentCtx.setTransform(1, 0, 0, 1, 0, 0);
                            currentCtx.translate(offsetX, offsetY);
                            currentCtx.scale(scaleX, scaleY);
                        }
                        copyCtxState(currentCtx, groupCtx);
                        this.ctx = groupCtx;
                        this.setGState([
                            ['BM', 'Normal'],
                            ['ca', 1],
                            ['CA', 1]
                        ]);
                        this.groupStack.push(currentCtx);
                        this.groupLevel++;
                    },
                    endGroup: function CanvasGraphics_endGroup(group) {
                        this.groupLevel--;
                        var groupCtx = this.ctx;
                        this.ctx = this.groupStack.pop();
                        if (this.ctx.imageSmoothingEnabled !== undefined) {
                            this.ctx.imageSmoothingEnabled = false;
                        } else {
                            this.ctx.mozImageSmoothingEnabled = false;
                        }
                        if (group.smask) {
                            this.tempSMask = this.smaskStack.pop();
                        } else {
                            this.ctx.drawImage(groupCtx.canvas, 0, 0);
                        }
                        this.restore();
                    },
                    beginAnnotations: function CanvasGraphics_beginAnnotations() {
                        this.save();
                        this.current = new CanvasExtraState();
                        if (this.baseTransform) {
                            this.ctx.setTransform.apply(this.ctx, this.baseTransform);
                        }
                    },
                    endAnnotations: function CanvasGraphics_endAnnotations() {
                        this.restore();
                    },
                    beginAnnotation: function CanvasGraphics_beginAnnotation(rect, transform, matrix) {
                        this.save();
                        if (isArray(rect) && 4 === rect.length) {
                            var width = rect[2] - rect[0];
                            var height = rect[3] - rect[1];
                            this.ctx.rect(rect[0], rect[1], width, height);
                            this.clip();
                            this.endPath();
                        }
                        this.transform.apply(this, transform);
                        this.transform.apply(this, matrix);
                    },
                    endAnnotation: function CanvasGraphics_endAnnotation() {
                        this.restore();
                    },
                    paintJpegXObject: function CanvasGraphics_paintJpegXObject(objId, w, h) {
                        var domImage = this.objs.get(objId);
                        if (!domImage) {
                            warn('Dependent image isn\'t ready yet');
                            return;
                        }
                        this.save();
                        var ctx = this.ctx;
                        ctx.scale(1 / w, -1 / h);
                        ctx.drawImage(domImage, 0, 0, domImage.width, domImage.height, 0, -h, w, h);
                        if (this.imageLayer) {
                            var currentTransform = ctx.mozCurrentTransformInverse;
                            var position = this.getCanvasPosition(0, 0);
                            this.imageLayer.appendImage({
                                objId: objId,
                                left: position[0],
                                top: position[1],
                                width: w / currentTransform[0],
                                height: h / currentTransform[3]
                            });
                        }
                        this.restore();
                    },
                    paintImageMaskXObject: function CanvasGraphics_paintImageMaskXObject(img) {
                        var ctx = this.ctx;
                        var width = img.width,
                            height = img.height;
                        var fillColor = this.current.fillColor;
                        var isPatternFill = this.current.patternFill;
                        var glyph = this.processingType3;
                        if (COMPILE_TYPE3_GLYPHS && glyph && glyph.compiled === undefined) {
                            if (width <= MAX_SIZE_TO_COMPILE && height <= MAX_SIZE_TO_COMPILE) {
                                glyph.compiled = compileType3Glyph({
                                    data: img.data,
                                    width: width,
                                    height: height
                                });
                            } else {
                                glyph.compiled = null;
                            }
                        }
                        if (glyph && glyph.compiled) {
                            glyph.compiled(ctx);
                            return;
                        }
                        var maskCanvas = this.cachedCanvases.getCanvas('maskCanvas', width, height);
                        var maskCtx = maskCanvas.context;
                        maskCtx.save();
                        putBinaryImageMask(maskCtx, img);
                        maskCtx.globalCompositeOperation = 'source-in';
                        maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
                        maskCtx.fillRect(0, 0, width, height);
                        maskCtx.restore();
                        this.paintInlineImageXObject(maskCanvas.canvas);
                    },
                    paintImageMaskXObjectRepeat: function CanvasGraphics_paintImageMaskXObjectRepeat(imgData, scaleX, scaleY, positions) {
                        var width = imgData.width;
                        var height = imgData.height;
                        var fillColor = this.current.fillColor;
                        var isPatternFill = this.current.patternFill;
                        var maskCanvas = this.cachedCanvases.getCanvas('maskCanvas', width, height);
                        var maskCtx = maskCanvas.context;
                        maskCtx.save();
                        putBinaryImageMask(maskCtx, imgData);
                        maskCtx.globalCompositeOperation = 'source-in';
                        maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
                        maskCtx.fillRect(0, 0, width, height);
                        maskCtx.restore();
                        var ctx = this.ctx;
                        for (var i = 0, ii = positions.length; i < ii; i += 2) {
                            ctx.save();
                            ctx.transform(scaleX, 0, 0, scaleY, positions[i], positions[i + 1]);
                            ctx.scale(1, -1);
                            ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
                            ctx.restore();
                        }
                    },
                    paintImageMaskXObjectGroup: function CanvasGraphics_paintImageMaskXObjectGroup(images) {
                        var ctx = this.ctx;
                        var fillColor = this.current.fillColor;
                        var isPatternFill = this.current.patternFill;
                        for (var i = 0, ii = images.length; i < ii; i++) {
                            var image = images[i];
                            var width = image.width,
                                height = image.height;
                            var maskCanvas = this.cachedCanvases.getCanvas('maskCanvas', width, height);
                            var maskCtx = maskCanvas.context;
                            maskCtx.save();
                            putBinaryImageMask(maskCtx, image);
                            maskCtx.globalCompositeOperation = 'source-in';
                            maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
                            maskCtx.fillRect(0, 0, width, height);
                            maskCtx.restore();
                            ctx.save();
                            ctx.transform.apply(ctx, image.transform);
                            ctx.scale(1, -1);
                            ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
                            ctx.restore();
                        }
                    },
                    paintImageXObject: function CanvasGraphics_paintImageXObject(objId) {
                        var imgData = this.objs.get(objId);
                        if (!imgData) {
                            warn('Dependent image isn\'t ready yet');
                            return;
                        }
                        this.paintInlineImageXObject(imgData);
                    },
                    paintImageXObjectRepeat: function CanvasGraphics_paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
                        var imgData = this.objs.get(objId);
                        if (!imgData) {
                            warn('Dependent image isn\'t ready yet');
                            return;
                        }
                        var width = imgData.width;
                        var height = imgData.height;
                        var map = [];
                        for (var i = 0, ii = positions.length; i < ii; i += 2) {
                            map.push({
                                transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
                                x: 0,
                                y: 0,
                                w: width,
                                h: height
                            });
                        }
                        this.paintInlineImageXObjectGroup(imgData, map);
                    },
                    paintInlineImageXObject: function CanvasGraphics_paintInlineImageXObject(imgData) {
                        var width = imgData.width;
                        var height = imgData.height;
                        var ctx = this.ctx;
                        this.save();
                        ctx.scale(1 / width, -1 / height);
                        var currentTransform = ctx.mozCurrentTransformInverse;
                        var a = currentTransform[0],
                            b = currentTransform[1];
                        var widthScale = Math.max(Math.sqrt(a * a + b * b), 1);
                        var c = currentTransform[2],
                            d = currentTransform[3];
                        var heightScale = Math.max(Math.sqrt(c * c + d * d), 1);
                        var imgToPaint, tmpCanvas;
                        if (imgData instanceof HTMLElement || !imgData.data) {
                            imgToPaint = imgData;
                        } else {
                            tmpCanvas = this.cachedCanvases.getCanvas('inlineImage', width, height);
                            var tmpCtx = tmpCanvas.context;
                            putBinaryImageData(tmpCtx, imgData);
                            imgToPaint = tmpCanvas.canvas;
                        }
                        var paintWidth = width,
                            paintHeight = height;
                        var tmpCanvasId = 'prescale1';
                        while ((widthScale > 2 && paintWidth > 1) || (heightScale > 2 && paintHeight > 1)) {
                            var newWidth = paintWidth,
                                newHeight = paintHeight;
                            if (widthScale > 2 && paintWidth > 1) {
                                newWidth = Math.ceil(paintWidth / 2);
                                widthScale /= paintWidth / newWidth;
                            }
                            if (heightScale > 2 && paintHeight > 1) {
                                newHeight = Math.ceil(paintHeight / 2);
                                heightScale /= paintHeight / newHeight;
                            }
                            tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
                            tmpCtx = tmpCanvas.context;
                            tmpCtx.clearRect(0, 0, newWidth, newHeight);
                            tmpCtx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
                            imgToPaint = tmpCanvas.canvas;
                            paintWidth = newWidth;
                            paintHeight = newHeight;
                            tmpCanvasId = tmpCanvasId === 'prescale1' ? 'prescale2' : 'prescale1';
                        }
                        ctx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, -height, width, height);
                        if (this.imageLayer) {
                            var position = this.getCanvasPosition(0, -height);
                            this.imageLayer.appendImage({
                                imgData: imgData,
                                left: position[0],
                                top: position[1],
                                width: width / currentTransform[0],
                                height: height / currentTransform[3]
                            });
                        }
                        this.restore();
                    },
                    paintInlineImageXObjectGroup: function CanvasGraphics_paintInlineImageXObjectGroup(imgData, map) {
                        var ctx = this.ctx;
                        var w = imgData.width;
                        var h = imgData.height;
                        var tmpCanvas = this.cachedCanvases.getCanvas('inlineImage', w, h);
                        var tmpCtx = tmpCanvas.context;
                        putBinaryImageData(tmpCtx, imgData);
                        for (var i = 0, ii = map.length; i < ii; i++) {
                            var entry = map[i];
                            ctx.save();
                            ctx.transform.apply(ctx, entry.transform);
                            ctx.scale(1, -1);
                            ctx.drawImage(tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);
                            if (this.imageLayer) {
                                var position = this.getCanvasPosition(entry.x, entry.y);
                                this.imageLayer.appendImage({
                                    imgData: imgData,
                                    left: position[0],
                                    top: position[1],
                                    width: w,
                                    height: h
                                });
                            }
                            ctx.restore();
                        }
                    },
                    paintSolidColorImageMask: function CanvasGraphics_paintSolidColorImageMask() {
                        this.ctx.fillRect(0, 0, 1, 1);
                    },
                    paintXObject: function CanvasGraphics_paintXObject() {
                        warn('Unsupported \'paintXObject\' command.');
                    },
                    markPoint: function CanvasGraphics_markPoint(tag) {},
                    markPointProps: function CanvasGraphics_markPointProps(tag, properties) {},
                    beginMarkedContent: function CanvasGraphics_beginMarkedContent(tag) {},
                    beginMarkedContentProps: function CanvasGraphics_beginMarkedContentProps(tag, properties) {},
                    endMarkedContent: function CanvasGraphics_endMarkedContent() {},
                    beginCompat: function CanvasGraphics_beginCompat() {},
                    endCompat: function CanvasGraphics_endCompat() {},
                    consumePath: function CanvasGraphics_consumePath() {
                        var ctx = this.ctx;
                        if (this.pendingClip) {
                            if (this.pendingClip === EO_CLIP) {
                                if (ctx.mozFillRule !== undefined) {
                                    ctx.mozFillRule = 'evenodd';
                                    ctx.clip();
                                    ctx.mozFillRule = 'nonzero';
                                } else {
                                    ctx.clip('evenodd');
                                }
                            } else {
                                ctx.clip();
                            }
                            this.pendingClip = null;
                        }
                        ctx.beginPath();
                    },
                    getSinglePixelWidth: function CanvasGraphics_getSinglePixelWidth(scale) {
                        if (this.cachedGetSinglePixelWidth === null) {
                            var inverse = this.ctx.mozCurrentTransformInverse;
                            this.cachedGetSinglePixelWidth = Math.sqrt(Math.max((inverse[0] * inverse[0] + inverse[1] * inverse[1]), (inverse[2] * inverse[2] + inverse[3] * inverse[3])));
                        }
                        return this.cachedGetSinglePixelWidth;
                    },
                    getCanvasPosition: function CanvasGraphics_getCanvasPosition(x, y) {
                        var transform = this.ctx.mozCurrentTransform;
                        return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]];
                    }
                };
                for (var op in OPS) {
                    CanvasGraphics.prototype[OPS[op]] = CanvasGraphics.prototype[op];
                }
                return CanvasGraphics;
            })();
            exports.CanvasGraphics = CanvasGraphics;
            exports.createScratchCanvas = createScratchCanvas;
        }));
        (function(root, factory) {
            {
                factory((root.pdfjsDisplayAPI = {}), root.pdfjsSharedUtil, root.pdfjsDisplayFontLoader, root.pdfjsDisplayCanvas, root.pdfjsDisplayMetadata, root.pdfjsSharedGlobal);
            }
        }(this, function(exports, sharedUtil, displayFontLoader, displayCanvas, displayMetadata, sharedGlobal, amdRequire) {
            var InvalidPDFException = sharedUtil.InvalidPDFException;
            var MessageHandler = sharedUtil.MessageHandler;
            var MissingPDFException = sharedUtil.MissingPDFException;
            var PasswordResponses = sharedUtil.PasswordResponses;
            var PasswordException = sharedUtil.PasswordException;
            var StatTimer = sharedUtil.StatTimer;
            var UnexpectedResponseException = sharedUtil.UnexpectedResponseException;
            var UnknownErrorException = sharedUtil.UnknownErrorException;
            var Util = sharedUtil.Util;
            var createPromiseCapability = sharedUtil.createPromiseCapability;
            var combineUrl = sharedUtil.combineUrl;
            var error = sharedUtil.error;
            var deprecated = sharedUtil.deprecated;
            var info = sharedUtil.info;
            var isArrayBuffer = sharedUtil.isArrayBuffer;
            var loadJpegStream = sharedUtil.loadJpegStream;
            var stringToBytes = sharedUtil.stringToBytes;
            var warn = sharedUtil.warn;
            var FontFaceObject = displayFontLoader.FontFaceObject;
            var FontLoader = displayFontLoader.FontLoader;
            var CanvasGraphics = displayCanvas.CanvasGraphics;
            var createScratchCanvas = displayCanvas.createScratchCanvas;
            var Metadata = displayMetadata.Metadata;
            var PDFJS = sharedGlobal.PDFJS;
            var globalScope = sharedGlobal.globalScope;
            var DEFAULT_RANGE_CHUNK_SIZE = 65536;
            var useRequireEnsure = false;
            if (typeof module !== 'undefined' && module.require) {
                PDFJS.disableWorker = true;
                if (typeof require.ensure === 'undefined') {
                    require.ensure = require('node-ensure');
                }
                useRequireEnsure = true;
            }
            if (typeof __webpack_require__ !== 'undefined') {
                PDFJS.workerSrc = require('entry?name=[hash]-worker.js!./pdf.worker.js');
                useRequireEnsure = true;
            }
            if (typeof requirejs !== 'undefined' && requirejs.toUrl) {
                PDFJS.workerSrc = requirejs.toUrl('pdfjs-dist/build/pdf.worker.js');
            }
            var fakeWorkerFilesLoader = useRequireEnsure ? (function(callback) {
                require.ensure([], function() {
                    require('./pdf.worker.js');
                    callback();
                });
            }) : (typeof requirejs !== 'undefined') ? (function(callback) {
                requirejs(['pdfjs-dist/build/pdf.worker'], function(worker) {
                    callback();
                });
            }) : null;
            PDFJS.maxImageSize = (PDFJS.maxImageSize === undefined ? -1 : PDFJS.maxImageSize);
            PDFJS.cMapUrl = (PDFJS.cMapUrl === undefined ? null : PDFJS.cMapUrl);
            PDFJS.cMapPacked = PDFJS.cMapPacked === undefined ? false : PDFJS.cMapPacked;
            PDFJS.disableFontFace = (PDFJS.disableFontFace === undefined ? false : PDFJS.disableFontFace);
            PDFJS.imageResourcesPath = (PDFJS.imageResourcesPath === undefined ? '' : PDFJS.imageResourcesPath);
            PDFJS.disableWorker = (PDFJS.disableWorker === undefined ? false : PDFJS.disableWorker);
            PDFJS.workerSrc = (PDFJS.workerSrc === undefined ? null : PDFJS.workerSrc);
            PDFJS.disableRange = (PDFJS.disableRange === undefined ? false : PDFJS.disableRange);
            PDFJS.disableStream = (PDFJS.disableStream === undefined ? false : PDFJS.disableStream);
            PDFJS.disableAutoFetch = (PDFJS.disableAutoFetch === undefined ? false : PDFJS.disableAutoFetch);
            PDFJS.pdfBug = (PDFJS.pdfBug === undefined ? false : PDFJS.pdfBug);
            PDFJS.postMessageTransfers = (PDFJS.postMessageTransfers === undefined ? true : PDFJS.postMessageTransfers);
            PDFJS.disableCreateObjectURL = (PDFJS.disableCreateObjectURL === undefined ? false : PDFJS.disableCreateObjectURL);
            PDFJS.disableWebGL = (PDFJS.disableWebGL === undefined ? true : PDFJS.disableWebGL);
            PDFJS.disableFullscreen = (PDFJS.disableFullscreen === undefined ? false : PDFJS.disableFullscreen);
            PDFJS.useOnlyCssZoom = (PDFJS.useOnlyCssZoom === undefined ? false : PDFJS.useOnlyCssZoom);
            PDFJS.verbosity = (PDFJS.verbosity === undefined ? PDFJS.VERBOSITY_LEVELS.warnings : PDFJS.verbosity);
            PDFJS.maxCanvasPixels = (PDFJS.maxCanvasPixels === undefined ? 16777216 : PDFJS.maxCanvasPixels);
            PDFJS.openExternalLinksInNewWindow = (PDFJS.openExternalLinksInNewWindow === undefined ? false : PDFJS.openExternalLinksInNewWindow);
            PDFJS.externalLinkTarget = (PDFJS.externalLinkTarget === undefined ? PDFJS.LinkTarget.NONE : PDFJS.externalLinkTarget);
            PDFJS.externalLinkRel = (PDFJS.externalLinkRel === undefined ? 'noreferrer' : PDFJS.externalLinkRel);
            PDFJS.isEvalSupported = (PDFJS.isEvalSupported === undefined ? true : PDFJS.isEvalSupported);
            PDFJS.getDocument = function getDocument(src, pdfDataRangeTransport, passwordCallback, progressCallback) {
                var task = new PDFDocumentLoadingTask();
                if (arguments.length > 1) {
                    deprecated('getDocument is called with pdfDataRangeTransport, ' + 'passwordCallback or progressCallback argument');
                }
                if (pdfDataRangeTransport) {
                    if (!(pdfDataRangeTransport instanceof PDFDataRangeTransport)) {
                        pdfDataRangeTransport = Object.create(pdfDataRangeTransport);
                        pdfDataRangeTransport.length = src.length;
                        pdfDataRangeTransport.initialData = src.initialData;
                        if (!pdfDataRangeTransport.abort) {
                            pdfDataRangeTransport.abort = function() {};
                        }
                    }
                    src = Object.create(src);
                    src.range = pdfDataRangeTransport;
                }
                task.onPassword = passwordCallback || null;
                task.onProgress = progressCallback || null;
                var source;
                if (typeof src === 'string') {
                    source = {
                        url: src
                    };
                } else if (isArrayBuffer(src)) {
                    source = {
                        data: src
                    };
                } else if (src instanceof PDFDataRangeTransport) {
                    source = {
                        range: src
                    };
                } else {
                    if (typeof src !== 'object') {
                        error('Invalid parameter in getDocument, need either Uint8Array, ' + 'string or a parameter object');
                    }
                    if (!src.url && !src.data && !src.range) {
                        error('Invalid parameter object: need either .data, .range or .url');
                    }
                    source = src;
                }
                var params = {};
                var rangeTransport = null;
                var worker = null;
                for (var key in source) {
                    if (key === 'url' && typeof window !== 'undefined') {
                        params[key] = combineUrl(window.location.href, source[key]);
                        continue;
                    } else if (key === 'range') {
                        rangeTransport = source[key];
                        continue;
                    } else if (key === 'worker') {
                        worker = source[key];
                        continue;
                    } else if (key === 'data' && !(source[key] instanceof Uint8Array)) {
                        var pdfBytes = source[key];
                        if (typeof pdfBytes === 'string') {
                            params[key] = stringToBytes(pdfBytes);
                        } else if (typeof pdfBytes === 'object' && pdfBytes !== null && !isNaN(pdfBytes.length)) {
                            params[key] = new Uint8Array(pdfBytes);
                        } else if (isArrayBuffer(pdfBytes)) {
                            params[key] = new Uint8Array(pdfBytes);
                        } else {
                            error('Invalid PDF binary data: either typed array, string or ' + 'array-like object is expected in the data property.');
                        }
                        continue;
                    }
                    params[key] = source[key];
                }
                params.rangeChunkSize = params.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE;
                if (!worker) {
                    worker = new PDFWorker();
                    task._worker = worker;
                }
                var docId = task.docId;
                worker.promise.then(function() {
                    if (task.destroyed) {
                        throw new Error('Loading aborted');
                    }
                    return _fetchDocument(worker, params, rangeTransport, docId).then(function(workerId) {
                        if (task.destroyed) {
                            throw new Error('Loading aborted');
                        }
                        var messageHandler = new MessageHandler(docId, workerId, worker.port);
                        messageHandler.send('Ready', null);
                        var transport = new WorkerTransport(messageHandler, task, rangeTransport);
                        task._transport = transport;
                    });
                }).catch(task._capability.reject);
                return task;
            };

            function _fetchDocument(worker, source, pdfDataRangeTransport, docId) {
                if (worker.destroyed) {
                    return Promise.reject(new Error('Worker was destroyed'));
                }
                source.disableAutoFetch = PDFJS.disableAutoFetch;
                source.disableStream = PDFJS.disableStream;
                source.chunkedViewerLoading = !!pdfDataRangeTransport;
                if (pdfDataRangeTransport) {
                    source.length = pdfDataRangeTransport.length;
                    source.initialData = pdfDataRangeTransport.initialData;
                }
                return worker.messageHandler.sendWithPromise('GetDocRequest', {
                    docId: docId,
                    source: source,
                    disableRange: PDFJS.disableRange,
                    maxImageSize: PDFJS.maxImageSize,
                    cMapUrl: PDFJS.cMapUrl,
                    cMapPacked: PDFJS.cMapPacked,
                    disableFontFace: PDFJS.disableFontFace,
                    disableCreateObjectURL: PDFJS.disableCreateObjectURL,
                    verbosity: PDFJS.verbosity
                }).then(function(workerId) {
                    if (worker.destroyed) {
                        throw new Error('Worker was destroyed');
                    }
                    return workerId;
                });
            }
            var PDFDocumentLoadingTask = (function PDFDocumentLoadingTaskClosure() {
                var nextDocumentId = 0;

                function PDFDocumentLoadingTask() {
                    this._capability = createPromiseCapability();
                    this._transport = null;
                    this._worker = null;
                    this.docId = 'd' + (nextDocumentId++);
                    this.destroyed = false;
                    this.onPassword = null;
                    this.onProgress = null;
                    this.onUnsupportedFeature = null;
                }
                PDFDocumentLoadingTask.prototype = {
                    get promise() {
                        return this._capability.promise;
                    },
                    destroy: function() {
                        this.destroyed = true;
                        var transportDestroyed = !this._transport ? Promise.resolve() : this._transport.destroy();
                        return transportDestroyed.then(function() {
                            this._transport = null;
                            if (this._worker) {
                                this._worker.destroy();
                                this._worker = null;
                            }
                        }.bind(this));
                    },
                    then: function PDFDocumentLoadingTask_then(onFulfilled, onRejected) {
                        return this.promise.then.apply(this.promise, arguments);
                    }
                };
                return PDFDocumentLoadingTask;
            })();
            var PDFDataRangeTransport = (function pdfDataRangeTransportClosure() {
                function PDFDataRangeTransport(length, initialData) {
                    this.length = length;
                    this.initialData = initialData;
                    this._rangeListeners = [];
                    this._progressListeners = [];
                    this._progressiveReadListeners = [];
                    this._readyCapability = createPromiseCapability();
                }
                PDFDataRangeTransport.prototype = {
                    addRangeListener: function PDFDataRangeTransport_addRangeListener(listener) {
                        this._rangeListeners.push(listener);
                    },
                    addProgressListener: function PDFDataRangeTransport_addProgressListener(listener) {
                        this._progressListeners.push(listener);
                    },
                    addProgressiveReadListener: function PDFDataRangeTransport_addProgressiveReadListener(listener) {
                        this._progressiveReadListeners.push(listener);
                    },
                    onDataRange: function PDFDataRangeTransport_onDataRange(begin, chunk) {
                        var listeners = this._rangeListeners;
                        for (var i = 0, n = listeners.length; i < n; ++i) {
                            listeners[i](begin, chunk);
                        }
                    },
                    onDataProgress: function PDFDataRangeTransport_onDataProgress(loaded) {
                        this._readyCapability.promise.then(function() {
                            var listeners = this._progressListeners;
                            for (var i = 0, n = listeners.length; i < n; ++i) {
                                listeners[i](loaded);
                            }
                        }.bind(this));
                    },
                    onDataProgressiveRead: function PDFDataRangeTransport_onDataProgress(chunk) {
                        this._readyCapability.promise.then(function() {
                            var listeners = this._progressiveReadListeners;
                            for (var i = 0, n = listeners.length; i < n; ++i) {
                                listeners[i](chunk);
                            }
                        }.bind(this));
                    },
                    transportReady: function PDFDataRangeTransport_transportReady() {
                        this._readyCapability.resolve();
                    },
                    requestDataRange: function PDFDataRangeTransport_requestDataRange(begin, end) {
                        throw new Error('Abstract method PDFDataRangeTransport.requestDataRange');
                    },
                    abort: function PDFDataRangeTransport_abort() {}
                };
                return PDFDataRangeTransport;
            })();
            PDFJS.PDFDataRangeTransport = PDFDataRangeTransport;
            var PDFDocumentProxy = (function PDFDocumentProxyClosure() {
                function PDFDocumentProxy(pdfInfo, transport, loadingTask) {
                    this.pdfInfo = pdfInfo;
                    this.transport = transport;
                    this.loadingTask = loadingTask;
                }
                PDFDocumentProxy.prototype = {
                    get numPages() {
                        return this.pdfInfo.numPages;
                    },
                    get fingerprint() {
                        return this.pdfInfo.fingerprint;
                    },
                    getPage: function PDFDocumentProxy_getPage(pageNumber) {
                        return this.transport.getPage(pageNumber);
                    },
                    getPageIndex: function PDFDocumentProxy_getPageIndex(ref) {
                        return this.transport.getPageIndex(ref);
                    },
                    getDestinations: function PDFDocumentProxy_getDestinations() {
                        return this.transport.getDestinations();
                    },
                    getDestination: function PDFDocumentProxy_getDestination(id) {
                        return this.transport.getDestination(id);
                    },
                    getPageLabels: function PDFDocumentProxy_getPageLabels() {
                        return this.transport.getPageLabels();
                    },
                    getAttachments: function PDFDocumentProxy_getAttachments() {
                        return this.transport.getAttachments();
                    },
                    getJavaScript: function PDFDocumentProxy_getJavaScript() {
                        return this.transport.getJavaScript();
                    },
                    getOutline: function PDFDocumentProxy_getOutline() {
                        return this.transport.getOutline();
                    },
                    getMetadata: function PDFDocumentProxy_getMetadata() {
                        return this.transport.getMetadata();
                    },
                    getData: function PDFDocumentProxy_getData() {
                        return this.transport.getData();
                    },
                    getDownloadInfo: function PDFDocumentProxy_getDownloadInfo() {
                        return this.transport.downloadInfoCapability.promise;
                    },
                    getStats: function PDFDocumentProxy_getStats() {
                        return this.transport.getStats();
                    },
                    cleanup: function PDFDocumentProxy_cleanup() {
                        this.transport.startCleanup();
                    },
                    destroy: function PDFDocumentProxy_destroy() {
                        return this.loadingTask.destroy();
                    }
                };
                return PDFDocumentProxy;
            })();
            var PDFPageProxy = (function PDFPageProxyClosure() {
                function PDFPageProxy(pageIndex, pageInfo, transport) {
                    this.pageIndex = pageIndex;
                    this.pageInfo = pageInfo;
                    this.transport = transport;
                    this.stats = new StatTimer();
                    this.stats.enabled = !!globalScope.PDFJS.enableStats;
                    this.commonObjs = transport.commonObjs;
                    this.objs = new PDFObjects();
                    this.cleanupAfterRender = false;
                    this.pendingCleanup = false;
                    this.intentStates = {};
                    this.destroyed = false;
                }
                PDFPageProxy.prototype = {
                    get pageNumber() {
                        return this.pageIndex + 1;
                    },
                    get rotate() {
                        return this.pageInfo.rotate;
                    },
                    get ref() {
                        return this.pageInfo.ref;
                    },
                    get view() {
                        return this.pageInfo.view;
                    },
                    getViewport: function PDFPageProxy_getViewport(scale, rotate) {
                        if (arguments.length < 2) {
                            rotate = this.rotate;
                        }
                        return new PDFJS.PageViewport(this.view, scale, rotate, 0, 0);
                    },
                    getAnnotations: function PDFPageProxy_getAnnotations(params) {
                        var intent = (params && params.intent) || null;
                        if (!this.annotationsPromise || this.annotationsIntent !== intent) {
                            this.annotationsPromise = this.transport.getAnnotations(this.pageIndex, intent);
                            this.annotationsIntent = intent;
                        }
                        return this.annotationsPromise;
                    },
                    render: function PDFPageProxy_render(params) {
                        var stats = this.stats;
                        stats.time('Overall');
                        this.pendingCleanup = false;
                        var renderingIntent = (params.intent === 'print' ? 'print' : 'display');
                        if (!this.intentStates[renderingIntent]) {
                            this.intentStates[renderingIntent] = {};
                        }
                        var intentState = this.intentStates[renderingIntent];
                        if (!intentState.displayReadyCapability) {
                            intentState.receivingOperatorList = true;
                            intentState.displayReadyCapability = createPromiseCapability();
                            intentState.operatorList = {
                                fnArray: [],
                                argsArray: [],
                                lastChunk: false
                            };
                            this.stats.time('Page Request');
                            this.transport.messageHandler.send('RenderPageRequest', {
                                pageIndex: this.pageNumber - 1,
                                intent: renderingIntent
                            });
                        }
                        var internalRenderTask = new InternalRenderTask(complete, params, this.objs, this.commonObjs, intentState.operatorList, this.pageNumber);
                        internalRenderTask.useRequestAnimationFrame = renderingIntent !== 'print';
                        if (!intentState.renderTasks) {
                            intentState.renderTasks = [];
                        }
                        intentState.renderTasks.push(internalRenderTask);
                        var renderTask = internalRenderTask.task;
                        if (params.continueCallback) {
                            deprecated('render is used with continueCallback parameter');
                            renderTask.onContinue = params.continueCallback;
                        }
                        var self = this;
                        intentState.displayReadyCapability.promise.then(function pageDisplayReadyPromise(transparency) {
                            if (self.pendingCleanup) {
                                complete();
                                return;
                            }
                            stats.time('Rendering');
                            internalRenderTask.initalizeGraphics(transparency);
                            internalRenderTask.operatorListChanged();
                        }, function pageDisplayReadPromiseError(reason) {
                            complete(reason);
                        });

                        function complete(error) {
                            var i = intentState.renderTasks.indexOf(internalRenderTask);
                            if (i >= 0) {
                                intentState.renderTasks.splice(i, 1);
                            }
                            if (self.cleanupAfterRender) {
                                self.pendingCleanup = true;
                            }
                            self._tryCleanup();
                            if (error) {
                                internalRenderTask.capability.reject(error);
                            } else {
                                internalRenderTask.capability.resolve();
                            }
                            stats.timeEnd('Rendering');
                            stats.timeEnd('Overall');
                        }
                        return renderTask;
                    },
                    getOperatorList: function PDFPageProxy_getOperatorList() {
                        function operatorListChanged() {
                            if (intentState.operatorList.lastChunk) {
                                intentState.opListReadCapability.resolve(intentState.operatorList);
                            }
                        }
                        var renderingIntent = 'oplist';
                        if (!this.intentStates[renderingIntent]) {
                            this.intentStates[renderingIntent] = {};
                        }
                        var intentState = this.intentStates[renderingIntent];
                        if (!intentState.opListReadCapability) {
                            var opListTask = {};
                            opListTask.operatorListChanged = operatorListChanged;
                            intentState.receivingOperatorList = true;
                            intentState.opListReadCapability = createPromiseCapability();
                            intentState.renderTasks = [];
                            intentState.renderTasks.push(opListTask);
                            intentState.operatorList = {
                                fnArray: [],
                                argsArray: [],
                                lastChunk: false
                            };
                            this.transport.messageHandler.send('RenderPageRequest', {
                                pageIndex: this.pageIndex,
                                intent: renderingIntent
                            });
                        }
                        return intentState.opListReadCapability.promise;
                    },
                    getTextContent: function PDFPageProxy_getTextContent(params) {
                        var normalizeWhitespace = (params && params.normalizeWhitespace) || false;
                        return this.transport.messageHandler.sendWithPromise('GetTextContent', {
                            pageIndex: this.pageNumber - 1,
                            normalizeWhitespace: normalizeWhitespace,
                        });
                    },
                    _destroy: function PDFPageProxy_destroy() {
                        this.destroyed = true;
                        this.transport.pageCache[this.pageIndex] = null;
                        var waitOn = [];
                        Object.keys(this.intentStates).forEach(function(intent) {
                            var intentState = this.intentStates[intent];
                            intentState.renderTasks.forEach(function(renderTask) {
                                var renderCompleted = renderTask.capability.promise.catch(function() {});
                                waitOn.push(renderCompleted);
                                renderTask.cancel();
                            });
                        }, this);
                        this.objs.clear();
                        this.annotationsPromise = null;
                        this.pendingCleanup = false;
                        return Promise.all(waitOn);
                    },
                    destroy: function() {
                        deprecated('page destroy method, use cleanup() instead');
                        this.cleanup();
                    },
                    cleanup: function PDFPageProxy_cleanup() {
                        this.pendingCleanup = true;
                        this._tryCleanup();
                    },
                    _tryCleanup: function PDFPageProxy_tryCleanup() {
                        if (!this.pendingCleanup || Object.keys(this.intentStates).some(function(intent) {
                                var intentState = this.intentStates[intent];
                                return (intentState.renderTasks.length !== 0 || intentState.receivingOperatorList);
                            }, this)) {
                            return;
                        }
                        Object.keys(this.intentStates).forEach(function(intent) {
                            delete this.intentStates[intent];
                        }, this);
                        this.objs.clear();
                        this.annotationsPromise = null;
                        this.pendingCleanup = false;
                    },
                    _startRenderPage: function PDFPageProxy_startRenderPage(transparency, intent) {
                        var intentState = this.intentStates[intent];
                        if (intentState.displayReadyCapability) {
                            intentState.displayReadyCapability.resolve(transparency);
                        }
                    },
                    _renderPageChunk: function PDFPageProxy_renderPageChunk(operatorListChunk, intent) {
                        var intentState = this.intentStates[intent];
                        var i, ii;
                        for (i = 0, ii = operatorListChunk.length; i < ii; i++) {
                            intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
                            intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
                        }
                        intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
                        for (i = 0; i < intentState.renderTasks.length; i++) {
                            intentState.renderTasks[i].operatorListChanged();
                        }
                        if (operatorListChunk.lastChunk) {
                            intentState.receivingOperatorList = false;
                            this._tryCleanup();
                        }
                    }
                };
                return PDFPageProxy;
            })();
            var PDFWorker = (function PDFWorkerClosure() {
                var nextFakeWorkerId = 0;

                function getWorkerSrc() {
                    if (PDFJS.workerSrc) {
                        return PDFJS.workerSrc;
                    }
                    if (pdfjsFilePath) {
                        return pdfjsFilePath.replace(/\.js$/i, '.worker.js');
                    }
                    error('No PDFJS.workerSrc specified');
                }

                function setupFakeWorkerGlobal() {
                    if (!PDFJS.fakeWorkerFilesLoadedCapability) {
                        PDFJS.fakeWorkerFilesLoadedCapability = createPromiseCapability();
                        var loader = fakeWorkerFilesLoader || function(callback) {
                            Util.loadScript(getWorkerSrc(), callback);
                        };
                        loader(function() {
                            PDFJS.fakeWorkerFilesLoadedCapability.resolve();
                        });
                    }
                    return PDFJS.fakeWorkerFilesLoadedCapability.promise;
                }

                function PDFWorker(name) {
                    this.name = name;
                    this.destroyed = false;
                    this._readyCapability = createPromiseCapability();
                    this._port = null;
                    this._webWorker = null;
                    this._messageHandler = null;
                    this._initialize();
                }
                PDFWorker.prototype = {
                    get promise() {
                        return this._readyCapability.promise;
                    },
                    get port() {
                        return this._port;
                    },
                    get messageHandler() {
                        return this._messageHandler;
                    },
                    _initialize: function PDFWorker_initialize() {
                        if (!globalScope.PDFJS.disableWorker && typeof Worker !== 'undefined') {
                            var workerSrc = getWorkerSrc();
                            try {
                                var worker = new Worker(workerSrc);
                                var messageHandler = new MessageHandler('main', 'worker', worker);
                                messageHandler.on('test', function PDFWorker_test(data) {
                                    if (this.destroyed) {
                                        this._readyCapability.reject(new Error('Worker was destroyed'));
                                        messageHandler.destroy();
                                        worker.terminate();
                                        return;
                                    }
                                    var supportTypedArray = data && data.supportTypedArray;
                                    if (supportTypedArray) {
                                        this._messageHandler = messageHandler;
                                        this._port = worker;
                                        this._webWorker = worker;
                                        if (!data.supportTransfers) {
                                            PDFJS.postMessageTransfers = false;
                                        }
                                        this._readyCapability.resolve();
                                    } else {
                                        this._setupFakeWorker();
                                        messageHandler.destroy();
                                        worker.terminate();
                                    }
                                }.bind(this));
                                messageHandler.on('console_log', function(data) {
                                    console.log.apply(console, data);
                                });
                                messageHandler.on('console_error', function(data) {
                                    console.error.apply(console, data);
                                });
                                messageHandler.on('ready', function(data) {
                                    if (this.destroyed) {
                                        this._readyCapability.reject(new Error('Worker was destroyed'));
                                        messageHandler.destroy();
                                        worker.terminate();
                                        return;
                                    }
                                    try {
                                        sendTest();
                                    } catch (e) {
                                        this._setupFakeWorker();
                                    }
                                }.bind(this));
                                var sendTest = function() {
                                    var testObj = new Uint8Array([PDFJS.postMessageTransfers ? 255 : 0]);
                                    try {
                                        messageHandler.send('test', testObj, [testObj.buffer]);
                                    } catch (ex) {
                                        info('Cannot use postMessage transfers');
                                        testObj[0] = 0;
                                        messageHandler.send('test', testObj);
                                    }
                                };
                                sendTest();
                                return;
                            } catch (e) {
                                info('The worker has been disabled.');
                            }
                        }
                        this._setupFakeWorker();
                    },
                    _setupFakeWorker: function PDFWorker_setupFakeWorker() {
                        if (!globalScope.PDFJS.disableWorker) {
                            warn('Setting up fake worker.');
                            globalScope.PDFJS.disableWorker = true;
                        }
                        setupFakeWorkerGlobal().then(function() {
                            if (this.destroyed) {
                                this._readyCapability.reject(new Error('Worker was destroyed'));
                                return;
                            }
                            var port = {
                                _listeners: [],
                                postMessage: function(obj) {
                                    var e = {
                                        data: obj
                                    };
                                    this._listeners.forEach(function(listener) {
                                        listener.call(this, e);
                                    }, this);
                                },
                                addEventListener: function(name, listener) {
                                    this._listeners.push(listener);
                                },
                                removeEventListener: function(name, listener) {
                                    var i = this._listeners.indexOf(listener);
                                    this._listeners.splice(i, 1);
                                },
                                terminate: function() {}
                            };
                            this._port = port;
                            var id = 'fake' + (nextFakeWorkerId++);
                            var workerHandler = new MessageHandler(id + '_worker', id, port);
                            PDFJS.WorkerMessageHandler.setup(workerHandler, port);
                            var messageHandler = new MessageHandler(id, id + '_worker', port);
                            this._messageHandler = messageHandler;
                            this._readyCapability.resolve();
                        }.bind(this));
                    },
                    destroy: function PDFWorker_destroy() {
                        this.destroyed = true;
                        if (this._webWorker) {
                            this._webWorker.terminate();
                            this._webWorker = null;
                        }
                        this._port = null;
                        if (this._messageHandler) {
                            this._messageHandler.destroy();
                            this._messageHandler = null;
                        }
                    }
                };
                return PDFWorker;
            })();
            PDFJS.PDFWorker = PDFWorker;
            var WorkerTransport = (function WorkerTransportClosure() {
                function WorkerTransport(messageHandler, loadingTask, pdfDataRangeTransport) {
                    this.messageHandler = messageHandler;
                    this.loadingTask = loadingTask;
                    this.pdfDataRangeTransport = pdfDataRangeTransport;
                    this.commonObjs = new PDFObjects();
                    this.fontLoader = new FontLoader(loadingTask.docId);
                    this.destroyed = false;
                    this.destroyCapability = null;
                    this.pageCache = [];
                    this.pagePromises = [];
                    this.downloadInfoCapability = createPromiseCapability();
                    this.setupMessageHandler();
                }
                WorkerTransport.prototype = {
                    destroy: function WorkerTransport_destroy() {
                        if (this.destroyCapability) {
                            return this.destroyCapability.promise;
                        }
                        this.destroyed = true;
                        this.destroyCapability = createPromiseCapability();
                        var waitOn = [];
                        this.pageCache.forEach(function(page) {
                            if (page) {
                                waitOn.push(page._destroy());
                            }
                        });
                        this.pageCache = [];
                        this.pagePromises = [];
                        var self = this;
                        var terminated = this.messageHandler.sendWithPromise('Terminate', null);
                        waitOn.push(terminated);
                        Promise.all(waitOn).then(function() {
                            self.fontLoader.clear();
                            if (self.pdfDataRangeTransport) {
                                self.pdfDataRangeTransport.abort();
                                self.pdfDataRangeTransport = null;
                            }
                            if (self.messageHandler) {
                                self.messageHandler.destroy();
                                self.messageHandler = null;
                            }
                            self.destroyCapability.resolve();
                        }, this.destroyCapability.reject);
                        return this.destroyCapability.promise;
                    },
                    setupMessageHandler: function WorkerTransport_setupMessageHandler() {
                        var messageHandler = this.messageHandler;

                        function updatePassword(password) {
                            messageHandler.send('UpdatePassword', password);
                        }
                        var pdfDataRangeTransport = this.pdfDataRangeTransport;
                        if (pdfDataRangeTransport) {
                            pdfDataRangeTransport.addRangeListener(function(begin, chunk) {
                                messageHandler.send('OnDataRange', {
                                    begin: begin,
                                    chunk: chunk
                                });
                            });
                            pdfDataRangeTransport.addProgressListener(function(loaded) {
                                messageHandler.send('OnDataProgress', {
                                    loaded: loaded
                                });
                            });
                            pdfDataRangeTransport.addProgressiveReadListener(function(chunk) {
                                messageHandler.send('OnDataRange', {
                                    chunk: chunk
                                });
                            });
                            messageHandler.on('RequestDataRange', function transportDataRange(data) {
                                pdfDataRangeTransport.requestDataRange(data.begin, data.end);
                            }, this);
                        }
                        messageHandler.on('GetDoc', function transportDoc(data) {
                            var pdfInfo = data.pdfInfo;
                            this.numPages = data.pdfInfo.numPages;
                            var loadingTask = this.loadingTask;
                            var pdfDocument = new PDFDocumentProxy(pdfInfo, this, loadingTask);
                            this.pdfDocument = pdfDocument;
                            loadingTask._capability.resolve(pdfDocument);
                        }, this);
                        messageHandler.on('NeedPassword', function transportNeedPassword(exception) {
                            var loadingTask = this.loadingTask;
                            if (loadingTask.onPassword) {
                                return loadingTask.onPassword(updatePassword, PasswordResponses.NEED_PASSWORD);
                            }
                            loadingTask._capability.reject(new PasswordException(exception.message, exception.code));
                        }, this);
                        messageHandler.on('IncorrectPassword', function transportIncorrectPassword(exception) {
                            var loadingTask = this.loadingTask;
                            if (loadingTask.onPassword) {
                                return loadingTask.onPassword(updatePassword, PasswordResponses.INCORRECT_PASSWORD);
                            }
                            loadingTask._capability.reject(new PasswordException(exception.message, exception.code));
                        }, this);
                        messageHandler.on('InvalidPDF', function transportInvalidPDF(exception) {
                            this.loadingTask._capability.reject(new InvalidPDFException(exception.message));
                        }, this);
                        messageHandler.on('MissingPDF', function transportMissingPDF(exception) {
                            this.loadingTask._capability.reject(new MissingPDFException(exception.message));
                        }, this);
                        messageHandler.on('UnexpectedResponse', function transportUnexpectedResponse(exception) {
                            this.loadingTask._capability.reject(new UnexpectedResponseException(exception.message, exception.status));
                        }, this);
                        messageHandler.on('UnknownError', function transportUnknownError(exception) {
                            this.loadingTask._capability.reject(new UnknownErrorException(exception.message, exception.details));
                        }, this);
                        messageHandler.on('DataLoaded', function transportPage(data) {
                            this.downloadInfoCapability.resolve(data);
                        }, this);
                        messageHandler.on('PDFManagerReady', function transportPage(data) {
                            if (this.pdfDataRangeTransport) {
                                this.pdfDataRangeTransport.transportReady();
                            }
                        }, this);
                        messageHandler.on('StartRenderPage', function transportRender(data) {
                            if (this.destroyed) {
                                return;
                            }
                            var page = this.pageCache[data.pageIndex];
                            page.stats.timeEnd('Page Request');
                            page._startRenderPage(data.transparency, data.intent);
                        }, this);
                        messageHandler.on('RenderPageChunk', function transportRender(data) {
                            if (this.destroyed) {
                                return;
                            }
                            var page = this.pageCache[data.pageIndex];
                            page._renderPageChunk(data.operatorList, data.intent);
                        }, this);
                        messageHandler.on('commonobj', function transportObj(data) {
                            if (this.destroyed) {
                                return;
                            }
                            var id = data[0];
                            var type = data[1];
                            if (this.commonObjs.hasData(id)) {
                                return;
                            }
                            switch (type) {
                                case 'Font':
                                    var exportedData = data[2];
                                    var font;
                                    if ('error' in exportedData) {
                                        var error = exportedData.error;
                                        warn('Error during font loading: ' + error);
                                        this.commonObjs.resolve(id, error);
                                        break;
                                    } else {
                                        font = new FontFaceObject(exportedData);
                                    }
                                    this.fontLoader.bind([font], function fontReady(fontObjs) {
                                        this.commonObjs.resolve(id, font);
                                    }.bind(this));
                                    break;
                                case 'FontPath':
                                    this.commonObjs.resolve(id, data[2]);
                                    break;
                                default:
                                    error('Got unknown common object type ' + type);
                            }
                        }, this);
                        messageHandler.on('obj', function transportObj(data) {
                            if (this.destroyed) {
                                return;
                            }
                            var id = data[0];
                            var pageIndex = data[1];
                            var type = data[2];
                            var pageProxy = this.pageCache[pageIndex];
                            var imageData;
                            if (pageProxy.objs.hasData(id)) {
                                return;
                            }
                            switch (type) {
                                case 'JpegStream':
                                    imageData = data[3];
                                    loadJpegStream(id, imageData, pageProxy.objs);
                                    break;
                                case 'Image':
                                    imageData = data[3];
                                    pageProxy.objs.resolve(id, imageData);
                                    var MAX_IMAGE_SIZE_TO_STORE = 8000000;
                                    if (imageData && 'data' in imageData && imageData.data.length > MAX_IMAGE_SIZE_TO_STORE) {
                                        pageProxy.cleanupAfterRender = true;
                                    }
                                    break;
                                default:
                                    error('Got unknown object type ' + type);
                            }
                        }, this);
                        messageHandler.on('DocProgress', function transportDocProgress(data) {
                            if (this.destroyed) {
                                return;
                            }
                            var loadingTask = this.loadingTask;
                            if (loadingTask.onProgress) {
                                loadingTask.onProgress({
                                    loaded: data.loaded,
                                    total: data.total
                                });
                            }
                        }, this);
                        messageHandler.on('PageError', function transportError(data) {
                            if (this.destroyed) {
                                return;
                            }
                            var page = this.pageCache[data.pageNum - 1];
                            var intentState = page.intentStates[data.intent];
                            if (intentState.displayReadyCapability) {
                                intentState.displayReadyCapability.reject(data.error);
                            } else {
                                error(data.error);
                            }
                        }, this);
                        messageHandler.on('UnsupportedFeature', function transportUnsupportedFeature(data) {
                            if (this.destroyed) {
                                return;
                            }
                            var featureId = data.featureId;
                            var loadingTask = this.loadingTask;
                            if (loadingTask.onUnsupportedFeature) {
                                loadingTask.onUnsupportedFeature(featureId);
                            }
                            PDFJS.UnsupportedManager.notify(featureId);
                        }, this);
                        messageHandler.on('JpegDecode', function(data) {
                            if (this.destroyed) {
                                return Promise.reject('Worker was terminated');
                            }
                            var imageUrl = data[0];
                            var components = data[1];
                            if (components !== 3 && components !== 1) {
                                return Promise.reject(new Error('Only 3 components or 1 component can be returned'));
                            }
                            return new Promise(function(resolve, reject) {
                                var img = new Image();
                                img.onload = function() {
                                    var width = img.width;
                                    var height = img.height;
                                    var size = width * height;
                                    var rgbaLength = size * 4;
                                    var buf = new Uint8Array(size * components);
                                    var tmpCanvas = createScratchCanvas(width, height);
                                    var tmpCtx = tmpCanvas.getContext('2d');
                                    tmpCtx.drawImage(img, 0, 0);
                                    var data = tmpCtx.getImageData(0, 0, width, height).data;
                                    var i, j;
                                    if (components === 3) {
                                        for (i = 0, j = 0; i < rgbaLength; i += 4, j += 3) {
                                            buf[j] = data[i];
                                            buf[j + 1] = data[i + 1];
                                            buf[j + 2] = data[i + 2];
                                        }
                                    } else if (components === 1) {
                                        for (i = 0, j = 0; i < rgbaLength; i += 4, j++) {
                                            buf[j] = data[i];
                                        }
                                    }
                                    resolve({
                                        data: buf,
                                        width: width,
                                        height: height
                                    });
                                };
                                img.onerror = function() {
                                    reject(new Error('JpegDecode failed to load image'));
                                };
                                img.src = imageUrl;
                            });
                        }, this);
                    },
                    getData: function WorkerTransport_getData() {
                        return this.messageHandler.sendWithPromise('GetData', null);
                    },
                    getPage: function WorkerTransport_getPage(pageNumber, capability) {
                        if (pageNumber <= 0 || pageNumber > this.numPages || (pageNumber | 0) !== pageNumber) {
                            return Promise.reject(new Error('Invalid page request'));
                        }
                        var pageIndex = pageNumber - 1;
                        if (pageIndex in this.pagePromises) {
                            return this.pagePromises[pageIndex];
                        }
                        var promise = this.messageHandler.sendWithPromise('GetPage', {
                            pageIndex: pageIndex
                        }).then(function(pageInfo) {
                            if (this.destroyed) {
                                throw new Error('Transport destroyed');
                            }
                            var page = new PDFPageProxy(pageIndex, pageInfo, this);
                            this.pageCache[pageIndex] = page;
                            return page;
                        }.bind(this));
                        this.pagePromises[pageIndex] = promise;
                        return promise;
                    },
                    getPageIndex: function WorkerTransport_getPageIndexByRef(ref) {
                        return this.messageHandler.sendWithPromise('GetPageIndex', {
                            ref: ref
                        });
                    },
                    getAnnotations: function WorkerTransport_getAnnotations(pageIndex, intent) {
                        return this.messageHandler.sendWithPromise('GetAnnotations', {
                            pageIndex: pageIndex,
                            intent: intent,
                        });
                    },
                    getDestinations: function WorkerTransport_getDestinations() {
                        return this.messageHandler.sendWithPromise('GetDestinations', null);
                    },
                    getDestination: function WorkerTransport_getDestination(id) {
                        return this.messageHandler.sendWithPromise('GetDestination', {
                            id: id
                        });
                    },
                    getPageLabels: function WorkerTransport_getPageLabels() {
                        return this.messageHandler.sendWithPromise('GetPageLabels', null);
                    },
                    getAttachments: function WorkerTransport_getAttachments() {
                        return this.messageHandler.sendWithPromise('GetAttachments', null);
                    },
                    getJavaScript: function WorkerTransport_getJavaScript() {
                        return this.messageHandler.sendWithPromise('GetJavaScript', null);
                    },
                    getOutline: function WorkerTransport_getOutline() {
                        return this.messageHandler.sendWithPromise('GetOutline', null);
                    },
                    getMetadata: function WorkerTransport_getMetadata() {
                        return this.messageHandler.sendWithPromise('GetMetadata', null).then(function transportMetadata(results) {
                            return {
                                info: results[0],
                                metadata: (results[1] ? new Metadata(results[1]) : null)
                            };
                        });
                    },
                    getStats: function WorkerTransport_getStats() {
                        return this.messageHandler.sendWithPromise('GetStats', null);
                    },
                    startCleanup: function WorkerTransport_startCleanup() {
                        this.messageHandler.sendWithPromise('Cleanup', null).then(function endCleanup() {
                            for (var i = 0, ii = this.pageCache.length; i < ii; i++) {
                                var page = this.pageCache[i];
                                if (page) {
                                    page.cleanup();
                                }
                            }
                            this.commonObjs.clear();
                            this.fontLoader.clear();
                        }.bind(this));
                    }
                };
                return WorkerTransport;
            })();
            var PDFObjects = (function PDFObjectsClosure() {
                function PDFObjects() {
                    this.objs = {};
                }
                PDFObjects.prototype = {
                    ensureObj: function PDFObjects_ensureObj(objId) {
                        if (this.objs[objId]) {
                            return this.objs[objId];
                        }
                        var obj = {
                            capability: createPromiseCapability(),
                            data: null,
                            resolved: false
                        };
                        this.objs[objId] = obj;
                        return obj;
                    },
                    get: function PDFObjects_get(objId, callback) {
                        if (callback) {
                            this.ensureObj(objId).capability.promise.then(callback);
                            return null;
                        }
                        var obj = this.objs[objId];
                        if (!obj || !obj.resolved) {
                            error('Requesting object that isn\'t resolved yet ' + objId);
                        }
                        return obj.data;
                    },
                    resolve: function PDFObjects_resolve(objId, data) {
                        var obj = this.ensureObj(objId);
                        obj.resolved = true;
                        obj.data = data;
                        obj.capability.resolve(data);
                    },
                    isResolved: function PDFObjects_isResolved(objId) {
                        var objs = this.objs;
                        if (!objs[objId]) {
                            return false;
                        } else {
                            return objs[objId].resolved;
                        }
                    },
                    hasData: function PDFObjects_hasData(objId) {
                        return this.isResolved(objId);
                    },
                    getData: function PDFObjects_getData(objId) {
                        var objs = this.objs;
                        if (!objs[objId] || !objs[objId].resolved) {
                            return null;
                        } else {
                            return objs[objId].data;
                        }
                    },
                    clear: function PDFObjects_clear() {
                        this.objs = {};
                    }
                };
                return PDFObjects;
            })();
            var RenderTask = (function RenderTaskClosure() {
                function RenderTask(internalRenderTask) {
                    this._internalRenderTask = internalRenderTask;
                    this.onContinue = null;
                }
                RenderTask.prototype = {
                    get promise() {
                        return this._internalRenderTask.capability.promise;
                    },
                    cancel: function RenderTask_cancel() {
                        this._internalRenderTask.cancel();
                    },
                    then: function RenderTask_then(onFulfilled, onRejected) {
                        return this.promise.then.apply(this.promise, arguments);
                    }
                };
                return RenderTask;
            })();
            var InternalRenderTask = (function InternalRenderTaskClosure() {
                function InternalRenderTask(callback, params, objs, commonObjs, operatorList, pageNumber) {
                    this.callback = callback;
                    this.params = params;
                    this.objs = objs;
                    this.commonObjs = commonObjs;
                    this.operatorListIdx = null;
                    this.operatorList = operatorList;
                    this.pageNumber = pageNumber;
                    this.running = false;
                    this.graphicsReadyCallback = null;
                    this.graphicsReady = false;
                    this.useRequestAnimationFrame = false;
                    this.cancelled = false;
                    this.capability = createPromiseCapability();
                    this.task = new RenderTask(this);
                    this._continueBound = this._continue.bind(this);
                    this._scheduleNextBound = this._scheduleNext.bind(this);
                    this._nextBound = this._next.bind(this);
                }
                InternalRenderTask.prototype = {
                    initalizeGraphics: function InternalRenderTask_initalizeGraphics(transparency) {
                        if (this.cancelled) {
                            return;
                        }
                        if (PDFJS.pdfBug && 'StepperManager' in globalScope && globalScope.StepperManager.enabled) {
                            this.stepper = globalScope.StepperManager.create(this.pageNumber - 1);
                            this.stepper.init(this.operatorList);
                            this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
                        }
                        var params = this.params;
                        this.gfx = new CanvasGraphics(params.canvasContext, this.commonObjs, this.objs, params.imageLayer);
                        this.gfx.beginDrawing(params.transform, params.viewport, transparency);
                        this.operatorListIdx = 0;
                        this.graphicsReady = true;
                        if (this.graphicsReadyCallback) {
                            this.graphicsReadyCallback();
                        }
                    },
                    cancel: function InternalRenderTask_cancel() {
                        this.running = false;
                        this.cancelled = true;
                        this.callback('cancelled');
                    },
                    operatorListChanged: function InternalRenderTask_operatorListChanged() {
                        if (!this.graphicsReady) {
                            if (!this.graphicsReadyCallback) {
                                this.graphicsReadyCallback = this._continueBound;
                            }
                            return;
                        }
                        if (this.stepper) {
                            this.stepper.updateOperatorList(this.operatorList);
                        }
                        if (this.running) {
                            return;
                        }
                        this._continue();
                    },
                    _continue: function InternalRenderTask__continue() {
                        this.running = true;
                        if (this.cancelled) {
                            return;
                        }
                        if (this.task.onContinue) {
                            this.task.onContinue.call(this.task, this._scheduleNextBound);
                        } else {
                            this._scheduleNext();
                        }
                    },
                    _scheduleNext: function InternalRenderTask__scheduleNext() {
                        if (this.useRequestAnimationFrame) {
                            window.requestAnimationFrame(this._nextBound);
                        } else {
                            Promise.resolve(undefined).then(this._nextBound);
                        }
                    },
                    _next: function InternalRenderTask__next() {
                        if (this.cancelled) {
                            return;
                        }
                        this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);
                        if (this.operatorListIdx === this.operatorList.argsArray.length) {
                            this.running = false;
                            if (this.operatorList.lastChunk) {
                                this.gfx.endDrawing();
                                this.callback();
                            }
                        }
                    }
                };
                return InternalRenderTask;
            })();
            PDFJS.UnsupportedManager = (function UnsupportedManagerClosure() {
                var listeners = [];
                return {
                    listen: function(cb) {
                        deprecated('Global UnsupportedManager.listen is used: ' + ' use PDFDocumentLoadingTask.onUnsupportedFeature instead');
                        listeners.push(cb);
                    },
                    notify: function(featureId) {
                        for (var i = 0, ii = listeners.length; i < ii; i++) {
                            listeners[i](featureId);
                        }
                    }
                };
            })();
            exports.getDocument = PDFJS.getDocument;
            exports.PDFDataRangeTransport = PDFDataRangeTransport;
            exports.PDFDocumentProxy = PDFDocumentProxy;
            exports.PDFPageProxy = PDFPageProxy;
        }));
    }).call(pdfjsLibs);
    exports.PDFJS = pdfjsLibs.pdfjsSharedGlobal.PDFJS;
    exports.getDocument = pdfjsLibs.pdfjsDisplayAPI.getDocument;
    exports.PDFDataRangeTransport = pdfjsLibs.pdfjsDisplayAPI.PDFDataRangeTransport;
    exports.renderTextLayer = pdfjsLibs.pdfjsDisplayTextLayer.renderTextLayer;
    exports.AnnotationLayer = pdfjsLibs.pdfjsDisplayAnnotationLayer.AnnotationLayer;
    exports.CustomStyle = pdfjsLibs.pdfjsDisplayDOMUtils.CustomStyle;
    exports.PasswordResponses = pdfjsLibs.pdfjsSharedUtil.PasswordResponses;
    exports.InvalidPDFException = pdfjsLibs.pdfjsSharedUtil.InvalidPDFException;
    exports.MissingPDFException = pdfjsLibs.pdfjsSharedUtil.MissingPDFException;
    exports.UnexpectedResponseException = pdfjsLibs.pdfjsSharedUtil.UnexpectedResponseException;
}));

var Locale = {
    'lang': 'en-US',
    'spell': function(str) {
        var words = [];
        if (typeof(words[str]) != 'undefined') {
            return words[str];
        } else {
            return str;
        }
    }
};